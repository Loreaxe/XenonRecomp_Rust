pub fn sub_821A7548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A7548 size=340
    let mut pc: u32 = 0x821A7548;
    'dispatch: loop {
        match pc {
            0x821A7548 => {
    //   block [0x821A7548..0x821A769C)
	// 821A7548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A754C: 4838DB69  bl 0x825350b4
	ctx.lr = 0x821A7550;
	sub_82535080(ctx, base);
	// 821A7550: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A7554: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A7558: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A755C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A7560: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821A7564: 38EB0E74  addi r7, r11, 0xe74
	ctx.r[7].s64 = ctx.r[11].s64 + 3700;
	// 821A7568: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A756C: 38A00389  li r5, 0x389
	ctx.r[5].s64 = 905;
	// 821A7570: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A7574: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 821A7578: 481C2F19  bl 0x8236a490
	ctx.lr = 0x821A757C;
	sub_8236A490(ctx, base);
	// 821A757C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A7580: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7584: 419A000C  beq cr6, 0x821a7590
	if ctx.cr[6].eq {
	pc = 0x821A7590; continue 'dispatch;
	}
	// 821A7588: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A758C: 48000008  b 0x821a7594
	pc = 0x821A7594; continue 'dispatch;
	// 821A7590: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821A7594: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7598: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A759C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A75A0: 419A00B0  beq cr6, 0x821a7650
	if ctx.cr[6].eq {
	pc = 0x821A7650; continue 'dispatch;
	}
	// 821A75A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A75A8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A75AC: 396B0E14  addi r11, r11, 0xe14
	ctx.r[11].s64 = ctx.r[11].s64 + 3604;
	// 821A75B0: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A75B4: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A75B8: 390876A0  addi r8, r8, 0x76a0
	ctx.r[8].s64 = ctx.r[8].s64 + 30368;
	// 821A75BC: 392977B0  addi r9, r9, 0x77b0
	ctx.r[9].s64 = ctx.r[9].s64 + 30640;
	// 821A75C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A75C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A75C8: 93BF0080  stw r29, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 821A75CC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821A75D0: B3BF0084  sth r29, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[29].u16 ) };
	// 821A75D4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A75D8: B3BF0086  sth r29, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[29].u16 ) };
	// 821A75DC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A75E0: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A75E4: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A75E8: FBBF00E0  std r29, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u64 ) };
	// 821A75EC: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A75F0: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A75F4: FBBF00E8  std r29, 0xe8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[29].u64 ) };
	// 821A75F8: 1C9B0660  mulli r4, r27, 0x660
	ctx.r[4].s64 = ctx.r[27].s64 * 1632;
	// 821A75FC: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A7600: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A7604: 9B9F001C  stb r28, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u8 ) };
	// 821A7608: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A760C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A7610: 4BFFA621  bl 0x821a1c30
	ctx.lr = 0x821A7614;
	sub_821A1C30(ctx, base);
	// 821A7614: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7618: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A761C: 409A0044  bne cr6, 0x821a7660
	if !ctx.cr[6].eq {
	pc = 0x821A7660; continue 'dispatch;
	}
	// 821A7620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7624: 419A002C  beq cr6, 0x821a7650
	if ctx.cr[6].eq {
	pc = 0x821A7650; continue 'dispatch;
	}
	// 821A7628: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A762C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7630: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7634: 409A001C  bne cr6, 0x821a7650
	if !ctx.cr[6].eq {
	pc = 0x821A7650; continue 'dispatch;
	}
	// 821A7638: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A763C: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A7640: 9B8B0025  stb r28, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[28].u8 ) };
	// 821A7644: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A7648: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A764C: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A7650: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A7654: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A7658: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A765C: 4838DAA8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 821A7660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7664: 419A0014  beq cr6, 0x821a7678
	if ctx.cr[6].eq {
	pc = 0x821A7678; continue 'dispatch;
	}
	// 821A7668: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A766C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7670: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7674: 419A0008  beq cr6, 0x821a767c
	if ctx.cr[6].eq {
	pc = 0x821A767C; continue 'dispatch;
	}
	// 821A7678: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821A767C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A7684: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 821A7688: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 821A768C: FBBF00E0  std r29, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u64 ) };
	// 821A7690: 937F00D0  stw r27, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[27].u32 ) };
	// 821A7694: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A7698: 4838DA6C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A76A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A76A0 size=272
    let mut pc: u32 = 0x821A76A0;
    'dispatch: loop {
        match pc {
            0x821A76A0 => {
    //   block [0x821A76A0..0x821A77B0)
	// 821A76A0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A76A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A76A8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A76AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A76B0: 419A0008  beq cr6, 0x821a76b8
	if ctx.cr[6].eq {
	pc = 0x821A76B8; continue 'dispatch;
	}
	// 821A76B4: 910B0040  stw r8, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[8].u32 ) };
	// 821A76B8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A76BC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A76C0: 3CC04020  lis r6, 0x4020
	ctx.r[6].s64 = 1075838976;
	// 821A76C4: 38A00120  li r5, 0x120
	ctx.r[5].s64 = 288;
	// 821A76C8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A76CC: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A76D0: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A76D4: 992B001E  stb r9, 0x1e(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A76D8: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A76DC: 394A8E40  addi r10, r10, -0x71c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29120;
	// 821A76E0: B10B0084  sth r8, 0x84(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[8].u16 ) };
	// 821A76E4: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 821A76E8: B10B0086  sth r8, 0x86(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(134 as u32), ctx.r[8].u16 ) };
	// 821A76EC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821A76F0: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A76F4: D00B00B0  stfs f0, 0xb0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A76F8: D00B00B4  stfs f0, 0xb4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A76FC: 90CB00A8  stw r6, 0xa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[6].u32 ) };
	// 821A7700: 90AB00A4  stw r5, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 821A7704: 912B0094  stw r9, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A7708: 908B0098  stw r4, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[4].u32 ) };
	// 821A770C: 906B00A0  stw r3, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 821A7710: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A7714: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7718: D00B00B8  stfs f0, 0xb8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A771C: 3D4A0504  addis r10, r10, 0x504
	ctx.r[10].s64 = ctx.r[10].s64 + 84148224;
	// 821A7720: 394A4000  addi r10, r10, 0x4000
	ctx.r[10].s64 = ctx.r[10].s64 + 16384;
	// 821A7724: 914B0090  stw r10, 0x90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 821A7728: 812B00D8  lwz r9, 0xd8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A772C: 80CB00D0  lwz r6, 0xd0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A7730: 814B00CC  lwz r10, 0xcc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A7734: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A7738: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A773C: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7740: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A7744: 40990064  ble cr6, 0x821a77a8
	if !ctx.cr[6].gt {
	pc = 0x821A77A8; continue 'dispatch;
	}
	// 821A7748: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821A774C: C169BA38  lfs f11, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A7750: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 821A7754: 7D260034  cntlzw r6, r9
	ctx.r[6].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821A7758: D16A000C  stfs f11, 0xc(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A775C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A7760: 54C6DFFE  rlwinm r6, r6, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 821A7764: 2F090011  cmpwi cr6, r9, 0x11
	ctx.cr[6].compare_i32(ctx.r[9].s32, 17, &mut ctx.xer);
	// 821A7768: 90CA002C  stw r6, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[6].u32 ) };
	// 821A776C: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A7770: D1AA0014  stfs f13, 0x14(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A7774: D18A0018  stfs f12, 0x18(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A7778: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 821A777C: D16A000C  stfs f11, 0xc(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A7780: 910A002C  stw r8, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 821A7784: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A7788: D1AA0014  stfs f13, 0x14(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A778C: D18A0018  stfs f12, 0x18(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A7790: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 821A7794: 4198FFC0  blt cr6, 0x821a7754
	if ctx.cr[6].lt {
	pc = 0x821A7754; continue 'dispatch;
	}
	// 821A7798: 812B00D0  lwz r9, 0xd0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A779C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821A77A0: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A77A4: 4198FFAC  blt cr6, 0x821a7750
	if ctx.cr[6].lt {
	pc = 0x821A7750; continue 'dispatch;
	}
	// 821A77A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A77AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A77B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A77B0 size=68
    let mut pc: u32 = 0x821A77B0;
    'dispatch: loop {
        match pc {
            0x821A77B0 => {
    //   block [0x821A77B0..0x821A77F4)
	// 821A77B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A77B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A77B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A77BC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A77C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A77C4: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A77C8: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A77CC: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A77D0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A77D4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A77D8: 419A0008  beq cr6, 0x821a77e0
	if ctx.cr[6].eq {
	pc = 0x821A77E0; continue 'dispatch;
	}
	// 821A77DC: 4800001D  bl 0x821a77f8
	ctx.lr = 0x821A77E0;
	sub_821A77F8(ctx, base);
	// 821A77E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A77E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A77E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A77EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A77F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A77F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A77F8 size=908
    let mut pc: u32 = 0x821A77F8;
    'dispatch: loop {
        match pc {
            0x821A77F8 => {
    //   block [0x821A77F8..0x821A7B84)
	// 821A77F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A77FC: 4838D8A5  bl 0x825350a0
	ctx.lr = 0x821A7800;
	sub_82535080(ctx, base);
	// 821A7800: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821A7804: 4838E7C5  bl 0x82535fc8
	ctx.lr = 0x821A7808;
	sub_82535FB0(ctx, base);
	// 821A7808: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A780C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821A7810: 817900E4  lwz r11, 0xe4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(228 as u32) ) } as u64;
	// 821A7814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7818: 419A0018  beq cr6, 0x821a7830
	if ctx.cr[6].eq {
	pc = 0x821A7830; continue 'dispatch;
	}
	// 821A781C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7820: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 821A7824: 813900E0  lwz r9, 0xe0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(224 as u32) ) } as u64;
	// 821A7828: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A782C: 419A0008  beq cr6, 0x821a7834
	if ctx.cr[6].eq {
	pc = 0x821A7834; continue 'dispatch;
	}
	// 821A7830: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A7834: 817A0084  lwz r11, 0x84(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A7838: 83F900CC  lwz r31, 0xcc(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A783C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A7840: 409A000C  bne cr6, 0x821a784c
	if !ctx.cr[6].eq {
	pc = 0x821A784C; continue 'dispatch;
	}
	// 821A7844: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A7848: 4800000C  b 0x821a7854
	pc = 0x821A7854; continue 'dispatch;
	// 821A784C: 815A008C  lwz r10, 0x8c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7850: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A7854: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821A7858: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821A785C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7860: 419A0308  beq cr6, 0x821a7b68
	if ctx.cr[6].eq {
	pc = 0x821A7B68; continue 'dispatch;
	}
	// 821A7864: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A7868: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821A786C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821A7870: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A7874: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A7878: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A787C: 3B0B20B0  addi r24, r11, 0x20b0
	ctx.r[24].s64 = ctx.r[11].s64 + 8368;
	// 821A7880: C3E6BA38  lfs f31, -0x45c8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A7884: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A7888: C2872490  lfs f20, 0x2490(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(9360 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821A788C: C2C82048  lfs f22, 0x2048(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8264 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A7890: C3C9BFFC  lfs f30, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A7894: 3AEBD030  addi r23, r11, -0x2fd0
	ctx.r[23].s64 = ctx.r[11].s64 + -12240;
	// 821A7898: C2AA1FF8  lfs f21, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 821A789C: 817A0098  lwz r11, 0x98(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A78A0: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 821A78A4: 393B0024  addi r9, r27, 0x24
	ctx.r[9].s64 = ctx.r[27].s64 + 36;
	// 821A78A8: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 821A78AC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A78B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A78B4: 409A000C  bne cr6, 0x821a78c0
	if !ctx.cr[6].eq {
	pc = 0x821A78C0; continue 'dispatch;
	}
	// 821A78B8: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A78BC: 48000020  b 0x821a78dc
	pc = 0x821A78DC; continue 'dispatch;
	// 821A78C0: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 821A78C4: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A78C8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A78CC: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821A78D0: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A78D4: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A78D8: 7DA8542E  lfsx f13, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A78DC: 38EB0020  addi r7, r11, 0x20
	ctx.r[7].s64 = ctx.r[11].s64 + 32;
	// 821A78E0: 39490010  addi r10, r9, 0x10
	ctx.r[10].s64 = ctx.r[9].s64 + 16;
	// 821A78E4: 8167000C  lwz r11, 0xc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A78E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A78EC: 409A000C  bne cr6, 0x821a78f8
	if !ctx.cr[6].eq {
	pc = 0x821A78F8; continue 'dispatch;
	}
	// 821A78F0: C02A0000  lfs f1, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A78F4: 48000020  b 0x821a7914
	pc = 0x821A7914; continue 'dispatch;
	// 821A78F8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821A78FC: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7900: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A7904: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 821A7908: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A790C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A7910: 7C295C2E  lfsx f1, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A7914: 817900D4  lwz r11, 0xd4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A7918: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 821A791C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7920: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A7924: 419A008C  beq cr6, 0x821a79b0
	if ctx.cr[6].eq {
	pc = 0x821A79B0; continue 'dispatch;
	}
	// 821A7928: 8147001C  lwz r10, 0x1c(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A792C: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A7934: 419A001C  beq cr6, 0x821a7950
	if ctx.cr[6].eq {
	pc = 0x821A7950; continue 'dispatch;
	}
	// 821A7938: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 821A793C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A7940: 7C0037AE  stfiwx f0, 0, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32, tmp.u32) };
	// 821A7944: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7948: 54C6103A  slwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821A794C: 7C06542E  lfsx f0, r6, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7950: FF00A800  fcmpu cr6, f0, f21
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[21].f64);
	// 821A7954: 40980008  bge cr6, 0x821a795c
	if !ctx.cr[6].lt {
	pc = 0x821A795C; continue 'dispatch;
	}
	// 821A7958: FC00A890  fmr f0, f21
	ctx.f[0].f64 = ctx.f[21].f64;
	// 821A795C: A0CB0012  lhz r6, 0x12(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A7960: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A7964: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821A7968: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A796C: C9810068  lfd f12, 0x68(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A7970: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821A7974: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821A7978: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A797C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A7980: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 821A7984: A1610076  lhz r11, 0x76(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(118 as u32) ) } as u64;
	// 821A7988: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A798C: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A7990: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A7994: C36B0000  lfs f27, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A7998: C38B0004  lfs f28, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A799C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A79A0: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A79A4: EF20D828  fsubs f25, f0, f27
	ctx.f[25].f64 = (((ctx.f[0].f64 - ctx.f[27].f64) as f32) as f64);
	// 821A79A8: EF4CE028  fsubs f26, f12, f28
	ctx.f[26].f64 = (((ctx.f[12].f64 - ctx.f[28].f64) as f32) as f64);
	// 821A79AC: 48000014  b 0x821a79c0
	pc = 0x821A79C0; continue 'dispatch;
	// 821A79B0: FF80A890  fmr f28, f21
	ctx.f[28].f64 = ctx.f[21].f64;
	// 821A79B4: FF60A890  fmr f27, f21
	ctx.f[27].f64 = ctx.f[21].f64;
	// 821A79B8: FF40F890  fmr f26, f31
	ctx.f[26].f64 = ctx.f[31].f64;
	// 821A79BC: FF20F890  fmr f25, f31
	ctx.f[25].f64 = ctx.f[31].f64;
	// 821A79C0: 8167002C  lwz r11, 0x2c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A79C4: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A79C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A79CC: 419A001C  beq cr6, 0x821a79e8
	if ctx.cr[6].eq {
	pc = 0x821A79E8; continue 'dispatch;
	}
	// 821A79D0: 3941005C  addi r10, r1, 0x5c
	ctx.r[10].s64 = ctx.r[1].s64 + 92;
	// 821A79D4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A79D8: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A79DC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A79E0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A79E4: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A79E8: 817A0094  lwz r11, 0x94(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A79EC: C19B0184  lfs f12, 0x184(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A79F0: 815900D8  lwz r10, 0xd8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A79F4: EC4C0372  fmuls f2, f12, f13
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A79F8: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 821A79FC: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821A7A00: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A7A04: 38FB0160  addi r7, r27, 0x160
	ctx.r[7].s64 = ctx.r[27].s64 + 352;
	// 821A7A08: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821A7A0C: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A10: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821A7A14: EFAD0032  fmuls f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A7A18: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821A7A1C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821A7A20: 4BFF51A1  bl 0x8219cbc0
	ctx.lr = 0x821A7A24;
	sub_8219CBC0(ctx, base);
	// 821A7A24: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 821A7A28: EF19DFBA  fmadds f24, f25, f30, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = (((ctx.f[25].f64 * ctx.f[30].f64 + ctx.f[27].f64) as f32) as f64);
	// 821A7A2C: EEFAE7BA  fmadds f23, f26, f30, f28
	ctx.f[23].f64 = (((ctx.f[26].f64 * ctx.f[30].f64 + ctx.f[28].f64) as f32) as f64);
	// 821A7A30: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821A7A34: 409A0008  bne cr6, 0x821a7a3c
	if !ctx.cr[6].eq {
	pc = 0x821A7A3C; continue 'dispatch;
	}
	// 821A7A38: 3B9CFF00  addi r28, r28, -0x100
	ctx.r[28].s64 = ctx.r[28].s64 + -256;
	// 821A7A3C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A40: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A7A44: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A48: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A7A4C: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A50: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A7A54: D31F0020  stfs f24, 0x20(r31)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A7A58: D2FF0024  stfs f23, 0x24(r31)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A7A5C: D3BF001C  stfs f29, 0x1c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A7A60: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821A7A64: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A68: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7A6C: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A7A70: C17C0008  lfs f11, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A7A74: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A7A78: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821A7A7C: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A7A80: D17F0008  stfs f11, 8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A7A84: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 821A7A88: 41980064  blt cr6, 0x821a7aec
	if ctx.cr[6].lt {
	pc = 0x821A7AEC; continue 'dispatch;
	}
	// 821A7A8C: EC00B028  fsubs f0, f0, f22
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[22].f64) as f32) as f64);
	// 821A7A90: FF00A800  fcmpu cr6, f0, f21
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[21].f64);
	// 821A7A94: 4098003C  bge cr6, 0x821a7ad0
	if !ctx.cr[6].lt {
	pc = 0x821A7AD0; continue 'dispatch;
	}
	// 821A7A98: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821A7A9C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A7AA0: 4098000C  bge cr6, 0x821a7aac
	if !ctx.cr[6].lt {
	pc = 0x821A7AAC; continue 'dispatch;
	}
	// 821A7AA4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A7AA8: 48000040  b 0x821a7ae8
	pc = 0x821A7AE8; continue 'dispatch;
	// 821A7AAC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A7AB0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A7AB4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A7AB8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A7ABC: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A7AC0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A7AC4: 41980024  blt cr6, 0x821a7ae8
	if ctx.cr[6].lt {
	pc = 0x821A7AE8; continue 'dispatch;
	}
	// 821A7AC8: FC00A890  fmr f0, f21
	ctx.f[0].f64 = ctx.f[21].f64;
	// 821A7ACC: 4800001C  b 0x821a7ae8
	pc = 0x821A7AE8; continue 'dispatch;
	// 821A7AD0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A7AD4: 41980014  blt cr6, 0x821a7ae8
	if ctx.cr[6].lt {
	pc = 0x821A7AE8; continue 'dispatch;
	}
	// 821A7AD8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A7ADC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A7AE0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A7AE4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A7AE8: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 821A7AEC: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 821A7AF0: EC200532  fmuls f1, f0, f20
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[20].f64) as f32) as f64);
	// 821A7AF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821A7AF8: 4BF6A2D9  bl 0x82111dd0
	ctx.lr = 0x821A7AFC;
	sub_82111DD0(ctx, base);
	// 821A7AFC: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7B00: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7B04: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821A7B08: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 821A7B0C: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821A7B10: D3BF001C  stfs f29, 0x1c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A7B14: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 821A7B18: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821A7B1C: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821A7B20: EDAD05B2  fmuls f13, f13, f22
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[22].f64) as f32) as f64);
	// 821A7B24: EC00DE7A  fmadds f0, f0, f25, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[27].f64) as f32) as f64);
	// 821A7B28: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A7B2C: EC0DE6BA  fmadds f0, f13, f26, f28
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[26].f64 + ctx.f[28].f64) as f32) as f64);
	// 821A7B30: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A7B34: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821A7B38: 4098FEFC  bge cr6, 0x821a7a34
	if !ctx.cr[6].lt {
	pc = 0x821A7A34; continue 'dispatch;
	}
	// 821A7B3C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7B40: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 821A7B44: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A7B48: 409A000C  bne cr6, 0x821a7b54
	if !ctx.cr[6].eq {
	pc = 0x821A7B54; continue 'dispatch;
	}
	// 821A7B4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A7B50: 4800000C  b 0x821a7b5c
	pc = 0x821A7B5C; continue 'dispatch;
	// 821A7B54: 815A008C  lwz r10, 0x8c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7B58: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A7B5C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821A7B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7B64: 409AFD38  bne cr6, 0x821a789c
	if !ctx.cr[6].eq {
	pc = 0x821A789C; continue 'dispatch;
	}
	// 821A7B68: 1D760022  mulli r11, r22, 0x22
	ctx.r[11].s64 = ctx.r[22].s64 * 34;
	// 821A7B6C: 92D900C8  stw r22, 0xc8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(200 as u32), ctx.r[22].u32 ) };
	// 821A7B70: 917900C4  stw r11, 0xc4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821A7B74: 38210240  addi r1, r1, 0x240
	ctx.r[1].s64 = ctx.r[1].s64 + 576;
	// 821A7B78: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821A7B7C: 4838E499  bl 0x82536014
	ctx.lr = 0x821A7B80;
	sub_82535FFC(ctx, base);
	// 821A7B80: 4838D570  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A7B88 size=460
    let mut pc: u32 = 0x821A7B88;
    'dispatch: loop {
        match pc {
            0x821A7B88 => {
    //   block [0x821A7B88..0x821A7D54)
	// 821A7B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A7B8C: 4838D51D  bl 0x825350a8
	ctx.lr = 0x821A7B90;
	sub_82535080(ctx, base);
	// 821A7B90: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A7B94: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821A7B98: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 821A7B9C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A7BA0: 570B0294  rlwinm r11, r24, 0, 0xa, 0xa
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821A7BA4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A7BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7BAC: FBDB0000  std r30, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A7BB0: 419A0010  beq cr6, 0x821a7bc0
	if ctx.cr[6].eq {
	pc = 0x821A7BC0; continue 'dispatch;
	}
	// 821A7BB4: 3D60821B  lis r11, -0x7de5
	ctx.r[11].s64 = -2112159744;
	// 821A7BB8: 3B2B83B0  addi r25, r11, -0x7c50
	ctx.r[25].s64 = ctx.r[11].s64 + -31824;
	// 821A7BBC: 4800000C  b 0x821a7bc8
	pc = 0x821A7BC8; continue 'dispatch;
	// 821A7BC0: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A7BC4: 3B2B7D78  addi r25, r11, 0x7d78
	ctx.r[25].s64 = ctx.r[11].s64 + 32120;
	// 821A7BC8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A7BCC: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 821A7BD0: 38EB0E7C  addi r7, r11, 0xe7c
	ctx.r[7].s64 = ctx.r[11].s64 + 3708;
	// 821A7BD4: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821A7BD8: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 821A7BDC: 481C28B5  bl 0x8236a490
	ctx.lr = 0x821A7BE0;
	sub_8236A490(ctx, base);
	// 821A7BE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A7BE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7BE8: 419A000C  beq cr6, 0x821a7bf4
	if ctx.cr[6].eq {
	pc = 0x821A7BF4; continue 'dispatch;
	}
	// 821A7BEC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7BF0: 48000008  b 0x821a7bf8
	pc = 0x821A7BF8; continue 'dispatch;
	// 821A7BF4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821A7BF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7BFC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A7C00: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A7C04: 419A00A0  beq cr6, 0x821a7ca4
	if ctx.cr[6].eq {
	pc = 0x821A7CA4; continue 'dispatch;
	}
	// 821A7C08: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A7C0C: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A7C10: 396B0F7C  addi r11, r11, 0xf7c
	ctx.r[11].s64 = ctx.r[11].s64 + 3964;
	// 821A7C14: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821A7C18: 39297D58  addi r9, r9, 0x7d58
	ctx.r[9].s64 = ctx.r[9].s64 + 32088;
	// 821A7C1C: 394A8B68  addi r10, r10, -0x7498
	ctx.r[10].s64 = ctx.r[10].s64 + -29848;
	// 821A7C20: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821A7C24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A7C28: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A7C2C: 3BBF008C  addi r29, r31, 0x8c
	ctx.r[29].s64 = ctx.r[31].s64 + 140;
	// 821A7C30: FBDF00A8  std r30, 0xa8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u64 ) };
	// 821A7C34: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A7C38: FBDF00B0  std r30, 0xb0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u64 ) };
	// 821A7C3C: FBDF00B8  std r30, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u64 ) };
	// 821A7C40: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A7C44: 1C9C01A0  mulli r4, r28, 0x1a0
	ctx.r[4].s64 = ctx.r[28].s64 * 416;
	// 821A7C48: FBDF00C0  std r30, 0xc0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 821A7C4C: 913F0054  stw r9, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821A7C50: 933F0058  stw r25, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 821A7C54: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A7C58: 9B5F001C  stb r26, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 821A7C5C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A7C60: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821A7C64: 4BFF9FCD  bl 0x821a1c30
	ctx.lr = 0x821A7C68;
	sub_821A1C30(ctx, base);
	// 821A7C68: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7C70: 409A0044  bne cr6, 0x821a7cb4
	if !ctx.cr[6].eq {
	pc = 0x821A7CB4; continue 'dispatch;
	}
	// 821A7C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7C78: 419A002C  beq cr6, 0x821a7ca4
	if ctx.cr[6].eq {
	pc = 0x821A7CA4; continue 'dispatch;
	}
	// 821A7C7C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7C80: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7C84: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7C88: 409A001C  bne cr6, 0x821a7ca4
	if !ctx.cr[6].eq {
	pc = 0x821A7CA4; continue 'dispatch;
	}
	// 821A7C8C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A7C90: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A7C94: 9B4B0025  stb r26, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 821A7C98: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A7C9C: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A7CA0: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A7CA4: FBDB0000  std r30, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A7CA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821A7CAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A7CB0: 4838D448  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 821A7CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7CB8: 419A0014  beq cr6, 0x821a7ccc
	if ctx.cr[6].eq {
	pc = 0x821A7CCC; continue 'dispatch;
	}
	// 821A7CBC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7CC0: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7CC4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7CC8: 419A0008  beq cr6, 0x821a7cd0
	if ctx.cr[6].eq {
	pc = 0x821A7CD0; continue 'dispatch;
	}
	// 821A7CCC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821A7CD0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7CD4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A7CD8: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 821A7CDC: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821A7CE0: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821A7CE4: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821A7CE8: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821A7CEC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821A7CF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7CF4: 939F0090  stw r28, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 821A7CF8: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 821A7CFC: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821A7D00: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 821A7D04: 90FF0084  stw r7, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A7D08: 40990028  ble cr6, 0x821a7d30
	if !ctx.cr[6].gt {
	pc = 0x821A7D30; continue 'dispatch;
	}
	// 821A7D0C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A7D10: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821A7D14: 394A01A0  addi r10, r10, 0x1a0
	ctx.r[10].s64 = ctx.r[10].s64 + 416;
	// 821A7D18: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A7D1C: 396B01A0  addi r11, r11, 0x1a0
	ctx.r[11].s64 = ctx.r[11].s64 + 416;
	// 821A7D20: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821A7D24: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A7D28: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821A7D2C: 4198FFE0  blt cr6, 0x821a7d0c
	if ctx.cr[6].lt {
	pc = 0x821A7D0C; continue 'dispatch;
	}
	// 821A7D30: 915F0088  stw r10, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 821A7D34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821A7D38: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A7D3C: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821A7D40: FBDF00B8  std r30, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u64 ) };
	// 821A7D44: FBDF00C0  std r30, 0xc0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 821A7D48: 931F00A0  stw r24, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[24].u32 ) };
	// 821A7D4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A7D50: 4838D3A8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A7D58 size=20
    let mut pc: u32 = 0x821A7D58;
    'dispatch: loop {
        match pc {
            0x821A7D58 => {
    //   block [0x821A7D58..0x821A7D6C)
	// 821A7D58: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A7D5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A7D60: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A7D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7D68: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7D6C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A7D6C size=12
    let mut pc: u32 = 0x821A7D6C;
    'dispatch: loop {
        match pc {
            0x821A7D6C => {
    //   block [0x821A7D6C..0x821A7D78)
	// 821A7D6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A7D70: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A7D74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A7D78 size=1592
    let mut pc: u32 = 0x821A7D78;
    'dispatch: loop {
        match pc {
            0x821A7D78 => {
    //   block [0x821A7D78..0x821A83B0)
	// 821A7D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A7D7C: 4838D315  bl 0x82535090
	ctx.lr = 0x821A7D80;
	sub_82535080(ctx, base);
	// 821A7D80: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 821A7D84: 4838E241  bl 0x82535fc4
	ctx.lr = 0x821A7D88;
	sub_82535FB0(ctx, base);
	// 821A7D88: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A7D8C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A7D90: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 821A7D94: 838BFAC0  lwz r28, -0x540(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A7D98: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A7D9C: 925C0040  stw r18, 0x40(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), ctx.r[18].u32 ) };
	// 821A7DA0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A7DA4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A7DA8: 419A05F4  beq cr6, 0x821a839c
	if ctx.cr[6].eq {
	pc = 0x821A839C; continue 'dispatch;
	}
	// 821A7DAC: 817C0084  lwz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A7DB0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A7DB4: 409A000C  bne cr6, 0x821a7dc0
	if !ctx.cr[6].eq {
	pc = 0x821A7DC0; continue 'dispatch;
	}
	// 821A7DB8: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 821A7DBC: 4800000C  b 0x821a7dc8
	pc = 0x821A7DC8; continue 'dispatch;
	// 821A7DC0: 815C008C  lwz r10, 0x8c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7DC4: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A7DC8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821A7DCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7DD0: 409A0034  bne cr6, 0x821a7e04
	if !ctx.cr[6].eq {
	pc = 0x821A7E04; continue 'dispatch;
	}
	// 821A7DD4: 817C00BC  lwz r11, 0xbc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(188 as u32) ) } as u64;
	// 821A7DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7DDC: 419A0014  beq cr6, 0x821a7df0
	if ctx.cr[6].eq {
	pc = 0x821A7DF0; continue 'dispatch;
	}
	// 821A7DE0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7DE4: 815C00B8  lwz r10, 0xb8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A7DE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A7DEC: 419A05B0  beq cr6, 0x821a839c
	if ctx.cr[6].eq {
	pc = 0x821A839C; continue 'dispatch;
	}
	// 821A7DF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A7DF4: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 821A7DF8: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 821A7DFC: 4838E215  bl 0x82536010
	ctx.lr = 0x821A7E00;
	sub_82535FFC(ctx, base);
	// 821A7E00: 4838D2E0  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
	// 821A7E04: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A7E08: 829C009C  lwz r20, 0x9c(r28)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(156 as u32) ) } as u64;
	// 821A7E0C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A7E10: 827C0098  lwz r19, 0x98(r28)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A7E14: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A7E18: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A7E1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A7E20: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821A7E24: 7F2B542E  lfsx f25, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821A7E28: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 821A7E2C: 4BFFA845  bl 0x821a2670
	ctx.lr = 0x821A7E30;
	sub_821A2670(ctx, base);
	// 821A7E30: 82FC0094  lwz r23, 0x94(r28)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A7E34: FE600890  fmr f19, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[19].f64 = ctx.f[1].f64;
	// 821A7E38: 817C00A0  lwz r11, 0xa0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A7E3C: 3957FFFF  addi r10, r23, -1
	ctx.r[10].s64 = ctx.r[23].s64 + -1;
	// 821A7E40: 55690252  rlwinm r9, r11, 0, 9, 9
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A7E44: 5559073E  clrlwi r25, r10, 0x1c
	ctx.r[25].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821A7E48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A7E4C: 419A0018  beq cr6, 0x821a7e64
	if ctx.cr[6].eq {
	pc = 0x821A7E64; continue 'dispatch;
	}
	// 821A7E50: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821A7E54: 409A0010  bne cr6, 0x821a7e64
	if !ctx.cr[6].eq {
	pc = 0x821A7E64; continue 'dispatch;
	}
	// 821A7E58: 616B2000  ori r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 8192;
	// 821A7E5C: 917C00A0  stw r11, 0xa0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821A7E60: 48000008  b 0x821a7e68
	pc = 0x821A7E68; continue 'dispatch;
	// 821A7E64: 933C0094  stw r25, 0x94(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(148 as u32), ctx.r[25].u32 ) };
	// 821A7E68: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
	// 821A7E6C: C301006C  lfs f24, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821A7E70: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 821A7E74: C2E10068  lfs f23, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821A7E78: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 821A7E7C: C2C10064  lfs f22, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A7E80: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821A7E84: C2A10060  lfs f21, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 821A7E88: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A7E8C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A7E90: C384BA38  lfs f28, -0x45c8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A7E94: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A7E98: C2851FF8  lfs f20, 0x1ff8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8184 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821A7E9C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A7EA0: C34624D0  lfs f26, 0x24d0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(9424 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A7EA4: C36724CC  lfs f27, 0x24cc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(9420 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A7EA8: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 821A7EAC: C3A82850  lfs f29, 0x2850(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10320 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A7EB0: 3B0B14A0  addi r24, r11, 0x14a0
	ctx.r[24].s64 = ctx.r[11].s64 + 5280;
	// 821A7EB4: C3C925C0  lfs f30, 0x25c0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9664 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A7EB8: 3AA00030  li r21, 0x30
	ctx.r[21].s64 = 48;
	// 821A7EBC: C3EA2280  lfs f31, 0x2280(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A7EC0: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 821A7EC4: B25F0010  sth r18, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[18].u16 ) };
	// 821A7EC8: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 821A7ECC: 817C00A0  lwz r11, 0xa0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A7ED0: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 821A7ED4: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 821A7ED8: 556B0318  rlwinm r11, r11, 0, 0xc, 0xc
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A7EDC: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A7EE0: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A7EE4: 71660041  andi. r6, r11, 0x41
	ctx.r[6].u64 = ctx.r[11].u64 & 65;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A7EE8: 4BFF46D9  bl 0x8219c5c0
	ctx.lr = 0x821A7EEC;
	sub_8219C5C0(ctx, base);
	// 821A7EEC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A7EF0: 40980018  bge cr6, 0x821a7f08
	if !ctx.cr[6].lt {
	pc = 0x821A7F08; continue 'dispatch;
	}
	// 821A7EF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A7EF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A7EFC: 4BFF900D  bl 0x821a0f08
	ctx.lr = 0x821A7F00;
	sub_821A0F08(ctx, base);
	// 821A7F00: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A7F04: 48000490  b 0x821a8394
	pc = 0x821A8394; continue 'dispatch;
	// 821A7F08: 811C00A0  lwz r8, 0xa0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A7F0C: 550B0420  rlwinm r11, r8, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821A7F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F14: 419A02C0  beq cr6, 0x821a81d4
	if ctx.cr[6].eq {
	pc = 0x821A81D4; continue 'dispatch;
	}
	// 821A7F18: 39770006  addi r11, r23, 6
	ctx.r[11].s64 = ctx.r[23].s64 + 6;
	// 821A7F1C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A7F20: 7F6BFA14  add r27, r11, r31
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A7F24: 817C00AC  lwz r11, 0xac(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A7F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F2C: 419A0040  beq cr6, 0x821a7f6c
	if ctx.cr[6].eq {
	pc = 0x821A7F6C; continue 'dispatch;
	}
	// 821A7F30: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7F34: 815C00A8  lwz r10, 0xa8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A7F38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A7F3C: 409A0030  bne cr6, 0x821a7f6c
	if !ctx.cr[6].eq {
	pc = 0x821A7F6C; continue 'dispatch;
	}
	// 821A7F40: 817C00AC  lwz r11, 0xac(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A7F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F48: 419A0018  beq cr6, 0x821a7f60
	if ctx.cr[6].eq {
	pc = 0x821A7F60; continue 'dispatch;
	}
	// 821A7F4C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7F50: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A7F54: 813C00A8  lwz r9, 0xa8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A7F58: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7F5C: 419A0008  beq cr6, 0x821a7f64
	if ctx.cr[6].eq {
	pc = 0x821A7F64; continue 'dispatch;
	}
	// 821A7F60: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 821A7F64: 3BAB0060  addi r29, r11, 0x60
	ctx.r[29].s64 = ctx.r[11].s64 + 96;
	// 821A7F68: 480000E8  b 0x821a8050
	pc = 0x821A8050; continue 'dispatch;
	// 821A7F6C: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A7F70: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A7F74: 83DC00CC  lwz r30, 0xcc(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A7F78: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 821A7F7C: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 821A7F80: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821A7F84: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A7F88: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 821A7F8C: 4BFFBB7D  bl 0x821a3b08
	ctx.lr = 0x821A7F90;
	sub_821A3B08(ctx, base);
	// 821A7F90: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7F94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A7F98: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821A7F9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A7FA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A7FA4: 4E800421  bctrl
	ctx.lr = 0x821A7FA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A7FA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A83B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A83B0 size=1976
    let mut pc: u32 = 0x821A83B0;
    'dispatch: loop {
        match pc {
            0x821A83B0 => {
    //   block [0x821A83B0..0x821A877C)
	// 821A83B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A83B4: 4838CCCD  bl 0x82535080
	ctx.lr = 0x821A83B8;
	sub_82535080(ctx, base);
	// 821A83B8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A83BC: 4838DBF5  bl 0x82535fb0
	ctx.lr = 0x821A83C0;
	sub_82535FB0(ctx, base);
	// 821A83C0: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A83C4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A83C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A83CC: 82ABFAC0  lwz r21, -0x540(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A83D0: 81750040  lwz r11, 0x40(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A83D4: 93F50040  stw r31, 0x40(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 821A83D8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A83DC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A83E0: 419A03B4  beq cr6, 0x821a8794
	if ctx.cr[6].eq {
	pc = 0x821A8794; continue 'dispatch;
	}
	// 821A83E4: 81750084  lwz r11, 0x84(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A83E8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A83EC: 419A000C  beq cr6, 0x821a83f8
	if ctx.cr[6].eq {
	pc = 0x821A83F8; continue 'dispatch;
	}
	// 821A83F0: 8155008C  lwz r10, 0x8c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A83F4: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A83F8: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A83FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821A8400: 396000C0  li r11, 0xc0
	ctx.r[11].s64 = 192;
	// 821A8404: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A8408: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A840C: 916AB9EC  stw r11, -0x4614(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17940 as u32), ctx.r[11].u32 ) };
	// 821A8410: 409A0034  bne cr6, 0x821a8444
	if !ctx.cr[6].eq {
	pc = 0x821A8444; continue 'dispatch;
	}
	// 821A8414: 817500BC  lwz r11, 0xbc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(188 as u32) ) } as u64;
	// 821A8418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A841C: 419A0014  beq cr6, 0x821a8430
	if ctx.cr[6].eq {
	pc = 0x821A8430; continue 'dispatch;
	}
	// 821A8420: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8424: 815500B8  lwz r10, 0xb8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A8428: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A842C: 419A0368  beq cr6, 0x821a8794
	if ctx.cr[6].eq {
	pc = 0x821A8794; continue 'dispatch;
	}
	// 821A8430: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A8434: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 821A8438: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A843C: 4838DBC1  bl 0x82535ffc
	ctx.lr = 0x821A8440;
	sub_82535FFC(ctx, base);
	// 821A8440: 4838CC90  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
	// 821A8444: 817500CC  lwz r11, 0xcc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A8448: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 821A844C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A8450: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8454: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A8458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A845C: 4E800421  bctrl
	ctx.lr = 0x821A8460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8460: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821A8464: 817500CC  lwz r11, 0xcc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A8468: C3E30030  lfs f31, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A846C: 614AA9C0  ori r10, r10, 0xa9c0
	ctx.r[10].u64 = ctx.r[10].u64 | 43456;
	// 821A8470: C3C30038  lfs f30, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A8474: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 821A8478: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A847C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A8480: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8484: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A8488: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A848C: 4E800421  bctrl
	ctx.lr = 0x821A8490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8490: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A8494: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821A8498: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 821A849C: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 821A84A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A84A4: 8075009C  lwz r3, 0x9c(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(156 as u32) ) } as u64;
	// 821A84A8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821A84AC: 7C2A4C2E  lfsx f1, r10, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A84B0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A84B4: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A84B8: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 821A84BC: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A84C0: C12B0034  lfs f9, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A84C4: D0210058  stfs f1, 0x58(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A84C8: C00ABFFC  lfs f0, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A84CC: 81550098  lwz r10, 0x98(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A84D0: ED7F0032  fmuls f11, f31, f0
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A84D4: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A84D8: ED5E0032  fmuls f10, f30, f0
	ctx.f[10].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A84DC: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A84E0: D1210084  stfs f9, 0x84(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A84E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821A84E8: EEAD583A  fmadds f21, f13, f0, f11
	ctx.f[21].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A84EC: EE8C503A  fmadds f20, f12, f0, f10
	ctx.f[20].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821A84F0: 4BFFA181  bl 0x821a2670
	ctx.lr = 0x821A84F4;
	sub_821A2670(ctx, base);
	// 821A84F4: 82550094  lwz r18, 0x94(r21)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A84F8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A84FC: D0210070  stfs f1, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821A8500: 3EC0820A  lis r22, -0x7df6
	ctx.r[22].s64 = -2113273856;
	// 821A8504: 3972FFFF  addi r11, r18, -1
	ctx.r[11].s64 = ctx.r[18].s64 + -1;
	// 821A8508: 3EE0820D  lis r23, -0x7df3
	ctx.r[23].s64 = -2113077248;
	// 821A850C: 5570073E  clrlwi r16, r11, 0x1c
	ctx.r[16].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821A8510: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A8514: C3EA2280  lfs f31, 0x2280(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A8518: 3F00820D  lis r24, -0x7df3
	ctx.r[24].s64 = -2113077248;
	// 821A851C: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821A8520: 3F20820D  lis r25, -0x7df3
	ctx.r[25].s64 = -2113077248;
	// 821A8524: 92150094  stw r16, 0x94(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(148 as u32), ctx.r[16].u32 ) };
	// 821A8528: 3F40820D  lis r26, -0x7df3
	ctx.r[26].s64 = -2113077248;
	// 821A852C: 3F60820D  lis r27, -0x7df3
	ctx.r[27].s64 = -2113077248;
	// 821A8530: 3F80820D  lis r28, -0x7df3
	ctx.r[28].s64 = -2113077248;
	// 821A8534: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821A8538: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A853C: 3FA0820D  lis r29, -0x7df3
	ctx.r[29].s64 = -2113077248;
	// 821A8540: 39EB14A0  addi r15, r11, 0x14a0
	ctx.r[15].s64 = ctx.r[11].s64 + 5280;
	// 821A8544: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A8548: 3FC0820D  lis r30, -0x7df3
	ctx.r[30].s64 = -2113077248;
	// 821A854C: 396B4D30  addi r11, r11, 0x4d30
	ctx.r[11].s64 = ctx.r[11].s64 + 19760;
	// 821A8550: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 821A8554: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 821A8558: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 821A855C: 3CC08288  lis r6, -0x7d78
	ctx.r[6].s64 = -2105016320;
	// 821A8560: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821A8564: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A8568: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821A856C: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 821A8570: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A8574: 3E8082C0  lis r20, -0x7d40
	ctx.r[20].s64 = -2101346304;
	// 821A8578: 3E6082C0  lis r19, -0x7d40
	ctx.r[19].s64 = -2101346304;
	// 821A857C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 821A8580: 3A200010  li r17, 0x10
	ctx.r[17].s64 = 16;
	// 821A8584: 39C00020  li r14, 0x20
	ctx.r[14].s64 = 32;
	// 821A8588: C31C209C  lfs f24, 0x209c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8348 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821A858C: 8394B9E8  lwz r28, -0x4618(r20)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-17944 as u32) ) } as u64;
	// 821A8590: C2FB207C  lfs f23, 0x207c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8316 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821A8594: 8373B9E0  lwz r27, -0x4620(r19)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-17952 as u32) ) } as u64;
	// 821A8598: C01720CC  lfs f0, 0x20cc(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A859C: C26928F4  lfs f19, 0x28f4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10484 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821A85A0: C24844A8  lfs f18, 0x44a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(17576 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 821A85A4: C2C72068  lfs f22, 0x2068(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8296 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A85A8: C3D6BA38  lfs f30, -0x45c8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A85AC: C226D4DC  lfs f17, -0x2b24(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 821A85B0: C20524CC  lfs f16, 0x24cc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(9420 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 821A85B4: C34424EC  lfs f26, 0x24ec(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(9452 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A85B8: C32321DC  lfs f25, 0x21dc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8668 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821A85BC: C3BE2138  lfs f29, 0x2138(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8504 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A85C0: C39D228C  lfs f28, 0x228c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8844 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A85C4: C37AD6C8  lfs f27, -0x2938(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A85C8: C1D9223C  lfs f14, 0x223c(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8764 as u32) ) };
	ctx.f[14].f64 = (tmp.f32 as f64);
	// 821A85CC: C1F81FF8  lfs f15, 0x1ff8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8184 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 821A85D0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821A85D4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A85D8: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	// 821A85DC: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A85E0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A85E4: 41980060  blt cr6, 0x821a8644
	if ctx.cr[6].lt {
	pc = 0x821A8644; continue 'dispatch;
	}
	// 821A85E8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821A85EC: 4098012C  bge cr6, 0x821a8718
	if !ctx.cr[6].lt {
	pc = 0x821A8718; continue 'dispatch;
	}
	// 821A85F0: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 821A85F4: 409A0124  bne cr6, 0x821a8718
	if !ctx.cr[6].eq {
	pc = 0x821A8718; continue 'dispatch;
	}
	// 821A85F8: 481BEB41  bl 0x82367138
	ctx.lr = 0x821A85FC;
	sub_82367138(ctx, base);
	// 821A85FC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8600: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A8604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8608: 80D500A0  lwz r6, 0xa0(r21)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A860C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A8610: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 821A8614: C8010090  lfd f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A8618: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A861C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8620: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8624: EC2094FA  fmadds f1, f0, f19, f18
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[19].f64 + ctx.f[18].f64) as f32) as f64);
	// 821A8628: 480006C9  bl 0x821a8cf0
	ctx.lr = 0x821A862C;
	sub_821A8CF0(ctx, base);
	// 821A862C: 80750128  lwz r3, 0x128(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(296 as u32) ) } as u64;
	// 821A8630: 4BFFCEB1  bl 0x821a54e0
	ctx.lr = 0x821A8634;
	sub_821A54E0(ctx, base);
	// 821A8634: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821A8638: B07F0198  sth r3, 0x198(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[3].u16 ) };
	// 821A863C: B17F019A  sth r11, 0x19a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(410 as u32), ctx.r[11].u16 ) };
	// 821A8640: 480000DC  b 0x821a871c
	pc = 0x821A871C; continue 'dispatch;
	// 821A8644: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A8648: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A864C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A8650: 815EFBAC  lwz r10, -0x454(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1108 as u32) ) } as u64;
	// 821A8654: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A8658: 419A000C  beq cr6, 0x821a8664
	if ctx.cr[6].eq {
	pc = 0x821A8664; continue 'dispatch;
	}
	// 821A865C: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 821A8660: 409A00B8  bne cr6, 0x821a8718
	if !ctx.cr[6].eq {
	pc = 0x821A8718; continue 'dispatch;
	}
	// 821A8664: 481BEAD5  bl 0x82367138
	ctx.lr = 0x821A8668;
	sub_82367138(ctx, base);
	// 821A8668: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A866C: F96100B8  std r11, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u64 ) };
	// 821A8670: C80100B8  lfd f0, 0xb8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 821A8674: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A8678: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A867C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8680: EC00F5B8  fmsubs f0, f0, f22, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64 - ctx.f[30].f64) as f32) as f64);
	// 821A8684: D00100D0  stfs f0, 0xd0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821A8688: 481BEAB1  bl 0x82367138
	ctx.lr = 0x821A868C;
	sub_82367138(ctx, base);
	// 821A868C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8690: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 821A8694: C80100A0  lfd f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821A8698: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A869C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A86A0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A86A4: EC00F5B8  fmsubs f0, f0, f22, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64 - ctx.f[30].f64) as f32) as f64);
	// 821A86A8: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 821A86AC: 481BEA8D  bl 0x82367138
	ctx.lr = 0x821A86B0;
	sub_82367138(ctx, base);
	// 821A86B0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A86B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A86B8: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 821A86BC: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 821A86C0: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 821A86C4: F9610110  std r11, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u64 ) };
	// 821A86C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821A86CC: 386B0100  addi r3, r11, 0x100
	ctx.r[3].s64 = ctx.r[11].s64 + 256;
	// 821A86D0: C8010110  lfd f0, 0x110(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	// 821A86D4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A86D8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A86DC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A86E0: EC00F5B8  fmsubs f0, f0, f22, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64 - ctx.f[30].f64) as f32) as f64);
	// 821A86E4: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 821A86E8: 4BFF8551  bl 0x821a0c38
	ctx.lr = 0x821A86EC;
	sub_821A0C38(ctx, base);
	// 821A86EC: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A86F0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A86F4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821A86F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A86FC: 814AB9EC  lwz r10, -0x4614(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17940 as u32) ) } as u64;
	// 821A8700: 9394B9E8  stw r28, -0x4618(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(-17944 as u32), ctx.r[28].u32 ) };
	// 821A8704: 7F1C5000  cmpw cr6, r28, r10
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A8708: B17F019A  sth r11, 0x19a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(410 as u32), ctx.r[11].u16 ) };
	// 821A870C: 4198000C  blt cr6, 0x821a8718
	if ctx.cr[6].lt {
	pc = 0x821A8718; continue 'dispatch;
	}
	// 821A8710: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821A8714: 917EFBAC  stw r11, -0x454(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-1108 as u32), ctx.r[11].u32 ) };
	// 821A8718: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A871C: 817500A0  lwz r11, 0xa0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A8720: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A8724: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 821A8728: C0210058  lfs f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A872C: 556B0318  rlwinm r11, r11, 0, 0xc, 0xc
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8730: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A8734: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A8738: 71660041  andi. r6, r11, 0x41
	ctx.r[6].u64 = ctx.r[11].u64 & 65;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A873C: 4BFF3E85  bl 0x8219c5c0
	ctx.lr = 0x821A8740;
	sub_8219C5C0(ctx, base);
	// 821A8740: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A8744: 409800A0  bge cr6, 0x821a87e4
	if !ctx.cr[6].lt {
	pc = 0x821A87E4; continue 'dispatch;
	}
	// 821A8748: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A874C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821A8750: 41990094  bgt cr6, 0x821a87e4
	if ctx.cr[6].gt {
	pc = 0x821A87E4; continue 'dispatch;
	}
	// 821A8754: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821A8758: 398C876C  addi r12, r12, -0x7894
	ctx.r[12].s64 = ctx.r[12].s64 + -30868;
	// 821A875C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A8760: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A8764: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A8768: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821A877C; continue 'dispatch;
		},
		1 => {
	pc = 0x821A87A8; continue 'dispatch;
		},
		2 => {
	pc = 0x821A8920; continue 'dispatch;
		},
		3 => {
	pc = 0x821A89E4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A876C: 821A877C  lwz r16, -0x7884(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30852 as u32) ) } as u64;
	// 821A8770: 821A87A8  lwz r16, -0x7858(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30808 as u32) ) } as u64;
	// 821A8774: 821A8920  lwz r16, -0x76e0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30432 as u32) ) } as u64;
	// 821A8778: 821A89E4  lwz r16, -0x761c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30236 as u32) ) } as u64;
            }
            0x821A877C => {
    //   block [0x821A877C..0x821A87A8)
	// 821A877C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A8780: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821A8784: 4BFF8785  bl 0x821a0f08
	ctx.lr = 0x821A8788;
	sub_821A0F08(ctx, base);
	// 821A8788: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A878C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A8790: 409AFE44  bne cr6, 0x821a85d4
	if !ctx.cr[6].eq {
	pc = 0x821A85D4; continue 'dispatch;
	}
	// 821A8794: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A8798: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 821A879C: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A87A0: 4838D85D  bl 0x82535ffc
	ctx.lr = 0x821A87A4;
	sub_82535FFC(ctx, base);
	// 821A87A4: 4838C92C  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x821A87A8 => {
    //   block [0x821A87A8..0x821A8920)
	// 821A87A8: 481BE991  bl 0x82367138
	ctx.lr = 0x821A87AC;
	sub_82367138(ctx, base);
	// 821A87AC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A87B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A87B4: 80D500A0  lwz r6, 0xa0(r21)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A87B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A87BC: F96100B0  std r11, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u64 ) };
	// 821A87C0: C80100B0  lfd f0, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 821A87C4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A87C8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A87CC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A87D0: EC20847A  fmadds f1, f0, f17, f16
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[17].f64 + ctx.f[16].f64) as f32) as f64);
	// 821A87D4: 4800051D  bl 0x821a8cf0
	ctx.lr = 0x821A87D8;
	sub_821A8CF0(ctx, base);
	// 821A87D8: 80750128  lwz r3, 0x128(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(296 as u32) ) } as u64;
	// 821A87DC: 4BFFCD05  bl 0x821a54e0
	ctx.lr = 0x821A87E0;
	sub_821A54E0(ctx, base);
	// 821A87E0: B07F0198  sth r3, 0x198(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[3].u16 ) };
	// 821A87E4: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A87E8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821A87EC: 409A0228  bne cr6, 0x821a8a14
	if !ctx.cr[6].eq {
	pc = 0x821A8A14; continue 'dispatch;
	}
	// 821A87F0: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A87F4: 39520006  addi r10, r18, 6
	ctx.r[10].s64 = ctx.r[18].s64 + 6;
	// 821A87F8: 83B500CC  lwz r29, 0xcc(r21)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A87FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A8800: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 821A8804: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A8808: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 821A880C: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 821A8810: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821A8814: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A8818: 4BFFB2F1  bl 0x821a3b08
	ctx.lr = 0x821A881C;
	sub_821A3B08(ctx, base);
	// 821A881C: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8820: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A8824: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 821A8828: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A882C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A8830: 4E800421  bctrl
	ctx.lr = 0x821A8834;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8834: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
            }
            0x821A8920 => {
    //   block [0x821A8920..0x821A89E4)
	// 821A8920: 481BE819  bl 0x82367138
	ctx.lr = 0x821A8924;
	sub_82367138(ctx, base);
	// 821A8924: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8928: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A892C: 80D500A0  lwz r6, 0xa0(r21)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A8930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8934: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 821A8938: C80100E0  lfd f0, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 821A893C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A8940: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8944: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8948: EC20CEBA  fmadds f1, f0, f26, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[26].f64 + ctx.f[25].f64) as f32) as f64);
	// 821A894C: 480003A5  bl 0x821a8cf0
	ctx.lr = 0x821A8950;
	sub_821A8CF0(ctx, base);
	// 821A8950: 80750128  lwz r3, 0x128(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(296 as u32) ) } as u64;
	// 821A8954: 4BFFCB8D  bl 0x821a54e0
	ctx.lr = 0x821A8958;
	sub_821A54E0(ctx, base);
	// 821A8958: 39720006  addi r11, r18, 6
	ctx.r[11].s64 = ctx.r[18].s64 + 6;
	// 821A895C: B07F0198  sth r3, 0x198(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[3].u16 ) };
	// 821A8960: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A8964: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A8968: 481BE7D1  bl 0x82367138
	ctx.lr = 0x821A896C;
	sub_82367138(ctx, base);
	// 821A896C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8970: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 821A8974: C80100C0  lfd f0, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 821A8978: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A897C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8980: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8984: EC00AF7A  fmadds f0, f0, f29, f21
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[21].f64) as f32) as f64);
	// 821A8988: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 821A898C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A8990: 481BE7A9  bl 0x82367138
	ctx.lr = 0x821A8994;
	sub_82367138(ctx, base);
	// 821A8994: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8998: D3040004  stfs f24, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A899C: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 821A89A0: C8010098  lfd f0, 0x98(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 821A89A4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A89A8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A89AC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A89B0: EC00A77A  fmadds f0, f0, f29, f20
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[20].f64) as f32) as f64);
	// 821A89B4: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 821A89B8: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A89BC: 481BE77D  bl 0x82367138
	ctx.lr = 0x821A89C0;
	sub_82367138(ctx, base);
	// 821A89C0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A89C4: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 821A89C8: C80100A8  lfd f0, 0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 821A89CC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A89D0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A89D4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A89D8: EC00DDF8  fmsubs f0, f0, f23, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[23].f64 - ctx.f[27].f64) as f32) as f64);
	// 821A89DC: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A89E0: 4BFFFE04  b 0x821a87e4
	pc = 0x821A87E4; continue 'dispatch;
            }
            0x821A89E4 => {
    //   block [0x821A89E4..0x821A8B68)
	// 821A89E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A89E8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821A89EC: 4BFF851D  bl 0x821a0f08
	ctx.lr = 0x821A89F0;
	sub_821A0F08(ctx, base);
	// 821A89F0: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 821A89F4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821A89F8: 9394B9E8  stw r28, -0x4618(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(-17944 as u32), ctx.r[28].u32 ) };
	// 821A89FC: 4199FD8C  bgt cr6, 0x821a8788
	if ctx.cr[6].gt {
	pc = 0x821A8788; continue 'dispatch;
	}
	// 821A8A00: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 821A8A04: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 821A8A08: 9394B9E8  stw r28, -0x4618(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(-17944 as u32), ctx.r[28].u32 ) };
	// 821A8A0C: 9373B9E0  stw r27, -0x4620(r19)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(-17952 as u32), ctx.r[27].u32 ) };
	// 821A8A10: 4BFFFD78  b 0x821a8788
	pc = 0x821A8788; continue 'dispatch;
	// 821A8A14: 397F0060  addi r11, r31, 0x60
	ctx.r[11].s64 = ctx.r[31].s64 + 96;
	// 821A8A18: C0210058  lfs f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A8A1C: 560A2036  slwi r10, r16, 4
	ctx.r[10].u32 = ctx.r[16].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A8A20: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A8A24: 56492036  slwi r9, r18, 4
	ctx.r[9].u32 = ctx.r[18].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A8A28: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A8A2C: 3BBF0160  addi r29, r31, 0x160
	ctx.r[29].s64 = ctx.r[31].s64 + 352;
	// 821A8A30: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821A8A34: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A8A38: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821A8A3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A8A40: 4BFF9D21  bl 0x821a2760
	ctx.lr = 0x821A8A44;
	sub_821A2760(ctx, base);
	// 821A8A44: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A8A48: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A8A4C: 409A00DC  bne cr6, 0x821a8b28
	if !ctx.cr[6].eq {
	pc = 0x821A8B28; continue 'dispatch;
	}
	// 821A8A50: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A8A54: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8A58: EC007028  fsubs f0, f0, f14
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[14].f64) as f32) as f64);
	// 821A8A5C: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8A60: C05E0008  lfs f2, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A8A64: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A8A68: 896A0001  lbz r11, 1(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 821A8A6C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821A8A70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A8A74: 40990018  ble cr6, 0x821a8a8c
	if !ctx.cr[6].gt {
	pc = 0x821A8A8C; continue 'dispatch;
	}
	// 821A8A78: 896A0002  lbz r11, 2(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A8A7C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821A8A80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A8A84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8A88: 41990008  bgt cr6, 0x821a8a90
	if ctx.cr[6].gt {
	pc = 0x821A8A90; continue 'dispatch;
	}
	// 821A8A8C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821A8A90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A8A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8A98: 409A0010  bne cr6, 0x821a8aa8
	if !ctx.cr[6].eq {
	pc = 0x821A8AA8; continue 'dispatch;
	}
	// 821A8A9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A8AA0: 4800EA29  bl 0x821b74c8
	ctx.lr = 0x821A8AA4;
	sub_821B74C8(ctx, base);
	// 821A8AA4: 48000014  b 0x821a8ab8
	pc = 0x821A8AB8; continue 'dispatch;
	// 821A8AA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A8AAC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 821A8AB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821A8AB4: 4800EA7D  bl 0x821b7530
	ctx.lr = 0x821A8AB8;
	sub_821B7530(ctx, base);
	// 821A8AB8: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8ABC: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 821A8AC0: 41990080  bgt cr6, 0x821a8b40
	if ctx.cr[6].gt {
	pc = 0x821A8B40; continue 'dispatch;
	}
	// 821A8AC4: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821A8AC8: 41990034  bgt cr6, 0x821a8afc
	if ctx.cr[6].gt {
	pc = 0x821A8AFC; continue 'dispatch;
	}
	// 821A8ACC: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8AD0: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 821A8AD4: D37F0174  stfs f27, 0x174(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 821A8AD8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8ADC: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821A8AE0: D1FD0008  stfs f15, 8(r29)
	tmp.f32 = (ctx.f[15].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A8AE4: D1FD0004  stfs f15, 4(r29)
	tmp.f32 = (ctx.f[15].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8AE8: D1FD0000  stfs f15, 0(r29)
	tmp.f32 = (ctx.f[15].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A8AEC: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A8AF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A8AF4: B17F019A  sth r11, 0x19a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(410 as u32), ctx.r[11].u16 ) };
	// 821A8AF8: 48000048  b 0x821a8b40
	pc = 0x821A8B40; continue 'dispatch;
	// 821A8AFC: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8B00: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8B04: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A8B08: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8B0C: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A8B10: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821A8B14: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821A8B18: D1BD0000  stfs f13, 0(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A8B1C: D19D0004  stfs f12, 4(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8B20: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A8B24: 4800001C  b 0x821a8b40
	pc = 0x821A8B40; continue 'dispatch;
	// 821A8B28: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A8B2C: 409A0014  bne cr6, 0x821a8b40
	if !ctx.cr[6].eq {
	pc = 0x821A8B40; continue 'dispatch;
	}
	// 821A8B30: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8B34: C1A10078  lfs f13, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8B38: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821A8B3C: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8B40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8B44: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A8B48: 409A0010  bne cr6, 0x821a8b58
	if !ctx.cr[6].eq {
	pc = 0x821A8B58; continue 'dispatch;
	}
	// 821A8B4C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 821A8B50: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821A8B54: 4BFFFC38  b 0x821a878c
	pc = 0x821A878C; continue 'dispatch;
	// 821A8B58: 8155008C  lwz r10, 0x8c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A8B5C: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A8B60: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821A8B64: 4BFFFC28  b 0x821a878c
	pc = 0x821A878C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A8B68 size=264
    let mut pc: u32 = 0x821A8B68;
    'dispatch: loop {
        match pc {
            0x821A8B68 => {
    //   block [0x821A8B68..0x821A8C70)
	// 821A8B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8B70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8B74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8B78: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A8B7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A8B80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821A8B84: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A8B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8B8C: 481C176D  bl 0x8236a2f8
	ctx.lr = 0x821A8B90;
	sub_8236A2F8(ctx, base);
	// 821A8B90: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A8B94: 389F008C  addi r4, r31, 0x8c
	ctx.r[4].s64 = ctx.r[31].s64 + 140;
	// 821A8B98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8B9C: 419A0014  beq cr6, 0x821a8bb0
	if ctx.cr[6].eq {
	pc = 0x821A8BB0; continue 'dispatch;
	}
	// 821A8BA0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A8BA4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A8BA8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A8BAC: 4BFF94D5  bl 0x821a2080
	ctx.lr = 0x821A8BB0;
	sub_821A2080(ctx, base);
	// 821A8BB0: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A8BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8BB8: 419A0048  beq cr6, 0x821a8c00
	if ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BBC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8BC0: 813F00A8  lwz r9, 0xa8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A8BC4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A8BC8: 409A0038  bne cr6, 0x821a8c00
	if !ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BCC: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A8BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8BD4: 419A002C  beq cr6, 0x821a8c00
	if ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BD8: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A8BDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A8BE0: 419A0020  beq cr6, 0x821a8c00
	if ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BE4: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8BE8: 812B0090  lwz r9, 0x90(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A8BEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A8BF0: 409A0010  bne cr6, 0x821a8c00
	if !ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BF4: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A8BF8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A8BFC: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A8C00: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821A8C04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A8C08: 419A0050  beq cr6, 0x821a8c58
	if ctx.cr[6].eq {
	pc = 0x821A8C58; continue 'dispatch;
	}
	// 821A8C0C: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821A8C10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A8C14: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A8C18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8C1C: 419A003C  beq cr6, 0x821a8c58
	if ctx.cr[6].eq {
	pc = 0x821A8C58; continue 'dispatch;
	}
	// 821A8C20: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8C24: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A8C28: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A8C2C: 409A002C  bne cr6, 0x821a8c58
	if !ctx.cr[6].eq {
	pc = 0x821A8C58; continue 'dispatch;
	}
	// 821A8C30: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A8C34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A8C38: 409A0024  bne cr6, 0x821a8c5c
	if !ctx.cr[6].eq {
	pc = 0x821A8C5C; continue 'dispatch;
	}
	// 821A8C3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A8C40: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A8C44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8C48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8C4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8C50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8C54: 4E800020  blr
	return;
	// 821A8C58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A8C5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8C60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8C64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8C68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8C6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A8C70 size=128
    let mut pc: u32 = 0x821A8C70;
    'dispatch: loop {
        match pc {
            0x821A8C70 => {
    //   block [0x821A8C70..0x821A8CF0)
	// 821A8C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8C78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A8C7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8C80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8C84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A8C88: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A8C8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A8C90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A8C94: 4BFF811D  bl 0x821a0db0
	ctx.lr = 0x821A8C98;
	sub_821A0DB0(ctx, base);
	// 821A8C98: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A8C9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A8CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8CA4: 419A0034  beq cr6, 0x821a8cd8
	if ctx.cr[6].eq {
	pc = 0x821A8CD8; continue 'dispatch;
	}
	// 821A8CA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8CAC: B17F0010  sth r11, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 821A8CB0: 80DE00A0  lwz r6, 0xa0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A8CB4: 809E0098  lwz r4, 0x98(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A8CB8: 48000039  bl 0x821a8cf0
	ctx.lr = 0x821A8CBC;
	sub_821A8CF0(ctx, base);
	// 821A8CBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A8CC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A8CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8CC8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8CCC: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 821A8CD0: D07F0194  stfs f3, 0x194(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 821A8CD4: B15F019A  sth r10, 0x19a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(410 as u32), ctx.r[10].u16 ) };
	// 821A8CD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8CDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8CE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8CE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A8CE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A8CF0 size=208
    let mut pc: u32 = 0x821A8CF0;
    'dispatch: loop {
        match pc {
            0x821A8CF0 => {
    //   block [0x821A8CF0..0x821A8DC0)
	// 821A8CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8CF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8CFC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8D00: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A8D04: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 821A8D08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A8D0C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A8D10: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8D14: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 821A8D18: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A8D1C: EDA00824  fdivs f13, f0, f1
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 821A8D20: 810A0084  lwz r8, 0x84(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A8D24: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8D28: 2F070005  cmpwi cr6, r7, 5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 5, &mut ctx.xer);
	// 821A8D2C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A8D30: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8D34: 409A0018  bne cr6, 0x821a8d4c
	if !ctx.cr[6].eq {
	pc = 0x821A8D4C; continue 'dispatch;
	}
	// 821A8D38: 7D054B78  or r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821A8D3C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8D40: 54A507FE  clrlwi r5, r5, 0x1f
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 821A8D44: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A8D48: 409A000C  bne cr6, 0x821a8d54
	if !ctx.cr[6].eq {
	pc = 0x821A8D54; continue 'dispatch;
	}
	// 821A8D4C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A8D50: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8D54: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821A8D58: 5529F87E  srwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A8D5C: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A8D60: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821A8D64: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A8D68: 2F070008  cmpwi cr6, r7, 8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 8, &mut ctx.xer);
	// 821A8D6C: 4198FFB8  blt cr6, 0x821a8d24
	if ctx.cr[6].lt {
	pc = 0x821A8D24; continue 'dispatch;
	}
	// 821A8D70: 54CB04E6  rlwinm r11, r6, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8D78: 419A0034  beq cr6, 0x821a8dac
	if ctx.cr[6].eq {
	pc = 0x821A8DAC; continue 'dispatch;
	}
	// 821A8D7C: 481BE3BD  bl 0x82367138
	ctx.lr = 0x821A8D80;
	sub_82367138(ctx, base);
	// 821A8D80: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8D84: C1BF0034  lfs f13, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8D88: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A8D8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A8D90: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A8D94: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A8D98: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8D9C: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8DA0: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8DA4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821A8DA8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821A8DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8DB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8DBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A8DC0 size=244
    let mut pc: u32 = 0x821A8DC0;
    'dispatch: loop {
        match pc {
            0x821A8DC0 => {
    //   block [0x821A8DC0..0x821A8EB4)
	// 821A8DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A8DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8DD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8DD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A8DD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A8DDC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A8DE0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821A8DE4: 38EB0E84  addi r7, r11, 0xe84
	ctx.r[7].s64 = ctx.r[11].s64 + 3716;
	// 821A8DE8: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821A8DEC: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 821A8DF0: FBFE0000  std r31, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 821A8DF4: 481C169D  bl 0x8236a490
	ctx.lr = 0x821A8DF8;
	sub_8236A490(ctx, base);
	// 821A8DF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A8DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8E00: 419A000C  beq cr6, 0x821a8e0c
	if ctx.cr[6].eq {
	pc = 0x821A8E0C; continue 'dispatch;
	}
	// 821A8E04: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8E08: 48000008  b 0x821a8e10
	pc = 0x821A8E10; continue 'dispatch;
	// 821A8E0C: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 821A8E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8E14: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A8E18: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821A8E1C: 419A0090  beq cr6, 0x821a8eac
	if ctx.cr[6].eq {
	pc = 0x821A8EAC; continue 'dispatch;
	}
	// 821A8E20: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A8E24: 3CE0821B  lis r7, -0x7de5
	ctx.r[7].s64 = -2112159744;
	// 821A8E28: 394A0F7C  addi r10, r10, 0xf7c
	ctx.r[10].s64 = ctx.r[10].s64 + 3964;
	// 821A8E2C: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821A8E30: 38E78EB8  addi r7, r7, -0x7148
	ctx.r[7].s64 = ctx.r[7].s64 + -29000;
	// 821A8E34: 39298EE8  addi r9, r9, -0x7118
	ctx.r[9].s64 = ctx.r[9].s64 + -28952;
	// 821A8E38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A8E3C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A8E40: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821A8E44: FBEB0188  std r31, 0x188(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(392 as u32), ctx.r[31].u64 ) };
	// 821A8E48: 394A90B0  addi r10, r10, -0x6f50
	ctx.r[10].s64 = ctx.r[10].s64 + -28496;
	// 821A8E4C: FBEB0190  std r31, 0x190(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(400 as u32), ctx.r[31].u64 ) };
	// 821A8E50: 912B0058  stw r9, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A8E54: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821A8E58: 90EB0054  stw r7, 0x54(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821A8E5C: 98CB001C  stb r6, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[6].u8 ) };
	// 821A8E60: 914B005C  stw r10, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A8E64: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8E68: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A8E6C: 419A0008  beq cr6, 0x821a8e74
	if ctx.cr[6].eq {
	pc = 0x821A8E74; continue 'dispatch;
	}
	// 821A8E70: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A8E74: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A8E78: 912B0194  stw r9, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[9].u32 ) };
	// 821A8E7C: 910B0190  stw r8, 0x190(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(400 as u32), ctx.r[8].u32 ) };
	// 821A8E80: FBEB0188  std r31, 0x188(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(392 as u32), ctx.r[31].u64 ) };
	// 821A8E84: 93EB017C  stw r31, 0x17c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(380 as u32), ctx.r[31].u32 ) };
	// 821A8E88: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8E8C: D00B0184  stfs f0, 0x184(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 821A8E90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A8E94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8E98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8E9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8EA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A8EA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8EA8: 4E800020  blr
	return;
	// 821A8EAC: FBFE0000  std r31, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 821A8EB0: 4BFFFFE0  b 0x821a8e90
	pc = 0x821A8E90; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A8EB8 size=48
    let mut pc: u32 = 0x821A8EB8;
    'dispatch: loop {
        match pc {
            0x821A8EB8 => {
    //   block [0x821A8EB8..0x821A8EE8)
	// 821A8EB8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A8EBC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A8EC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8EC4: 419A000C  beq cr6, 0x821a8ed0
	if ctx.cr[6].eq {
	pc = 0x821A8ED0; continue 'dispatch;
	}
	// 821A8EC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A8ECC: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A8ED0: C00B00C0  lfs f0, 0xc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8ED4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A8ED8: D00B0170  stfs f0, 0x170(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 821A8EDC: C00B00C4  lfs f0, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8EE0: D00B0174  stfs f0, 0x174(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 821A8EE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A8EE8 size=456
    let mut pc: u32 = 0x821A8EE8;
    'dispatch: loop {
        match pc {
            0x821A8EE8 => {
    //   block [0x821A8EE8..0x821A90B0)
	// 821A8EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A8EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8EF8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821A8EFC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8F00: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A8F04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A8F08: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A8F0C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A8F10: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A8F14: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A8F18: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A8F1C: 419A0174  beq cr6, 0x821a9090
	if ctx.cr[6].eq {
	pc = 0x821A9090; continue 'dispatch;
	}
	// 821A8F20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A8F24: C01F0184  lfs f0, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8F28: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A8F2C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A8F30: 41990144  bgt cr6, 0x821a9074
	if ctx.cr[6].gt {
	pc = 0x821A9074; continue 'dispatch;
	}
	// 821A8F34: 83DF0118  lwz r30, 0x118(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 821A8F38: 57CB05EE  rlwinm r11, r30, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8F40: 419A0008  beq cr6, 0x821a8f48
	if ctx.cr[6].eq {
	pc = 0x821A8F48; continue 'dispatch;
	}
	// 821A8F44: 57DE07B6  rlwinm r30, r30, 0, 0x1e, 0x1b
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8F48: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 821A8F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8F50: 419A0054  beq cr6, 0x821a8fa4
	if ctx.cr[6].eq {
	pc = 0x821A8FA4; continue 'dispatch;
	}
	// 821A8F54: 57CB0294  rlwinm r11, r30, 0, 0xa, 0xa
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8F5C: 419A0024  beq cr6, 0x821a8f80
	if ctx.cr[6].eq {
	pc = 0x821A8F80; continue 'dispatch;
	}
	// 821A8F60: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A8F64: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A8F68: 816BB9E8  lwz r11, -0x4618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17944 as u32) ) } as u64;
	// 821A8F6C: 814AB9EC  lwz r10, -0x4614(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17940 as u32) ) } as u64;
	// 821A8F70: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A8F74: 4098000C  bge cr6, 0x821a8f80
	if !ctx.cr[6].lt {
	pc = 0x821A8F80; continue 'dispatch;
	}
	// 821A8F78: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A8F7C: 48000020  b 0x821a8f9c
	pc = 0x821A8F9C; continue 'dispatch;
	// 821A8F80: C01F0170  lfs f0, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8F84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821A8F88: C1BF00D0  lfs f13, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8F8C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A8F90: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A8F94: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821A8F98: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A8F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8FA0: 48000149  bl 0x821a90e8
	ctx.lr = 0x821A8FA4;
	sub_821A90E8(ctx, base);
	// 821A8FA4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A8FA8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821A8FAC: 397F0170  addi r11, r31, 0x170
	ctx.r[11].s64 = ctx.r[31].s64 + 368;
	// 821A8FB0: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 821A8FB4: C14ABA38  lfs f10, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A8FB8: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A8FBC: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 821A8FC0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8FC4: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8FC8: EC0A0024  fdivs f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 821A8FCC: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A8FD0: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821A8FD4: 419A0050  beq cr6, 0x821a9024
	if ctx.cr[6].eq {
	pc = 0x821A9024; continue 'dispatch;
	}
	// 821A8FD8: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8FDC: C1BF00C8  lfs f13, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8FE0: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A8FE4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821A8FE8: ED6B602A  fadds f11, f11, f12
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 821A8FEC: 40980010  bge cr6, 0x821a8ffc
	if !ctx.cr[6].lt {
	pc = 0x821A8FFC; continue 'dispatch;
	}
	// 821A8FF0: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 821A8FF4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821A8FF8: 48000008  b 0x821a9000
	pc = 0x821A9000; continue 'dispatch;
	// 821A8FFC: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 821A9000: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 821A9004: 4199000C  bgt cr6, 0x821a9010
	if ctx.cr[6].gt {
	pc = 0x821A9010; continue 'dispatch;
	}
	// 821A9008: D3EB0004  stfs f31, 4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A900C: FD606090  fmr f11, f12
	ctx.f[11].f64 = ctx.f[12].f64;
	// 821A9010: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 821A9014: 4198000C  blt cr6, 0x821a9020
	if ctx.cr[6].lt {
	pc = 0x821A9020; continue 'dispatch;
	}
	// 821A9018: D3EB0004  stfs f31, 4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A901C: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 821A9020: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A9024: 57CB077A  rlwinm r11, r30, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821A9028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A902C: 419A001C  beq cr6, 0x821a9048
	if ctx.cr[6].eq {
	pc = 0x821A9048; continue 'dispatch;
	}
	// 821A9030: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 821A9034: 815F0180  lwz r10, 0x180(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 821A9038: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A903C: 41980024  blt cr6, 0x821a9060
	if ctx.cr[6].lt {
	pc = 0x821A9060; continue 'dispatch;
	}
	// 821A9040: D3FF0178  stfs f31, 0x178(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821A9044: 4800001C  b 0x821a9060
	pc = 0x821A9060; continue 'dispatch;
	// 821A9048: 57CB0738  rlwinm r11, r30, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821A904C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9050: 419A0010  beq cr6, 0x821a9060
	if ctx.cr[6].eq {
	pc = 0x821A9060; continue 'dispatch;
	}
	// 821A9054: C01F0178  lfs f0, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9058: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 821A905C: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821A9060: C01F0178  lfs f0, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9064: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A9068: 41990028  bgt cr6, 0x821a9090
	if ctx.cr[6].gt {
	pc = 0x821A9090; continue 'dispatch;
	}
	// 821A906C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A9070: 48000024  b 0x821a9094
	pc = 0x821A9094; continue 'dispatch;
	// 821A9074: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A9078: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A907C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A9080: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A9084: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A9088: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A908C: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 821A9090: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A9094: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A9098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A909C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A90A0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821A90A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A90A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A90AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A90B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A90B0 size=24
    let mut pc: u32 = 0x821A90B0;
    'dispatch: loop {
        match pc {
            0x821A90B0 => {
    //   block [0x821A90B0..0x821A90C8)
	// 821A90B0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A90B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A90B8: 814BFAC0  lwz r10, -0x540(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A90BC: 816A018C  lwz r11, 0x18c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(396 as u32) ) } as u64;
	// 821A90C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A90C4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A90C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A90C8 size=16
    let mut pc: u32 = 0x821A90C8;
    'dispatch: loop {
        match pc {
            0x821A90C8 => {
    //   block [0x821A90C8..0x821A90D8)
	// 821A90C8: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A90CC: 814A0188  lwz r10, 0x188(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(392 as u32) ) } as u64;
	// 821A90D0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A90D4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A90D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A90D8 size=12
    let mut pc: u32 = 0x821A90D8;
    'dispatch: loop {
        match pc {
            0x821A90D8 => {
    //   block [0x821A90D8..0x821A90E4)
	// 821A90D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A90DC: F94B00B8  std r10, 0xb8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[10].u64 ) };
	// 821A90E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A90E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A90E8 size=1740
    let mut pc: u32 = 0x821A90E8;
    'dispatch: loop {
        match pc {
            0x821A90E8 => {
    //   block [0x821A90E8..0x821A97B4)
	// 821A90E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A90EC: 4838BF95  bl 0x82535080
	ctx.lr = 0x821A90F0;
	sub_82535080(ctx, base);
	// 821A90F0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A90F4: 4838CEC9  bl 0x82535fbc
	ctx.lr = 0x821A90F8;
	sub_82535FB0(ctx, base);
	// 821A90F8: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A90FC: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 821A9100: 9081020C  stw r4, 0x20c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(524 as u32), ctx.r[4].u32 ) };
	// 821A9104: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 821A9108: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A910C: 91C10054  stw r14, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[14].u32 ) };
	// 821A9110: 4199000C  bgt cr6, 0x821a911c
	if ctx.cr[6].gt {
	pc = 0x821A911C; continue 'dispatch;
	}
	// 821A9114: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A9118: 9161020C  stw r11, 0x20c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(524 as u32), ctx.r[11].u32 ) };
	// 821A911C: 8177018C  lwz r11, 0x18c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(396 as u32) ) } as u64;
	// 821A9120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9124: 419A0018  beq cr6, 0x821a913c
	if ctx.cr[6].eq {
	pc = 0x821A913C; continue 'dispatch;
	}
	// 821A9128: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A912C: 7D705B78  mr r16, r11
	ctx.r[16].u64 = ctx.r[11].u64;
	// 821A9130: 81370188  lwz r9, 0x188(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(392 as u32) ) } as u64;
	// 821A9134: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9138: 419A0008  beq cr6, 0x821a9140
	if ctx.cr[6].eq {
	pc = 0x821A9140; continue 'dispatch;
	}
	// 821A913C: 7DD07378  mr r16, r14
	ctx.r[16].u64 = ctx.r[14].u64;
	// 821A9140: 8161020C  lwz r11, 0x20c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(524 as u32) ) } as u64;
	// 821A9144: 83170118  lwz r24, 0x118(r23)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(280 as u32) ) } as u64;
	// 821A9148: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 821A914C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A9150: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A9154: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 821A9158: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821A915C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A9160: C30BBA38  lfs f24, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821A9164: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A9168: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A916C: EE380024  fdivs f17, f24, f0
	ctx.f[17].f64 = ((ctx.f[24].f64 / ctx.f[0].f64) as f32) as f64;
	// 821A9170: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9174: EFF10032  fmuls f31, f17, f0
	ctx.f[31].f64 = (((ctx.f[17].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9178: 4099061C  ble cr6, 0x821a9794
	if !ctx.cr[6].gt {
	pc = 0x821A9794; continue 'dispatch;
	}
	// 821A917C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A9180: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821A9184: 396BD6D0  addi r11, r11, -0x2930
	ctx.r[11].s64 = ctx.r[11].s64 + -10544;
	// 821A9188: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 821A918C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821A9190: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A9194: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A9198: 3A4ADBD0  addi r18, r10, -0x2430
	ctx.r[18].s64 = ctx.r[10].s64 + -9264;
	// 821A919C: C2ABFB48  lfs f21, -0x4b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 821A91A0: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821A91A4: C28B0000  lfs f20, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821A91A8: C2671FF8  lfs f19, 0x1ff8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821A91AC: 3DE08286  lis r15, -0x7d7a
	ctx.r[15].s64 = -2105147392;
	// 821A91B0: C2C82280  lfs f22, 0x2280(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8832 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A91B4: 3A6A14A0  addi r19, r10, 0x14a0
	ctx.r[19].s64 = ctx.r[10].s64 + 5280;
	// 821A91B8: C24920B0  lfs f18, 0x20b0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8368 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 821A91BC: 3A800030  li r20, 0x30
	ctx.r[20].s64 = 48;
	// 821A91C0: C2E6D6C8  lfs f23, -0x2938(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821A91C4: 3AA00010  li r21, 0x10
	ctx.r[21].s64 = 16;
	// 821A91C8: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 821A91CC: 3A20003F  li r17, 0x3f
	ctx.r[17].s64 = 63;
	// 821A91D0: 570B06B4  rlwinm r11, r24, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821A91D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A91D8: 419A0010  beq cr6, 0x821a91e8
	if ctx.cr[6].eq {
	pc = 0x821A91E8; continue 'dispatch;
	}
	// 821A91DC: C0170178  lfs f0, 0x178(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A91E0: EC2004B2  fmuls f1, f0, f18
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[18].f64) as f32) as f64);
	// 821A91E4: 4800002C  b 0x821a9210
	pc = 0x821A9210; continue 'dispatch;
	// 821A91E8: 481BDF51  bl 0x82367138
	ctx.lr = 0x821A91EC;
	sub_82367138(ctx, base);
	// 821A91EC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A91F0: C1B70114  lfs f13, 0x114(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A91F4: C1970110  lfs f12, 0x110(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A91F8: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 821A91FC: C80100D0  lfd f0, 0xd0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 821A9200: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A9204: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A9208: EC0005B2  fmuls f0, f0, f22
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 821A920C: EC2D603A  fmadds f1, f13, f0, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A9210: 570B039C  rlwinm r11, r24, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821A9214: FC409890  fmr f2, f19
	ctx.f[2].f64 = ctx.f[19].f64;
	// 821A9218: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 821A921C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9220: 419A000C  beq cr6, 0x821a922c
	if ctx.cr[6].eq {
	pc = 0x821A922C; continue 'dispatch;
	}
	// 821A9224: FC60C090  fmr f3, f24
	ctx.f[3].f64 = ctx.f[24].f64;
	// 821A9228: 48000008  b 0x821a9230
	pc = 0x821A9230; continue 'dispatch;
	// 821A922C: FC609890  fmr f3, f19
	ctx.f[3].f64 = ctx.f[19].f64;
	// 821A9230: 4BFFFA41  bl 0x821a8c70
	ctx.lr = 0x821A9234;
	sub_821A8C70(ctx, base);
	// 821A9234: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821A9238: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821A923C: 419A0558  beq cr6, 0x821a9794
	if ctx.cr[6].eq {
	pc = 0x821A9794; continue 'dispatch;
	}
	// 821A9240: 570B0294  rlwinm r11, r24, 0, 0xa, 0xa
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821A9244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9248: 419A0018  beq cr6, 0x821a9260
	if ctx.cr[6].eq {
	pc = 0x821A9260; continue 'dispatch;
	}
	// 821A924C: 816FFBAC  lwz r11, -0x454(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-1108 as u32) ) } as u64;
	// 821A9250: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A9254: 4198000C  blt cr6, 0x821a9260
	if ctx.cr[6].lt {
	pc = 0x821A9260; continue 'dispatch;
	}
	// 821A9258: B1790012  sth r11, 0x12(r25)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[25].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 821A925C: 48000010  b 0x821a926c
	pc = 0x821A926C; continue 'dispatch;
	// 821A9260: 3877011C  addi r3, r23, 0x11c
	ctx.r[3].s64 = ctx.r[23].s64 + 284;
	// 821A9264: 4BFFA785  bl 0x821a39e8
	ctx.lr = 0x821A9268;
	sub_821A39E8(ctx, base);
	// 821A9268: B0790012  sth r3, 0x12(r25)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[25].u32.wrapping_add(18 as u32), ctx.r[3].u16 ) };
	// 821A926C: 817000AC  lwz r11, 0xac(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A9270: 3BF90060  addi r31, r25, 0x60
	ctx.r[31].s64 = ctx.r[25].s64 + 96;
	// 821A9274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9278: 419A0064  beq cr6, 0x821a92dc
	if ctx.cr[6].eq {
	pc = 0x821A92DC; continue 'dispatch;
	}
	// 821A927C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9280: 813000A8  lwz r9, 0xa8(r16)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A9284: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9288: 409A0054  bne cr6, 0x821a92dc
	if !ctx.cr[6].eq {
	pc = 0x821A92DC; continue 'dispatch;
	}
	// 821A928C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A9290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9294: 419A0048  beq cr6, 0x821a92dc
	if ctx.cr[6].eq {
	pc = 0x821A92DC; continue 'dispatch;
	}
	// 821A9298: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A929C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A92A0: 419A0020  beq cr6, 0x821a92c0
	if ctx.cr[6].eq {
	pc = 0x821A92C0; continue 'dispatch;
	}
	// 821A92A4: 730A8040  andi. r10, r24, 0x8040
	ctx.r[10].u64 = ctx.r[24].u64 & 32832;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A92A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A92AC: 409A0014  bne cr6, 0x821a92c0
	if !ctx.cr[6].eq {
	pc = 0x821A92C0; continue 'dispatch;
	}
	// 821A92B0: D27F0008  stfs f19, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A92B4: D27F0004  stfs f19, 4(r31)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A92B8: D27F0000  stfs f19, 0(r31)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A92BC: 48000374  b 0x821a9630
	pc = 0x821A9630; continue 'dispatch;
	// 821A92C0: C00B0060  lfs f0, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A92C4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A92C8: C00B0064  lfs f0, 0x64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A92CC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A92D0: C00B0068  lfs f0, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A92D4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A92D8: 48000358  b 0x821a9630
	pc = 0x821A9630; continue 'dispatch;
	// 821A92DC: 730B8040  andi. r11, r24, 0x8040
	ctx.r[11].u64 = ctx.r[24].u64 & 32832;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A92E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A92E4: 419A0318  beq cr6, 0x821a95fc
	if ctx.cr[6].eq {
	pc = 0x821A95FC; continue 'dispatch;
	}
	// 821A92E8: 8177018C  lwz r11, 0x18c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(396 as u32) ) } as u64;
	// 821A92EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A92F0: 419A0014  beq cr6, 0x821a9304
	if ctx.cr[6].eq {
	pc = 0x821A9304; continue 'dispatch;
	}
	// 821A92F4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A92F8: 81370188  lwz r9, 0x188(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(392 as u32) ) } as u64;
	// 821A92FC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9300: 419A0008  beq cr6, 0x821a9308
	if ctx.cr[6].eq {
	pc = 0x821A9308; continue 'dispatch;
	}
	// 821A9304: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A9308: A1590012  lhz r10, 0x12(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[25].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A930C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A9310: 83CB00CC  lwz r30, 0xcc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A9314: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821A9318: 7D440734  extsh r4, r10
	ctx.r[4].s64 = ctx.r[10].s16 as i64;
	// 821A931C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821A9320: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A9324: 4BFFA7E5  bl 0x821a3b08
	ctx.lr = 0x821A9328;
	sub_821A3B08(ctx, base);
	// 821A9328: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A932C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A9330: 3B9E0030  addi r28, r30, 0x30
	ctx.r[28].s64 = ctx.r[30].s64 + 48;
	// 821A9334: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A9338: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A933C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A9340: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A9344: 4E800421  bctrl
	ctx.lr = 0x821A9348;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A9348: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A934C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A9350: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9354: 3B5B0010  addi r26, r27, 0x10
	ctx.r[26].s64 = ctx.r[27].s64 + 16;
	// 821A9358: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A935C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A97B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A97B8 size=332
    let mut pc: u32 = 0x821A97B8;
    'dispatch: loop {
        match pc {
            0x821A97B8 => {
    //   block [0x821A97B8..0x821A9904)
	// 821A97B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A97BC: 4838B8F5  bl 0x825350b0
	ctx.lr = 0x821A97C0;
	sub_82535080(ctx, base);
	// 821A97C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A97C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A97C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A97CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A97D0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821A97D4: 38EB0E8C  addi r7, r11, 0xe8c
	ctx.r[7].s64 = ctx.r[11].s64 + 3724;
	// 821A97D8: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A97DC: 38A00385  li r5, 0x385
	ctx.r[5].s64 = 901;
	// 821A97E0: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A97E4: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 821A97E8: 481C0CA9  bl 0x8236a490
	ctx.lr = 0x821A97EC;
	sub_8236A490(ctx, base);
	// 821A97EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A97F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A97F4: 419A000C  beq cr6, 0x821a9800
	if ctx.cr[6].eq {
	pc = 0x821A9800; continue 'dispatch;
	}
	// 821A97F8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A97FC: 48000008  b 0x821a9804
	pc = 0x821A9804; continue 'dispatch;
	// 821A9800: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A9804: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A9808: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A980C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A9810: 419A0084  beq cr6, 0x821a9894
	if ctx.cr[6].eq {
	pc = 0x821A9894; continue 'dispatch;
	}
	// 821A9814: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A9818: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821A981C: 396B0EA0  addi r11, r11, 0xea0
	ctx.r[11].s64 = ctx.r[11].s64 + 3744;
	// 821A9820: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A9824: 38BF0090  addi r5, r31, 0x90
	ctx.r[5].s64 = ctx.r[31].s64 + 144;
	// 821A9828: 57643032  slwi r4, r27, 6
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A982C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A9830: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A9834: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821A9838: 3BABC470  addi r29, r11, -0x3b90
	ctx.r[29].s64 = ctx.r[11].s64 + -15248;
	// 821A983C: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821A9840: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821A9844: FB9F0098  std r28, 0x98(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[28].u64 ) };
	// 821A9848: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 821A984C: FB9F00A0  std r28, 0xa0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[28].u64 ) };
	// 821A9850: 9B5F001C  stb r26, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 821A9854: 4BFF83DD  bl 0x821a1c30
	ctx.lr = 0x821A9858;
	sub_821A1C30(ctx, base);
	// 821A9858: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A985C: 409A0048  bne cr6, 0x821a98a4
	if !ctx.cr[6].eq {
	pc = 0x821A98A4; continue 'dispatch;
	}
	// 821A9860: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A9864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9868: 419A002C  beq cr6, 0x821a9894
	if ctx.cr[6].eq {
	pc = 0x821A9894; continue 'dispatch;
	}
	// 821A986C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9870: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A9874: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9878: 409A001C  bne cr6, 0x821a9894
	if !ctx.cr[6].eq {
	pc = 0x821A9894; continue 'dispatch;
	}
	// 821A987C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A9880: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A9884: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A9888: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A988C: 9B4B0025  stb r26, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 821A9890: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A9894: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A9898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A989C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A98A0: 4838B860  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A98A4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A98A8: 38BF0094  addi r5, r31, 0x94
	ctx.r[5].s64 = ctx.r[31].s64 + 148;
	// 821A98AC: 5764103A  slwi r4, r27, 2
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A98B0: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 821A98B4: 4BFF837D  bl 0x821a1c30
	ctx.lr = 0x821A98B8;
	sub_821A1C30(ctx, base);
	// 821A98B8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A98BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A98C0: 419AFFA4  beq cr6, 0x821a9864
	if ctx.cr[6].eq {
	pc = 0x821A9864; continue 'dispatch;
	}
	// 821A98C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A98C8: 419A0014  beq cr6, 0x821a98dc
	if ctx.cr[6].eq {
	pc = 0x821A98DC; continue 'dispatch;
	}
	// 821A98CC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A98D0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A98D4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A98D8: 419A0008  beq cr6, 0x821a98e0
	if ctx.cr[6].eq {
	pc = 0x821A98E0; continue 'dispatch;
	}
	// 821A98DC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821A98E0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A98E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A98E8: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 821A98EC: 915F00A0  stw r10, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821A98F0: FB9F0098  std r28, 0x98(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[28].u64 ) };
	// 821A98F4: 937F0088  stw r27, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 821A98F8: 939F008C  stw r28, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 821A98FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A9900: 4838B800  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A9908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A9908 size=348
    let mut pc: u32 = 0x821A9908;
    'dispatch: loop {
        match pc {
            0x821A9908 => {
    //   block [0x821A9908..0x821A9A64)
	// 821A9908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A990C: 4838B7A5  bl 0x825350b0
	ctx.lr = 0x821A9910;
	sub_82535080(ctx, base);
	// 821A9910: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A9914: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A9918: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A991C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A9920: 419A0008  beq cr6, 0x821a9928
	if ctx.cr[6].eq {
	pc = 0x821A9928; continue 'dispatch;
	}
	// 821A9924: 93FE0040  stw r31, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 821A9928: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A992C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A9930: 38EB0E94  addi r7, r11, 0xe94
	ctx.r[7].s64 = ctx.r[11].s64 + 3732;
	// 821A9934: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A9938: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A993C: 38600108  li r3, 0x108
	ctx.r[3].s64 = 264;
	// 821A9940: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A9944: 481C0B4D  bl 0x8236a490
	ctx.lr = 0x821A9948;
	sub_8236A490(ctx, base);
	// 821A9948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A994C: 419A010C  beq cr6, 0x821a9a58
	if ctx.cr[6].eq {
	pc = 0x821A9A58; continue 'dispatch;
	}
	// 821A9950: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821A9954: 811E008C  lwz r8, 0x8c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9958: 39630090  addi r11, r3, 0x90
	ctx.r[11].s64 = ctx.r[3].s64 + 144;
	// 821A995C: 80FE0094  lwz r7, 0x94(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A9960: 80DE0090  lwz r6, 0x90(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A9964: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 821A9968: 3CA08288  lis r5, -0x7d78
	ctx.r[5].s64 = -2105016320;
	// 821A996C: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 821A9970: C009BA38  lfs f0, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9974: 3D2082CF  lis r9, -0x7d31
	ctx.r[9].s64 = -2100363264;
	// 821A9978: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 821A997C: 38A58E40  addi r5, r5, -0x71c0
	ctx.r[5].s64 = ctx.r[5].s64 + -29120;
	// 821A9980: FBEB0008  std r31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 821A9984: 3929C470  addi r9, r9, -0x3b90
	ctx.r[9].s64 = ctx.r[9].s64 + -15248;
	// 821A9988: FBEB0010  std r31, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 821A998C: 3FA0820C  lis r29, -0x7df4
	ctx.r[29].s64 = -2113142784;
	// 821A9990: FBEB0018  std r31, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 821A9994: 3B690228  addi r27, r9, 0x228
	ctx.r[27].s64 = ctx.r[9].s64 + 552;
	// 821A9998: FBEB0020  std r31, 0x20(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[31].u64 ) };
	// 821A999C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A99A0: FBEB0028  std r31, 0x28(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[31].u64 ) };
	// 821A99A4: 38843B44  addi r4, r4, 0x3b44
	ctx.r[4].s64 = ctx.r[4].s64 + 15172;
	// 821A99A8: FBEB0030  std r31, 0x30(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[31].u64 ) };
	// 821A99AC: 394300E0  addi r10, r3, 0xe0
	ctx.r[10].s64 = ctx.r[3].s64 + 224;
	// 821A99B0: FBEB0038  std r31, 0x38(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[31].u64 ) };
	// 821A99B4: 3BBD3B80  addi r29, r29, 0x3b80
	ctx.r[29].s64 = ctx.r[29].s64 + 15232;
	// 821A99B8: 93EB0040  stw r31, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 821A99BC: B3EB0044  sth r31, 0x44(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[31].u16 ) };
	// 821A99C0: B3EB0046  sth r31, 0x46(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(70 as u32), ctx.r[31].u16 ) };
	// 821A99C4: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821A99C8: A3430014  lhz r26, 0x14(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A99CC: 93630080  stw r27, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 821A99D0: 539A1EDE  rlwimi r26, r28, 3, 0x1b, 0xf
	ctx.r[26].u64 = (((ctx.r[28].u32).rotate_left(3) as u64) & 0xFFFFFFFFFFFF001F) | (ctx.r[26].u64 & 0x000000000000FFE0);
	// 821A99D4: 91230084  stw r9, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 821A99D8: 9923001D  stb r9, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[9].u8 ) };
	// 821A99DC: 9923001E  stb r9, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A99E0: 90A300D0  stw r5, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[5].u32 ) };
	// 821A99E4: B3430014  sth r26, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[26].u16 ) };
	// 821A99E8: 93EB0048  stw r31, 0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 821A99EC: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 821A99F0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A99F4: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821A99F8: 93AA0000  stw r29, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821A99FC: 396B8E38  addi r11, r11, -0x71c8
	ctx.r[11].s64 = ctx.r[11].s64 + -29128;
	// 821A9A00: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A9A04: B3EA0008  sth r31, 8(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[31].u16 ) };
	// 821A9A08: B3EA000A  sth r31, 0xa(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(10 as u32), ctx.r[31].u16 ) };
	// 821A9A0C: 93EA000C  stw r31, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 821A9A10: B3EA0010  sth r31, 0x10(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[31].u16 ) };
	// 821A9A14: B3EA0012  sth r31, 0x12(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[31].u16 ) };
	// 821A9A18: 3D408287  lis r10, -0x7d79
	ctx.r[10].s64 = -2105081856;
	// 821A9A1C: 910300F8  stw r8, 0xf8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), ctx.r[8].u32 ) };
	// 821A9A20: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 821A9A24: 394A7790  addi r10, r10, 0x7790
	ctx.r[10].s64 = ctx.r[10].s64 + 30608;
	// 821A9A28: 90C30100  stw r6, 0x100(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[6].u32 ) };
	// 821A9A2C: 90E300FC  stw r7, 0xfc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), ctx.r[7].u32 ) };
	// 821A9A30: 91030088  stw r8, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 821A9A34: 916300E4  stw r11, 0xe4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 821A9A38: B12300E8  sth r9, 0xe8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), ctx.r[9].u16 ) };
	// 821A9A3C: B3E300EA  sth r31, 0xea(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(234 as u32), ctx.r[31].u16 ) };
	// 821A9A40: 914300EC  stw r10, 0xec(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 821A9A44: B12300F0  sth r9, 0xf0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), ctx.r[9].u16 ) };
	// 821A9A48: B3E300F2  sth r31, 0xf2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(242 as u32), ctx.r[31].u16 ) };
	// 821A9A4C: 907E00A8  stw r3, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[3].u32 ) };
	// 821A9A50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A9A54: 4838B6AC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821A9A58: 93FE00A8  stw r31, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 821A9A5C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A9A60: 4838B6A0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A9A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A9A68 size=1488
    let mut pc: u32 = 0x821A9A68;
    'dispatch: loop {
        match pc {
            0x821A9A68 => {
    //   block [0x821A9A68..0x821AA038)
	// 821A9A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A9A6C: 4838B641  bl 0x825350ac
	ctx.lr = 0x821A9A70;
	sub_82535080(ctx, base);
	// 821A9A70: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821A9A74: 4838C551  bl 0x82535fc4
	ctx.lr = 0x821A9A78;
	sub_82535FB0(ctx, base);
	// 821A9A78: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A9A7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A9A80: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821A9A84: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A9A88: 933E0040  stw r25, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[25].u32 ) };
	// 821A9A8C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A9A90: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A9A94: 419A0594  beq cr6, 0x821aa028
	if ctx.cr[6].eq {
	pc = 0x821AA028; continue 'dispatch;
	}
	// 821A9A98: 817E009C  lwz r11, 0x9c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 821A9A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9AA0: 419A0018  beq cr6, 0x821a9ab8
	if ctx.cr[6].eq {
	pc = 0x821A9AB8; continue 'dispatch;
	}
	// 821A9AA4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9AA8: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 821A9AAC: 813E0098  lwz r9, 0x98(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A9AB0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9AB4: 419A0008  beq cr6, 0x821a9abc
	if ctx.cr[6].eq {
	pc = 0x821A9ABC; continue 'dispatch;
	}
	// 821A9AB8: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 821A9ABC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A9AC0: 817A00AC  lwz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A9AC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9AC8: C30A1FF8  lfs f24, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821A9ACC: 419A0038  beq cr6, 0x821a9b04
	if ctx.cr[6].eq {
	pc = 0x821A9B04; continue 'dispatch;
	}
	// 821A9AD0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9AD4: 813A00A8  lwz r9, 0xa8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A9AD8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9ADC: 409A0028  bne cr6, 0x821a9b04
	if !ctx.cr[6].eq {
	pc = 0x821A9B04; continue 'dispatch;
	}
	// 821A9AE0: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A9AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9AE8: 419A001C  beq cr6, 0x821a9b04
	if ctx.cr[6].eq {
	pc = 0x821A9B04; continue 'dispatch;
	}
	// 821A9AEC: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A9AF0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A9AF4: 419A0010  beq cr6, 0x821a9b04
	if ctx.cr[6].eq {
	pc = 0x821A9B04; continue 'dispatch;
	}
	// 821A9AF8: C26B0060  lfs f19, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821A9AFC: C28B0068  lfs f20, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821A9B00: 4800000C  b 0x821a9b0c
	pc = 0x821A9B0C; continue 'dispatch;
	// 821A9B04: FE80C090  fmr f20, f24
	ctx.f[20].f64 = ctx.f[24].f64;
	// 821A9B08: FE60C090  fmr f19, f24
	ctx.f[19].f64 = ctx.f[24].f64;
	// 821A9B0C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9B10: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821A9B14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A9B18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A9B1C: C34B2280  lfs f26, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A9B20: 4099011C  ble cr6, 0x821a9c3c
	if !ctx.cr[6].gt {
	pc = 0x821A9C3C; continue 'dispatch;
	}
	// 821A9B24: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A9B28: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A9B2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A9B30: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 821A9B34: C0E9207C  lfs f7, 0x207c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8316 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A9B38: C12AD478  lfs f9, -0x2b88(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A9B3C: C10BD6C8  lfs f8, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A9B40: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A9B44: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821A9B48: 481BD5F1  bl 0x82367138
	ctx.lr = 0x821A9B4C;
	sub_82367138(ctx, base);
	// 821A9B4C: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A9B50: 813E0088  lwz r9, 0x88(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A9B54: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 821A9B58: C1840008  lfs f12, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A9B5C: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821A9B60: ECCC0332  fmuls f6, f12, f12
	ctx.f[6].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 821A9B64: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A9B68: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A9B6C: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 821A9B70: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 821A9B74: C8010070  lfd f0, 0x70(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821A9B78: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 821A9B7C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A9B80: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 821A9B84: ECCD337A  fmadds f6, f13, f13, f6
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[6].f64) as f32) as f64);
	// 821A9B88: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A9B8C: ECCB32FA  fmadds f6, f11, f11, f6
	ctx.f[6].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[6].f64) as f32) as f64);
	// 821A9B90: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 821A9B94: EC004A3A  fmadds f0, f0, f8, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[9].f64) as f32) as f64);
	// 821A9B98: C9410068  lfd f10, 0x68(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A9B9C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 821A9BA0: C8A10060  lfd f5, 0x60(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A9BA4: FCA02E9C  fcfid f5, f5
	ctx.f[5].f64 = (ctx.f[5].s64 as f64);
	// 821A9BA8: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821A9BAC: FCA02818  frsp f5, f5
	ctx.f[5].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821A9BB0: ECA55024  fdivs f5, f5, f10
	ctx.f[5].f64 = ((ctx.f[5].f64 / ctx.f[10].f64) as f32) as f64;
	// 821A9BB4: ED40302C  fsqrts f10, f6
	ctx.f[10].f64 = ((ctx.f[6].f64).sqrt() as f32) as f64;
	// 821A9BB8: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BBC: ECC549FA  fmadds f6, f5, f7, f9
	ctx.f[6].f64 = (((ctx.f[5].f64 * ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64);
	// 821A9BC0: FF0A3000  fcmpu cr6, f10, f6
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[6].f64);
	// 821A9BC4: 40980064  bge cr6, 0x821a9c28
	if !ctx.cr[6].lt {
	pc = 0x821A9C28; continue 'dispatch;
	}
	// 821A9BC8: C1440010  lfs f10, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A9BCC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BD0: C0C40014  lfs f6, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821A9BD4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BD8: C0A40018  lfs f5, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821A9BDC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BE0: C0840020  lfs f4, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821A9BE4: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BE8: C0640024  lfs f3, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821A9BEC: ECC60032  fmuls f6, f6, f0
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BF0: C0440028  lfs f2, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A9BF4: ECA00172  fmuls f5, f0, f5
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[5].f64) as f32) as f64);
	// 821A9BF8: D1640000  stfs f11, 0(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A9BFC: ED640032  fmuls f11, f4, f0
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9C00: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A9C04: EDA000F2  fmuls f13, f0, f3
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[3].f64) as f32) as f64);
	// 821A9C08: EC020032  fmuls f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9C0C: D1840008  stfs f12, 8(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A9C10: D1440010  stfs f10, 0x10(r4)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A9C14: D0C40014  stfs f6, 0x14(r4)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A9C18: D0A40018  stfs f5, 0x18(r4)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A9C1C: D1640020  stfs f11, 0x20(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A9C20: D1A40024  stfs f13, 0x24(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A9C24: D0040028  stfs f0, 0x28(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821A9C28: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A9C2C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9C30: 3BBD0040  addi r29, r29, 0x40
	ctx.r[29].s64 = ctx.r[29].s64 + 64;
	// 821A9C34: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821A9C38: 4198FF08  blt cr6, 0x821a9b40
	if ctx.cr[6].lt {
	pc = 0x821A9B40; continue 'dispatch;
	}
	// 821A9C3C: 817A0084  lwz r11, 0x84(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A9C40: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A9C44: 409A000C  bne cr6, 0x821a9c50
	if !ctx.cr[6].eq {
	pc = 0x821A9C50; continue 'dispatch;
	}
	// 821A9C48: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821A9C4C: 4800000C  b 0x821a9c58
	pc = 0x821A9C58; continue 'dispatch;
	// 821A9C50: 815A008C  lwz r10, 0x8c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9C54: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A9C58: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A9C5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9C60: 419A03BC  beq cr6, 0x821aa01c
	if ctx.cr[6].eq {
	pc = 0x821AA01C; continue 'dispatch;
	}
	// 821A9C64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A9C68: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821A9C6C: 396BBA38  addi r11, r11, -0x45c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17864;
	// 821A9C70: 3CE08288  lis r7, -0x7d78
	ctx.r[7].s64 = -2105016320;
	// 821A9C74: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A9C78: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A9C7C: 3B8ADBD0  addi r28, r10, -0x2430
	ctx.r[28].s64 = ctx.r[10].s64 + -9264;
	// 821A9C80: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A9C84: C2AB000C  lfs f21, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 821A9C88: C3EB0000  lfs f31, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A9C8C: C2E82190  lfs f23, 0x2190(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8592 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821A9C90: 3B6AD040  addi r27, r10, -0x2fc0
	ctx.r[27].s64 = ctx.r[10].s64 + -12224;
	// 821A9C94: C2C92194  lfs f22, 0x2194(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8596 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A9C98: C327D560  lfs f25, -0x2aa0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821A9C9C: 815E008C  lwz r10, 0x8c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9CA0: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A9CA4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821A9CA8: 4098034C  bge cr6, 0x821a9ff4
	if !ctx.cr[6].lt {
	pc = 0x821A9FF4; continue 'dispatch;
	}
	// 821A9CAC: 817A0094  lwz r11, 0x94(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A9CB0: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A9CB4: 813E0090  lwz r9, 0x90(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A9CB8: 390B0006  addi r8, r11, 6
	ctx.r[8].s64 = ctx.r[11].s64 + 6;
	// 821A9CBC: 897C0001  lbz r11, 1(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(1 as u32) ) } as u64;
	// 821A9CC0: 7FEA4A14  add r31, r10, r9
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821A9CC4: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 821A9CC8: 550B2036  slwi r11, r8, 4
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A9CCC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821A9CD0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821A9CD4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9CD8: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A9CDC: EF80982A  fadds f28, f0, f19
	ctx.f[28].f64 = ((ctx.f[0].f64 + ctx.f[19].f64) as f32) as f64;
	// 821A9CE0: EF6DA02A  fadds f27, f13, f20
	ctx.f[27].f64 = ((ctx.f[13].f64 + ctx.f[20].f64) as f32) as f64;
	// 821A9CE4: D3810080  stfs f28, 0x80(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A9CE8: D3610088  stfs f27, 0x88(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A9CEC: 40990018  ble cr6, 0x821a9d04
	if !ctx.cr[6].gt {
	pc = 0x821A9D04; continue 'dispatch;
	}
	// 821A9CF0: 897C0002  lbz r11, 2(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A9CF4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821A9CF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A9CFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A9D00: 41990008  bgt cr6, 0x821a9d08
	if ctx.cr[6].gt {
	pc = 0x821A9D08; continue 'dispatch;
	}
	// 821A9D04: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821A9D08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A9D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9D10: 409A004C  bne cr6, 0x821a9d5c
	if !ctx.cr[6].eq {
	pc = 0x821A9D5C; continue 'dispatch;
	}
	// 821A9D14: FF1CB000  fcmpu cr6, f28, f22
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[22].f64);
	// 821A9D18: 4098000C  bge cr6, 0x821a9d24
	if !ctx.cr[6].lt {
	pc = 0x821A9D24; continue 'dispatch;
	}
	// 821A9D1C: FFC0B890  fmr f30, f23
	ctx.f[30].f64 = ctx.f[23].f64;
	// 821A9D20: 48000058  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
	// 821A9D24: FF1CA800  fcmpu cr6, f28, f21
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[21].f64);
	// 821A9D28: 4099000C  ble cr6, 0x821a9d34
	if !ctx.cr[6].gt {
	pc = 0x821A9D34; continue 'dispatch;
	}
	// 821A9D2C: FFC0B890  fmr f30, f23
	ctx.f[30].f64 = ctx.f[23].f64;
	// 821A9D30: 48000048  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
	// 821A9D34: FF1BB000  fcmpu cr6, f27, f22
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[22].f64);
	// 821A9D38: 4098000C  bge cr6, 0x821a9d44
	if !ctx.cr[6].lt {
	pc = 0x821A9D44; continue 'dispatch;
	}
	// 821A9D3C: FFC0B890  fmr f30, f23
	ctx.f[30].f64 = ctx.f[23].f64;
	// 821A9D40: 48000038  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
	// 821A9D44: FF1BA800  fcmpu cr6, f27, f21
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[21].f64);
	// 821A9D48: 4099000C  ble cr6, 0x821a9d54
	if !ctx.cr[6].gt {
	pc = 0x821A9D54; continue 'dispatch;
	}
	// 821A9D4C: FFC0B890  fmr f30, f23
	ctx.f[30].f64 = ctx.f[23].f64;
	// 821A9D50: 48000028  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
	// 821A9D54: FFC0C090  fmr f30, f24
	ctx.f[30].f64 = ctx.f[24].f64;
	// 821A9D58: 48000020  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
	// 821A9D5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A9D60: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 821A9D64: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821A9D68: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A9D6C: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 821A9D70: 4800D7C1  bl 0x821b7530
	ctx.lr = 0x821A9D74;
	sub_821B7530(ctx, base);
	// 821A9D74: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821A9D78: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A9D7C: 481BD3BD  bl 0x82367138
	ctx.lr = 0x821A9D80;
	sub_82367138(ctx, base);
	// 821A9D80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A9D84: FC20C090  fmr f1, f24
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[24].f64;
	// 821A9D88: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821A9D8C: 796B0260  clrldi r11, r11, 0x29
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000007FFFFFu64;
	// 821A9D90: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A9D94: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A9D98: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A9D9C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A9DA0: EFA006B2  fmuls f29, f0, f26
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 821A9DA4: 481BE0ED  bl 0x82367e90
	ctx.lr = 0x821A9DA8;
	sub_82367E90(ctx, base);
	// 821A9DA8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821A9DAC: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821A9DB0: 481BE209  bl 0x82367fb8
	ctx.lr = 0x821A9DB4;
	sub_82367FB8(ctx, base);
	// 821A9DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A9DB8: FC20C090  fmr f1, f24
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[24].f64;
	// 821A9DBC: 481BE32D  bl 0x823680e8
	ctx.lr = 0x821A9DC0;
	sub_823680E8(ctx, base);
	// 821A9DC0: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA038 size=104
    let mut pc: u32 = 0x821AA038;
    'dispatch: loop {
        match pc {
            0x821AA038 => {
    //   block [0x821AA038..0x821AA0A0)
	// 821AA038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AA044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AA048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA04C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AA050: 389F0090  addi r4, r31, 0x90
	ctx.r[4].s64 = ctx.r[31].s64 + 144;
	// 821AA054: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA05C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AA060: 3BCBC470  addi r30, r11, -0x3b90
	ctx.r[30].s64 = ctx.r[11].s64 + -15248;
	// 821AA064: 419A000C  beq cr6, 0x821aa070
	if ctx.cr[6].eq {
	pc = 0x821AA070; continue 'dispatch;
	}
	// 821AA068: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821AA06C: 4BFF8015  bl 0x821a2080
	ctx.lr = 0x821AA070;
	sub_821A2080(ctx, base);
	// 821AA070: 389F0094  addi r4, r31, 0x94
	ctx.r[4].s64 = ctx.r[31].s64 + 148;
	// 821AA074: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA07C: 419A000C  beq cr6, 0x821aa088
	if ctx.cr[6].eq {
	pc = 0x821AA088; continue 'dispatch;
	}
	// 821AA080: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821AA084: 4BFF7FFD  bl 0x821a2080
	ctx.lr = 0x821AA088;
	sub_821A2080(ctx, base);
	// 821AA088: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA08C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA094: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AA098: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA09C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA0A0 size=356
    let mut pc: u32 = 0x821AA0A0;
    'dispatch: loop {
        match pc {
            0x821AA0A0 => {
    //   block [0x821AA0A0..0x821AA204)
	// 821AA0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA0A4: 4838B011  bl 0x825350b4
	ctx.lr = 0x821AA0A8;
	sub_82535080(ctx, base);
	// 821AA0A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA0AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AA0B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821AA0B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AA0B8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821AA0BC: 38EB0EC0  addi r7, r11, 0xec0
	ctx.r[7].s64 = ctx.r[11].s64 + 3776;
	// 821AA0C0: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821AA0C4: 38A00385  li r5, 0x385
	ctx.r[5].s64 = 901;
	// 821AA0C8: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821AA0CC: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 821AA0D0: 481C03C1  bl 0x8236a490
	ctx.lr = 0x821AA0D4;
	sub_8236A490(ctx, base);
	// 821AA0D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AA0D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AA0DC: 419A000C  beq cr6, 0x821aa0e8
	if ctx.cr[6].eq {
	pc = 0x821AA0E8; continue 'dispatch;
	}
	// 821AA0E0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA0E4: 48000008  b 0x821aa0ec
	pc = 0x821AA0EC; continue 'dispatch;
	// 821AA0E8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821AA0EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AA0F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AA0F4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821AA0F8: 419A00B8  beq cr6, 0x821aa1b0
	if ctx.cr[6].eq {
	pc = 0x821AA1B0; continue 'dispatch;
	}
	// 821AA0FC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AA100: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AA104: 396B0EC8  addi r11, r11, 0xec8
	ctx.r[11].s64 = ctx.r[11].s64 + 3784;
	// 821AA108: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AA10C: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821AA110: 3908A208  addi r8, r8, -0x5df8
	ctx.r[8].s64 = ctx.r[8].s64 + -24056;
	// 821AA114: 3929A2F0  addi r9, r9, -0x5d10
	ctx.r[9].s64 = ctx.r[9].s64 + -23824;
	// 821AA118: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AA11C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AA120: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821AA124: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821AA128: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AA12C: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821AA130: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821AA134: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821AA138: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821AA13C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AA140: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821AA144: FB9F00E0  std r28, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[28].u64 ) };
	// 821AA148: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA14C: FB9F00E8  std r28, 0xe8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[28].u64 ) };
	// 821AA150: 394AA338  addi r10, r10, -0x5cc8
	ctx.r[10].s64 = ctx.r[10].s64 + -23752;
	// 821AA154: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821AA158: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821AA15C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821AA160: 38BF00C0  addi r5, r31, 0xc0
	ctx.r[5].s64 = ctx.r[31].s64 + 192;
	// 821AA164: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821AA168: 55642834  slwi r4, r11, 5
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AA16C: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AA170: 4BFF7AC1  bl 0x821a1c30
	ctx.lr = 0x821AA174;
	sub_821A1C30(ctx, base);
	// 821AA174: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AA17C: 409A0044  bne cr6, 0x821aa1c0
	if !ctx.cr[6].eq {
	pc = 0x821AA1C0; continue 'dispatch;
	}
	// 821AA180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA184: 419A002C  beq cr6, 0x821aa1b0
	if ctx.cr[6].eq {
	pc = 0x821AA1B0; continue 'dispatch;
	}
	// 821AA188: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA18C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA190: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AA194: 409A001C  bne cr6, 0x821aa1b0
	if !ctx.cr[6].eq {
	pc = 0x821AA1B0; continue 'dispatch;
	}
	// 821AA198: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821AA19C: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AA1A0: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821AA1A4: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AA1A8: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821AA1AC: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821AA1B0: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821AA1B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AA1B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AA1BC: 4838AF48  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 821AA1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA1C4: 419A0014  beq cr6, 0x821aa1d8
	if ctx.cr[6].eq {
	pc = 0x821AA1D8; continue 'dispatch;
	}
	// 821AA1C8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA1CC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA1D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AA1D4: 419A0008  beq cr6, 0x821aa1dc
	if ctx.cr[6].eq {
	pc = 0x821AA1DC; continue 'dispatch;
	}
	// 821AA1D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821AA1DC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA1E0: 393F00D0  addi r9, r31, 0xd0
	ctx.r[9].s64 = ctx.r[31].s64 + 208;
	// 821AA1E4: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 821AA1E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AA1EC: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 821AA1F0: FB9F00E0  std r28, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[28].u64 ) };
	// 821AA1F4: 93BF00C4  stw r29, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[29].u32 ) };
	// 821AA1F8: 913F00CC  stw r9, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[9].u32 ) };
	// 821AA1FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AA200: 4838AF04  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA208 size=232
    let mut pc: u32 = 0x821AA208;
    'dispatch: loop {
        match pc {
            0x821AA208 => {
    //   block [0x821AA208..0x821AA2F0)
	// 821AA208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA210: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA214: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AA218: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AA21C: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AA220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AA224: 419A0008  beq cr6, 0x821aa22c
	if ctx.cr[6].eq {
	pc = 0x821AA22C; continue 'dispatch;
	}
	// 821AA228: 91230040  stw r9, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 821AA22C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821AA230: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AA234: 396B8E40  addi r11, r11, -0x71c0
	ctx.r[11].s64 = ctx.r[11].s64 + -29120;
	// 821AA238: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 821AA23C: 38E00160  li r7, 0x160
	ctx.r[7].s64 = 352;
	// 821AA240: 9943001E  stb r10, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[10].u8 ) };
	// 821AA244: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821AA248: B1230084  sth r9, 0x84(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u16 ) };
	// 821AA24C: B1230086  sth r9, 0x86(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(134 as u32), ctx.r[9].u16 ) };
	// 821AA250: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AA254: 91030090  stw r8, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[8].u32 ) };
	// 821AA258: 90E300A4  stw r7, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821AA25C: 916300B8  stw r11, 0xb8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 821AA260: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA264: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821AA268: 556B0030  rlwinm r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA26C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA270: 419A000C  beq cr6, 0x821aa27c
	if ctx.cr[6].eq {
	pc = 0x821AA27C; continue 'dispatch;
	}
	// 821AA274: 9143008C  stw r10, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 821AA278: 4800000C  b 0x821aa284
	pc = 0x821AA284; continue 'dispatch;
	// 821AA27C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821AA280: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821AA284: 814300C8  lwz r10, 0xc8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA288: 896A0015  lbz r11, 0x15(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821AA28C: 556B0672  rlwinm r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA294: 39600011  li r11, 0x11
	ctx.r[11].s64 = 17;
	// 821AA298: 409A0008  bne cr6, 0x821aa2a0
	if !ctx.cr[6].eq {
	pc = 0x821AA2A0; continue 'dispatch;
	}
	// 821AA29C: 39600022  li r11, 0x22
	ctx.r[11].s64 = 34;
	// 821AA2A0: 916300AC  stw r11, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 821AA2A4: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA2A8: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 821AA2AC: 3D080504  addis r8, r8, 0x504
	ctx.r[8].s64 = ctx.r[8].s64 + 84148224;
	// 821AA2B0: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA2B4: 39084000  addi r8, r8, 0x4000
	ctx.r[8].s64 = ctx.r[8].s64 + 16384;
	// 821AA2B8: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821AA2BC: 91030088  stw r8, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 821AA2C0: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821AA2C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AA2C8: 409A000C  bne cr6, 0x821aa2d4
	if !ctx.cr[6].eq {
	pc = 0x821AA2D4; continue 'dispatch;
	}
	// 821AA2CC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA2D0: 91630098  stw r11, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AA2D4: 912300A0  stw r9, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 821AA2D8: 480000A9  bl 0x821aa380
	ctx.lr = 0x821AA2DC;
	sub_821AA380(ctx, base);
	// 821AA2DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AA2E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AA2E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA2E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA2F0 size=68
    let mut pc: u32 = 0x821AA2F0;
    'dispatch: loop {
        match pc {
            0x821AA2F0 => {
    //   block [0x821AA2F0..0x821AA334)
	// 821AA2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA2F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA2FC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AA300: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AA304: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AA308: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AA30C: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821AA310: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AA314: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AA318: 419A0008  beq cr6, 0x821aa320
	if ctx.cr[6].eq {
	pc = 0x821AA320; continue 'dispatch;
	}
	// 821AA31C: 4800021D  bl 0x821aa538
	ctx.lr = 0x821AA320;
	sub_821AA538(ctx, base);
	// 821AA320: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AA324: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AA328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA32C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA338 size=72
    let mut pc: u32 = 0x821AA338;
    'dispatch: loop {
        match pc {
            0x821AA338 => {
    //   block [0x821AA338..0x821AA380)
	// 821AA338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA340: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA344: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AA348: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AA34C: 388B00C0  addi r4, r11, 0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + 192;
	// 821AA350: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA358: 419A0014  beq cr6, 0x821aa36c
	if ctx.cr[6].eq {
	pc = 0x821AA36C; continue 'dispatch;
	}
	// 821AA35C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AA360: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AA364: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AA368: 4BFF7D19  bl 0x821a2080
	ctx.lr = 0x821AA36C;
	sub_821A2080(ctx, base);
	// 821AA36C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AA370: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AA374: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA378: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA37C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AA380 size=344
    let mut pc: u32 = 0x821AA380;
    'dispatch: loop {
        match pc {
            0x821AA380 => {
    //   block [0x821AA380..0x821AA4D8)
	// 821AA380: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821AA384: 80C300C4  lwz r6, 0xc4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AA388: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AA38C: 814300C0  lwz r10, 0xc0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AA390: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AA394: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 821AA398: C1A8BA38  lfs f13, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA39C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA3A0: 41980130  blt cr6, 0x821aa4d0
	if ctx.cr[6].lt {
	pc = 0x821AA4D0; continue 'dispatch;
	}
	// 821AA3A4: 3966FFFC  addi r11, r6, -4
	ctx.r[11].s64 = ctx.r[6].s64 + -4;
	// 821AA3A8: 5568F0BE  srwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA3AC: 396A0028  addi r11, r10, 0x28
	ctx.r[11].s64 = ctx.r[10].s64 + 40;
	// 821AA3B0: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 821AA3B4: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA3B8: 7CC83050  subf r6, r8, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	// 821AA3BC: D1ABFFF4  stfs f13, -0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AA3C0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 821AA3C4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AA3C8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AA3CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AA3D0: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AA3D4: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821AA3D8: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA3DC: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA3E0: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AA3E4: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA3E8: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AA3EC: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA3F0: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AA3F4: 810BFFDC  lwz r8, -0x24(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 821AA3F8: D1AB0054  stfs f13, 0x54(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821AA3FC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821AA400: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA404: 394A0180  addi r10, r10, 0x180
	ctx.r[10].s64 = ctx.r[10].s64 + 384;
	// 821AA408: 910BFFDC  stw r8, -0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-36 as u32), ctx.r[8].u32 ) };
	// 821AA40C: D00B0064  stfs f0, 0x64(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821AA410: D00B0060  stfs f0, 0x60(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821AA414: D00B005C  stfs f0, 0x5c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821AA418: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821AA41C: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA420: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA424: D18B0068  stfs f12, 0x68(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821AA428: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA42C: D18B006C  stfs f12, 0x6c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821AA430: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA434: D18B0070  stfs f12, 0x70(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821AA438: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821AA43C: D1AB00B4  stfs f13, 0xb4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821AA440: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 821AA444: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA448: 910B003C  stw r8, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 821AA44C: D00B00C4  stfs f0, 0xc4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 821AA450: D00B00C0  stfs f0, 0xc0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 821AA454: D00B00BC  stfs f0, 0xbc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 821AA458: D00B00B8  stfs f0, 0xb8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821AA45C: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA460: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA464: D18B00C8  stfs f12, 0xc8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 821AA468: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA46C: D18B00CC  stfs f12, 0xcc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 821AA470: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA474: D18B00D0  stfs f12, 0xd0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821AA478: 810B009C  lwz r8, 0x9c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 821AA47C: D1AB0114  stfs f13, 0x114(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 821AA480: 912B0098  stw r9, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 821AA484: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA488: 910B009C  stw r8, 0x9c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[8].u32 ) };
	// 821AA48C: D00B0124  stfs f0, 0x124(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 821AA490: D00B0120  stfs f0, 0x120(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 821AA494: D00B011C  stfs f0, 0x11c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 821AA498: D00B0118  stfs f0, 0x118(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 821AA49C: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA4A0: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA4A4: D18B0128  stfs f12, 0x128(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 821AA4A8: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA4AC: D18B012C  stfs f12, 0x12c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 821AA4B0: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA4B4: D18B0130  stfs f12, 0x130(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 821AA4B8: 810B00FC  lwz r8, 0xfc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 821AA4BC: 912B00F8  stw r9, 0xf8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), ctx.r[9].u32 ) };
	// 821AA4C0: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA4C4: 910B00FC  stw r8, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[8].u32 ) };
	// 821AA4C8: 396B0180  addi r11, r11, 0x180
	ctx.r[11].s64 = ctx.r[11].s64 + 384;
	// 821AA4CC: 409AFEF0  bne cr6, 0x821aa3bc
	if !ctx.cr[6].eq {
	pc = 0x821AA3BC; continue 'dispatch;
	}
	// 821AA4D0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821AA4D4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AA4D8 size=92
    let mut pc: u32 = 0x821AA4D8;
    'dispatch: loop {
        match pc {
            0x821AA4D8 => {
    //   block [0x821AA4D8..0x821AA534)
	// 821AA4D8: 396A0028  addi r11, r10, 0x28
	ctx.r[11].s64 = ctx.r[10].s64 + 40;
	// 821AA4DC: D1ABFFF4  stfs f13, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AA4E0: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 821AA4E4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AA4E8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AA4EC: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821AA4F0: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AA4F4: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821AA4F8: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA4FC: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA500: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AA504: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA508: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AA50C: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA510: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AA514: 810BFFDC  lwz r8, -0x24(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 821AA518: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821AA51C: 394A0060  addi r10, r10, 0x60
	ctx.r[10].s64 = ctx.r[10].s64 + 96;
	// 821AA520: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA524: 910BFFDC  stw r8, -0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-36 as u32), ctx.r[8].u32 ) };
	// 821AA528: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 821AA52C: 4199FFB0  bgt cr6, 0x821aa4dc
	if ctx.cr[6].gt {
	pc = 0x821AA4DC; continue 'dispatch;
	}
	// 821AA530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AA538 size=868
    let mut pc: u32 = 0x821AA538;
    'dispatch: loop {
        match pc {
            0x821AA538 => {
    //   block [0x821AA538..0x821AA89C)
	// 821AA538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA53C: 4838AB75  bl 0x825350b0
	ctx.lr = 0x821AA540;
	sub_82535080(ctx, base);
	// 821AA540: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA544: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821AA548: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821AA54C: 817C00E4  lwz r11, 0xe4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 821AA550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA554: 419A0018  beq cr6, 0x821aa56c
	if ctx.cr[6].eq {
	pc = 0x821AA56C; continue 'dispatch;
	}
	// 821AA558: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA55C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821AA560: 813C00E0  lwz r9, 0xe0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(224 as u32) ) } as u64;
	// 821AA564: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AA568: 419A0008  beq cr6, 0x821aa570
	if ctx.cr[6].eq {
	pc = 0x821AA570; continue 'dispatch;
	}
	// 821AA56C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821AA570: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AA574: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 821AA578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA57C: C14A1FF8  lfs f10, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AA580: 419A003C  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA584: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA588: 813D00A8  lwz r9, 0xa8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(168 as u32) ) } as u64;
	// 821AA58C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AA590: 409A002C  bne cr6, 0x821aa5bc
	if !ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA594: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821AA598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA59C: 419A0020  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA5A0: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821AA5A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AA5A8: 419A0014  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA5AC: C0EB0060  lfs f7, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AA5B0: C10B0064  lfs f8, 0x64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AA5B4: C12B0068  lfs f9, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AA5B8: 48000010  b 0x821aa5c8
	pc = 0x821AA5C8; continue 'dispatch;
	// 821AA5BC: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	// 821AA5C0: FD005090  fmr f8, f10
	ctx.f[8].f64 = ctx.f[10].f64;
	// 821AA5C4: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	// 821AA5C8: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AA5CC: 837C00C0  lwz r27, 0xc0(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AA5D0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AA5D4: 409A000C  bne cr6, 0x821aa5e0
	if !ctx.cr[6].eq {
	pc = 0x821AA5E0; continue 'dispatch;
	}
	// 821AA5D8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 821AA5DC: 4800000C  b 0x821aa5e8
	pc = 0x821AA5E8; continue 'dispatch;
	// 821AA5E0: 815D008C  lwz r10, 0x8c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA5E4: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AA5E8: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 821AA5EC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AA5F0: 409A000C  bne cr6, 0x821aa5fc
	if !ctx.cr[6].eq {
	pc = 0x821AA5FC; continue 'dispatch;
	}
	// 821AA5F4: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821AA5F8: 4800000C  b 0x821aa604
	pc = 0x821AA604; continue 'dispatch;
	// 821AA5FC: 815D008C  lwz r10, 0x8c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA600: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AA604: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821AA608: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AA60C: 419A0040  beq cr6, 0x821aa64c
	if ctx.cr[6].eq {
	pc = 0x821AA64C; continue 'dispatch;
	}
	// 821AA610: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA614: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821AA618: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AA61C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AA620: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA624: 7F4BD92E  stwx r26, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[26].u32) };
	// 821AA628: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA62C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AA630: 409A000C  bne cr6, 0x821aa63c
	if !ctx.cr[6].eq {
	pc = 0x821AA63C; continue 'dispatch;
	}
	// 821AA634: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 821AA638: 4800000C  b 0x821aa644
	pc = 0x821AA644; continue 'dispatch;
	// 821AA63C: 815D008C  lwz r10, 0x8c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA640: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AA644: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AA648: 409AFFC8  bne cr6, 0x821aa610
	if !ctx.cr[6].eq {
	pc = 0x821AA610; continue 'dispatch;
	}
	// 821AA64C: 83DC00C8  lwz r30, 0xc8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA650: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AA654: 913C00BC  stw r9, 0xbc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(188 as u32), ctx.r[9].u32 ) };
	// 821AA658: 419A023C  beq cr6, 0x821aa894
	if ctx.cr[6].eq {
	pc = 0x821AA894; continue 'dispatch;
	}
	// 821AA65C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AA660: C0CBBA38  lfs f6, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AA664: A15F0010  lhz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AA668: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA66C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA670: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AA674: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AA678: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA67C: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821AA680: 419A0044  beq cr6, 0x821aa6c4
	if ctx.cr[6].eq {
	pc = 0x821AA6C4; continue 'dispatch;
	}
	// 821AA684: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821AA688: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AA68C: 48000215  bl 0x821aa8a0
	ctx.lr = 0x821AA690;
	sub_821AA8A0(ctx, base);
	// 821AA690: A17E000C  lhz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA694: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821AA698: 40990020  ble cr6, 0x821aa6b8
	if !ctx.cr[6].gt {
	pc = 0x821AA6B8; continue 'dispatch;
	}
	// 821AA69C: 481BCA9D  bl 0x82367138
	ctx.lr = 0x821AA6A0;
	sub_82367138(ctx, base);
	// 821AA6A0: A17E000C  lhz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA6A4: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821AA6A8: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s64 = (ctx.r[10].s32 as i64) * (ctx.r[11].s32 as i64);
	// 821AA6AC: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821AA6B0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821AA6B4: 48000008  b 0x821aa6bc
	pc = 0x821AA6BC; continue 'dispatch;
	// 821AA6B8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821AA6BC: B17F0198  sth r11, 0x198(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821AA6C0: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	// 821AA6C4: 817D0098  lwz r11, 0x98(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AA6C8: 395F001C  addi r10, r31, 0x1c
	ctx.r[10].s64 = ctx.r[31].s64 + 28;
	// 821AA6CC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AA6D0: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA6D4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA6D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AA6DC: 419A001C  beq cr6, 0x821aa6f8
	if ctx.cr[6].eq {
	pc = 0x821AA6F8; continue 'dispatch;
	}
	// 821AA6E0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821AA6E4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA6E8: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821AA6EC: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AA6F0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA6F4: 7C084C2E  lfsx f0, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA6F8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AA6FC: D0040048  stfs f0, 0x48(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821AA700: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 821AA704: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA708: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA70C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA710: 419A001C  beq cr6, 0x821aa72c
	if ctx.cr[6].eq {
	pc = 0x821AA72C; continue 'dispatch;
	}
	// 821AA714: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821AA718: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA71C: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821AA720: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AA724: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA728: 7C08542E  lfsx f0, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA72C: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 821AA730: D004004C  stfs f0, 0x4c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821AA734: 39690010  addi r11, r9, 0x10
	ctx.r[11].s64 = ctx.r[9].s64 + 16;
	// 821AA738: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA73C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA740: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AA744: 419A001C  beq cr6, 0x821aa760
	if ctx.cr[6].eq {
	pc = 0x821AA760; continue 'dispatch;
	}
	// 821AA748: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 821AA74C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA750: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821AA754: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AA758: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA75C: 7C084C2E  lfsx f0, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA760: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821AA764: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AA768: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AA76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA770: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA774: 419A001C  beq cr6, 0x821aa790
	if ctx.cr[6].eq {
	pc = 0x821AA790; continue 'dispatch;
	}
	// 821AA778: 3921005C  addi r9, r1, 0x5c
	ctx.r[9].s64 = ctx.r[1].s64 + 92;
	// 821AA77C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA780: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 821AA784: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AA788: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AA78C: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA790: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 821AA794: 40980008  bge cr6, 0x821aa79c
	if !ctx.cr[6].lt {
	pc = 0x821AA79C; continue 'dispatch;
	}
	// 821AA798: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 821AA79C: A17F0198  lhz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 821AA7A0: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821AA7A4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AA7A8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA7AC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AA7B0: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821AA7B4: A12B0010  lhz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AA7B8: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 821AA7BC: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821AA7C0: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821AA7C4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821AA7C8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821AA7CC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA7D0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821AA7D4: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 821AA7D8: A1610076  lhz r11, 0x76(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(118 as u32) ) } as u64;
	// 821AA7DC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AA7E0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821AA7E4: F9640050  std r11, 0x50(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA7E8: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA7EC: 816A002C  lwz r11, 0x2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821AA7F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA7F4: 419A001C  beq cr6, 0x821aa810
	if ctx.cr[6].eq {
	pc = 0x821AA810; continue 'dispatch;
	}
	// 821AA7F8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821AA7FC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA800: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821AA804: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821AA808: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AA80C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA810: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AA814: 556B018C  rlwinm r11, r11, 0, 6, 6
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA81C: 419A0010  beq cr6, 0x821aa82c
	if ctx.cr[6].eq {
	pc = 0x821AA82C; continue 'dispatch;
	}
	// 821AA820: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 821AA824: 40990008  ble cr6, 0x821aa82c
	if !ctx.cr[6].gt {
	pc = 0x821AA82C; continue 'dispatch;
	}
	// 821AA828: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 821AA82C: 817C00CC  lwz r11, 0xcc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA830: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA834: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA838: D004003C  stfs f0, 0x3c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821AA83C: 817D0094  lwz r11, 0x94(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 821AA840: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 821AA844: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA848: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821AA84C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA850: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 821AA854: D0040010  stfs f0, 0x10(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AA858: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA85C: EC00402A  fadds f0, f0, f8
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 821AA860: D0040014  stfs f0, 0x14(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821AA864: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA868: EC00482A  fadds f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64;
	// 821AA86C: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821AA870: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA874: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AA878: 409A000C  bne cr6, 0x821aa884
	if !ctx.cr[6].eq {
	pc = 0x821AA884; continue 'dispatch;
	}
	// 821AA87C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 821AA880: 4800000C  b 0x821aa88c
	pc = 0x821AA88C; continue 'dispatch;
	// 821AA884: 815D008C  lwz r10, 0x8c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA888: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AA88C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AA890: 409AFDD4  bne cr6, 0x821aa664
	if !ctx.cr[6].eq {
	pc = 0x821AA664; continue 'dispatch;
	}
	// 821AA894: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821AA898: 4838A868  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AA8A0 size=268
    let mut pc: u32 = 0x821AA8A0;
    'dispatch: loop {
        match pc {
            0x821AA8A0 => {
    //   block [0x821AA8A0..0x821AA9AC)
	// 821AA8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA8A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AA8AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AA8B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA8B4: C0050180  lfs f0, 0x180(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA8B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA8BC: D0040040  stfs f0, 0x40(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821AA8C0: C0050184  lfs f0, 0x184(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA8C4: D0040044  stfs f0, 0x44(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821AA8C8: C0050184  lfs f0, 0x184(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA8CC: C1A50180  lfs f13, 0x180(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA8D0: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AA8D4: C185018C  lfs f12, 0x18c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA8D8: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AA8DC: FC0B036E  fsel f0, f11, f13, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 821AA8E0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AA8E4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821AA8E8: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AA8EC: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA8F0: 8BEB0014  lbz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AA8F4: 57EB0030  rlwinm r11, r31, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA8FC: 419A008C  beq cr6, 0x821aa988
	if ctx.cr[6].eq {
	pc = 0x821AA988; continue 'dispatch;
	}
	// 821AA900: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 821AA904: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AA908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA90C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AA910: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AA914: C1AABFFC  lfs f13, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA918: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA91C: 419A002C  beq cr6, 0x821aa948
	if ctx.cr[6].eq {
	pc = 0x821AA948; continue 'dispatch;
	}
	// 821AA920: 481BC819  bl 0x82367138
	ctx.lr = 0x821AA924;
	sub_82367138(ctx, base);
	// 821AA924: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AA928: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA92C: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA930: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821AA934: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821AA938: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA93C: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 821AA940: 40990008  ble cr6, 0x821aa948
	if !ctx.cr[6].gt {
	pc = 0x821AA948; continue 'dispatch;
	}
	// 821AA944: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821AA948: 57EB07BC  rlwinm r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA94C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA950: 419A002C  beq cr6, 0x821aa97c
	if ctx.cr[6].eq {
	pc = 0x821AA97C; continue 'dispatch;
	}
	// 821AA954: 481BC7E5  bl 0x82367138
	ctx.lr = 0x821AA958;
	sub_82367138(ctx, base);
	// 821AA958: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AA95C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA960: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA964: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821AA968: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821AA96C: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA970: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821AA974: 40990008  ble cr6, 0x821aa97c
	if !ctx.cr[6].gt {
	pc = 0x821AA97C; continue 'dispatch;
	}
	// 821AA978: 63DE0002  ori r30, r30, 2
	ctx.r[30].u64 = ctx.r[30].u64 | 2;
	// 821AA97C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA980: 53CBE086  rlwimi r11, r30, 0x1c, 2, 3
	ctx.r[11].u64 = (((ctx.r[30].u32).rotate_left(28) as u64) & 0x0000000030000000) | (ctx.r[11].u64 & 0xFFFFFFFFCFFFFFFF);
	// 821AA984: 4800000C  b 0x821aa990
	pc = 0x821AA990; continue 'dispatch;
	// 821AA988: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA98C: 53EBE086  rlwimi r11, r31, 0x1c, 2, 3
	ctx.r[11].u64 = (((ctx.r[31].u32).rotate_left(28) as u64) & 0x0000000030000000) | (ctx.r[11].u64 & 0xFFFFFFFFCFFFFFFF);
	// 821AA990: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821AA994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA99C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA9A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AA9A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AA9B0 size=60
    let mut pc: u32 = 0x821AA9B0;
    'dispatch: loop {
        match pc {
            0x821AA9B0 => {
    //   block [0x821AA9B0..0x821AA9EC)
	// 821AA9B0: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA9B4: 38E30088  addi r7, r3, 0x88
	ctx.r[7].s64 = ctx.r[3].s64 + 136;
	// 821AA9B8: 810300C0  lwz r8, 0xc0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AA9BC: 38C30080  addi r6, r3, 0x80
	ctx.r[6].s64 = ctx.r[3].s64 + 128;
	// 821AA9C0: 80A300BC  lwz r5, 0xbc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AA9C4: 808300B8  lwz r4, 0xb8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AA9C8: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821AA9CC: 556B0030  rlwinm r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA9D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA9D4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AA9D8: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AA9DC: 392B0060  addi r9, r11, 0x60
	ctx.r[9].s64 = ctx.r[11].s64 + 96;
	// 821AA9E0: 419A000C  beq cr6, 0x821aa9ec
	if ctx.cr[6].eq {
		sub_821AA9EC(ctx, base);
		return;
	}
	// 821AA9E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AA9E8: 481C3658  b 0x8236e040
	sub_8236E040(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA9EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AA9EC size=8
    let mut pc: u32 = 0x821AA9EC;
    'dispatch: loop {
        match pc {
            0x821AA9EC => {
    //   block [0x821AA9EC..0x821AA9F4)
	// 821AA9EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AA9F0: 481C3650  b 0x8236e040
	sub_8236E040(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AA9F8 size=1888
    let mut pc: u32 = 0x821AA9F8;
    'dispatch: loop {
        match pc {
            0x821AA9F8 => {
    //   block [0x821AA9F8..0x821AAC1C)
	// 821AA9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA9FC: 4838A699  bl 0x82535094
	ctx.lr = 0x821AAA00;
	sub_82535080(ctx, base);
	// 821AAA00: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 821AAA04: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AAA08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AAA0C: 9141016C  stw r10, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[10].u32 ) };
	// 821AAA10: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AAA14: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 821AAA18: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAA1C: 396B1E50  addi r11, r11, 0x1e50
	ctx.r[11].s64 = ctx.r[11].s64 + 7760;
	// 821AAA20: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 821AAA24: 7D134378  mr r19, r8
	ctx.r[19].u64 = ctx.r[8].u64;
	// 821AAA28: 81010174  lwz r8, 0x174(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 821AAA2C: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAA30: 7D354B78  mr r21, r9
	ctx.r[21].u64 = ctx.r[9].u64;
	// 821AAA34: 7F2A5A14  add r25, r10, r11
	ctx.r[25].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AAA38: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821AAA3C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 821AAA40: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AAA44: 82990048  lwz r20, 0x48(r25)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AAA48: 568967FE  rlwinm r9, r20, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[20].u32 as u64 & 0x000FFFFFu64;
	// 821AAA4C: 419A0014  beq cr6, 0x821aaa60
	if ctx.cr[6].eq {
	pc = 0x821AAA60; continue 'dispatch;
	}
	// 821AAA50: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AAA54: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821AAA58: 7D6858AE  lbzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AAA5C: 48000008  b 0x821aaa64
	pc = 0x821AAA64; continue 'dispatch;
	// 821AAA60: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821AAA64: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAA68: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AAA6C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821AAA70: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AAA74: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAA78: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 821AAA7C: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 821AAA80: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAA84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821AAA88: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AAA8C: 4BFFD0FD  bl 0x821a7b88
	ctx.lr = 0x821AAA90;
	sub_821A7B88(ctx, base);
	// 821AAA90: EB630000  ld r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AAA94: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 821AAA98: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AAA9C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AAAA0: 419A06AC  beq cr6, 0x821ab14c
	if ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AAAA4: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAAA8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AAAAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAAB0: 409A069C  bne cr6, 0x821ab14c
	if !ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AAAB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAAB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821AAABC: 4BFFE305  bl 0x821a8dc0
	ctx.lr = 0x821AAAC0;
	sub_821A8DC0(ctx, base);
	// 821AAAC0: EAE30000  ld r23, 0(r3)
	ctx.r[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AAAC4: FAE10050  std r23, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u64 ) };
	// 821AAAC8: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AAACC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821AAAD0: 419A0644  beq cr6, 0x821ab114
	if ctx.cr[6].eq {
	pc = 0x821AB114; continue 'dispatch;
	}
	// 821AAAD4: 817A0030  lwz r11, 0x30(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAAD8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AAADC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAAE0: 409A0634  bne cr6, 0x821ab114
	if !ctx.cr[6].eq {
	pc = 0x821AB114; continue 'dispatch;
	}
	// 821AAAE4: 83B90040  lwz r29, 0x40(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AAAE8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AAAEC: 4098000C  bge cr6, 0x821aaaf8
	if !ctx.cr[6].lt {
	pc = 0x821AAAF8; continue 'dispatch;
	}
	// 821AAAF0: 83D90044  lwz r30, 0x44(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(68 as u32) ) } as u64;
	// 821AAAF4: 48000014  b 0x821aab08
	pc = 0x821AAB08; continue 'dispatch;
	// 821AAAF8: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821AAAFC: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAB00: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 821AAB04: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AAB08: 397FFFFB  addi r11, r31, -5
	ctx.r[11].s64 = ctx.r[31].s64 + -5;
	// 821AAB0C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821AAB10: 2B0B003A  cmplwi cr6, r11, 0x3a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 58 as u32, &mut ctx.xer);
	// 821AAB14: 41990394  bgt cr6, 0x821aaea8
	if ctx.cr[6].gt {
	pc = 0x821AAEA8; continue 'dispatch;
	}
	// 821AAB18: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821AAB1C: 398CAB30  addi r12, r12, -0x54d0
	ctx.r[12].s64 = ctx.r[12].s64 + -21712;
	// 821AAB20: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821AAB24: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821AAB28: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821AAB2C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821AAC1C; continue 'dispatch;
		},
		1 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		2 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		3 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		4 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		5 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		6 => {
	pc = 0x821AACC8; continue 'dispatch;
		},
		7 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		8 => {
	pc = 0x821AAC64; continue 'dispatch;
		},
		9 => {
	pc = 0x821AAC64; continue 'dispatch;
		},
		10 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		11 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		12 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		13 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		14 => {
	pc = 0x821AAD1C; continue 'dispatch;
		},
		15 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		16 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		17 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		18 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		19 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		20 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		21 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		22 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		23 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		24 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		25 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		26 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		27 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		28 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		29 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		30 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		31 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		32 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		33 => {
	pc = 0x821AAD7C; continue 'dispatch;
		},
		34 => {
	pc = 0x821AADF0; continue 'dispatch;
		},
		35 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		36 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		37 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		38 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		39 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		40 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		41 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		42 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		43 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		44 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		45 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		46 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		47 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		48 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		49 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		50 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		51 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		52 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		53 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		54 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		55 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		56 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		57 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		58 => {
	pc = 0x821AAE4C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821AAB30: 821AAC1C  lwz r16, -0x53e4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21476 as u32) ) } as u64;
	// 821AAB34: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB38: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB3C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB40: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB44: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB48: 821AACC8  lwz r16, -0x5338(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21304 as u32) ) } as u64;
	// 821AAB4C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB50: 821AAC64  lwz r16, -0x539c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21404 as u32) ) } as u64;
	// 821AAB54: 821AAC64  lwz r16, -0x539c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21404 as u32) ) } as u64;
	// 821AAB58: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB5C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB60: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB64: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB68: 821AAD1C  lwz r16, -0x52e4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21220 as u32) ) } as u64;
	// 821AAB6C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB70: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB74: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB78: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB7C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB80: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB84: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB88: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB8C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB90: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB94: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB98: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB9C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABA0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABA4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABA8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABAC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABB0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABB4: 821AAD7C  lwz r16, -0x5284(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21124 as u32) ) } as u64;
	// 821AABB8: 821AADF0  lwz r16, -0x5210(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21008 as u32) ) } as u64;
	// 821AABBC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABC0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABC4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABC8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABCC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABD0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABD4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABD8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABDC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABE0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABE4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABE8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABEC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABF0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABF4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABF8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABFC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC00: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC04: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC08: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC0C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC10: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC14: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC18: 821AAE4C  lwz r16, -0x51b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20916 as u32) ) } as u64;
            }
            0x821AAC1C => {
    //   block [0x821AAC1C..0x821AAC64)
	// 821AAC1C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAC20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAC24: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821AAC28: 4BFFC149  bl 0x821a6d70
	ctx.lr = 0x821AAC2C;
	sub_821A6D70(ctx, base);
	// 821AAC2C: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AAC30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AAC34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AAC38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAC3C: 419A0464  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAC40: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAC44: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AAC48: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAC4C: 409A0454  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAC50: EBEB00F8  ld r31, 0xf8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AAC54: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AAC58: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AAC5C: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AAC60: 480002A0  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AAC64 => {
    //   block [0x821AAC64..0x821AACC8)
	// 821AAC64: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAC68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAC6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821AAC70: 4BFFB7D9  bl 0x821a6448
	ctx.lr = 0x821AAC74;
	sub_821A6448(ctx, base);
	// 821AAC74: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAC7C: 419A0014  beq cr6, 0x821aac90
	if ctx.cr[6].eq {
	pc = 0x821AAC90; continue 'dispatch;
	}
	// 821AAC80: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAC84: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAC88: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAC8C: 419A0008  beq cr6, 0x821aac94
	if ctx.cr[6].eq {
	pc = 0x821AAC94; continue 'dispatch;
	}
	// 821AAC90: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821AAC94: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAC9C: 419A0404  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AACA0: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AACA4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AACA8: 409A03F8  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AACAC: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821AACB0: EBEB00F8  ld r31, 0xf8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AACB4: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AACB8: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AACBC: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AACC0: 914B0100  stw r10, 0x100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[10].u32 ) };
	// 821AACC4: 4800023C  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AACC8 => {
    //   block [0x821AACC8..0x821AAD1C)
	// 821AACC8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AACCC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AACD0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821AACD4: 4BFFC875  bl 0x821a7548
	ctx.lr = 0x821AACD8;
	sub_821A7548(ctx, base);
	// 821AACD8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AACDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AACE0: 419A0014  beq cr6, 0x821aacf4
	if ctx.cr[6].eq {
	pc = 0x821AACF4; continue 'dispatch;
	}
	// 821AACE4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AACE8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AACEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AACF0: 419A0008  beq cr6, 0x821aacf8
	if ctx.cr[6].eq {
	pc = 0x821AACF8; continue 'dispatch;
	}
	// 821AACF4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821AACF8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AACFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAD00: 419A03A0  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAD04: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAD08: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAD0C: 409A0394  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAD10: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AAD14: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AAD18: 480001E0  b 0x821aaef8
	pc = 0x821AAEF8; continue 'dispatch;
            }
            0x821AAD1C => {
    //   block [0x821AAD1C..0x821AAD7C)
	// 821AAD1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AAD20: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAD24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAD28: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821AAD2C: 4BFFA80D  bl 0x821a5538
	ctx.lr = 0x821AAD30;
	sub_821A5538(ctx, base);
	// 821AAD30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAD34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAD38: 419A0014  beq cr6, 0x821aad4c
	if ctx.cr[6].eq {
	pc = 0x821AAD4C; continue 'dispatch;
	}
	// 821AAD3C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAD40: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAD44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAD48: 419A0008  beq cr6, 0x821aad50
	if ctx.cr[6].eq {
	pc = 0x821AAD50; continue 'dispatch;
	}
	// 821AAD4C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821AAD50: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAD54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAD58: 419A0348  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAD5C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAD60: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAD64: 409A033C  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAD68: EBEB00F8  ld r31, 0xf8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AAD6C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AAD70: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AAD74: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AAD78: 48000188  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AAD7C => {
    //   block [0x821AAD7C..0x821AADF0)
	// 821AAD7C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAD80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAD84: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821AAD88: 4BFFA1F9  bl 0x821a4f80
	ctx.lr = 0x821AAD8C;
	sub_821A4F80(ctx, base);
	// 821AAD8C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAD90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAD94: 419A0014  beq cr6, 0x821aada8
	if ctx.cr[6].eq {
	pc = 0x821AADA8; continue 'dispatch;
	}
	// 821AAD98: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAD9C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AADA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AADA4: 419A0008  beq cr6, 0x821aadac
	if ctx.cr[6].eq {
	pc = 0x821AADAC; continue 'dispatch;
	}
	// 821AADA8: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821AADAC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AADB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AADB4: 419A02EC  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AADB8: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AADBC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AADC0: 409A02E0  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AADC4: EBEB00E8  ld r31, 0xe8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	// 821AADC8: 386B00F0  addi r3, r11, 0xf0
	ctx.r[3].s64 = ctx.r[11].s64 + 240;
	// 821AADCC: FB6B00E0  std r27, 0xe0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), ctx.r[27].u64 ) };
	// 821AADD0: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AADD4: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AADD8: C0730008  lfs f3, 8(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821AADDC: C0530004  lfs f2, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AADE0: C0330000  lfs f1, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AADE4: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 821AADE8: 480055A1  bl 0x821b0388
	ctx.lr = 0x821AADEC;
	sub_821B0388(ctx, base);
	// 821AADEC: 48000118  b 0x821aaf04
	pc = 0x821AAF04; continue 'dispatch;
            }
            0x821AADF0 => {
    //   block [0x821AADF0..0x821AAE4C)
	// 821AADF0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AADF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AADF8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821AADFC: 4BFFB0A5  bl 0x821a5ea0
	ctx.lr = 0x821AAE00;
	sub_821A5EA0(ctx, base);
	// 821AAE00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAE04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAE08: 419A0014  beq cr6, 0x821aae1c
	if ctx.cr[6].eq {
	pc = 0x821AAE1C; continue 'dispatch;
	}
	// 821AAE0C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAE10: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE14: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAE18: 419A0008  beq cr6, 0x821aae20
	if ctx.cr[6].eq {
	pc = 0x821AAE20; continue 'dispatch;
	}
	// 821AAE1C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821AAE20: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAE28: 419A0278  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAE2C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAE30: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAE34: 409A026C  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAE38: EBEB00F8  ld r31, 0xf8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AAE3C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AAE40: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AAE44: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AAE48: 480000B8  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AAE4C => {
    //   block [0x821AAE4C..0x821AAEA8)
	// 821AAE4C: 570B103A  slwi r11, r24, 2
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AAE50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAE54: 7D785A14  add r11, r24, r11
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 821AAE58: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821AAE5C: 5565083C  slwi r5, r11, 1
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AAE60: 4BFFE959  bl 0x821a97b8
	ctx.lr = 0x821AAE64;
	sub_821A97B8(ctx, base);
	// 821AAE64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAE68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAE6C: 419A0014  beq cr6, 0x821aae80
	if ctx.cr[6].eq {
	pc = 0x821AAE80; continue 'dispatch;
	}
	// 821AAE70: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAE74: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE78: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAE7C: 419A0008  beq cr6, 0x821aae84
	if ctx.cr[6].eq {
	pc = 0x821AAE84; continue 'dispatch;
	}
	// 821AAE80: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821AAE84: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAE8C: 419A0214  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAE90: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAE94: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAE98: 409A0208  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAE9C: EBEB00A0  ld r31, 0xa0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) };
	// 821AAEA0: FB6B0098  std r27, 0x98(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[27].u64 ) };
	// 821AAEA4: 4800005C  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AAEA8 => {
    //   block [0x821AAEA8..0x821AB158)
	// 821AAEA8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAEAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAEB0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821AAEB4: 4BFFF1ED  bl 0x821aa0a0
	ctx.lr = 0x821AAEB8;
	sub_821AA0A0(ctx, base);
	// 821AAEB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAEC0: 419A0014  beq cr6, 0x821aaed4
	if ctx.cr[6].eq {
	pc = 0x821AAED4; continue 'dispatch;
	}
	// 821AAEC4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAEC8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAECC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAED0: 419A0008  beq cr6, 0x821aaed8
	if ctx.cr[6].eq {
	pc = 0x821AAED8; continue 'dispatch;
	}
	// 821AAED4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821AAED8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAEE0: 419A01C0  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAEE4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAEE8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAEEC: 409A01B4  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAEF0: 93AB00C8  stw r29, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[29].u32 ) };
	// 821AAEF4: 93CB00CC  stw r30, 0xcc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 821AAEF8: FB6B00E0  std r27, 0xe0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), ctx.r[27].u64 ) };
	// 821AAEFC: EBEB00E8  ld r31, 0xe8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	// 821AAF00: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 821AAF04: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AAF08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAF0C: 419A0194  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAF10: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAF14: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AAF18: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAF1C: 409A0184  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAF20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AAF24: FB7A0188  std r27, 0x188(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(392 as u32), ctx.r[27].u64 ) };
	// 821AAF28: FAFC00B8  std r23, 0xb8(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(184 as u32), ctx.r[23].u64 ) };
	// 821AAF2C: 395A0080  addi r10, r26, 0x80
	ctx.r[10].s64 = ctx.r[26].s64 + 128;
	// 821AAF30: FBFC00C0  std r31, 0xc0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(192 as u32), ctx.r[31].u64 ) };
	// 821AAF34: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821AAF38: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAF3C: D01A0178  stfs f0, 0x178(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821AAF40: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAF44: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821AAF48: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AAF4C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821AAF50: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821AAF54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AAF58: 4200FFF0  bdnz 0x821aaf48
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821AAF48; continue 'dispatch;
	}
	// 821AAF5C: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAF60: 393A00C0  addi r9, r26, 0xc0
	ctx.r[9].s64 = ctx.r[26].s64 + 192;
	// 821AAF64: 397A00E0  addi r11, r26, 0xe0
	ctx.r[11].s64 = ctx.r[26].s64 + 224;
	// 821AAF68: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AAF6C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 821AAF70: 3908B8B0  addi r8, r8, -0x4750
	ctx.r[8].s64 = ctx.r[8].s64 + -18256;
	// 821AAF74: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAF78: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821AAF7C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAF80: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821AAF84: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AAF88: 90E90008  stw r7, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821AAF8C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AAF90: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821AAF94: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAF98: D01A00D0  stfs f0, 0xd0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821AAF9C: C019001C  lfs f0, 0x1c(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAFA0: C1790010  lfs f11, 0x10(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AAFA4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AAFA8: C1B9002C  lfs f13, 0x2c(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AAFAC: ED6B07F2  fmuls f11, f11, f31
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AAFB0: C1990020  lfs f12, 0x20(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AAFB4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AAFB8: EC0D07F2  fmuls f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AAFBC: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AAFC0: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AAFC4: EC0C07F2  fmuls f0, f12, f31
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AAFC8: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AAFCC: 910B0020  stw r8, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 821AAFD0: C0190030  lfs f0, 0x30(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAFD4: D01A0110  stfs f0, 0x110(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821AAFD8: C0190034  lfs f0, 0x34(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAFDC: D01A0114  stfs f0, 0x114(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 821AAFE0: 419A001C  beq cr6, 0x821aaffc
	if ctx.cr[6].eq {
	pc = 0x821AAFFC; continue 'dispatch;
	}
	// 821AAFE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AAFE8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 821AAFEC: 387A0130  addi r3, r26, 0x130
	ctx.r[3].s64 = ctx.r[26].s64 + 304;
	// 821AAFF0: 4BFF8C61  bl 0x821a3c50
	ctx.lr = 0x821AAFF4;
	sub_821A3C50(ctx, base);
	// 821AAFF4: FADC00A8  std r22, 0xa8(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(168 as u32), ctx.r[22].u64 ) };
	// 821AAFF8: 4800004C  b 0x821ab044
	pc = 0x821AB044; continue 'dispatch;
	// 821AAFFC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AB000: 392BC448  addi r9, r11, -0x3bb8
	ctx.r[9].s64 = ctx.r[11].s64 + -15288;
	// 821AB004: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB00C: 419A0030  beq cr6, 0x821ab03c
	if ctx.cr[6].eq {
	pc = 0x821AB03C; continue 'dispatch;
	}
	// 821AB010: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB014: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB018: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AB01C: 409A0020  bne cr6, 0x821ab03c
	if !ctx.cr[6].eq {
	pc = 0x821AB03C; continue 'dispatch;
	}
	// 821AB020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB024: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821AB028: 409A0008  bne cr6, 0x821ab030
	if !ctx.cr[6].eq {
	pc = 0x821AB030; continue 'dispatch;
	}
	// 821AB02C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821AB030: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AB034: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AB038: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821AB03C: E9690000  ld r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821AB040: F97C00A8  std r11, 0xa8(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 821AB044: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821AB048: 419A001C  beq cr6, 0x821ab064
	if ctx.cr[6].eq {
	pc = 0x821AB064; continue 'dispatch;
	}
	// 821AB04C: C0130000  lfs f0, 0(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB050: D01A0160  stfs f0, 0x160(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 821AB054: C0130004  lfs f0, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB058: D01A0164  stfs f0, 0x164(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 821AB05C: C0130008  lfs f0, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB060: 48000014  b 0x821ab074
	pc = 0x821AB074; continue 'dispatch;
	// 821AB064: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AB068: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB06C: D01A0164  stfs f0, 0x164(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 821AB070: D01A0160  stfs f0, 0x160(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 821AB074: D01A0168  stfs f0, 0x168(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 821AB078: 929A0118  stw r20, 0x118(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(280 as u32), ctx.r[20].u32 ) };
	// 821AB07C: 931A0180  stw r24, 0x180(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(384 as u32), ctx.r[24].u32 ) };
	// 821AB080: 81790038  lwz r11, 0x38(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AB084: 917C0098  stw r11, 0x98(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AB088: 8179003C  lwz r11, 0x3c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(60 as u32) ) } as u64;
	// 821AB08C: 92DC00C8  stw r22, 0xc8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(200 as u32), ctx.r[22].u32 ) };
	// 821AB090: 917C009C  stw r11, 0x9c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821AB094: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821AB098: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AB09C: 4838A048  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
	// 821AB0A0: 817A0194  lwz r11, 0x194(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(404 as u32) ) } as u64;
	// 821AB0A4: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 821AB0A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AB0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB0B0: 419A0028  beq cr6, 0x821ab0d8
	if ctx.cr[6].eq {
	pc = 0x821AB0D8; continue 'dispatch;
	}
	// 821AB0B4: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB0B8: 80FA0190  lwz r7, 0x190(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(400 as u32) ) } as u64;
	// 821AB0BC: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AB0C0: 409A0018  bne cr6, 0x821ab0d8
	if !ctx.cr[6].eq {
	pc = 0x821AB0D8; continue 'dispatch;
	}
	// 821AB0C4: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB0C8: 992B0019  stb r9, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[9].u8 ) };
	// 821AB0CC: 61088000  ori r8, r8, 0x8000
	ctx.r[8].u64 = ctx.r[8].u64 | 32768;
	// 821AB0D0: 994B0025  stb r10, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821AB0D4: B10B0014  sth r8, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u16 ) };
	// 821AB0D8: 817C00B4  lwz r11, 0xb4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(180 as u32) ) } as u64;
	// 821AB0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB0E0: 419A006C  beq cr6, 0x821ab14c
	if ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AB0E4: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB0E8: 80FC00B0  lwz r7, 0xb0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AB0EC: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AB0F0: 409A005C  bne cr6, 0x821ab14c
	if !ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AB0F4: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB0F8: 992B0019  stb r9, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[9].u8 ) };
	// 821AB0FC: 61098000  ori r9, r8, 0x8000
	ctx.r[9].u64 = ctx.r[8].u64 | 32768;
	// 821AB100: 994B0025  stb r10, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821AB104: B12B0014  sth r9, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 821AB108: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821AB10C: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AB110: 48389FD4  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
	// 821AB114: 817C00B4  lwz r11, 0xb4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(180 as u32) ) } as u64;
	// 821AB118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB11C: 419A0030  beq cr6, 0x821ab14c
	if ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AB120: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB124: 813C00B0  lwz r9, 0xb0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AB128: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB12C: 409A0020  bne cr6, 0x821ab14c
	if !ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AB130: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821AB134: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB138: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AB13C: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AB140: 610A8000  ori r10, r8, 0x8000
	ctx.r[10].u64 = ctx.r[8].u64 | 32768;
	// 821AB144: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 821AB148: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821AB14C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821AB150: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AB154: 48389F90  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AB158 size=1876
    let mut pc: u32 = 0x821AB158;
    'dispatch: loop {
        match pc {
            0x821AB158 => {
    //   block [0x821AB158..0x821AB3D0)
	// 821AB158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AB15C: 48389F31  bl 0x8253508c
	ctx.lr = 0x821AB160;
	sub_82535080(ctx, base);
	// 821AB160: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 821AB164: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 821AB168: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AB16C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821AB170: 82610194  lwz r19, 0x194(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 821AB174: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AB178: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821AB17C: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AB180: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821AB184: 396B1E50  addi r11, r11, 0x1e50
	ctx.r[11].s64 = ctx.r[11].s64 + 7760;
	// 821AB188: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 821AB18C: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 821AB190: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AB194: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821AB198: 7F4A5A14  add r26, r10, r11
	ctx.r[26].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AB19C: 814101A4  lwz r10, 0x1a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 821AB1A0: 7D124378  mr r18, r8
	ctx.r[18].u64 = ctx.r[8].u64;
	// 821AB1A4: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821AB1A8: FAF10000  std r23, 0(r17)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[23].u64 ) };
	// 821AB1AC: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AB1B0: 7D745378  or r20, r11, r10
	ctx.r[20].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 821AB1B4: 568967FE  rlwinm r9, r20, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[20].u32 as u64 & 0x000FFFFFu64;
	// 821AB1B8: 419A0014  beq cr6, 0x821ab1cc
	if ctx.cr[6].eq {
	pc = 0x821AB1CC; continue 'dispatch;
	}
	// 821AB1BC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AB1C0: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821AB1C4: 7D5358AE  lbzx r10, r19, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AB1C8: 48000008  b 0x821ab1d0
	pc = 0x821AB1D0; continue 'dispatch;
	// 821AB1CC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AB1D0: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AB1D4: 82C1019C  lwz r22, 0x19c(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 821AB1D8: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821AB1DC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821AB1E0: 394AC470  addi r10, r10, -0x3b90
	ctx.r[10].s64 = ctx.r[10].s64 + -15248;
	// 821AB1E4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AB1E8: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 821AB1EC: 56CB057E  clrlwi r11, r22, 0x15
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000007FFu64;
	// 821AB1F0: 56C80428  rlwinm r8, r22, 0, 0x10, 0x14
	ctx.r[8].u64 = ctx.r[22].u32 as u64 & 0xFFFFFFFFu64;
	// 821AB1F4: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 821AB1F8: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 821AB1FC: 7C89502E  lwzx r4, r9, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AB200: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 821AB204: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821AB208: B101009C  sth r8, 0x9c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[8].u16 ) };
	// 821AB20C: B1410098  sth r10, 0x98(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u16 ) };
	// 821AB210: 40980008  bge cr6, 0x821ab218
	if !ctx.cr[6].lt {
	pc = 0x821AB218; continue 'dispatch;
	}
	// 821AB214: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821AB218: B161009A  sth r11, 0x9a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(154 as u32), ctx.r[11].u16 ) };
	// 821AB21C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AB220: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 821AB224: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AB228: 4198002C  blt cr6, 0x821ab254
	if ctx.cr[6].lt {
	pc = 0x821AB254; continue 'dispatch;
	}
	// 821AB22C: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 821AB230: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AB234: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 821AB238: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 821AB23C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AB240: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AB244: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AB248: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AB24C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AB250: 48000008  b 0x821ab258
	pc = 0x821AB258; continue 'dispatch;
	// 821AB254: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 821AB258: 7F2B29D6  mullw r25, r11, r5
	ctx.r[25].s64 = (ctx.r[11].s32 as i64) * (ctx.r[5].s32 as i64);
	// 821AB25C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB260: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 821AB264: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821AB268: 4BFFC921  bl 0x821a7b88
	ctx.lr = 0x821AB26C;
	sub_821A7B88(ctx, base);
	// 821AB26C: EB630000  ld r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB270: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 821AB274: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB278: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821AB27C: 419A061C  beq cr6, 0x821ab898
	if ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB280: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB284: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB288: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AB28C: 409A060C  bne cr6, 0x821ab898
	if !ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB290: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB294: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821AB298: 4BFFDB29  bl 0x821a8dc0
	ctx.lr = 0x821AB29C;
	sub_821A8DC0(ctx, base);
	// 821AB29C: EB030000  ld r24, 0(r3)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB2A0: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 821AB2A4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB2A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AB2AC: 419A05B8  beq cr6, 0x821ab864
	if ctx.cr[6].eq {
	pc = 0x821AB864; continue 'dispatch;
	}
	// 821AB2B0: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB2B4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB2B8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AB2BC: 409A05A8  bne cr6, 0x821ab864
	if !ctx.cr[6].eq {
	pc = 0x821AB864; continue 'dispatch;
	}
	// 821AB2C0: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AB2C4: 395D011C  addi r10, r29, 0x11c
	ctx.r[10].s64 = ctx.r[29].s64 + 284;
	// 821AB2C8: 8101009C  lwz r8, 0x9c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 821AB2CC: 397FFFF7  addi r11, r31, -9
	ctx.r[11].s64 = ctx.r[31].s64 + -9;
	// 821AB2D0: 2B0B0033  cmplwi cr6, r11, 0x33
	ctx.cr[6].compare_u32(ctx.r[11].u32, 51 as u32, &mut ctx.xer);
	// 821AB2D4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821AB2D8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821AB2DC: 938A0008  stw r28, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 821AB2E0: 839A0040  lwz r28, 0x40(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AB2E4: 419902CC  bgt cr6, 0x821ab5b0
	if ctx.cr[6].gt {
	pc = 0x821AB5B0; continue 'dispatch;
	}
	// 821AB2E8: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821AB2EC: 398CB300  addi r12, r12, -0x4d00
	ctx.r[12].s64 = ctx.r[12].s64 + -19712;
	// 821AB2F0: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821AB2F4: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821AB2F8: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821AB2FC: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821AB46C; continue 'dispatch;
		},
		1 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		2 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		3 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		4 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		5 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		6 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		7 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		8 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		9 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		10 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		11 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		12 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		13 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		14 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		15 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		16 => {
	pc = 0x821AB420; continue 'dispatch;
		},
		17 => {
	pc = 0x821AB46C; continue 'dispatch;
		},
		18 => {
	pc = 0x821AB4BC; continue 'dispatch;
		},
		19 => {
	pc = 0x821AB46C; continue 'dispatch;
		},
		20 => {
	pc = 0x821AB4BC; continue 'dispatch;
		},
		21 => {
	pc = 0x821AB420; continue 'dispatch;
		},
		22 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		23 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		24 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		25 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		26 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		27 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		28 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		29 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		30 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		31 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		32 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		33 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		34 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		35 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		36 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		37 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		38 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		39 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		40 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		41 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		42 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		43 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		44 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		45 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		46 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		47 => {
	pc = 0x821AB510; continue 'dispatch;
		},
		48 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		49 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		50 => {
	pc = 0x821AB55C; continue 'dispatch;
		},
		51 => {
	pc = 0x821AB46C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821AB300: 821AB46C  lwz r16, -0x4b94(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19348 as u32) ) } as u64;
	// 821AB304: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB308: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB30C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB310: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB314: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB318: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB31C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB320: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB324: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB328: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB32C: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB330: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB334: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB338: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB33C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB340: 821AB420  lwz r16, -0x4be0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19424 as u32) ) } as u64;
	// 821AB344: 821AB46C  lwz r16, -0x4b94(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19348 as u32) ) } as u64;
	// 821AB348: 821AB4BC  lwz r16, -0x4b44(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19268 as u32) ) } as u64;
	// 821AB34C: 821AB46C  lwz r16, -0x4b94(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19348 as u32) ) } as u64;
	// 821AB350: 821AB4BC  lwz r16, -0x4b44(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19268 as u32) ) } as u64;
	// 821AB354: 821AB420  lwz r16, -0x4be0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19424 as u32) ) } as u64;
	// 821AB358: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB35C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB360: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB364: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB368: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB36C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB370: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB374: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB378: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB37C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB380: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB384: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB388: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB38C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB390: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB394: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB398: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB39C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3A0: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB3A4: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB3A8: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB3AC: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3B0: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3B4: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3B8: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3BC: 821AB510  lwz r16, -0x4af0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19184 as u32) ) } as u64;
	// 821AB3C0: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3C4: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3C8: 821AB55C  lwz r16, -0x4aa4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19108 as u32) ) } as u64;
	// 821AB3CC: 821AB46C  lwz r16, -0x4b94(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19348 as u32) ) } as u64;
            }
            0x821AB3D0 => {
    //   block [0x821AB3D0..0x821AB420)
	// 821AB3D0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB3D4: 80C101B4  lwz r6, 0x1b4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 821AB3D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB3DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821AB3E0: 4BFFA159  bl 0x821a5538
	ctx.lr = 0x821AB3E4;
	sub_821A5538(ctx, base);
	// 821AB3E4: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB3E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB3EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB3F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB3F4: 419A041C  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB3F8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB3FC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB400: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB404: 409A040C  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB408: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB40C: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB410: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB414: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB418: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB41C: 4800020C  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB420 => {
    //   block [0x821AB420..0x821AB46C)
	// 821AB420: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB424: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB428: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821AB42C: 4BFFB945  bl 0x821a6d70
	ctx.lr = 0x821AB430;
	sub_821A6D70(ctx, base);
	// 821AB430: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB434: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB438: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB43C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB440: 419A03D0  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB444: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB448: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB44C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB450: 409A03C0  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB454: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB458: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB45C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB460: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB464: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB468: 480001C0  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB46C => {
    //   block [0x821AB46C..0x821AB4BC)
	// 821AB46C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB470: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB474: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821AB478: 4BFFAFD1  bl 0x821a6448
	ctx.lr = 0x821AB47C;
	sub_821A6448(ctx, base);
	// 821AB47C: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB480: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB484: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB48C: 419A0384  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB490: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB494: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB498: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB49C: 409A0374  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB4A0: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB4A4: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB4A8: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB4AC: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB4B0: 92EB0100  stw r23, 0x100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[23].u32 ) };
	// 821AB4B4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB4B8: 48000170  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB4BC => {
    //   block [0x821AB4BC..0x821AB510)
	// 821AB4BC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB4C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB4C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821AB4C8: 4BFFAF81  bl 0x821a6448
	ctx.lr = 0x821AB4CC;
	sub_821A6448(ctx, base);
	// 821AB4CC: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB4D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB4D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB4DC: 419A0334  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB4E0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB4E4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB4E8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB4EC: 409A0324  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB4F0: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB4F4: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 821AB4F8: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB4FC: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB500: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB504: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB508: 912B0100  stw r9, 0x100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[9].u32 ) };
	// 821AB50C: 4800011C  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB510 => {
    //   block [0x821AB510..0x821AB55C)
	// 821AB510: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB514: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB518: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821AB51C: 4BFFA985  bl 0x821a5ea0
	ctx.lr = 0x821AB520;
	sub_821A5EA0(ctx, base);
	// 821AB520: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB524: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB528: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB52C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB530: 419A02E0  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB534: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB538: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB53C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB540: 409A02D0  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB544: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB548: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB54C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB550: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB554: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB558: 480000D0  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB55C => {
    //   block [0x821AB55C..0x821AB5B0)
	// 821AB55C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB560: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB564: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821AB568: 4BFFAEE1  bl 0x821a6448
	ctx.lr = 0x821AB56C;
	sub_821A6448(ctx, base);
	// 821AB56C: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB570: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB574: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB57C: 419A0294  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB580: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB584: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB588: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB58C: 409A0284  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB590: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB594: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 821AB598: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB59C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB5A0: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB5A4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB5A8: 912B0100  stw r9, 0x100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[9].u32 ) };
	// 821AB5AC: 4800007C  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB5B0 => {
    //   block [0x821AB5B0..0x821AB8AC)
	// 821AB5B0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB5B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB5B8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821AB5BC: 4BFFEAE5  bl 0x821aa0a0
	ctx.lr = 0x821AB5C0;
	sub_821AA0A0(ctx, base);
	// 821AB5C0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB5C4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB5C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB5CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB5D0: 419A0240  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB5D4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB5D8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB5DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB5E0: 409A0230  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB5E4: E94B00E8  ld r10, 0xe8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	// 821AB5E8: 2F1F0037  cmpwi cr6, r31, 0x37
	ctx.cr[6].compare_i32(ctx.r[31].s32, 55, &mut ctx.xer);
	// 821AB5EC: FB6B00E0  std r27, 0xe0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), ctx.r[27].u64 ) };
	// 821AB5F0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB5F4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB5F8: 409A0028  bne cr6, 0x821ab620
	if !ctx.cr[6].eq {
	pc = 0x821AB620; continue 'dispatch;
	}
	// 821AB5FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AB600: 419A0014  beq cr6, 0x821ab614
	if ctx.cr[6].eq {
	pc = 0x821AB614; continue 'dispatch;
	}
	// 821AB604: 81090030  lwz r8, 0x30(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB608: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB60C: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AB610: 419A0008  beq cr6, 0x821ab618
	if ctx.cr[6].eq {
	pc = 0x821AB618; continue 'dispatch;
	}
	// 821AB614: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 821AB618: 39000388  li r8, 0x388
	ctx.r[8].s64 = 904;
	// 821AB61C: B1090014  sth r8, 0x14(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u16 ) };
	// 821AB620: 3BEB00D0  addi r31, r11, 0xd0
	ctx.r[31].s64 = ctx.r[11].s64 + 208;
	// 821AB624: 938B00C8  stw r28, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[28].u32 ) };
	// 821AB628: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB62C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AB630: 419A01E0  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB634: 81690030  lwz r11, 0x30(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB638: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB63C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AB640: 409A01D0  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB644: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821AB648: 419A0030  beq cr6, 0x821ab678
	if ctx.cr[6].eq {
	pc = 0x821AB678; continue 'dispatch;
	}
	// 821AB64C: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB654: 419A001C  beq cr6, 0x821ab670
	if ctx.cr[6].eq {
	pc = 0x821AB670; continue 'dispatch;
	}
	// 821AB658: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB65C: 80F30000  lwz r7, 0(r19)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB660: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AB664: 409A000C  bne cr6, 0x821ab670
	if !ctx.cr[6].eq {
	pc = 0x821AB670; continue 'dispatch;
	}
	// 821AB668: A16B0016  lhz r11, 0x16(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 821AB66C: 48000008  b 0x821ab674
	pc = 0x821AB674; continue 'dispatch;
	// 821AB670: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821AB674: B1690016  sth r11, 0x16(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(22 as u32), ctx.r[11].u16 ) };
	// 821AB678: FB7D0188  std r27, 0x188(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(392 as u32), ctx.r[27].u64 ) };
	// 821AB67C: 393D0080  addi r9, r29, 0x80
	ctx.r[9].s64 = ctx.r[29].s64 + 128;
	// 821AB680: FB1E00B8  std r24, 0xb8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), ctx.r[24].u64 ) };
	// 821AB684: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 821AB688: F95E00C0  std r10, 0xc0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[10].u64 ) };
	// 821AB68C: D3FD0178  stfs f31, 0x178(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821AB690: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB694: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821AB698: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AB69C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821AB6A0: F9490000  std r10, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821AB6A4: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821AB6A8: 4200FFF0  bdnz 0x821ab698
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821AB698; continue 'dispatch;
	}
	// 821AB6AC: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB6B0: 393D00C0  addi r9, r29, 0xc0
	ctx.r[9].s64 = ctx.r[29].s64 + 192;
	// 821AB6B4: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AB6B8: 397D00E0  addi r11, r29, 0xe0
	ctx.r[11].s64 = ctx.r[29].s64 + 224;
	// 821AB6BC: 3908B8B0  addi r8, r8, -0x4750
	ctx.r[8].s64 = ctx.r[8].s64 + -18256;
	// 821AB6C0: 2F16005A  cmpwi cr6, r22, 0x5a
	ctx.cr[6].compare_i32(ctx.r[22].s32, 90, &mut ctx.xer);
	// 821AB6C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB6C8: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821AB6CC: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB6D0: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821AB6D4: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AB6D8: 90E90008  stw r7, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821AB6DC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AB6E0: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821AB6E4: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB6E8: D01D00D0  stfs f0, 0xd0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821AB6EC: C01A001C  lfs f0, 0x1c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB6F0: C1BA002C  lfs f13, 0x2c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AB6F4: C19A0020  lfs f12, 0x20(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AB6F8: C17A0010  lfs f11, 0x10(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AB6FC: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AB700: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AB704: D1AB001C  stfs f13, 0x1c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AB708: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AB70C: 910B0020  stw r8, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 821AB710: C01A0030  lfs f0, 0x30(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB714: D01D0110  stfs f0, 0x110(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821AB718: C01A0034  lfs f0, 0x34(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB71C: D01D0114  stfs f0, 0x114(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 821AB720: 409A0050  bne cr6, 0x821ab770
	if !ctx.cr[6].eq {
	pc = 0x821AB770; continue 'dispatch;
	}
	// 821AB724: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AB728: 392BC448  addi r9, r11, -0x3bb8
	ctx.r[9].s64 = ctx.r[11].s64 + -15288;
	// 821AB72C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB734: 419A0030  beq cr6, 0x821ab764
	if ctx.cr[6].eq {
	pc = 0x821AB764; continue 'dispatch;
	}
	// 821AB738: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB73C: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB740: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AB744: 409A0020  bne cr6, 0x821ab764
	if !ctx.cr[6].eq {
	pc = 0x821AB764; continue 'dispatch;
	}
	// 821AB748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB74C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821AB750: 409A0008  bne cr6, 0x821ab758
	if !ctx.cr[6].eq {
	pc = 0x821AB758; continue 'dispatch;
	}
	// 821AB754: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821AB758: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AB75C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AB760: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821AB764: E9690000  ld r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821AB768: F97E00A8  std r11, 0xa8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 821AB76C: 4800001C  b 0x821ab788
	pc = 0x821AB788; continue 'dispatch;
	// 821AB770: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821AB774: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AB778: 388BD050  addi r4, r11, -0x2fb0
	ctx.r[4].s64 = ctx.r[11].s64 + -12208;
	// 821AB77C: 387D0130  addi r3, r29, 0x130
	ctx.r[3].s64 = ctx.r[29].s64 + 304;
	// 821AB780: 4BFF84D1  bl 0x821a3c50
	ctx.lr = 0x821AB784;
	sub_821A3C50(ctx, base);
	// 821AB784: FAFE00A8  std r23, 0xa8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[23].u64 ) };
	// 821AB788: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821AB78C: 3D408287  lis r10, -0x7d79
	ctx.r[10].s64 = -2105081856;
	// 821AB790: 396B3410  addi r11, r11, 0x3410
	ctx.r[11].s64 = ctx.r[11].s64 + 13328;
	// 821AB794: 38CAB910  addi r6, r10, -0x46f0
	ctx.r[6].s64 = ctx.r[10].s64 + -18160;
	// 821AB798: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821AB79C: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 821AB7A0: 386A07E4  addi r3, r10, 0x7e4
	ctx.r[3].s64 = ctx.r[10].s64 + 2020;
	// 821AB7A4: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB7A8: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 821AB7AC: D01D0160  stfs f0, 0x160(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 821AB7B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AB7B4: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB7B8: D01D0164  stfs f0, 0x164(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 821AB7BC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB7C0: D01D0168  stfs f0, 0x168(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 821AB7C4: 929D0118  stw r20, 0x118(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(280 as u32), ctx.r[20].u32 ) };
	// 821AB7C8: 933D0180  stw r25, 0x180(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(384 as u32), ctx.r[25].u32 ) };
	// 821AB7CC: 927E00CC  stw r19, 0xcc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(204 as u32), ctx.r[19].u32 ) };
	// 821AB7D0: 817A0038  lwz r11, 0x38(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AB7D4: 917E0098  stw r11, 0x98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AB7D8: 817A003C  lwz r11, 0x3c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 821AB7DC: 92FE00C8  stw r23, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[23].u32 ) };
	// 821AB7E0: 917E009C  stw r11, 0x9c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821AB7E4: 4BFF1905  bl 0x8219d0e8
	ctx.lr = 0x821AB7E8;
	sub_8219D0E8(ctx, base);
	// 821AB7E8: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB7EC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821AB7F0: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821AB7F4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AB7F8: E97E00B0  ld r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) };
	// 821AB7FC: F9710000  std r11, 0(r17)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821AB800: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 821AB804: CBC1FF70  lfd f30, -0x90(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AB808: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821AB80C: 483898D0  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
	// 821AB810: 817D0194  lwz r11, 0x194(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(404 as u32) ) } as u64;
	// 821AB814: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821AB818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB81C: 419A0028  beq cr6, 0x821ab844
	if ctx.cr[6].eq {
	pc = 0x821AB844; continue 'dispatch;
	}
	// 821AB820: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB824: 811D0190  lwz r8, 0x190(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(400 as u32) ) } as u64;
	// 821AB828: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AB82C: 409A0018  bne cr6, 0x821ab844
	if !ctx.cr[6].eq {
	pc = 0x821AB844; continue 'dispatch;
	}
	// 821AB830: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB834: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AB838: 61298000  ori r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 32768;
	// 821AB83C: 9AAB0025  stb r21, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[21].u8 ) };
	// 821AB840: B12B0014  sth r9, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 821AB844: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 821AB848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB84C: 419A004C  beq cr6, 0x821ab898
	if ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB850: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB854: 811E00B0  lwz r8, 0xb0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AB858: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AB85C: 409A003C  bne cr6, 0x821ab898
	if !ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB860: 48000024  b 0x821ab884
	pc = 0x821AB884; continue 'dispatch;
	// 821AB864: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 821AB868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB86C: 419A002C  beq cr6, 0x821ab898
	if ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB870: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB874: 813E00B0  lwz r9, 0xb0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AB878: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB87C: 409A001C  bne cr6, 0x821ab898
	if !ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB880: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821AB884: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AB888: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB88C: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821AB890: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821AB894: 9AAB0025  stb r21, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[21].u8 ) };
	// 821AB898: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821AB89C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 821AB8A0: CBC1FF70  lfd f30, -0x90(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AB8A4: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821AB8A8: 48389834  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AB8B0 size=140
    let mut pc: u32 = 0x821AB8B0;
    'dispatch: loop {
        match pc {
            0x821AB8B0 => {
    //   block [0x821AB8B0..0x821AB93C)
	// 821AB8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AB8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AB8B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AB8BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AB8C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AB8C4: 481BB875  bl 0x82367138
	ctx.lr = 0x821AB8C8;
	sub_82367138(ctx, base);
	// 821AB8C8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AB8CC: C1840010  lfs f12, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AB8D0: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AB8D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB8D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AB8DC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AB8E0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AB8E4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AB8E8: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB8EC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AB8F0: EDAC5B7A  fmadds f13, f12, f13, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 821AB8F4: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AB8F8: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AB8FC: 481BB83D  bl 0x82367138
	ctx.lr = 0x821AB900;
	sub_82367138(ctx, base);
	// 821AB900: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AB904: C1A4001C  lfs f13, 0x1c(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AB908: C184000C  lfs f12, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AB90C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB910: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AB914: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 821AB918: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821AB91C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AB920: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821AB924: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AB928: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AB92C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AB930: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AB934: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AB938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AB940 size=1812
    let mut pc: u32 = 0x821AB940;
    'dispatch: loop {
        match pc {
            0x821AB940 => {
    //   block [0x821AB940..0x821AC054)
	// 821AB940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AB944: 48389759  bl 0x8253509c
	ctx.lr = 0x821AB948;
	sub_82535080(ctx, base);
	// 821AB948: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821AB94C: 3AC5FFFF  addi r22, r5, -1
	ctx.r[22].s64 = ctx.r[5].s64 + -1;
	// 821AB950: 394B20C0  addi r10, r11, 0x20c0
	ctx.r[10].s64 = ctx.r[11].s64 + 8384;
	// 821AB954: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AB958: 392A0100  addi r9, r10, 0x100
	ctx.r[9].s64 = ctx.r[10].s64 + 256;
	// 821AB95C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821AB960: 2F160004  cmpwi cr6, r22, 4
	ctx.cr[6].compare_i32(ctx.r[22].s32, 4, &mut ctx.xer);
	// 821AB964: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB968: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AB96C: 7EAB4A14  add r21, r11, r9
	ctx.r[21].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AB970: D015FFF8  stfs f0, -8(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821AB974: D00A0108  stfs f0, 0x108(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 821AB978: D015FFF4  stfs f0, -0xc(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AB97C: D00A0104  stfs f0, 0x104(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 821AB980: D015FFF0  stfs f0, -0x10(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821AB984: D00A0100  stfs f0, 0x100(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 821AB988: 41980148  blt cr6, 0x821abad0
	if ctx.cr[6].lt {
	pc = 0x821ABAD0; continue 'dispatch;
	}
	// 821AB98C: 3976FFFC  addi r11, r22, -4
	ctx.r[11].s64 = ctx.r[22].s64 + -4;
	// 821AB990: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 821AB994: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AB998: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
	// 821AB99C: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821AB9A0: 38CA0014  addi r6, r10, 0x14
	ctx.r[6].s64 = ctx.r[10].s64 + 20;
	// 821AB9A4: 386A001C  addi r3, r10, 0x1c
	ctx.r[3].s64 = ctx.r[10].s64 + 28;
	// 821AB9A8: 3BEA0020  addi r31, r10, 0x20
	ctx.r[31].s64 = ctx.r[10].s64 + 32;
	// 821AB9AC: 3BCA0024  addi r30, r10, 0x24
	ctx.r[30].s64 = ctx.r[10].s64 + 36;
	// 821AB9B0: 3BAA002C  addi r29, r10, 0x2c
	ctx.r[29].s64 = ctx.r[10].s64 + 44;
	// 821AB9B4: 3B8A0030  addi r28, r10, 0x30
	ctx.r[28].s64 = ctx.r[10].s64 + 48;
	// 821AB9B8: 3B6A0034  addi r27, r10, 0x34
	ctx.r[27].s64 = ctx.r[10].s64 + 52;
	// 821AB9BC: 3B4A003C  addi r26, r10, 0x3c
	ctx.r[26].s64 = ctx.r[10].s64 + 60;
	// 821AB9C0: 3B2A0040  addi r25, r10, 0x40
	ctx.r[25].s64 = ctx.r[10].s64 + 64;
	// 821AB9C4: 3B0A0044  addi r24, r10, 0x44
	ctx.r[24].s64 = ctx.r[10].s64 + 68;
	// 821AB9C8: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 821AB9CC: 7D044050  subf r8, r4, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 821AB9D0: 7CE43850  subf r7, r4, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 821AB9D4: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 821AB9D8: 7C641850  subf r3, r4, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 821AB9DC: 7FE4F850  subf r31, r4, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 821AB9E0: 7FC4F050  subf r30, r4, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[4].s64;
	// 821AB9E4: 7FA4E850  subf r29, r4, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[4].s64;
	// 821AB9E8: 7F84E050  subf r28, r4, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[4].s64;
	// 821AB9EC: 7F64D850  subf r27, r4, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[4].s64;
	// 821AB9F0: 7F44D050  subf r26, r4, r26
	ctx.r[26].s64 = ctx.r[26].s64 - ctx.r[4].s64;
	// 821AB9F4: 7F24C850  subf r25, r4, r25
	ctx.r[25].s64 = ctx.r[25].s64 - ctx.r[4].s64;
	// 821AB9F8: 7F04C050  subf r24, r4, r24
	ctx.r[24].s64 = ctx.r[24].s64 - ctx.r[4].s64;
	// 821AB9FC: 5537103A  slwi r23, r9, 2
	ctx.r[23].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 821ABA00: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA04: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821ABA08: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA0C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA10: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA14: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821ABA1C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA20: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA24: 7C075D2E  stfsx f0, r7, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA28: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA2C: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA30: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA34: 7C065D2E  stfsx f0, r6, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA38: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA3C: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA40: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA44: 7C035D2E  stfsx f0, r3, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA48: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA4C: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA50: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA54: 7C1F5D2E  stfsx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA58: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA5C: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA60: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA64: 7C1E5D2E  stfsx f0, r30, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA68: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA6C: C00B002C  lfs f0, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA70: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA74: 7C1D5D2E  stfsx f0, r29, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA78: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA7C: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA80: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA84: 7C1C5D2E  stfsx f0, r28, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA88: C1AB0024  lfs f13, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA8C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA90: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA94: 7C1B5D2E  stfsx f0, r27, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA98: C1AB002C  lfs f13, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA9C: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABAA0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABAA4: 7C1A5D2E  stfsx f0, r26, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABAA8: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABAAC: C00B0040  lfs f0, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABAB0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABAB4: 7C195D2E  stfsx f0, r25, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABAB8: C00B0044  lfs f0, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABABC: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABAC0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABAC4: 7C185D2E  stfsx f0, r24, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABAC8: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821ABACC: 409AFF34  bne cr6, 0x821aba00
	if !ctx.cr[6].eq {
	pc = 0x821ABA00; continue 'dispatch;
	}
	// 821ABAD0: 7F17B000  cmpw cr6, r23, r22
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[22].s32, &mut ctx.xer);
	// 821ABAD4: 4098006C  bge cr6, 0x821abb40
	if !ctx.cr[6].lt {
	pc = 0x821ABB40; continue 'dispatch;
	}
	// 821ABAD8: 56EB2036  slwi r11, r23, 4
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABADC: 392A000C  addi r9, r10, 0xc
	ctx.r[9].s64 = ctx.r[10].s64 + 12;
	// 821ABAE0: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 821ABAE4: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
	// 821ABAE8: 38CA0014  addi r6, r10, 0x14
	ctx.r[6].s64 = ctx.r[10].s64 + 20;
	// 821ABAEC: 7D044850  subf r8, r4, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 821ABAF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821ABAF4: 7CE43850  subf r7, r4, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 821ABAF8: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 821ABAFC: 7D37B050  subf r9, r23, r22
	ctx.r[9].s64 = ctx.r[22].s64 - ctx.r[23].s64;
	// 821ABB00: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB04: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821ABB08: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB0C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB10: 7C0B452E  stfsx f0, r11, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 821ABB14: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821ABB1C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB20: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB24: 7C0B3D2E  stfsx f0, r11, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 821ABB28: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB2C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB30: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB34: 7C0B352E  stfsx f0, r11, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 821ABB38: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821ABB3C: 409AFFC4  bne cr6, 0x821abb00
	if !ctx.cr[6].eq {
	pc = 0x821ABB00; continue 'dispatch;
	}
	// 821ABB40: C00A0020  lfs f0, 0x20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821ABB48: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB4C: 3925FFFE  addi r9, r5, -2
	ctx.r[9].s64 = ctx.r[5].s64 + -2;
	// 821ABB50: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB54: C00A0024  lfs f0, 0x24(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB58: C1AA0014  lfs f13, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB5C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821ABB60: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB64: C00A0028  lfs f0, 0x28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB68: C1AA0018  lfs f13, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB6C: ED406828  fsubs f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB70: C00BCFEC  lfs f0, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB74: D00A0018  stfs f0, 0x18(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821ABB78: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 821ABB7C: D00A0014  stfs f0, 0x14(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821ABB80: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821ABB84: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821ABB88: C1AA0100  lfs f13, 0x100(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821ABB90: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB94: D1AA0110  stfs f13, 0x110(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821ABB98: C1AA0104  lfs f13, 0x104(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB9C: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABBA0: D1AA0114  stfs f13, 0x114(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 821ABBA4: C1AA0108  lfs f13, 0x108(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABBA8: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABBAC: D1AA0118  stfs f13, 0x118(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 821ABBB0: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABBB4: 4198020C  blt cr6, 0x821abdc0
	if ctx.cr[6].lt {
	pc = 0x821ABDC0; continue 'dispatch;
	}
	// 821ABBB8: 3969FFFB  addi r11, r9, -5
	ctx.r[11].s64 = ctx.r[9].s64 + -5;
	// 821ABBBC: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABBC0: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821ABBC4: 396A0114  addi r11, r10, 0x114
	ctx.r[11].s64 = ctx.r[10].s64 + 276;
	// 821ABBC8: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821ABBCC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821ABBD0: C18BFEFC  lfs f12, -0x104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABBD4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 821ABBD8: C14BFF0C  lfs f10, -0xf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-244 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABBDC: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABBE0: C16BFF1C  lfs f11, -0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABBE4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821ABBE8: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABBEC: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABBF0: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABBF4: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABBF8: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821ABBFC: C18BFF00  lfs f12, -0x100(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABC00: C14BFF10  lfs f10, -0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-240 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC04: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABC08: C16BFF20  lfs f11, -0xe0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-224 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABC0C: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABC10: D12BFF0C  stfs f9, -0xf4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-244 as u32), tmp.u32 ) };
	// 821ABC14: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC18: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABC1C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC20: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821ABC24: C18BFF04  lfs f12, -0xfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABC28: C14BFF14  lfs f10, -0xec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-236 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC2C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABC30: C16BFF24  lfs f11, -0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-220 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABC34: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABC38: D12BFF10  stfs f9, -0xf0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-240 as u32), tmp.u32 ) };
	// 821ABC3C: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC40: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABC44: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC48: D18B0014  stfs f12, 0x14(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821ABC4C: C18BFF0C  lfs f12, -0xf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-244 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABC50: C14BFF2C  lfs f10, -0xd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-212 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC54: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABC58: C16BFF1C  lfs f11, -0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABC5C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC60: D12BFF14  stfs f9, -0xec(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-236 as u32), tmp.u32 ) };
	// 821ABC64: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC68: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABC6C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC70: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821ABC74: C18BFF10  lfs f12, -0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-240 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABC78: C16BFF20  lfs f11, -0xe0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-224 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABC7C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABC80: C14BFF30  lfs f10, -0xd0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-208 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC84: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC88: D12BFF1C  stfs f9, -0xe4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-228 as u32), tmp.u32 ) };
	// 821ABC8C: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC90: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABC94: ED8C5ABC  fnmsubs f12, f12, f10, f11
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC98: D18B0020  stfs f12, 0x20(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821ABC9C: C18BFF14  lfs f12, -0xec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABCA0: C16BFF24  lfs f11, -0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-220 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABCA4: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABCA8: C14BFF34  lfs f10, -0xcc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-204 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCAC: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABCB0: D12BFF20  stfs f9, -0xe0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-224 as u32), tmp.u32 ) };
	// 821ABCB4: C14B0014  lfs f10, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCB8: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABCBC: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABCC0: D18B0024  stfs f12, 0x24(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821ABCC4: C18BFF1C  lfs f12, -0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABCC8: C14BFF2C  lfs f10, -0xd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-212 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCCC: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABCD0: C16BFF3C  lfs f11, -0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-196 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABCD4: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABCD8: D12BFF24  stfs f9, -0xdc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-220 as u32), tmp.u32 ) };
	// 821ABCDC: C14B001C  lfs f10, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCE0: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABCE4: ED8C5ABC  fnmsubs f12, f12, f10, f11
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABCE8: D18B002C  stfs f12, 0x2c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821ABCEC: C18BFF20  lfs f12, -0xe0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABCF0: C14BFF30  lfs f10, -0xd0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-208 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCF4: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABCF8: C16BFF40  lfs f11, -0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-192 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABCFC: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABD00: D12BFF2C  stfs f9, -0xd4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-212 as u32), tmp.u32 ) };
	// 821ABD04: C14B0020  lfs f10, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD08: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABD0C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD10: D18B0030  stfs f12, 0x30(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821ABD14: C18BFF24  lfs f12, -0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-220 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABD18: C14BFF34  lfs f10, -0xcc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-204 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD1C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABD20: C16BFF44  lfs f11, -0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABD24: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABD28: D12BFF30  stfs f9, -0xd0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-208 as u32), tmp.u32 ) };
	// 821ABD2C: C14B0024  lfs f10, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD30: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABD34: ED8C5ABC  fnmsubs f12, f12, f10, f11
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD38: D18B0034  stfs f12, 0x34(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821ABD3C: C18BFF2C  lfs f12, -0xd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABD40: C16BFF3C  lfs f11, -0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-196 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABD44: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABD48: C14BFF4C  lfs f10, -0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-180 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD4C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD50: D12BFF34  stfs f9, -0xcc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-204 as u32), tmp.u32 ) };
	// 821ABD54: C14B002C  lfs f10, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD58: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABD5C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD60: D18B003C  stfs f12, 0x3c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821ABD64: C18BFF30  lfs f12, -0xd0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-208 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABD68: C16BFF40  lfs f11, -0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-192 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABD6C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABD70: C14BFF50  lfs f10, -0xb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-176 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD74: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD78: D12BFF3C  stfs f9, -0xc4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-196 as u32), tmp.u32 ) };
	// 821ABD7C: C14B0030  lfs f10, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD80: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABD84: ED8C5ABC  fnmsubs f12, f12, f10, f11
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD88: D18B0040  stfs f12, 0x40(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821ABD8C: C18BFF34  lfs f12, -0xcc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-204 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABD90: C16BFF44  lfs f11, -0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABD94: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABD98: C14BFF54  lfs f10, -0xac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-172 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD9C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABDA0: D12BFF40  stfs f9, -0xc0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-192 as u32), tmp.u32 ) };
	// 821ABDA4: C14B0034  lfs f10, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABDA8: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABDAC: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABDB0: D18B0044  stfs f12, 0x44(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821ABDB4: D12BFF44  stfs f9, -0xbc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-188 as u32), tmp.u32 ) };
	// 821ABDB8: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821ABDBC: 409AFE14  bne cr6, 0x821abbd0
	if !ctx.cr[6].eq {
	pc = 0x821ABBD0; continue 'dispatch;
	}
	// 821ABDC0: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821ABDC4: 4098009C  bge cr6, 0x821abe60
	if !ctx.cr[6].lt {
	pc = 0x821ABE60; continue 'dispatch;
	}
	// 821ABDC8: 54EB2036  slwi r11, r7, 4
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABDCC: 7D074850  subf r8, r7, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 821ABDD0: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
	// 821ABDD4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821ABDD8: C18BFFF0  lfs f12, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABDDC: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 821ABDE0: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABDE4: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABDE8: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABDEC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821ABDF0: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABDF4: C14B00F0  lfs f10, 0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABDF8: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABDFC: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE00: D18B0100  stfs f12, 0x100(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 821ABE04: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABE08: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABE0C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABE10: C14B0014  lfs f10, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE14: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE18: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821ABE1C: C14B00F4  lfs f10, 0xf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE20: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABE24: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE28: D18B0104  stfs f12, 0x104(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 821ABE2C: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABE30: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABE34: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABE38: C14B0018  lfs f10, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE3C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE40: D12B0004  stfs f9, 4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821ABE44: C14B00F8  lfs f10, 0xf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE48: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABE4C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE50: D18B0108  stfs f12, 0x108(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 821ABE54: D12B0008  stfs f9, 8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821ABE58: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821ABE5C: 409AFF7C  bne cr6, 0x821abdd8
	if !ctx.cr[6].eq {
	pc = 0x821ABDD8; continue 'dispatch;
	}
	// 821ABE60: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABE64: C015FFE4  lfs f0, -0x1c(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABE68: 390A0100  addi r8, r10, 0x100
	ctx.r[8].s64 = ctx.r[10].s64 + 256;
	// 821ABE6C: C175FFF4  lfs f11, -0xc(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABE70: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE74: D015FFE4  stfs f0, -0x1c(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 821ABE78: C1B5FFE8  lfs f13, -0x18(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABE7C: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 821ABE80: C195FFF0  lfs f12, -0x10(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABE84: C155FFF8  lfs f10, -8(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE88: 7C0B442E  lfsx f0, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABE8C: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABE90: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABE94: D1B5FFE8  stfs f13, -0x18(r21)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 821ABE98: 7C0B452E  stfsx f0, r11, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 821ABE9C: 41980148  blt cr6, 0x821abfe4
	if ctx.cr[6].lt {
	pc = 0x821ABFE4; continue 'dispatch;
	}
	// 821ABEA0: 3969FFFC  addi r11, r9, -4
	ctx.r[11].s64 = ctx.r[9].s64 + -4;
	// 821ABEA4: 38EA0114  addi r7, r10, 0x114
	ctx.r[7].s64 = ctx.r[10].s64 + 276;
	// 821ABEA8: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABEAC: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821ABEB0: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABEB4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821ABEB8: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821ABEBC: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 821ABEC0: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABEC4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 821ABEC8: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABECC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABED0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABED4: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABED8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821ABEDC: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABEE0: C18BFEEC  lfs f12, -0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABEE4: C16BFFF4  lfs f11, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABEE8: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABEEC: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABEF0: C14BFFDC  lfs f10, -0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABEF4: C12BFFE0  lfs f9, -0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821ABEF8: C10BFFE4  lfs f8, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821ABEFC: C0EBFFCC  lfs f7, -0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821ABF00: C0CBFFD0  lfs f6, -0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821ABF04: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF08: D00BFFEC  stfs f0, -0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 821ABF0C: C00BFEF0  lfs f0, -0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABF10: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821ABF14: C18BFFEC  lfs f12, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF18: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABF1C: D00BFFF0  stfs f0, -0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821ABF20: C18BFEF4  lfs f12, -0x10c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-268 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF24: ED8B6024  fdivs f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF28: D18BFFF4  stfs f12, -0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821ABF2C: C18BFEDC  lfs f12, -0x124(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-292 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF30: C16BFFF4  lfs f11, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABF34: ED685828  fsubs f11, f8, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABF38: C14BFFD4  lfs f10, -0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABF3C: C10BFFC0  lfs f8, -0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-64 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821ABF40: C0ABFFC4  lfs f5, -0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821ABF44: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ABF48: C12BFFBC  lfs f9, -0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-68 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821ABF4C: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF50: D1ABFFDC  stfs f13, -0x24(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-36 as u32), tmp.u32 ) };
	// 821ABF54: C1ABFEE0  lfs f13, -0x120(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-288 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABF58: C18BFFDC  lfs f12, -0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF5C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821ABF60: D00BFFE0  stfs f0, -0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 821ABF64: EDA76028  fsubs f13, f7, f12
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABF68: C18BFEE4  lfs f12, -0x11c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-284 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF6C: ED8B6024  fdivs f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF70: D18BFFE4  stfs f12, -0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 821ABF74: C18BFECC  lfs f12, -0x134(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF78: C16BFFE4  lfs f11, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABF7C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABF80: EC060028  fsubs f0, f6, f0
	ctx.f[0].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ABF84: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF88: D1ABFFCC  stfs f13, -0x34(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-52 as u32), tmp.u32 ) };
	// 821ABF8C: C1ABFED0  lfs f13, -0x130(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABF90: C18BFFCC  lfs f12, -0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF94: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821ABF98: D00BFFD0  stfs f0, -0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 821ABF9C: EDA96028  fsubs f13, f9, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABFA0: C18BFED4  lfs f12, -0x12c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-300 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABFA4: ED8B6024  fdivs f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABFA8: D18BFFD4  stfs f12, -0x2c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 821ABFAC: C16BFFD4  lfs f11, -0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABFB0: ED655828  fsubs f11, f5, f11
	ctx.f[11].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABFB4: C18BFEBC  lfs f12, -0x144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-324 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABFB8: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ABFBC: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABFC0: D1ABFFBC  stfs f13, -0x44(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-68 as u32), tmp.u32 ) };
	// 821ABFC4: C1ABFEC0  lfs f13, -0x140(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABFC8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821ABFCC: D00BFFC0  stfs f0, -0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	// 821ABFD0: C00BFEC4  lfs f0, -0x13c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABFD4: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 821ABFD8: D00BFFC4  stfs f0, -0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-60 as u32), tmp.u32 ) };
	// 821ABFDC: 396BFFC0  addi r11, r11, -0x40
	ctx.r[11].s64 = ctx.r[11].s64 + -64;
	// 821ABFE0: 409AFEE0  bne cr6, 0x821abec0
	if !ctx.cr[6].eq {
	pc = 0x821ABEC0; continue 'dispatch;
	}
	// 821ABFE4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821ABFE8: 40990068  ble cr6, 0x821ac050
	if !ctx.cr[6].gt {
	pc = 0x821AC050; continue 'dispatch;
	}
	// 821ABFEC: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABFF0: 394A0114  addi r10, r10, 0x114
	ctx.r[10].s64 = ctx.r[10].s64 + 276;
	// 821ABFF4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821ABFF8: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABFFC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821AC000: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC004: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AC008: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AC00C: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC010: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821AC014: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AC018: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AC01C: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AC020: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821AC024: C16BFEEC  lfs f11, -0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-276 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AC028: EC005824  fdivs f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 821AC02C: D00BFFEC  stfs f0, -0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 821AC030: C00BFEF0  lfs f0, -0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC034: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821AC038: D00BFFF0  stfs f0, -0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821AC03C: C00BFEF4  lfs f0, -0x10c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC040: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 821AC044: D00BFFF4  stfs f0, -0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AC048: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821AC04C: 4199FFAC  bgt cr6, 0x821abff8
	if ctx.cr[6].gt {
	pc = 0x821ABFF8; continue 'dispatch;
	}
	// 821AC050: 4838909C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AC058 size=556
    let mut pc: u32 = 0x821AC058;
    'dispatch: loop {
        match pc {
            0x821AC058 => {
    //   block [0x821AC058..0x821AC284)
	// 821AC058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC05C: 4838905D  bl 0x825350b8
	ctx.lr = 0x821AC060;
	sub_82535080(ctx, base);
	// 821AC060: 3946FFFF  addi r10, r6, -1
	ctx.r[10].s64 = ctx.r[6].s64 + -1;
	// 821AC064: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AC068: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821AC06C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AC070: 409901E4  ble cr6, 0x821ac254
	if !ctx.cr[6].gt {
	pc = 0x821AC254; continue 'dispatch;
	}
	// 821AC074: 3D20829E  lis r9, -0x7d62
	ctx.r[9].s64 = -2103574528;
	// 821AC078: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 821AC07C: 392920C0  addi r9, r9, 0x20c0
	ctx.r[9].s64 = ctx.r[9].s64 + 8384;
	// 821AC080: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 821AC084: 39290100  addi r9, r9, 0x100
	ctx.r[9].s64 = ctx.r[9].s64 + 256;
	// 821AC088: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821AC08C: 7FE54850  subf r31, r5, r9
	ctx.r[31].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 821AC090: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AC094: C16425B8  lfs f11, 0x25b8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(9656 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AC098: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 821AC09C: 7FAA4850  subf r29, r10, r9
	ctx.r[29].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821AC0A0: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821AC0A4: C1872068  lfs f12, 0x2068(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8296 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AC0A8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AC0AC: C1A9D5B0  lfs f13, -0x2a50(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC0B0: C14A1FF8  lfs f10, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AC0B4: 7D5F4214  add r10, r31, r8
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[8].u64;
	// 821AC0B8: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 821AC0BC: 38880010  addi r4, r8, 0x10
	ctx.r[4].s64 = ctx.r[8].s64 + 16;
	// 821AC0C0: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 821AC0C4: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AC288 size=344
    let mut pc: u32 = 0x821AC288;
    'dispatch: loop {
        match pc {
            0x821AC288 => {
    //   block [0x821AC288..0x821AC3E0)
	// 821AC288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC28C: 48388E15  bl 0x825350a0
	ctx.lr = 0x821AC290;
	sub_82535080(ctx, base);
	// 821AC290: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC294: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821AC298: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821AC29C: 7F8B1E70  srawi r11, r28, 3
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 3) as i64;
	// 821AC2A0: 3AE0000F  li r23, 0xf
	ctx.r[23].s64 = 15;
	// 821AC2A4: 7D4B0194  addze r10, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821AC2A8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821AC2AC: 555B063E  clrlwi r27, r10, 0x18
	ctx.r[27].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821AC2B0: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 821AC2B4: 3BEB63D0  addi r31, r11, 0x63d0
	ctx.r[31].s64 = ctx.r[11].s64 + 25552;
	// 821AC2B8: 7F8B1E70  srawi r11, r28, 3
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 3) as i64;
	// 821AC2BC: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 821AC2C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AC2C4: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821AC2C8: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 821AC2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC2D0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC2D4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AC2D8: 7D6BE050  subf r11, r11, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 821AC2DC: 557A063E  clrlwi r26, r11, 0x18
	ctx.r[26].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AC2E0: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 821AC2E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC2E8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821AC2EC: 48560F71  bl 0x8270d25c
	ctx.lr = 0x821AC2F0;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 821AC2F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AC2F4: 3F0082C0  lis r24, -0x7d40
	ctx.r[24].s64 = -2101346304;
	// 821AC2F8: 3B2B0EE8  addi r25, r11, 0xee8
	ctx.r[25].s64 = ctx.r[11].s64 + 3816;
	// 821AC2FC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821AC300: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 821AC304: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821AC308: 8098B9F8  lwz r4, -0x4608(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-17928 as u32) ) } as u64;
	// 821AC30C: 48049C55  bl 0x821f5f60
	ctx.lr = 0x821AC310;
	sub_821F5F60(ctx, base);
	// 821AC310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC314: 48560F59  bl 0x8270d26c
	ctx.lr = 0x821AC318;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821AC318: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821AC31C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC320: 419A00A8  beq cr6, 0x821ac3c8
	if ctx.cr[6].eq {
	pc = 0x821AC3C8; continue 'dispatch;
	}
	// 821AC324: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC328: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AC32C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AC330: 4E800421  bctrl
	ctx.lr = 0x821AC334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC334: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821AC338: 41980090  blt cr6, 0x821ac3c8
	if ctx.cr[6].lt {
	pc = 0x821AC3C8; continue 'dispatch;
	}
	// 821AC33C: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 821AC340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC344: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 821AC348: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 821AC34C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC350: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 821AC354: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821AC358: 48560F05  bl 0x8270d25c
	ctx.lr = 0x821AC35C;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 821AC35C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821AC360: 8098B9F8  lwz r4, -0x4608(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-17928 as u32) ) } as u64;
	// 821AC364: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 821AC368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AC36C: 48049BF5  bl 0x821f5f60
	ctx.lr = 0x821AC370;
	sub_821F5F60(ctx, base);
	// 821AC370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC374: 48560EF9  bl 0x8270d26c
	ctx.lr = 0x821AC378;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821AC378: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC37C: 397D0008  addi r11, r29, 8
	ctx.r[11].s64 = ctx.r[29].s64 + 8;
	// 821AC380: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821AC384: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC388: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC38C: 7CABF214  add r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AC390: 814A0034  lwz r10, 0x34(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AC394: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AC398: 4E800421  bctrl
	ctx.lr = 0x821AC39C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC39C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AC3A0: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AC3A4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AC3A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC3AC: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AC3B0: 7D6AF12A  stdx r11, r10, r30
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u64) };
	// 821AC3B4: 419A0008  beq cr6, 0x821ac3bc
	if ctx.cr[6].eq {
	pc = 0x821AC3BC; continue 'dispatch;
	}
	// 821AC3B8: 4BF70CA1  bl 0x8211d058
	ctx.lr = 0x821AC3BC;
	sub_8211D058(ctx, base);
	// 821AC3BC: 397D0060  addi r11, r29, 0x60
	ctx.r[11].s64 = ctx.r[29].s64 + 96;
	// 821AC3C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC3C4: 7F8BF12E  stwx r28, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[28].u32) };
	// 821AC3C8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821AC3CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC3D0: 419A0008  beq cr6, 0x821ac3d8
	if ctx.cr[6].eq {
	pc = 0x821AC3D8; continue 'dispatch;
	}
	// 821AC3D4: 4BF70C85  bl 0x8211d058
	ctx.lr = 0x821AC3D8;
	sub_8211D058(ctx, base);
	// 821AC3D8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821AC3DC: 48388D14  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC3E0 size=88
    let mut pc: u32 = 0x821AC3E0;
    'dispatch: loop {
        match pc {
            0x821AC3E0 => {
    //   block [0x821AC3E0..0x821AC438)
	// 821AC3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC3E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AC3E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AC3EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC3F0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AC3F4: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AC3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC3FC: 4800003D  bl 0x821ac438
	ctx.lr = 0x821AC400;
	sub_821AC438(ctx, base);
	// 821AC400: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 821AC404: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AC408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC40C: 419A0018  beq cr6, 0x821ac424
	if ctx.cr[6].eq {
	pc = 0x821AC424; continue 'dispatch;
	}
	// 821AC410: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC414: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821AC418: 409A000C  bne cr6, 0x821ac424
	if !ctx.cr[6].eq {
	pc = 0x821AC424; continue 'dispatch;
	}
	// 821AC41C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AC420: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821AC424: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AC428: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AC42C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AC430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AC434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC438 size=96
    let mut pc: u32 = 0x821AC438;
    'dispatch: loop {
        match pc {
            0x821AC438 => {
    //   block [0x821AC438..0x821AC498)
	// 821AC438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AC440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AC444: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AC44C: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AC450: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AC454: 409A0030  bne cr6, 0x821ac484
	if !ctx.cr[6].eq {
	pc = 0x821AC484; continue 'dispatch;
	}
	// 821AC458: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AC45C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC460: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AC464: 409A0020  bne cr6, 0x821ac484
	if !ctx.cr[6].eq {
	pc = 0x821AC484; continue 'dispatch;
	}
	// 821AC468: E97F00D0  ld r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	// 821AC46C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 821AC470: 419A0014  beq cr6, 0x821ac484
	if ctx.cr[6].eq {
	pc = 0x821AC484; continue 'dispatch;
	}
	// 821AC474: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AC478: 481CC861  bl 0x82378cd8
	ctx.lr = 0x821AC47C;
	sub_82378CD8(ctx, base);
	// 821AC47C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AC480: F97F00D0  std r11, 0xd0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 821AC484: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AC488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AC48C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AC490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AC494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AC498 size=824
    let mut pc: u32 = 0x821AC498;
    'dispatch: loop {
        match pc {
            0x821AC498 => {
    //   block [0x821AC498..0x821AC7D0)
	// 821AC498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC49C: 48388BFD  bl 0x82535098
	ctx.lr = 0x821AC4A0;
	sub_82535080(ctx, base);
	// 821AC4A0: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 821AC4A4: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 821AC4A8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC4AC: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 821AC4B0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821AC4B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AC4B8: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 821AC4BC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AC4C0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821AC4C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AC4C8: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 821AC4CC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC4D0: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 821AC4D4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AC4D8: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 821AC4DC: 3D4B0006  addis r10, r11, 6
	ctx.r[10].s64 = ctx.r[11].s64 + 393216;
	// 821AC4E0: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 821AC4E4: 394AA580  addi r10, r10, -0x5a80
	ctx.r[10].s64 = ctx.r[10].s64 + -23168;
	// 821AC4E8: 3A800005  li r20, 5
	ctx.r[20].s64 = 5;
	// 821AC4EC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821AC4F0: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 821AC4F4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC4F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC4FC: 419A0088  beq cr6, 0x821ac584
	if ctx.cr[6].eq {
	pc = 0x821AC584; continue 'dispatch;
	}
	// 821AC500: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC504: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC508: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC50C: 409A0078  bne cr6, 0x821ac584
	if !ctx.cr[6].eq {
	pc = 0x821AC584; continue 'dispatch;
	}
	// 821AC510: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821AC514: E97D0110  ld r11, 0x110(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(272 as u32) ) };
	// 821AC518: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AC51C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AC520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC524: 419A003C  beq cr6, 0x821ac560
	if ctx.cr[6].eq {
	pc = 0x821AC560; continue 'dispatch;
	}
	// 821AC528: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC52C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC530: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AC534: 409A002C  bne cr6, 0x821ac560
	if !ctx.cr[6].eq {
	pc = 0x821AC560; continue 'dispatch;
	}
	// 821AC538: 574A06B4  rlwinm r10, r26, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 821AC53C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AC540: 409A0070  bne cr6, 0x821ac5b0
	if !ctx.cr[6].eq {
	pc = 0x821AC5B0; continue 'dispatch;
	}
	// 821AC544: A14B0014  lhz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AC548: 9A8B0019  stb r20, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[20].u8 ) };
	// 821AC54C: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 821AC550: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821AC554: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821AC558: FABD0110  std r21, 0x110(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), ctx.r[21].u64 ) };
	// 821AC55C: 48000054  b 0x821ac5b0
	pc = 0x821AC5B0; continue 'dispatch;
	// 821AC560: E97D0118  ld r11, 0x118(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(280 as u32) ) };
	// 821AC564: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AC568: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AC56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC570: 419A0014  beq cr6, 0x821ac584
	if ctx.cr[6].eq {
	pc = 0x821AC584; continue 'dispatch;
	}
	// 821AC574: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC578: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC57C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC580: 419A0030  beq cr6, 0x821ac5b0
	if ctx.cr[6].eq {
	pc = 0x821AC5B0; continue 'dispatch;
	}
	// 821AC584: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821AC588: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821AC58C: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 821AC590: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821AC594: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 821AC598: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AC59C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AC5A0: 48002401  bl 0x821ae9a0
	ctx.lr = 0x821AC5A4;
	sub_821AE9A0(ctx, base);
	// 821AC5A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC5A8: 419A0100  beq cr6, 0x821ac6a8
	if ctx.cr[6].eq {
	pc = 0x821AC6A8; continue 'dispatch;
	}
	// 821AC5AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821AC5B0: E97D0118  ld r11, 0x118(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(280 as u32) ) };
	// 821AC5B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AC5B8: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AC5BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AC5C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AC5C4: 419A0014  beq cr6, 0x821ac5d8
	if ctx.cr[6].eq {
	pc = 0x821AC5D8; continue 'dispatch;
	}
	// 821AC5C8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC5CC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AC5D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC5D4: 419A01C4  beq cr6, 0x821ac798
	if ctx.cr[6].eq {
	pc = 0x821AC798; continue 'dispatch;
	}
	// 821AC5D8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AC5DC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821AC5E0: 38EB0F18  addi r7, r11, 0xf18
	ctx.r[7].s64 = ctx.r[11].s64 + 3864;
	// 821AC5E4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 821AC5E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821AC5EC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 821AC5F0: 481BDEA1  bl 0x8236a490
	ctx.lr = 0x821AC5F4;
	sub_8236A490(ctx, base);
	// 821AC5F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AC5F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AC5FC: 419A000C  beq cr6, 0x821ac608
	if ctx.cr[6].eq {
	pc = 0x821AC608; continue 'dispatch;
	}
	// 821AC600: 839F0030  lwz r28, 0x30(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC604: 48000008  b 0x821ac60c
	pc = 0x821AC60C; continue 'dispatch;
	// 821AC608: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 821AC60C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821AC610: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AC614: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AC618: 419A0090  beq cr6, 0x821ac6a8
	if ctx.cr[6].eq {
	pc = 0x821AC6A8; continue 'dispatch;
	}
	// 821AC61C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AC620: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AC624: 396B0F20  addi r11, r11, 0xf20
	ctx.r[11].s64 = ctx.r[11].s64 + 3872;
	// 821AC628: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AC62C: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821AC630: 3908D9D8  addi r8, r8, -0x2628
	ctx.r[8].s64 = ctx.r[8].s64 + -9768;
	// 821AC634: 3929C7D0  addi r9, r9, -0x3830
	ctx.r[9].s64 = ctx.r[9].s64 + -14384;
	// 821AC638: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AC63C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AC640: 92BF0080  stw r21, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[21].u32 ) };
	// 821AC644: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821AC648: B2BF0084  sth r21, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[21].u16 ) };
	// 821AC64C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AC650: B2BF0086  sth r21, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[21].u16 ) };
	// 821AC654: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821AC658: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821AC65C: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821AC660: 388056A0  li r4, 0x56a0
	ctx.r[4].s64 = 22176;
	// 821AC664: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821AC668: 394AC878  addi r10, r10, -0x3788
	ctx.r[10].s64 = ctx.r[10].s64 + -14216;
	// 821AC66C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821AC670: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AC674: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821AC678: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AC67C: 4BFF55B5  bl 0x821a1c30
	ctx.lr = 0x821AC680;
	sub_821A1C30(ctx, base);
	// 821AC680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC684: 409A0038  bne cr6, 0x821ac6bc
	if !ctx.cr[6].eq {
	pc = 0x821AC6BC; continue 'dispatch;
	}
	// 821AC688: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC68C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821AC690: 409A0018  bne cr6, 0x821ac6a8
	if !ctx.cr[6].eq {
	pc = 0x821AC6A8; continue 'dispatch;
	}
	// 821AC694: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AC698: 9A9F0019  stb r20, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[20].u8 ) };
	// 821AC69C: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 821AC6A0: 9B7F0025  stb r27, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821AC6A4: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 821AC6A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AC6AC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AC6B0: CBC1FF88  lfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AC6B4: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 821AC6B8: 48388A30  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
	// 821AC6BC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AC6C0: 574A06B4  rlwinm r10, r26, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 821AC6C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AC6C8: F97D0118  std r11, 0x118(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(280 as u32), ctx.r[11].u64 ) };
	// 821AC6CC: 409A0008  bne cr6, 0x821ac6d4
	if !ctx.cr[6].eq {
	pc = 0x821AC6D4; continue 'dispatch;
	}
	// 821AC6D0: FABD0110  std r21, 0x110(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), ctx.r[21].u64 ) };
	// 821AC6D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821AC6D8: 419A0030  beq cr6, 0x821ac708
	if ctx.cr[6].eq {
	pc = 0x821AC708; continue 'dispatch;
	}
	// 821AC6DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC6E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC6E4: 419A001C  beq cr6, 0x821ac700
	if ctx.cr[6].eq {
	pc = 0x821AC700; continue 'dispatch;
	}
	// 821AC6E8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC6EC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC6F0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AC6F4: 409A000C  bne cr6, 0x821ac700
	if !ctx.cr[6].eq {
	pc = 0x821AC700; continue 'dispatch;
	}
	// 821AC6F8: A16B0016  lhz r11, 0x16(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 821AC6FC: 48000008  b 0x821ac704
	pc = 0x821AC704; continue 'dispatch;
	// 821AC700: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 821AC704: B17F0016  sth r11, 0x16(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[11].u16 ) };
	// 821AC708: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AC70C: D3FF00D8  stfs f31, 0xd8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 821AC710: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AC714: 813F00CC  lwz r9, 0xcc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AC718: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821AC71C: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821AC720: 38C00022  li r6, 0x22
	ctx.r[6].s64 = 34;
	// 821AC724: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC728: 81410144  lwz r10, 0x144(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 821AC72C: 396B160C  addi r11, r11, 0x160c
	ctx.r[11].s64 = ctx.r[11].s64 + 5644;
	// 821AC730: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AC734: 911F00A8  stw r8, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821AC738: 90FF00A4  stw r7, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821AC73C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 821AC740: 90DF0094  stw r6, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[6].u32 ) };
	// 821AC744: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821AC748: 3940018C  li r10, 0x18c
	ctx.r[10].s64 = 396;
	// 821AC74C: 7D65582E  lwzx r11, r5, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AC750: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821AC754: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821AC758: 909F00A0  stw r4, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 821AC75C: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821AC760: C1A8BA38  lfs f13, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC764: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AC768: 39690024  addi r11, r9, 0x24
	ctx.r[11].s64 = ctx.r[9].s64 + 36;
	// 821AC76C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821AC770: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC774: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821AC778: D1ABFFE8  stfs f13, -0x18(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 821AC77C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AC780: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AC784: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AC788: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821AC78C: 4199FFE8  bgt cr6, 0x821ac774
	if ctx.cr[6].gt {
	pc = 0x821AC774; continue 'dispatch;
	}
	// 821AC790: 92BF00D0  stw r21, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[21].u32 ) };
	// 821AC794: 48000008  b 0x821ac79c
	pc = 0x821AC79C; continue 'dispatch;
	// 821AC798: D3FF00D8  stfs f31, 0xd8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 821AC79C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821AC7A0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821AC7A4: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 821AC7A8: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 821AC7AC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AC7B0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821AC7B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AC7B8: 480028B1  bl 0x821af068
	ctx.lr = 0x821AC7BC;
	sub_821AF068(ctx, base);
	// 821AC7BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC7C0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AC7C4: CBC1FF88  lfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AC7C8: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 821AC7CC: 4838891C  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AC7D0 size=164
    let mut pc: u32 = 0x821AC7D0;
    'dispatch: loop {
        match pc {
            0x821AC7D0 => {
    //   block [0x821AC7D0..0x821AC874)
	// 821AC7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC7D4: 483888E5  bl 0x825350b8
	ctx.lr = 0x821AC7D8;
	sub_82535080(ctx, base);
	// 821AC7D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC7DC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AC7E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AC7E4: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AC7E8: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AC7EC: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821AC7F0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AC7F4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AC7F8: 419A0070  beq cr6, 0x821ac868
	if ctx.cr[6].eq {
	pc = 0x821AC868; continue 'dispatch;
	}
	// 821AC7FC: 83BF00D0  lwz r29, 0xd0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 821AC800: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821AC804: 40990060  ble cr6, 0x821ac864
	if !ctx.cr[6].gt {
	pc = 0x821AC864; continue 'dispatch;
	}
	// 821AC808: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821AC80C: 839F00CC  lwz r28, 0xcc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AC810: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821AC814: C03F00D8  lfs f1, 0xd8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AC818: 3BCB22C0  addi r30, r11, 0x22c0
	ctx.r[30].s64 = ctx.r[11].s64 + 8896;
	// 821AC81C: 38BC4A40  addi r5, r28, 0x4a40
	ctx.r[5].s64 = ctx.r[28].s64 + 19008;
	// 821AC820: 38DE18C0  addi r6, r30, 0x18c0
	ctx.r[6].s64 = ctx.r[30].s64 + 6336;
	// 821AC824: 389E0C60  addi r4, r30, 0xc60
	ctx.r[4].s64 = ctx.r[30].s64 + 3168;
	// 821AC828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AC82C: 480000AD  bl 0x821ac8d8
	ctx.lr = 0x821AC830;
	sub_821AC8D8(ctx, base);
	// 821AC830: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC834: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AC838: C03F00DC  lfs f1, 0xdc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AC83C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821AC840: 80FF00D4  lwz r7, 0xd4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 821AC844: 38BE0C60  addi r5, r30, 0xc60
	ctx.r[5].s64 = ctx.r[30].s64 + 3168;
	// 821AC848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AC84C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AC850: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821AC854: 48001245  bl 0x821ada98
	ctx.lr = 0x821AC858;
	sub_821ADA98(ctx, base);
	// 821AC858: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AC85C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AC860: 483888A8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821AC864: 915F00C4  stw r10, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 821AC868: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AC86C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AC870: 48388898  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC878 size=92
    let mut pc: u32 = 0x821AC878;
    'dispatch: loop {
        match pc {
            0x821AC878 => {
    //   block [0x821AC878..0x821AC8D4)
	// 821AC878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AC880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AC884: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC888: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AC88C: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AC890: 389F00CC  addi r4, r31, 0xcc
	ctx.r[4].s64 = ctx.r[31].s64 + 204;
	// 821AC894: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AC898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC89C: 419A0014  beq cr6, 0x821ac8b0
	if ctx.cr[6].eq {
	pc = 0x821AC8B0; continue 'dispatch;
	}
	// 821AC8A0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AC8A4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AC8A8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AC8AC: 4BFF57D5  bl 0x821a2080
	ctx.lr = 0x821AC8B0;
	sub_821A2080(ctx, base);
	// 821AC8B0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AC8B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AC8B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AC8BC: F94B0118  std r10, 0x118(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), ctx.r[10].u64 ) };
	// 821AC8C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AC8C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AC8C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AC8CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AC8D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC8D8 size=1092
    let mut pc: u32 = 0x821AC8D8;
    'dispatch: loop {
        match pc {
            0x821AC8D8 => {
    //   block [0x821AC8D8..0x821ACD1C)
	// 821AC8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC8DC: 483887D9  bl 0x825350b4
	ctx.lr = 0x821AC8E0;
	sub_82535080(ctx, base);
	// 821AC8E0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821AC8E4: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC8E8: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 821AC8EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821AC8F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AC8F4: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 821AC8F8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821AC8FC: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821AC900: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC908: 419A0014  beq cr6, 0x821ac91c
	if ctx.cr[6].eq {
	pc = 0x821AC91C; continue 'dispatch;
	}
	// 821AC90C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC910: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC914: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC918: 419A0008  beq cr6, 0x821ac920
	if ctx.cr[6].eq {
	pc = 0x821AC920; continue 'dispatch;
	}
	// 821AC91C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AC920: 392B0090  addi r9, r11, 0x90
	ctx.r[9].s64 = ctx.r[11].s64 + 144;
	// 821AC924: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821AC928: 4099005C  ble cr6, 0x821ac984
	if !ctx.cr[6].gt {
	pc = 0x821AC984; continue 'dispatch;
	}
	// 821AC92C: 39090030  addi r8, r9, 0x30
	ctx.r[8].s64 = ctx.r[9].s64 + 48;
	// 821AC930: 38E90010  addi r7, r9, 0x10
	ctx.r[7].s64 = ctx.r[9].s64 + 16;
	// 821AC934: 38C90020  addi r6, r9, 0x20
	ctx.r[6].s64 = ctx.r[9].s64 + 32;
	// 821AC938: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821AC93C: 7CBB2850  subf r5, r27, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[27].s64;
	// 821AC940: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ACD20 size=244
    let mut pc: u32 = 0x821ACD20;
    'dispatch: loop {
        match pc {
            0x821ACD20 => {
    //   block [0x821ACD20..0x821ACE14)
	// 821ACD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ACD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ACD28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821ACD2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ACD30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ACD34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ACD38: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821ACD3C: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821ACD40: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821ACD44: 612993F0  ori r9, r9, 0x93f0
	ctx.r[9].u64 = ctx.r[9].u64 | 37872;
	// 821ACD48: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ACD4C: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821ACD50: 808A0080  lwz r4, 0x80(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821ACD54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACD58: 419A003C  beq cr6, 0x821acd94
	if ctx.cr[6].eq {
	pc = 0x821ACD94; continue 'dispatch;
	}
	// 821ACD5C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ACD60: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 821ACD64: 3BCBB460  addi r30, r11, -0x4ba0
	ctx.r[30].s64 = ctx.r[11].s64 + -19360;
	// 821ACD68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821ACD6C: 48193B1D  bl 0x82340888
	ctx.lr = 0x821ACD70;
	sub_82340888(ctx, base);
	// 821ACD70: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821ACD74: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821ACD78: 419A0064  beq cr6, 0x821acddc
	if ctx.cr[6].eq {
	pc = 0x821ACDDC; continue 'dispatch;
	}
	// 821ACD7C: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 821ACD80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821ACD84: 48193B05  bl 0x82340888
	ctx.lr = 0x821ACD88;
	sub_82340888(ctx, base);
	// 821ACD88: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821ACD8C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821ACD90: 419A004C  beq cr6, 0x821acddc
	if ctx.cr[6].eq {
	pc = 0x821ACDDC; continue 'dispatch;
	}
	// 821ACD94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821ACD98: 419A0064  beq cr6, 0x821acdfc
	if ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	// 821ACD9C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACDA0: 616B9C00  ori r11, r11, 0x9c00
	ctx.r[11].u64 = ctx.r[11].u64 | 39936;
	// 821ACDA4: 7D64582E  lwzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACDA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACDAC: 419A0050  beq cr6, 0x821acdfc
	if ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	// 821ACDB0: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ACDB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACDB8: 419A0044  beq cr6, 0x821acdfc
	if ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	// 821ACDBC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACDC0: 616BEB2B  ori r11, r11, 0xeb2b
	ctx.r[11].u64 = ctx.r[11].u64 | 60203;
	// 821ACDC4: 7D6458AE  lbzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACDCC: 409A0030  bne cr6, 0x821acdfc
	if !ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	// 821ACDD0: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821ACDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACDD8: 419A0024  beq cr6, 0x821acdfc
	if ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	// 821ACDDC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821ACDE0: 80DF00CC  lwz r6, 0xcc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821ACDE4: 38BF0090  addi r5, r31, 0x90
	ctx.r[5].s64 = ctx.r[31].s64 + 144;
	// 821ACDE8: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821ACDEC: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821ACDF0: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 821ACDF4: 38EB00E0  addi r7, r11, 0xe0
	ctx.r[7].s64 = ctx.r[11].s64 + 224;
	// 821ACDF8: 481C0B11  bl 0x8236d908
	ctx.lr = 0x821ACDFC;
	sub_8236D908(ctx, base);
	// 821ACDFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821ACE00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ACE04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ACE08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821ACE0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ACE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ACE18 size=2104
    let mut pc: u32 = 0x821ACE18;
    'dispatch: loop {
        match pc {
            0x821ACE18 => {
    //   block [0x821ACE18..0x821ACFD0)
	// 821ACE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ACE1C: 4838826D  bl 0x82535088
	ctx.lr = 0x821ACE20;
	sub_82535080(ctx, base);
	// 821ACE20: DBC1FF68  stfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 821ACE24: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 821ACE28: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ACE2C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACE30: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821ACE34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821ACE38: 616ABEB8  ori r10, r11, 0xbeb8
	ctx.r[10].u64 = ctx.r[11].u64 | 48824;
	// 821ACE3C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821ACE40: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821ACE44: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821ACE48: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 821ACE4C: 7E1C522E  lhzx r16, r28, r10
	ctx.r[16].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821ACE50: 7D134378  mr r19, r8
	ctx.r[19].u64 = ctx.r[8].u64;
	// 821ACE54: C3CB24D0  lfs f30, 0x24d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9424 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821ACE58: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 821ACE5C: 2B100027  cmplwi cr6, r16, 0x27
	ctx.cr[6].compare_u32(ctx.r[16].u32, 39 as u32, &mut ctx.xer);
	// 821ACE60: 419A000C  beq cr6, 0x821ace6c
	if ctx.cr[6].eq {
	pc = 0x821ACE6C; continue 'dispatch;
	}
	// 821ACE64: 2B100026  cmplwi cr6, r16, 0x26
	ctx.cr[6].compare_u32(ctx.r[16].u32, 38 as u32, &mut ctx.xer);
	// 821ACE68: 409A0014  bne cr6, 0x821ace7c
	if !ctx.cr[6].eq {
	pc = 0x821ACE7C; continue 'dispatch;
	}
	// 821ACE6C: 7CEB0734  extsh r11, r7
	ctx.r[11].s64 = ctx.r[7].s16 as i64;
	// 821ACE70: 3AA00005  li r21, 5
	ctx.r[21].s64 = 5;
	// 821ACE74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ACE78: 419A0008  beq cr6, 0x821ace80
	if ctx.cr[6].eq {
	pc = 0x821ACE80; continue 'dispatch;
	}
	// 821ACE7C: 82A1016C  lwz r21, 0x16c(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) } as u64;
	// 821ACE80: 7F110734  extsh r17, r24
	ctx.r[17].s64 = ctx.r[24].s16 as i64;
	// 821ACE84: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACE88: 2F110001  cmpwi cr6, r17, 1
	ctx.cr[6].compare_i32(ctx.r[17].s32, 1, &mut ctx.xer);
	// 821ACE8C: 6172BEBC  ori r18, r11, 0xbebc
	ctx.r[18].u64 = ctx.r[11].u64 | 48828;
	// 821ACE90: 409A0020  bne cr6, 0x821aceb0
	if !ctx.cr[6].eq {
	pc = 0x821ACEB0; continue 'dispatch;
	}
	// 821ACE94: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821ACE98: 7D5C922E  lhzx r10, r28, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821ACE9C: 396B5720  addi r11, r11, 0x5720
	ctx.r[11].s64 = ctx.r[11].s64 + 22304;
	// 821ACEA0: 7D6A58AE  lbzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACEA4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821ACEA8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821ACEAC: 41980444  blt cr6, 0x821ad2f0
	if ctx.cr[6].lt {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	// 821ACEB0: 7E6B0734  extsh r11, r19
	ctx.r[11].s64 = ctx.r[19].s16 as i64;
	// 821ACEB4: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 821ACEB8: 409A0078  bne cr6, 0x821acf30
	if !ctx.cr[6].eq {
	pc = 0x821ACF30; continue 'dispatch;
	}
	// 821ACEBC: 7D7C922E  lhzx r11, r28, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821ACEC0: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 821ACEC4: 409A0014  bne cr6, 0x821aced8
	if !ctx.cr[6].eq {
	pc = 0x821ACED8; continue 'dispatch;
	}
	// 821ACEC8: 2F110002  cmpwi cr6, r17, 2
	ctx.cr[6].compare_i32(ctx.r[17].s32, 2, &mut ctx.xer);
	// 821ACECC: 409A000C  bne cr6, 0x821aced8
	if !ctx.cr[6].eq {
	pc = 0x821ACED8; continue 'dispatch;
	}
	// 821ACED0: 3A600100  li r19, 0x100
	ctx.r[19].s64 = 256;
	// 821ACED4: 4800005C  b 0x821acf30
	pc = 0x821ACF30; continue 'dispatch;
	// 821ACED8: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 821ACEDC: 409A0030  bne cr6, 0x821acf0c
	if !ctx.cr[6].eq {
	pc = 0x821ACF0C; continue 'dispatch;
	}
	// 821ACEE0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACEE4: 616BED6A  ori r11, r11, 0xed6a
	ctx.r[11].u64 = ctx.r[11].u64 | 60778;
	// 821ACEE8: 7D7C5A2E  lhzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACEEC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821ACEF0: 419A0014  beq cr6, 0x821acf04
	if ctx.cr[6].eq {
	pc = 0x821ACF04; continue 'dispatch;
	}
	// 821ACEF4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821ACEF8: 409A0038  bne cr6, 0x821acf30
	if !ctx.cr[6].eq {
	pc = 0x821ACF30; continue 'dispatch;
	}
	// 821ACEFC: 3A600102  li r19, 0x102
	ctx.r[19].s64 = 258;
	// 821ACF00: 48000030  b 0x821acf30
	pc = 0x821ACF30; continue 'dispatch;
	// 821ACF04: 3A600101  li r19, 0x101
	ctx.r[19].s64 = 257;
	// 821ACF08: 48000028  b 0x821acf30
	pc = 0x821ACF30; continue 'dispatch;
	// 821ACF0C: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 821ACF10: 409A0020  bne cr6, 0x821acf30
	if !ctx.cr[6].eq {
	pc = 0x821ACF30; continue 'dispatch;
	}
	// 821ACF14: 2F110001  cmpwi cr6, r17, 1
	ctx.cr[6].compare_i32(ctx.r[17].s32, 1, &mut ctx.xer);
	// 821ACF18: 41980018  blt cr6, 0x821acf30
	if ctx.cr[6].lt {
	pc = 0x821ACF30; continue 'dispatch;
	}
	// 821ACF1C: 3971FFFF  addi r11, r17, -1
	ctx.r[11].s64 = ctx.r[17].s64 + -1;
	// 821ACF20: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821ACF24: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821ACF28: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 821ACF2C: 3A6B0103  addi r19, r11, 0x103
	ctx.r[19].s64 = ctx.r[11].s64 + 259;
	// 821ACF30: 7CF40734  extsh r20, r7
	ctx.r[20].s64 = ctx.r[7].s16 as i64;
	// 821ACF34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821ACF38: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 821ACF3C: 419A0014  beq cr6, 0x821acf50
	if ctx.cr[6].eq {
	pc = 0x821ACF50; continue 'dispatch;
	}
	// 821ACF40: 2F14FFFF  cmpwi cr6, r20, -1
	ctx.cr[6].compare_i32(ctx.r[20].s32, -1, &mut ctx.xer);
	// 821ACF44: 419A000C  beq cr6, 0x821acf50
	if ctx.cr[6].eq {
	pc = 0x821ACF50; continue 'dispatch;
	}
	// 821ACF48: 2F140001  cmpwi cr6, r20, 1
	ctx.cr[6].compare_i32(ctx.r[20].s32, 1, &mut ctx.xer);
	// 821ACF4C: 409A01EC  bne cr6, 0x821ad138
	if !ctx.cr[6].eq {
	pc = 0x821AD138; continue 'dispatch;
	}
	// 821ACF50: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACF54: 616BE2D4  ori r11, r11, 0xe2d4
	ctx.r[11].u64 = ctx.r[11].u64 | 58068;
	// 821ACF58: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACF5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACF60: 419A0080  beq cr6, 0x821acfe0
	if ctx.cr[6].eq {
	pc = 0x821ACFE0; continue 'dispatch;
	}
	// 821ACF64: A16B0034  lhz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821ACF68: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821ACF6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ACF70: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 821ACF74: 4199006C  bgt cr6, 0x821acfe0
	if ctx.cr[6].gt {
	pc = 0x821ACFE0; continue 'dispatch;
	}
	// 821ACF78: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821ACF7C: 398CCF90  addi r12, r12, -0x3070
	ctx.r[12].s64 = ctx.r[12].s64 + -12400;
	// 821ACF80: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821ACF84: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821ACF88: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821ACF8C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821ACFD0; continue 'dispatch;
		},
		1 => {
	pc = 0x821ACFD0; continue 'dispatch;
		},
		2 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		3 => {
	pc = 0x821ACFD8; continue 'dispatch;
		},
		4 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		5 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		6 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		7 => {
	pc = 0x821ACFD8; continue 'dispatch;
		},
		8 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		9 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		10 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		11 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		12 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		13 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		14 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		15 => {
	pc = 0x821ACFD8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821ACF90: 821ACFD0  lwz r16, -0x3030(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12336 as u32) ) } as u64;
	// 821ACF94: 821ACFD0  lwz r16, -0x3030(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12336 as u32) ) } as u64;
	// 821ACF98: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACF9C: 821ACFD8  lwz r16, -0x3028(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12328 as u32) ) } as u64;
	// 821ACFA0: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFA4: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFA8: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFAC: 821ACFD8  lwz r16, -0x3028(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12328 as u32) ) } as u64;
	// 821ACFB0: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFB4: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFB8: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFBC: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFC0: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFC4: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFC8: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFCC: 821ACFD8  lwz r16, -0x3028(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12328 as u32) ) } as u64;
            }
            0x821ACFD0 => {
    //   block [0x821ACFD0..0x821ACFD8)
	// 821ACFD0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 821ACFD4: 48000010  b 0x821acfe4
	pc = 0x821ACFE4; continue 'dispatch;
            }
            0x821ACFD8 => {
    //   block [0x821ACFD8..0x821ACFE0)
	// 821ACFD8: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 821ACFDC: 48000008  b 0x821acfe4
	pc = 0x821ACFE4; continue 'dispatch;
            }
            0x821ACFE0 => {
    //   block [0x821ACFE0..0x821AD2B8)
	// 821ACFE0: 7FB9EB78  mr r25, r29
	ctx.r[25].u64 = ctx.r[29].u64;
	// 821ACFE4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821ACFE8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821ACFEC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821ACFF0: 614A93F0  ori r10, r10, 0x93f0
	ctx.r[10].u64 = ctx.r[10].u64 | 37872;
	// 821ACFF4: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821ACFF8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ACFFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD000: 3B6BB460  addi r27, r11, -0x4ba0
	ctx.r[27].s64 = ctx.r[11].s64 + -19360;
	// 821AD004: 419A0024  beq cr6, 0x821ad028
	if ctx.cr[6].eq {
	pc = 0x821AD028; continue 'dispatch;
	}
	// 821AD008: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 821AD00C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AD010: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AD014: 48193875  bl 0x82340888
	ctx.lr = 0x821AD018;
	sub_82340888(ctx, base);
	// 821AD018: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821AD01C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821AD020: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821AD024: 419A0008  beq cr6, 0x821ad02c
	if ctx.cr[6].eq {
	pc = 0x821AD02C; continue 'dispatch;
	}
	// 821AD028: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 821AD02C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD030: 419A0024  beq cr6, 0x821ad054
	if ctx.cr[6].eq {
	pc = 0x821AD054; continue 'dispatch;
	}
	// 821AD034: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 821AD038: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AD03C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AD040: 48193849  bl 0x82340888
	ctx.lr = 0x821AD044;
	sub_82340888(ctx, base);
	// 821AD044: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821AD048: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821AD04C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD050: 419A0008  beq cr6, 0x821ad058
	if ctx.cr[6].eq {
	pc = 0x821AD058; continue 'dispatch;
	}
	// 821AD054: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821AD058: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821AD05C: 409A0014  bne cr6, 0x821ad070
	if !ctx.cr[6].eq {
	pc = 0x821AD070; continue 'dispatch;
	}
	// 821AD060: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD064: 409A001C  bne cr6, 0x821ad080
	if !ctx.cr[6].eq {
	pc = 0x821AD080; continue 'dispatch;
	}
	// 821AD068: 63DE0020  ori r30, r30, 0x20
	ctx.r[30].u64 = ctx.r[30].u64 | 32;
	// 821AD06C: 4800003C  b 0x821ad0a8
	pc = 0x821AD0A8; continue 'dispatch;
	// 821AD070: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 821AD074: 419A0014  beq cr6, 0x821ad088
	if ctx.cr[6].eq {
	pc = 0x821AD088; continue 'dispatch;
	}
	// 821AD078: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD07C: 419A0020  beq cr6, 0x821ad09c
	if ctx.cr[6].eq {
	pc = 0x821AD09C; continue 'dispatch;
	}
	// 821AD080: 2F190002  cmpwi cr6, r25, 2
	ctx.cr[6].compare_i32(ctx.r[25].s32, 2, &mut ctx.xer);
	// 821AD084: 409A0018  bne cr6, 0x821ad09c
	if !ctx.cr[6].eq {
	pc = 0x821AD09C; continue 'dispatch;
	}
	// 821AD088: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD08C: 63DE0060  ori r30, r30, 0x60
	ctx.r[30].u64 = ctx.r[30].u64 | 96;
	// 821AD090: 3A6000C2  li r19, 0xc2
	ctx.r[19].s64 = 194;
	// 821AD094: C3CB240C  lfs f30, 0x240c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9228 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821AD098: 48000010  b 0x821ad0a8
	pc = 0x821AD0A8; continue 'dispatch;
	// 821AD09C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD0A0: C00B20C8  lfs f0, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AD0A4: EFFF0032  fmuls f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AD0A8: 7D7C922E  lhzx r11, r28, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821AD0AC: 2B0B002B  cmplwi cr6, r11, 0x2b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 43 as u32, &mut ctx.xer);
	// 821AD0B0: 419A0014  beq cr6, 0x821ad0c4
	if ctx.cr[6].eq {
	pc = 0x821AD0C4; continue 'dispatch;
	}
	// 821AD0B4: 2B0B002A  cmplwi cr6, r11, 0x2a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 42 as u32, &mut ctx.xer);
	// 821AD0B8: 419A000C  beq cr6, 0x821ad0c4
	if ctx.cr[6].eq {
	pc = 0x821AD0C4; continue 'dispatch;
	}
	// 821AD0BC: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 821AD0C0: 409A0014  bne cr6, 0x821ad0d4
	if !ctx.cr[6].eq {
	pc = 0x821AD0D4; continue 'dispatch;
	}
	// 821AD0C4: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 821AD0C8: 409A000C  bne cr6, 0x821ad0d4
	if !ctx.cr[6].eq {
	pc = 0x821AD0D4; continue 'dispatch;
	}
	// 821AD0CC: 38E00018  li r7, 0x18
	ctx.r[7].s64 = 24;
	// 821AD0D0: 48000068  b 0x821ad138
	pc = 0x821AD138; continue 'dispatch;
	// 821AD0D4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821AD0D8: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 821AD0DC: 614ABECC  ori r10, r10, 0xbecc
	ctx.r[10].u64 = ctx.r[10].u64 | 48844;
	// 821AD0E0: 409A002C  bne cr6, 0x821ad10c
	if !ctx.cr[6].eq {
	pc = 0x821AD10C; continue 'dispatch;
	}
	// 821AD0E4: 7D3C502E  lwzx r9, r28, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AD0E8: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 821AD0EC: 409A0020  bne cr6, 0x821ad10c
	if !ctx.cr[6].eq {
	pc = 0x821AD10C; continue 'dispatch;
	}
	// 821AD0F0: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 821AD0F4: 409A0018  bne cr6, 0x821ad10c
	if !ctx.cr[6].eq {
	pc = 0x821AD10C; continue 'dispatch;
	}
	// 821AD0F8: 2F140001  cmpwi cr6, r20, 1
	ctx.cr[6].compare_i32(ctx.r[20].s32, 1, &mut ctx.xer);
	// 821AD0FC: 419A0010  beq cr6, 0x821ad10c
	if ctx.cr[6].eq {
	pc = 0x821AD10C; continue 'dispatch;
	}
	// 821AD100: 38E0001A  li r7, 0x1a
	ctx.r[7].s64 = 26;
	// 821AD104: 3AA00005  li r21, 5
	ctx.r[21].s64 = 5;
	// 821AD108: 48000030  b 0x821ad138
	pc = 0x821AD138; continue 'dispatch;
	// 821AD10C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 821AD110: 409A0024  bne cr6, 0x821ad134
	if !ctx.cr[6].eq {
	pc = 0x821AD134; continue 'dispatch;
	}
	// 821AD114: 7D7C502E  lwzx r11, r28, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AD118: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 821AD11C: 409A0018  bne cr6, 0x821ad134
	if !ctx.cr[6].eq {
	pc = 0x821AD134; continue 'dispatch;
	}
	// 821AD120: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 821AD124: 409A0010  bne cr6, 0x821ad134
	if !ctx.cr[6].eq {
	pc = 0x821AD134; continue 'dispatch;
	}
	// 821AD128: 2F140001  cmpwi cr6, r20, 1
	ctx.cr[6].compare_i32(ctx.r[20].s32, 1, &mut ctx.xer);
	// 821AD12C: 38E0001B  li r7, 0x1b
	ctx.r[7].s64 = 27;
	// 821AD130: 409A0008  bne cr6, 0x821ad138
	if !ctx.cr[6].eq {
	pc = 0x821AD138; continue 'dispatch;
	}
	// 821AD134: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AD138: 7CEB0734  extsh r11, r7
	ctx.r[11].s64 = ctx.r[7].s16 as i64;
	// 821AD13C: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 821AD140: 409A0008  bne cr6, 0x821ad148
	if !ctx.cr[6].eq {
	pc = 0x821AD148; continue 'dispatch;
	}
	// 821AD144: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821AD148: 7CEB0734  extsh r11, r7
	ctx.r[11].s64 = ctx.r[7].s16 as i64;
	// 821AD14C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821AD150: 419800D4  blt cr6, 0x821ad224
	if ctx.cr[6].lt {
	pc = 0x821AD224; continue 'dispatch;
	}
	// 821AD154: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 821AD158: 409800CC  bge cr6, 0x821ad224
	if !ctx.cr[6].lt {
	pc = 0x821AD224; continue 'dispatch;
	}
	// 821AD15C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 821AD160: 56E6047E  clrlwi r6, r23, 0x11
	ctx.r[6].u64 = ctx.r[23].u32 as u64 & 0x00007FFFu64;
	// 821AD164: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 821AD168: 7CCB0734  extsh r11, r6
	ctx.r[11].s64 = ctx.r[6].s16 as i64;
	// 821AD16C: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 821AD170: 409A0008  bne cr6, 0x821ad178
	if !ctx.cr[6].eq {
	pc = 0x821AD178; continue 'dispatch;
	}
	// 821AD174: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821AD178: 7D7C922E  lhzx r11, r28, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821AD17C: 2B0B001B  cmplwi cr6, r11, 0x1b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 27 as u32, &mut ctx.xer);
	// 821AD180: 409A0010  bne cr6, 0x821ad190
	if !ctx.cr[6].eq {
	pc = 0x821AD190; continue 'dispatch;
	}
	// 821AD184: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD188: 396B15A0  addi r11, r11, 0x15a0
	ctx.r[11].s64 = ctx.r[11].s64 + 5536;
	// 821AD18C: 48000020  b 0x821ad1ac
	pc = 0x821AD1AC; continue 'dispatch;
	// 821AD190: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 821AD194: 409A0010  bne cr6, 0x821ad1a4
	if !ctx.cr[6].eq {
	pc = 0x821AD1A4; continue 'dispatch;
	}
	// 821AD198: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD19C: 396B1630  addi r11, r11, 0x1630
	ctx.r[11].s64 = ctx.r[11].s64 + 5680;
	// 821AD1A0: 4800000C  b 0x821ad1ac
	pc = 0x821AD1AC; continue 'dispatch;
	// 821AD1A4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD1A8: 396B1528  addi r11, r11, 0x1528
	ctx.r[11].s64 = ctx.r[11].s64 + 5416;
	// 821AD1AC: 562A103A  slwi r10, r17, 2
	ctx.r[10].u32 = ctx.r[17].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AD1B0: 2B10000B  cmplwi cr6, r16, 0xb
	ctx.cr[6].compare_u32(ctx.r[16].u32, 11 as u32, &mut ctx.xer);
	// 821AD1B4: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AD1B8: 409A0010  bne cr6, 0x821ad1c8
	if !ctx.cr[6].eq {
	pc = 0x821AD1C8; continue 'dispatch;
	}
	// 821AD1BC: 2F050017  cmpwi cr6, r5, 0x17
	ctx.cr[6].compare_i32(ctx.r[5].s32, 23, &mut ctx.xer);
	// 821AD1C0: 409A0008  bne cr6, 0x821ad1c8
	if !ctx.cr[6].eq {
	pc = 0x821AD1C8; continue 'dispatch;
	}
	// 821AD1C4: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 821AD1C8: 7E6B0734  extsh r11, r19
	ctx.r[11].s64 = ctx.r[19].s16 as i64;
	// 821AD1CC: 2F0B00C1  cmpwi cr6, r11, 0xc1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 193, &mut ctx.xer);
	// 821AD1D0: 409A001C  bne cr6, 0x821ad1ec
	if !ctx.cr[6].eq {
	pc = 0x821AD1EC; continue 'dispatch;
	}
	// 821AD1D4: 7D2A0734  extsh r10, r9
	ctx.r[10].s64 = ctx.r[9].s16 as i64;
	// 821AD1D8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD1DC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AD1E0: 396B53C8  addi r11, r11, 0x53c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21448;
	// 821AD1E4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AD1E8: 7D730734  extsh r19, r11
	ctx.r[19].s64 = ctx.r[11].s16 as i64;
	// 821AD1EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AD1F0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821AD1F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AD1F8: 7E680734  extsh r8, r19
	ctx.r[8].s64 = ctx.r[19].s16 as i64;
	// 821AD1FC: 7D270734  extsh r7, r9
	ctx.r[7].s64 = ctx.r[9].s16 as i64;
	// 821AD200: 7CC60734  extsh r6, r6
	ctx.r[6].s64 = ctx.r[6].s16 as i64;
	// 821AD204: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AD208: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AD20C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821AD210: 4BFF38B9  bl 0x821a0ac8
	ctx.lr = 0x821AD214;
	sub_821A0AC8(ctx, base);
	// 821AD214: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD218: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD21C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD220: 48387EB8  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
	// 821AD224: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AD228: 2B0B001A  cmplwi cr6, r11, 0x1a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 26 as u32, &mut ctx.xer);
	// 821AD22C: 41990420  bgt cr6, 0x821ad64c
	if ctx.cr[6].gt {
	pc = 0x821AD64C; continue 'dispatch;
	}
	// 821AD230: 83E10164  lwz r31, 0x164(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD234: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821AD238: 398CD24C  addi r12, r12, -0x2db4
	ctx.r[12].s64 = ctx.r[12].s64 + -11700;
	// 821AD23C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821AD240: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821AD244: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821AD248: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821AD2B8; continue 'dispatch;
		},
		1 => {
	pc = 0x821AD3D8; continue 'dispatch;
		},
		2 => {
	pc = 0x821AD300; continue 'dispatch;
		},
		3 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		4 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		5 => {
	pc = 0x821AD394; continue 'dispatch;
		},
		6 => {
	pc = 0x821AD364; continue 'dispatch;
		},
		7 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		8 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		9 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		10 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		11 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		12 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		13 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		14 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		15 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		16 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		17 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		18 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		19 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		20 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		21 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		22 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		23 => {
	pc = 0x821AD470; continue 'dispatch;
		},
		24 => {
	pc = 0x821AD430; continue 'dispatch;
		},
		25 => {
	pc = 0x821AD554; continue 'dispatch;
		},
		26 => {
	pc = 0x821AD5D0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821AD24C: 821AD2B8  lwz r16, -0x2d48(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11592 as u32) ) } as u64;
	// 821AD250: 821AD3D8  lwz r16, -0x2c28(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11304 as u32) ) } as u64;
	// 821AD254: 821AD300  lwz r16, -0x2d00(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11520 as u32) ) } as u64;
	// 821AD258: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD25C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD260: 821AD394  lwz r16, -0x2c6c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11372 as u32) ) } as u64;
	// 821AD264: 821AD364  lwz r16, -0x2c9c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11420 as u32) ) } as u64;
	// 821AD268: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD26C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD270: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD274: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD278: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD27C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD280: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD284: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD288: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD28C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD290: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD294: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD298: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD29C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD2A0: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD2A4: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD2A8: 821AD470  lwz r16, -0x2b90(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11152 as u32) ) } as u64;
	// 821AD2AC: 821AD430  lwz r16, -0x2bd0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11216 as u32) ) } as u64;
	// 821AD2B0: 821AD554  lwz r16, -0x2aac(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10924 as u32) ) } as u64;
	// 821AD2B4: 821AD5D0  lwz r16, -0x2a30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10800 as u32) ) } as u64;
            }
            0x821AD2B8 => {
    //   block [0x821AD2B8..0x821AD300)
	// 821AD2B8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD2BC: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD2C0: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD2C4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD2C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AD2CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD2D0: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD2D4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD2D8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD2DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD2E0: 48000371  bl 0x821ad650
	ctx.lr = 0x821AD2E4;
	sub_821AD650(ctx, base);
	// 821AD2E4: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD2E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD2EC: 409A00EC  bne cr6, 0x821ad3d8
	if !ctx.cr[6].eq {
	pc = 0x821AD3D8; continue 'dispatch;
	}
	// 821AD2F0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD2F4: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD2F8: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD2FC: 48387DDC  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD300 => {
    //   block [0x821AD300..0x821AD364)
	// 821AD300: 2F110019  cmpwi cr6, r17, 0x19
	ctx.cr[6].compare_i32(ctx.r[17].s32, 25, &mut ctx.xer);
	// 821AD304: 419A0018  beq cr6, 0x821ad31c
	if ctx.cr[6].eq {
	pc = 0x821AD31C; continue 'dispatch;
	}
	// 821AD308: 2F11001A  cmpwi cr6, r17, 0x1a
	ctx.cr[6].compare_i32(ctx.r[17].s32, 26, &mut ctx.xer);
	// 821AD30C: 419A0010  beq cr6, 0x821ad31c
	if ctx.cr[6].eq {
	pc = 0x821AD31C; continue 'dispatch;
	}
	// 821AD310: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD314: C04B2098  lfs f2, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AD318: 4800000C  b 0x821ad324
	pc = 0x821AD324; continue 'dispatch;
	// 821AD31C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD320: C04B2090  lfs f2, 0x2090(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8336 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AD324: 81610164  lwz r11, 0x164(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD328: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD32C: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD330: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 821AD334: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AD338: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD33C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD340: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD344: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD348: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821AD34C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD350: 4BFFF149  bl 0x821ac498
	ctx.lr = 0x821AD354;
	sub_821AC498(ctx, base);
	// 821AD354: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD358: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD35C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD360: 48387D78  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD364 => {
    //   block [0x821AD364..0x821AD394)
	// 821AD364: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD368: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD36C: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD370: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD374: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 821AD378: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD37C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD380: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD384: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD388: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD38C: 480002C5  bl 0x821ad650
	ctx.lr = 0x821AD390;
	sub_821AD650(ctx, base);
	// 821AD390: 4BFFFF54  b 0x821ad2e4
	pc = 0x821AD2E4; continue 'dispatch;
            }
            0x821AD394 => {
    //   block [0x821AD394..0x821AD3D8)
	// 821AD394: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD398: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD39C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD3A0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD3A4: 390000C1  li r8, 0xc1
	ctx.r[8].s64 = 193;
	// 821AD3A8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821AD3AC: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD3B0: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AD3B4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD3B8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD3BC: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AD3C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD3C4: 3A6000C1  li r19, 0xc1
	ctx.r[19].s64 = 193;
	// 821AD3C8: 48000289  bl 0x821ad650
	ctx.lr = 0x821AD3CC;
	sub_821AD650(ctx, base);
	// 821AD3CC: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD3D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD3D4: 419AFF1C  beq cr6, 0x821ad2f0
	if ctx.cr[6].eq {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	pc = 0x821AD3D8; continue 'dispatch;
            }
            0x821AD3D8 => {
    //   block [0x821AD3D8..0x821AD430)
	// 821AD3D8: 2F110019  cmpwi cr6, r17, 0x19
	ctx.cr[6].compare_i32(ctx.r[17].s32, 25, &mut ctx.xer);
	// 821AD3DC: 419A000C  beq cr6, 0x821ad3e8
	if ctx.cr[6].eq {
	pc = 0x821AD3E8; continue 'dispatch;
	}
	// 821AD3E0: 2F11001A  cmpwi cr6, r17, 0x1a
	ctx.cr[6].compare_i32(ctx.r[17].s32, 26, &mut ctx.xer);
	// 821AD3E4: 409A000C  bne cr6, 0x821ad3f0
	if !ctx.cr[6].eq {
	pc = 0x821AD3F0; continue 'dispatch;
	}
	// 821AD3E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD3EC: C3CB209C  lfs f30, 0x209c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8348 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821AD3F0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD3F4: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 821AD3F8: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD3FC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821AD400: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AD404: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821AD408: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD40C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD410: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD414: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD418: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD41C: 4BFFF07D  bl 0x821ac498
	ctx.lr = 0x821AD420;
	sub_821AC498(ctx, base);
	// 821AD420: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD424: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD428: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD42C: 48387CAC  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD430 => {
    //   block [0x821AD430..0x821AD470)
	// 821AD430: 81610164  lwz r11, 0x164(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD434: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD438: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD43C: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD440: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 821AD444: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD448: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD44C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD450: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD454: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821AD458: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD45C: 480001F5  bl 0x821ad650
	ctx.lr = 0x821AD460;
	sub_821AD650(ctx, base);
	// 821AD460: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD464: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD468: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD46C: 48387C6C  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD470 => {
    //   block [0x821AD470..0x821AD554)
	// 821AD470: 7D7C922E  lhzx r11, r28, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821AD474: 2B0B002B  cmplwi cr6, r11, 0x2b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 43 as u32, &mut ctx.xer);
	// 821AD478: 409A0010  bne cr6, 0x821ad488
	if !ctx.cr[6].eq {
	pc = 0x821AD488; continue 'dispatch;
	}
	// 821AD47C: 3BA00040  li r29, 0x40
	ctx.r[29].s64 = 64;
	// 821AD480: 3B400156  li r26, 0x156
	ctx.r[26].s64 = 342;
	// 821AD484: 48000008  b 0x821ad48c
	pc = 0x821AD48C; continue 'dispatch;
	// 821AD488: 3B400128  li r26, 0x128
	ctx.r[26].s64 = 296;
	// 821AD48C: 83610164  lwz r27, 0x164(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD490: 63DE0001  ori r30, r30, 1
	ctx.r[30].u64 = ctx.r[30].u64 | 1;
	// 821AD494: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 821AD498: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD49C: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AD4A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD4A4: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD4A8: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD4AC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD4B0: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 821AD4B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD4B8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD4BC: 48000195  bl 0x821ad650
	ctx.lr = 0x821AD4C0;
	sub_821AD650(ctx, base);
	// 821AD4C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AD4C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD4C8: 419A0040  beq cr6, 0x821ad508
	if ctx.cr[6].eq {
	pc = 0x821AD508; continue 'dispatch;
	}
	// 821AD4CC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821AD4D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD4D4: 409A0034  bne cr6, 0x821ad508
	if !ctx.cr[6].eq {
	pc = 0x821AD508; continue 'dispatch;
	}
	// 821AD4D8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AD4DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AD4E0: 38EB0F40  addi r7, r11, 0xf40
	ctx.r[7].s64 = ctx.r[11].s64 + 3904;
	// 821AD4E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AD4E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AD4EC: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 821AD4F0: 481BCFA1  bl 0x8236a490
	ctx.lr = 0x821AD4F4;
	sub_8236A490(ctx, base);
	// 821AD4F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AD4F8: 419A0010  beq cr6, 0x821ad508
	if ctx.cr[6].eq {
	pc = 0x821AD508; continue 'dispatch;
	}
	// 821AD4FC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821AD500: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AD504: 4BFEEA7D  bl 0x8219bf80
	ctx.lr = 0x821AD508;
	sub_8219BF80(ctx, base);
	// 821AD508: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD50C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD510: 419AFDE0  beq cr6, 0x821ad2f0
	if ctx.cr[6].eq {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	// 821AD514: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD518: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 821AD51C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 821AD520: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 821AD524: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AD528: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821AD52C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD530: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD534: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD538: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD53C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD540: 4BFFEF59  bl 0x821ac498
	ctx.lr = 0x821AD544;
	sub_821AC498(ctx, base);
	// 821AD544: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD548: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD54C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD550: 48387B88  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD554 => {
    //   block [0x821AD554..0x821AD5D0)
	// 821AD554: 83E10164  lwz r31, 0x164(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD558: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD55C: 390000C0  li r8, 0xc0
	ctx.r[8].s64 = 192;
	// 821AD560: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD564: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 821AD568: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD56C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD570: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD574: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD578: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD57C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD580: 480000D1  bl 0x821ad650
	ctx.lr = 0x821AD584;
	sub_821AD650(ctx, base);
	// 821AD584: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD58C: 419AFD64  beq cr6, 0x821ad2f0
	if ctx.cr[6].eq {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	// 821AD590: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD594: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821AD598: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD59C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821AD5A0: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 821AD5A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD5A8: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD5AC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 821AD5B0: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD5B4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD5B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD5BC: 4BFFEEDD  bl 0x821ac498
	ctx.lr = 0x821AD5C0;
	sub_821AC498(ctx, base);
	// 821AD5C0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD5C4: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD5C8: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD5CC: 48387B0C  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD5D0 => {
    //   block [0x821AD5D0..0x821AD64C)
	// 821AD5D0: 83E10164  lwz r31, 0x164(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD5D4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD5D8: 390000C0  li r8, 0xc0
	ctx.r[8].s64 = 192;
	// 821AD5DC: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD5E0: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 821AD5E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD5E8: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD5EC: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD5F0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD5F4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD5F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD5FC: 48000055  bl 0x821ad650
	ctx.lr = 0x821AD600;
	sub_821AD650(ctx, base);
	// 821AD600: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD608: 419AFCE8  beq cr6, 0x821ad2f0
	if ctx.cr[6].eq {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	// 821AD60C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD610: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821AD614: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD618: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821AD61C: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 821AD620: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD624: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD628: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 821AD62C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD630: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD634: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD638: 4BFFEE61  bl 0x821ac498
	ctx.lr = 0x821AD63C;
	sub_821AC498(ctx, base);
	// 821AD63C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD640: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD644: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD648: 48387A90  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD64C => {
    //   block [0x821AD64C..0x821AD650)
	// 821AD64C: 48000000  b 0x821ad64c
	pc = 0x821AD64C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AD650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AD650 size=900
    let mut pc: u32 = 0x821AD650;
    'dispatch: loop {
        match pc {
            0x821AD650 => {
    //   block [0x821AD650..0x821AD9D4)
	// 821AD650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AD654: 48387A41  bl 0x82535094
	ctx.lr = 0x821AD658;
	sub_82535080(ctx, base);
	// 821AD658: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 821AD65C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AD660: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821AD664: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821AD668: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 821AD66C: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 821AD670: 6149A580  ori r9, r10, 0xa580
	ctx.r[9].u64 = ctx.r[10].u64 | 42368;
	// 821AD674: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AD678: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821AD67C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AD680: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821AD684: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AD688: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 821AD68C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821AD690: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 821AD694: 7D144378  mr r20, r8
	ctx.r[20].u64 = ctx.r[8].u64;
	// 821AD698: 3A600005  li r19, 5
	ctx.r[19].s64 = 5;
	// 821AD69C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821AD6A0: 7D6B482A  ldx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	// 821AD6A4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821AD6A8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AD6AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AD6B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD6B4: 419A0088  beq cr6, 0x821ad73c
	if ctx.cr[6].eq {
	pc = 0x821AD73C; continue 'dispatch;
	}
	// 821AD6B8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD6BC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AD6C0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AD6C4: 409A0078  bne cr6, 0x821ad73c
	if !ctx.cr[6].eq {
	pc = 0x821AD73C; continue 'dispatch;
	}
	// 821AD6C8: E94B0118  ld r10, 0x118(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) };
	// 821AD6CC: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821AD6D0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AD6D4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AD6D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD6DC: 419A003C  beq cr6, 0x821ad718
	if ctx.cr[6].eq {
	pc = 0x821AD718; continue 'dispatch;
	}
	// 821AD6E0: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD6E4: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AD6E8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AD6EC: 409A002C  bne cr6, 0x821ad718
	if !ctx.cr[6].eq {
	pc = 0x821AD718; continue 'dispatch;
	}
	// 821AD6F0: 570906B4  rlwinm r9, r24, 0, 0x1a, 0x1a
	ctx.r[9].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD6F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AD6F8: 409A0070  bne cr6, 0x821ad768
	if !ctx.cr[6].eq {
	pc = 0x821AD768; continue 'dispatch;
	}
	// 821AD6FC: A12A0014  lhz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AD700: 9A6A0019  stb r19, 0x19(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(25 as u32), ctx.r[19].u8 ) };
	// 821AD704: 61298000  ori r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 32768;
	// 821AD708: 9B4A0025  stb r26, 0x25(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 821AD70C: B12A0014  sth r9, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 821AD710: FB2B0118  std r25, 0x118(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), ctx.r[25].u64 ) };
	// 821AD714: 48000054  b 0x821ad768
	pc = 0x821AD768; continue 'dispatch;
	// 821AD718: E96B0110  ld r11, 0x110(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	// 821AD71C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AD720: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AD724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD728: 419A0014  beq cr6, 0x821ad73c
	if ctx.cr[6].eq {
	pc = 0x821AD73C; continue 'dispatch;
	}
	// 821AD72C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD730: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AD734: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AD738: 419A0030  beq cr6, 0x821ad768
	if ctx.cr[6].eq {
	pc = 0x821AD768; continue 'dispatch;
	}
	// 821AD73C: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821AD740: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD744: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	// 821AD748: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 821AD74C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD750: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD754: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AD758: 48001249  bl 0x821ae9a0
	ctx.lr = 0x821AD75C;
	sub_821AE9A0(ctx, base);
	// 821AD75C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AD760: 419A0164  beq cr6, 0x821ad8c4
	if ctx.cr[6].eq {
	pc = 0x821AD8C4; continue 'dispatch;
	}
	// 821AD764: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821AD768: E97B0110  ld r11, 0x110(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(272 as u32) ) };
	// 821AD76C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AD770: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AD774: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AD778: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD77C: 419A0014  beq cr6, 0x821ad790
	if ctx.cr[6].eq {
	pc = 0x821AD790; continue 'dispatch;
	}
	// 821AD780: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD784: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AD788: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AD78C: 419A0218  beq cr6, 0x821ad9a4
	if ctx.cr[6].eq {
	pc = 0x821AD9A4; continue 'dispatch;
	}
	// 821AD790: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AD794: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821AD798: 38EB0F4C  addi r7, r11, 0xf4c
	ctx.r[7].s64 = ctx.r[11].s64 + 3916;
	// 821AD79C: 38A00389  li r5, 0x389
	ctx.r[5].s64 = 905;
	// 821AD7A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821AD7A4: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 821AD7A8: 481BCCE9  bl 0x8236a490
	ctx.lr = 0x821AD7AC;
	sub_8236A490(ctx, base);
	// 821AD7AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AD7B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD7B4: 419A000C  beq cr6, 0x821ad7c0
	if ctx.cr[6].eq {
	pc = 0x821AD7C0; continue 'dispatch;
	}
	// 821AD7B8: 839F0030  lwz r28, 0x30(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD7BC: 48000008  b 0x821ad7c4
	pc = 0x821AD7C4; continue 'dispatch;
	// 821AD7C0: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 821AD7C4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821AD7C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD7CC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD7D0: 419A00F4  beq cr6, 0x821ad8c4
	if ctx.cr[6].eq {
	pc = 0x821AD8C4; continue 'dispatch;
	}
	// 821AD7D4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AD7D8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AD7DC: 396B0F54  addi r11, r11, 0xf54
	ctx.r[11].s64 = ctx.r[11].s64 + 3924;
	// 821AD7E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AD7E4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821AD7E8: 933F0080  stw r25, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 821AD7EC: B33F0084  sth r25, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[25].u16 ) };
	// 821AD7F0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821AD7F4: B33F0086  sth r25, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[25].u16 ) };
	// 821AD7F8: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821AD7FC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821AD800: 614A93F0  ori r10, r10, 0x93f0
	ctx.r[10].u64 = ctx.r[10].u64 | 37872;
	// 821AD804: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AD808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD80C: 419A004C  beq cr6, 0x821ad858
	if ctx.cr[6].eq {
	pc = 0x821AD858; continue 'dispatch;
	}
	// 821AD810: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AD814: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 821AD818: 3BCBB460  addi r30, r11, -0x4ba0
	ctx.r[30].s64 = ctx.r[11].s64 + -19360;
	// 821AD81C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821AD820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AD824: 48193065  bl 0x82340888
	ctx.lr = 0x821AD828;
	sub_82340888(ctx, base);
	// 821AD828: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821AD82C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821AD830: 419A001C  beq cr6, 0x821ad84c
	if ctx.cr[6].eq {
	pc = 0x821AD84C; continue 'dispatch;
	}
	// 821AD834: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 821AD838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AD83C: 4819304D  bl 0x82340888
	ctx.lr = 0x821AD840;
	sub_82340888(ctx, base);
	// 821AD840: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821AD844: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821AD848: 409A0010  bne cr6, 0x821ad858
	if !ctx.cr[6].eq {
	pc = 0x821AD858; continue 'dispatch;
	}
	// 821AD84C: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AD850: 716BFDFF  andi. r11, r11, 0xfdff
	ctx.r[11].u64 = ctx.r[11].u64 & 65023;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD854: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 821AD858: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AD85C: 9B5F001C  stb r26, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 821AD860: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821AD864: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821AD868: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AD86C: 3908D9D8  addi r8, r8, -0x2628
	ctx.r[8].s64 = ctx.r[8].s64 + -9768;
	// 821AD870: 3929DA18  addi r9, r9, -0x25e8
	ctx.r[9].s64 = ctx.r[9].s64 + -9704;
	// 821AD874: 394ADA38  addi r10, r10, -0x25c8
	ctx.r[10].s64 = ctx.r[10].s64 + -9672;
	// 821AD878: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AD87C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821AD880: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821AD884: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821AD888: 38804A40  li r4, 0x4a40
	ctx.r[4].s64 = 19008;
	// 821AD88C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821AD890: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AD894: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AD898: 4BFF4399  bl 0x821a1c30
	ctx.lr = 0x821AD89C;
	sub_821A1C30(ctx, base);
	// 821AD89C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AD8A0: 409A0034  bne cr6, 0x821ad8d4
	if !ctx.cr[6].eq {
	pc = 0x821AD8D4; continue 'dispatch;
	}
	// 821AD8A4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD8A8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821AD8AC: 409A0018  bne cr6, 0x821ad8c4
	if !ctx.cr[6].eq {
	pc = 0x821AD8C4; continue 'dispatch;
	}
	// 821AD8B0: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AD8B4: 9A7F0019  stb r19, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[19].u8 ) };
	// 821AD8B8: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 821AD8BC: 9B5F0025  stb r26, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 821AD8C0: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 821AD8C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AD8C8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AD8CC: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AD8D0: 48387814  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
	// 821AD8D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AD8D8: 570A06B4  rlwinm r10, r24, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD8DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD8E0: F97B0110  std r11, 0x110(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(272 as u32), ctx.r[11].u64 ) };
	// 821AD8E4: 409A0008  bne cr6, 0x821ad8ec
	if !ctx.cr[6].eq {
	pc = 0x821AD8EC; continue 'dispatch;
	}
	// 821AD8E8: FB3B0118  std r25, 0x118(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(280 as u32), ctx.r[25].u64 ) };
	// 821AD8EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AD8F0: 419A0030  beq cr6, 0x821ad920
	if ctx.cr[6].eq {
	pc = 0x821AD920; continue 'dispatch;
	}
	// 821AD8F4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD8FC: 419A001C  beq cr6, 0x821ad918
	if ctx.cr[6].eq {
	pc = 0x821AD918; continue 'dispatch;
	}
	// 821AD900: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD904: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD908: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AD90C: 409A000C  bne cr6, 0x821ad918
	if !ctx.cr[6].eq {
	pc = 0x821AD918; continue 'dispatch;
	}
	// 821AD910: A16B0016  lhz r11, 0x16(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 821AD914: 48000008  b 0x821ad91c
	pc = 0x821AD91C; continue 'dispatch;
	// 821AD918: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821AD91C: B17F0016  sth r11, 0x16(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[11].u16 ) };
	// 821AD920: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD924: 8141013C  lwz r10, 0x13c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 821AD928: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821AD92C: 813F00CC  lwz r9, 0xcc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AD930: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821AD934: 38C00022  li r6, 0x22
	ctx.r[6].s64 = 34;
	// 821AD938: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AD93C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AD940: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD944: 911F00A8  stw r8, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821AD948: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 821AD94C: 396B160C  addi r11, r11, 0x160c
	ctx.r[11].s64 = ctx.r[11].s64 + 5644;
	// 821AD950: 90FF00A4  stw r7, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821AD954: 90DF0094  stw r6, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[6].u32 ) };
	// 821AD958: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821AD95C: 3940018C  li r10, 0x18c
	ctx.r[10].s64 = 396;
	// 821AD960: 7D65582E  lwzx r11, r5, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AD964: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821AD968: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821AD96C: 909F00A0  stw r4, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 821AD970: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821AD974: C1A8BA38  lfs f13, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AD978: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AD97C: 39690024  addi r11, r9, 0x24
	ctx.r[11].s64 = ctx.r[9].s64 + 36;
	// 821AD980: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821AD984: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AD988: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821AD98C: D1ABFFE8  stfs f13, -0x18(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 821AD990: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AD994: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AD998: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AD99C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821AD9A0: 4199FFE8  bgt cr6, 0x821ad988
	if ctx.cr[6].gt {
	pc = 0x821AD988; continue 'dispatch;
	}
	// 821AD9A4: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 821AD9A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD9AC: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 821AD9B0: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 821AD9B4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821AD9B8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821AD9BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AD9C0: 480016A9  bl 0x821af068
	ctx.lr = 0x821AD9C4;
	sub_821AF068(ctx, base);
	// 821AD9C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AD9C8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AD9CC: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AD9D0: 48387714  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AD9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AD9D8 size=60
    let mut pc: u32 = 0x821AD9D8;
    'dispatch: loop {
        match pc {
            0x821AD9D8 => {
    //   block [0x821AD9D8..0x821ADA14)
	// 821AD9D8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AD9DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AD9E0: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AD9E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD9E8: 419A0008  beq cr6, 0x821ad9f0
	if ctx.cr[6].eq {
	pc = 0x821AD9F0; continue 'dispatch;
	}
	// 821AD9EC: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821AD9F0: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 821AD9F4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821AD9F8: 39298E40  addi r9, r9, -0x71c0
	ctx.r[9].s64 = ctx.r[9].s64 + -29120;
	// 821AD9FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821ADA00: 990B001E  stb r8, 0x1e(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(30 as u32), ctx.r[8].u8 ) };
	// 821ADA04: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821ADA08: B14B0084  sth r10, 0x84(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u16 ) };
	// 821ADA0C: B14B0086  sth r10, 0x86(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(134 as u32), ctx.r[10].u16 ) };
	// 821ADA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821ADA18 size=32
    let mut pc: u32 = 0x821ADA18;
    'dispatch: loop {
        match pc {
            0x821ADA18 => {
    //   block [0x821ADA18..0x821ADA38)
	// 821ADA18: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ADA1C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821ADA20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821ADA24: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821ADA28: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821ADA2C: 912B0040  stw r9, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 821ADA30: B141FFF0  sth r10, -0x10(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u16 ) };
	// 821ADA34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADA38 size=92
    let mut pc: u32 = 0x821ADA38;
    'dispatch: loop {
        match pc {
            0x821ADA38 => {
    //   block [0x821ADA38..0x821ADA94)
	// 821ADA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADA3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ADA40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ADA44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADA48: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ADA4C: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821ADA50: 389F00CC  addi r4, r31, 0xcc
	ctx.r[4].s64 = ctx.r[31].s64 + 204;
	// 821ADA54: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821ADA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADA5C: 419A0014  beq cr6, 0x821ada70
	if ctx.cr[6].eq {
	pc = 0x821ADA70; continue 'dispatch;
	}
	// 821ADA60: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821ADA64: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821ADA68: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821ADA6C: 4BFF4615  bl 0x821a2080
	ctx.lr = 0x821ADA70;
	sub_821A2080(ctx, base);
	// 821ADA70: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ADA74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821ADA78: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821ADA7C: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 821ADA80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ADA84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ADA88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ADA8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ADA90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ADA98 size=772
    let mut pc: u32 = 0x821ADA98;
    'dispatch: loop {
        match pc {
            0x821ADA98 => {
    //   block [0x821ADA98..0x821ADD9C)
	// 821ADA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADA9C: 4838761D  bl 0x825350b8
	ctx.lr = 0x821ADAA0;
	sub_82535080(ctx, base);
	// 821ADAA0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821ADAA4: 4838850D  bl 0x82535fb0
	ctx.lr = 0x821ADAA8;
	sub_82535FB0(ctx, base);
	// 821ADAA8: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADAAC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821ADAB0: C007000C  lfs f0, 0xc(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADAB4: EEA00072  fmuls f21, f0, f1
	ctx.f[21].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821ADAB8: C007001C  lfs f0, 0x1c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADABC: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 821ADAC0: EF400072  fmuls f26, f0, f1
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821ADAC4: C3070000  lfs f24, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821ADAC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ADACC: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821ADAD0: C1A70020  lfs f13, 0x20(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADAD4: C2E70004  lfs f23, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821ADAD8: EDADC028  fsubs f13, f13, f24
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[24].f64) as f32) as f64);
	// 821ADADC: C1870024  lfs f12, 0x24(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ADAE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821ADAE4: C2C70008  lfs f22, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821ADAE8: ED8CB828  fsubs f12, f12, f23
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[23].f64) as f32) as f64);
	// 821ADAEC: C1670028  lfs f11, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ADAF0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821ADAF4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821ADAF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821ADAFC: C147002C  lfs f10, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ADB00: ED6BB028  fsubs f11, f11, f22
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[22].f64) as f32) as f64);
	// 821ADB04: ED4AA878  fmsubs f10, f10, f1, f21
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[1].f64 - ctx.f[21].f64) as f32) as f64);
	// 821ADB08: C3A70010  lfs f29, 0x10(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821ADB0C: C3870014  lfs f28, 0x14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821ADB10: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821ADB14: C3670018  lfs f27, 0x18(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821ADB18: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821ADB1C: C8010068  lfd f0, 0x68(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821ADB20: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821ADB24: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821ADB28: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 821ADB2C: EDCD0032  fmuls f14, f13, f0
	ctx.f[14].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB30: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB34: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821ADB38: EDAB0032  fmuls f13, f11, f0
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB3C: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821ADB40: EDAA0032  fmuls f13, f10, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB44: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821ADB48: C1A70030  lfs f13, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADB4C: C1870034  lfs f12, 0x34(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ADB50: EDADE828  fsubs f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[29].f64) as f32) as f64);
	// 821ADB54: C1670038  lfs f11, 0x38(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ADB58: ED8CE028  fsubs f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[28].f64) as f32) as f64);
	// 821ADB5C: C147003C  lfs f10, 0x3c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ADB60: ED6BD828  fsubs f11, f11, f27
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[27].f64) as f32) as f64);
	// 821ADB64: ED4AD078  fmsubs f10, f10, f1, f26
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[1].f64 - ctx.f[26].f64) as f32) as f64);
	// 821ADB68: EE4D0032  fmuls f18, f13, f0
	ctx.f[18].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB6C: EE2C0032  fmuls f17, f12, f0
	ctx.f[17].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB70: EE0B0032  fmuls f16, f11, f0
	ctx.f[16].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB74: EDEA0032  fmuls f15, f10, f0
	ctx.f[15].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB78: 419A0214  beq cr6, 0x821add8c
	if ctx.cr[6].eq {
	pc = 0x821ADD8C; continue 'dispatch;
	}
	// 821ADB7C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821ADB80: 3CE08288  lis r7, -0x7d78
	ctx.r[7].s64 = -2105016320;
	// 821ADB84: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821ADB88: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821ADB8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821ADB90: C1A91FF8  lfs f13, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADB94: C267D4DC  lfs f19, -0x2b24(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821ADB98: C2882490  lfs f20, 0x2490(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(9360 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821ADB9C: C32A2048  lfs f25, 0x2048(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8264 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821ADBA0: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821ADBA4: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821ADBA8: 48000008  b 0x821adbb0
	pc = 0x821ADBB0; continue 'dispatch;
	// 821ADBAC: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADBB0: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADBB4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821ADBB8: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADBBC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821ADBC0: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADBC4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821ADBC8: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADBCC: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821ADBD0: FF0CF000  fcmpu cr6, f12, f30
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[30].f64);
	// 821ADBD4: 41980064  blt cr6, 0x821adc38
	if ctx.cr[6].lt {
	pc = 0x821ADC38; continue 'dispatch;
	}
	// 821ADBD8: EC00C828  fsubs f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[25].f64) as f32) as f64);
	// 821ADBDC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821ADBE0: 4098003C  bge cr6, 0x821adc1c
	if !ctx.cr[6].lt {
	pc = 0x821ADC1C; continue 'dispatch;
	}
	// 821ADBE4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821ADBE8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADBEC: 4098000C  bge cr6, 0x821adbf8
	if !ctx.cr[6].lt {
	pc = 0x821ADBF8; continue 'dispatch;
	}
	// 821ADBF0: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ADBF4: 48000040  b 0x821adc34
	pc = 0x821ADC34; continue 'dispatch;
	// 821ADBF8: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821ADBFC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821ADC00: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821ADC04: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ADC08: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ADC0C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADC10: 41980024  blt cr6, 0x821adc34
	if ctx.cr[6].lt {
	pc = 0x821ADC34; continue 'dispatch;
	}
	// 821ADC14: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821ADC18: 4800001C  b 0x821adc34
	pc = 0x821ADC34; continue 'dispatch;
	// 821ADC1C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADC20: 41980014  blt cr6, 0x821adc34
	if ctx.cr[6].lt {
	pc = 0x821ADC34; continue 'dispatch;
	}
	// 821ADC24: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821ADC28: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821ADC2C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821ADC30: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ADC34: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 821ADC38: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821ADC3C: EC200532  fmuls f1, f0, f20
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[20].f64) as f32) as f64);
	// 821ADC40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ADC44: 4BF6418D  bl 0x82111dd0
	ctx.lr = 0x821ADC48;
	sub_82111DD0(ctx, base);
	// 821ADC48: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADC4C: EC00FCFA  fmadds f0, f0, f19, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[19].f64 + ctx.f[31].f64) as f32) as f64);
	// 821ADC50: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADC54: EDADFCF8  fmsubs f13, f13, f19, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[19].f64 - ctx.f[31].f64) as f32) as f64);
	// 821ADC58: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821ADC5C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821ADC60: EC0D0672  fmuls f0, f13, f25
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64) as f32) as f64);
	// 821ADC64: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821ADC68: D3BF0010  stfs f29, 0x10(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821ADC6C: EFB2E82A  fadds f29, f18, f29
	ctx.f[29].f64 = ((ctx.f[18].f64 + ctx.f[29].f64) as f32) as f64;
	// 821ADC70: D39F0014  stfs f28, 0x14(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821ADC74: EF91E02A  fadds f28, f17, f28
	ctx.f[28].f64 = ((ctx.f[17].f64 + ctx.f[28].f64) as f32) as f64;
	// 821ADC78: D37F0018  stfs f27, 0x18(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821ADC7C: EF70D82A  fadds f27, f16, f27
	ctx.f[27].f64 = ((ctx.f[16].f64 + ctx.f[27].f64) as f32) as f64;
	// 821ADC80: D35F001C  stfs f26, 0x1c(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821ADC84: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821ADC88: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADC8C: EF4FD02A  fadds f26, f15, f26
	ctx.f[26].f64 = ((ctx.f[15].f64 + ctx.f[26].f64) as f32) as f64;
	// 821ADC90: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821ADC94: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADC98: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821ADC9C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADCA0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821ADCA4: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADCA8: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821ADCAC: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 821ADCB0: 41980068  blt cr6, 0x821add18
	if ctx.cr[6].lt {
	pc = 0x821ADD18; continue 'dispatch;
	}
	// 821ADCB4: EC00C828  fsubs f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[25].f64) as f32) as f64);
	// 821ADCB8: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADCBC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821ADCC0: 4098003C  bge cr6, 0x821adcfc
	if !ctx.cr[6].lt {
	pc = 0x821ADCFC; continue 'dispatch;
	}
	// 821ADCC4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821ADCC8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADCCC: 4098000C  bge cr6, 0x821adcd8
	if !ctx.cr[6].lt {
	pc = 0x821ADCD8; continue 'dispatch;
	}
	// 821ADCD0: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ADCD4: 48000040  b 0x821add14
	pc = 0x821ADD14; continue 'dispatch;
	// 821ADCD8: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821ADCDC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821ADCE0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821ADCE4: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ADCE8: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ADCEC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADCF0: 41980024  blt cr6, 0x821add14
	if ctx.cr[6].lt {
	pc = 0x821ADD14; continue 'dispatch;
	}
	// 821ADCF4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821ADCF8: 4800001C  b 0x821add14
	pc = 0x821ADD14; continue 'dispatch;
	// 821ADCFC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADD00: 41980014  blt cr6, 0x821add14
	if ctx.cr[6].lt {
	pc = 0x821ADD14; continue 'dispatch;
	}
	// 821ADD04: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821ADD08: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821ADD0C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821ADD10: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ADD14: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 821ADD18: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821ADD1C: EC200532  fmuls f1, f0, f20
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[20].f64) as f32) as f64);
	// 821ADD20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ADD24: 4BF640AD  bl 0x82111dd0
	ctx.lr = 0x821ADD28;
	sub_82111DD0(ctx, base);
	// 821ADD28: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADD2C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821ADD30: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADD34: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 821ADD38: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821ADD3C: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 821ADD40: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821ADD44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821ADD48: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821ADD4C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821ADD50: EC0D0672  fmuls f0, f13, f25
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64) as f32) as f64);
	// 821ADD54: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821ADD58: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADD5C: D2FF0014  stfs f23, 0x14(r31)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821ADD60: EEE0B82A  fadds f23, f0, f23
	ctx.f[23].f64 = ((ctx.f[0].f64 + ctx.f[23].f64) as f32) as f64;
	// 821ADD64: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADD68: D2DF0018  stfs f22, 0x18(r31)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821ADD6C: EEC0B02A  fadds f22, f0, f22
	ctx.f[22].f64 = ((ctx.f[0].f64 + ctx.f[22].f64) as f32) as f64;
	// 821ADD70: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADD74: D31F0010  stfs f24, 0x10(r31)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821ADD78: EF0EC02A  fadds f24, f14, f24
	ctx.f[24].f64 = ((ctx.f[14].f64 + ctx.f[24].f64) as f32) as f64;
	// 821ADD7C: D2BF001C  stfs f21, 0x1c(r31)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821ADD80: EEA0A82A  fadds f21, f0, f21
	ctx.f[21].f64 = ((ctx.f[0].f64 + ctx.f[21].f64) as f32) as f64;
	// 821ADD84: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821ADD88: 409AFE24  bne cr6, 0x821adbac
	if !ctx.cr[6].eq {
	pc = 0x821ADBAC; continue 'dispatch;
	}
	// 821ADD8C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 821ADD90: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821ADD94: 48388269  bl 0x82535ffc
	ctx.lr = 0x821ADD98;
	sub_82535FFC(ctx, base);
	// 821ADD98: 48387370  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821ADDA0 size=36
    let mut pc: u32 = 0x821ADDA0;
    'dispatch: loop {
        match pc {
            0x821ADDA0 => {
    //   block [0x821ADDA0..0x821ADDC4)
	// 821ADDA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821ADDA4: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821ADDA8: 38AB0090  addi r5, r11, 0x90
	ctx.r[5].s64 = ctx.r[11].s64 + 144;
	// 821ADDAC: 394AC470  addi r10, r10, -0x3b90
	ctx.r[10].s64 = ctx.r[10].s64 + -15248;
	// 821ADDB0: 388B0080  addi r4, r11, 0x80
	ctx.r[4].s64 = ctx.r[11].s64 + 128;
	// 821ADDB4: 80CB00CC  lwz r6, 0xcc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 821ADDB8: 38EA0060  addi r7, r10, 0x60
	ctx.r[7].s64 = ctx.r[10].s64 + 96;
	// 821ADDBC: 806B00C4  lwz r3, 0xc4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821ADDC0: 481BFB48  b 0x8236d908
	sub_8236D908(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADDC8 size=100
    let mut pc: u32 = 0x821ADDC8;
    'dispatch: loop {
        match pc {
            0x821ADDC8 => {
    //   block [0x821ADDC8..0x821ADE2C)
	// 821ADDC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADDCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ADDD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ADDD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADDD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ADDDC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821ADDE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADDE4: 419A0034  beq cr6, 0x821ade18
	if ctx.cr[6].eq {
	pc = 0x821ADE18; continue 'dispatch;
	}
	// 821ADDE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821ADDEC: 4E800421  bctrl
	ctx.lr = 0x821ADDF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ADDF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ADDF4: 409A0024  bne cr6, 0x821ade18
	if !ctx.cr[6].eq {
	pc = 0x821ADE18; continue 'dispatch;
	}
	// 821ADDF8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ADDFC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821ADE00: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821ADE04: 409A0014  bne cr6, 0x821ade18
	if !ctx.cr[6].eq {
	pc = 0x821ADE18; continue 'dispatch;
	}
	// 821ADE08: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821ADE0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821ADE10: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821ADE14: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821ADE18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ADE1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ADE20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ADE24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ADE28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADE30 size=100
    let mut pc: u32 = 0x821ADE30;
    'dispatch: loop {
        match pc {
            0x821ADE30 => {
    //   block [0x821ADE30..0x821ADE94)
	// 821ADE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ADE38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ADE3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADE40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ADE44: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821ADE48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADE4C: 419A0034  beq cr6, 0x821ade80
	if ctx.cr[6].eq {
	pc = 0x821ADE80; continue 'dispatch;
	}
	// 821ADE50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821ADE54: 4E800421  bctrl
	ctx.lr = 0x821ADE58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ADE58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ADE5C: 409A0024  bne cr6, 0x821ade80
	if !ctx.cr[6].eq {
	pc = 0x821ADE80; continue 'dispatch;
	}
	// 821ADE60: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ADE64: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821ADE68: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821ADE6C: 409A0014  bne cr6, 0x821ade80
	if !ctx.cr[6].eq {
	pc = 0x821ADE80; continue 'dispatch;
	}
	// 821ADE70: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821ADE74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821ADE78: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821ADE7C: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821ADE80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ADE84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ADE88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ADE8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ADE90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ADE98 size=1292
    let mut pc: u32 = 0x821ADE98;
    'dispatch: loop {
        match pc {
            0x821ADE98 => {
    //   block [0x821ADE98..0x821AE3A4)
	// 821ADE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADE9C: 4838720D  bl 0x825350a8
	ctx.lr = 0x821ADEA0;
	sub_82535080(ctx, base);
	// 821ADEA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADEA4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821ADEA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ADEAC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821ADEB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ADEB4: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 821ADEB8: 419A04E0  beq cr6, 0x821ae398
	if ctx.cr[6].eq {
	pc = 0x821AE398; continue 'dispatch;
	}
	// 821ADEBC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ADEC0: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821ADEC4: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 821ADEC8: 3BCAC470  addi r30, r10, -0x3b90
	ctx.r[30].s64 = ctx.r[10].s64 + -15248;
	// 821ADECC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821ADED0: 54ABE7FE  rlwinm r11, r5, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 821ADED4: 38EA0F74  addi r7, r10, 0xf74
	ctx.r[7].s64 = ctx.r[10].s64 + 3956;
	// 821ADED8: 7D5F48AE  lbzx r10, r31, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821ADEDC: 393E0014  addi r9, r30, 0x14
	ctx.r[9].s64 = ctx.r[30].s64 + 20;
	// 821ADEE0: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 821ADEE4: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 821ADEE8: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821ADEEC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821ADEF0: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 821ADEF4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ADEF8: 7C8B482E  lwzx r4, r11, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821ADEFC: 481BC595  bl 0x8236a490
	ctx.lr = 0x821ADF00;
	sub_8236A490(ctx, base);
	// 821ADF00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821ADF04: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821ADF08: 419A000C  beq cr6, 0x821adf14
	if ctx.cr[6].eq {
	pc = 0x821ADF14; continue 'dispatch;
	}
	// 821ADF0C: 833C0030  lwz r25, 0x30(r28)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821ADF10: 48000008  b 0x821adf18
	pc = 0x821ADF18; continue 'dispatch;
	// 821ADF14: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 821ADF18: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821ADF1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821ADF20: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821ADF24: 419A0018  beq cr6, 0x821adf3c
	if ctx.cr[6].eq {
	pc = 0x821ADF3C; continue 'dispatch;
	}
	// 821ADF28: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821ADF2C: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 821ADF30: 396B0F7C  addi r11, r11, 0xf7c
	ctx.r[11].s64 = ctx.r[11].s64 + 3964;
	// 821ADF34: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821ADF38: 48000008  b 0x821adf40
	pc = 0x821ADF40; continue 'dispatch;
	// 821ADF3C: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 821ADF40: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821ADF44: 93FB0080  stw r31, 0x80(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 821ADF48: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821ADF4C: B3BB00C0  sth r29, 0xc0(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(192 as u32), ctx.r[29].u16 ) };
	// 821ADF50: 3D60821B  lis r11, -0x7de5
	ctx.r[11].s64 = -2112159744;
	// 821ADF54: 3929E3A8  addi r9, r9, -0x1c58
	ctx.r[9].s64 = ctx.r[9].s64 + -7256;
	// 821ADF58: 394AE458  addi r10, r10, -0x1ba8
	ctx.r[10].s64 = ctx.r[10].s64 + -7080;
	// 821ADF5C: 396BE510  addi r11, r11, -0x1af0
	ctx.r[11].s64 = ctx.r[11].s64 + -6896;
	// 821ADF60: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821ADF64: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821ADF68: 38BB00C4  addi r5, r27, 0xc4
	ctx.r[5].s64 = ctx.r[27].s64 + 196;
	// 821ADF6C: 913B0054  stw r9, 0x54(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821ADF70: 38800300  li r4, 0x300
	ctx.r[4].s64 = 768;
	// 821ADF74: 915B0058  stw r10, 0x58(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821ADF78: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821ADF7C: 917B005C  stw r11, 0x5c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821ADF80: 9B5B001C  stb r26, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 821ADF84: 4BFF3CAD  bl 0x821a1c30
	ctx.lr = 0x821ADF88;
	sub_821A1C30(ctx, base);
	// 821ADF88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ADF8C: 419A03E0  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821ADF90: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821ADF94: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821ADF98: 7FAB0734  extsh r11, r29
	ctx.r[11].s64 = ctx.r[29].s16 as i64;
	// 821ADF9C: 6149A578  ori r9, r10, 0xa578
	ctx.r[9].u64 = ctx.r[10].u64 | 42360;
	// 821ADFA0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821ADFA4: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 821ADFA8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821ADFAC: 387B0090  addi r3, r27, 0x90
	ctx.r[3].s64 = ctx.r[27].s64 + 144;
	// 821ADFB0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821ADFB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADFB8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821ADFBC: 7D0A492A  stdx r8, r10, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u64) };
	// 821ADFC0: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821ADFC4: 98FB0025  stb r7, 0x25(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(37 as u32), ctx.r[7].u8 ) };
	// 821ADFC8: 38EAFC94  addi r7, r10, -0x36c
	ctx.r[7].s64 = ctx.r[10].s64 + -876;
	// 821ADFCC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821ADFD0: 614ABEBC  ori r10, r10, 0xbebc
	ctx.r[10].u64 = ctx.r[10].u64 | 48828;
	// 821ADFD4: 4198003C  blt cr6, 0x821ae010
	if ctx.cr[6].lt {
	pc = 0x821AE010; continue 'dispatch;
	}
	// 821ADFD8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821ADFDC: 41990034  bgt cr6, 0x821ae010
	if ctx.cr[6].gt {
	pc = 0x821AE010; continue 'dispatch;
	}
	// 821ADFE0: 7CDF522E  lhzx r6, r31, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821ADFE4: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821ADFE8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821ADFEC: 39290198  addi r9, r9, 0x198
	ctx.r[9].s64 = ctx.r[9].s64 + 408;
	// 821ADFF0: 54C6103E  rotlwi r6, r6, 2
	ctx.r[6].u64 = ((ctx.r[6].u32).rotate_left(2)) as u64;
	// 821ADFF4: 7D26482E  lwzx r9, r6, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821ADFF8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821ADFFC: A1090002  lhz r8, 2(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 821AE000: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE004: 7D040734  extsh r4, r8
	ctx.r[4].s64 = ctx.r[8].s16 as i64;
	// 821AE008: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 821AE00C: 48000018  b 0x821ae024
	pc = 0x821AE024; continue 'dispatch;
	// 821AE010: 392BFFF7  addi r9, r11, -9
	ctx.r[9].s64 = ctx.r[11].s64 + -9;
	// 821AE014: 390704BC  addi r8, r7, 0x4bc
	ctx.r[8].s64 = ctx.r[7].s64 + 1212;
	// 821AE018: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AE01C: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821AE020: 7C86402E  lwzx r4, r6, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821AE024: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE028: 4198019C  blt cr6, 0x821ae1c4
	if ctx.cr[6].lt {
	pc = 0x821AE1C4; continue 'dispatch;
	}
	// 821AE02C: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 821AE030: 41990194  bgt cr6, 0x821ae1c4
	if ctx.cr[6].gt {
	pc = 0x821AE1C4; continue 'dispatch;
	}
	// 821AE034: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 821AE038: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AE03C: 5526083C  slwi r6, r9, 1
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AE040: 390A1308  addi r8, r10, 0x1308
	ctx.r[8].s64 = ctx.r[10].s64 + 4872;
	// 821AE044: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AE048: 392A1040  addi r9, r10, 0x1040
	ctx.r[9].s64 = ctx.r[10].s64 + 4160;
	// 821AE04C: 7D5F3A2E  lhzx r10, r31, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821AE050: 3CE08286  lis r7, -0x7d7a
	ctx.r[7].s64 = -2105147392;
	// 821AE054: 5545103E  rotlwi r5, r10, 2
	ctx.r[5].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821AE058: 2B0A000B  cmplwi cr6, r10, 0xb
	ctx.cr[6].compare_u32(ctx.r[10].u32, 11 as u32, &mut ctx.xer);
	// 821AE05C: 38E70540  addi r7, r7, 0x540
	ctx.r[7].s64 = ctx.r[7].s64 + 1344;
	// 821AE060: 7D45402E  lwzx r10, r5, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821AE064: 7D4A322E  lhzx r10, r10, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821AE068: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821AE06C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE070: 7D4A4A2E  lhzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821AE074: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821AE078: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE07C: 7CAA3A14  add r5, r10, r7
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821AE080: 409A0028  bne cr6, 0x821ae0a8
	if !ctx.cr[6].eq {
	pc = 0x821AE0A8; continue 'dispatch;
	}
	// 821AE084: 38E50010  addi r7, r5, 0x10
	ctx.r[7].s64 = ctx.r[5].s64 + 16;
	// 821AE088: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821AE08C: 38A0001D  li r5, 0x1d
	ctx.r[5].s64 = 29;
	// 821AE090: 3880001F  li r4, 0x1f
	ctx.r[4].s64 = 31;
	// 821AE094: 4BFF6655  bl 0x821a46e8
	ctx.lr = 0x821AE098;
	sub_821A46E8(ctx, base);
	// 821AE098: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE09C: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE0A0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE0A4: 48387054  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 821AE0A8: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 821AE0AC: 409A020C  bne cr6, 0x821ae2b8
	if !ctx.cr[6].eq {
	pc = 0x821AE2B8; continue 'dispatch;
	}
	// 821AE0B0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AE0B4: 616B9CFC  ori r11, r11, 0x9cfc
	ctx.r[11].u64 = ctx.r[11].u64 | 40188;
	// 821AE0B8: 7D3F582E  lwzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AE0BC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821AE0C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE0C4: 419A0048  beq cr6, 0x821ae10c
	if ctx.cr[6].eq {
	pc = 0x821AE10C; continue 'dispatch;
	}
	// 821AE0C8: 896A004A  lbz r11, 0x4a(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(74 as u32) ) } as u64;
	// 821AE0CC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821AE0D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE0D4: 4099002C  ble cr6, 0x821ae100
	if !ctx.cr[6].gt {
	pc = 0x821AE100; continue 'dispatch;
	}
	// 821AE0D8: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821AE0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE0E0: 419A0020  beq cr6, 0x821ae100
	if ctx.cr[6].eq {
	pc = 0x821AE100; continue 'dispatch;
	}
	// 821AE0E4: 890B004E  lbz r8, 0x4e(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(78 as u32) ) } as u64;
	// 821AE0E8: 550807BC  rlwinm r8, r8, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821AE0EC: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 821AE0F0: 419A00BC  beq cr6, 0x821ae1ac
	if ctx.cr[6].eq {
	pc = 0x821AE1AC; continue 'dispatch;
	}
	// 821AE0F4: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AE0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE0FC: 409AFFE8  bne cr6, 0x821ae0e4
	if !ctx.cr[6].eq {
	pc = 0x821AE0E4; continue 'dispatch;
	}
	// 821AE100: 814A0040  lwz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AE104: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE108: 409AFFC0  bne cr6, 0x821ae0c8
	if !ctx.cr[6].eq {
	pc = 0x821AE0C8; continue 'dispatch;
	}
	// 821AE10C: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 821AE110: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821AE114: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE118: 419A0048  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	// 821AE11C: 896A004A  lbz r11, 0x4a(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(74 as u32) ) } as u64;
	// 821AE120: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821AE124: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE128: 4099002C  ble cr6, 0x821ae154
	if !ctx.cr[6].gt {
	pc = 0x821AE154; continue 'dispatch;
	}
	// 821AE12C: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821AE130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE134: 419A0020  beq cr6, 0x821ae154
	if ctx.cr[6].eq {
	pc = 0x821AE154; continue 'dispatch;
	}
	// 821AE138: 892B004E  lbz r9, 0x4e(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(78 as u32) ) } as u64;
	// 821AE13C: 552907FE  clrlwi r9, r9, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821AE140: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 821AE144: 419A0074  beq cr6, 0x821ae1b8
	if ctx.cr[6].eq {
	pc = 0x821AE1B8; continue 'dispatch;
	}
	// 821AE148: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AE14C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE150: 409AFFE8  bne cr6, 0x821ae138
	if !ctx.cr[6].eq {
	pc = 0x821AE138; continue 'dispatch;
	}
	// 821AE154: 814A0040  lwz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AE158: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE15C: 409AFFC0  bne cr6, 0x821ae11c
	if !ctx.cr[6].eq {
	pc = 0x821AE11C; continue 'dispatch;
	}
	// 821AE160: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 821AE164: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821AE168: 419A0204  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE16C: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821AE170: 419A01FC  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE174: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821AE178: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821AE17C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821AE180: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AE184: 394A4780  addi r10, r10, 0x4780
	ctx.r[10].s64 = ctx.r[10].s64 + 18304;
	// 821AE188: 93030008  stw r24, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 821AE18C: 396B4780  addi r11, r11, 0x4780
	ctx.r[11].s64 = ctx.r[11].s64 + 18304;
	// 821AE190: 9303000C  stw r24, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 821AE194: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AE198: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821AE19C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE1A0: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE1A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE1A8: 48386F50  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 821AE1AC: A16B0020  lhz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE1B0: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 821AE1B4: 4BFFFF5C  b 0x821ae110
	pc = 0x821AE110; continue 'dispatch;
	// 821AE1B8: A16B0020  lhz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE1BC: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 821AE1C0: 4BFFFFA4  b 0x821ae164
	pc = 0x821AE164; continue 'dispatch;
	// 821AE1C4: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821AE1C8: 41980090  blt cr6, 0x821ae258
	if ctx.cr[6].lt {
	pc = 0x821AE258; continue 'dispatch;
	}
	// 821AE1CC: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 821AE1D0: 41990088  bgt cr6, 0x821ae258
	if ctx.cr[6].gt {
	pc = 0x821AE258; continue 'dispatch;
	}
	// 821AE1D4: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 821AE1D8: 392BFFF6  addi r9, r11, -0xa
	ctx.r[9].s64 = ctx.r[11].s64 + -10;
	// 821AE1DC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AE1E0: 6108BEB8  ori r8, r8, 0xbeb8
	ctx.r[8].u64 = ctx.r[8].u64 | 48824;
	// 821AE1E4: 394AFB68  addi r10, r10, -0x498
	ctx.r[10].s64 = ctx.r[10].s64 + -1176;
	// 821AE1E8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE1EC: 7D1F422E  lhzx r8, r31, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821AE1F0: 7CA9502E  lwzx r5, r9, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AE1F4: 2B08002B  cmplwi cr6, r8, 0x2b
	ctx.cr[6].compare_u32(ctx.r[8].u32, 43 as u32, &mut ctx.xer);
	// 821AE1F8: 409A00C0  bne cr6, 0x821ae2b8
	if !ctx.cr[6].eq {
	pc = 0x821AE2B8; continue 'dispatch;
	}
	// 821AE1FC: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 821AE200: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821AE204: 40980008  bge cr6, 0x821ae20c
	if !ctx.cr[6].lt {
	pc = 0x821AE20C; continue 'dispatch;
	}
	// 821AE208: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821AE20C: 3D2B0001  addis r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 65536;
	// 821AE210: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821AE214: 39296104  addi r9, r9, 0x6104
	ctx.r[9].s64 = ctx.r[9].s64 + 24836;
	// 821AE218: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821AE21C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE220: 39050010  addi r8, r5, 0x10
	ctx.r[8].s64 = ctx.r[5].s64 + 16;
	// 821AE224: 394A42C0  addi r10, r10, 0x42c0
	ctx.r[10].s64 = ctx.r[10].s64 + 17088;
	// 821AE228: 396B4520  addi r11, r11, 0x4520
	ctx.r[11].s64 = ctx.r[11].s64 + 17696;
	// 821AE22C: 7C09FC2E  lfsx f0, r9, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE230: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821AE234: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AE238: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821AE23C: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 821AE240: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821AE244: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AE248: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE24C: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE250: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE254: 48386EA4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 821AE258: 2F0B001B  cmpwi cr6, r11, 0x1b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 27, &mut ctx.xer);
	// 821AE25C: 41980074  blt cr6, 0x821ae2d0
	if ctx.cr[6].lt {
	pc = 0x821AE2D0; continue 'dispatch;
	}
	// 821AE260: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821AE264: 4199006C  bgt cr6, 0x821ae2d0
	if ctx.cr[6].gt {
	pc = 0x821AE2D0; continue 'dispatch;
	}
	// 821AE268: 394BFFE5  addi r10, r11, -0x1b
	ctx.r[10].s64 = ctx.r[11].s64 + -27;
	// 821AE26C: 3D7F0002  addis r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 131072;
	// 821AE270: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 821AE274: 396B9CF0  addi r11, r11, -0x6310
	ctx.r[11].s64 = ctx.r[11].s64 + -25360;
	// 821AE278: 409800F4  bge cr6, 0x821ae36c
	if !ctx.cr[6].lt {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE27C: 392A001D  addi r9, r10, 0x1d
	ctx.r[9].s64 = ctx.r[10].s64 + 29;
	// 821AE280: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE284: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AE288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE28C: 419A00E0  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE290: A16B0020  lhz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE294: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE298: 388B0002  addi r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 2;
	// 821AE29C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 821AE2A0: 419A00CC  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE2A4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AE2A8: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE2AC: 396B0540  addi r11, r11, 0x540
	ctx.r[11].s64 = ctx.r[11].s64 + 1344;
	// 821AE2B0: 396B0800  addi r11, r11, 0x800
	ctx.r[11].s64 = ctx.r[11].s64 + 2048;
	// 821AE2B4: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AE2B8: 38C50010  addi r6, r5, 0x10
	ctx.r[6].s64 = ctx.r[5].s64 + 16;
	// 821AE2BC: 4BFF5B25  bl 0x821a3de0
	ctx.lr = 0x821AE2C0;
	sub_821A3DE0(ctx, base);
	// 821AE2C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE2C4: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE2C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE2CC: 48386E2C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 821AE2D0: 2F0B0023  cmpwi cr6, r11, 0x23
	ctx.cr[6].compare_i32(ctx.r[11].s32, 35, &mut ctx.xer);
	// 821AE2D4: 41980098  blt cr6, 0x821ae36c
	if ctx.cr[6].lt {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE2D8: 2F0B0025  cmpwi cr6, r11, 0x25
	ctx.cr[6].compare_i32(ctx.r[11].s32, 37, &mut ctx.xer);
	// 821AE2DC: 41990090  bgt cr6, 0x821ae36c
	if ctx.cr[6].gt {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE2E0: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AE2E4: 396BFFDD  addi r11, r11, -0x23
	ctx.r[11].s64 = ctx.r[11].s64 + -35;
	// 821AE2E8: 392A02B0  addi r9, r10, 0x2b0
	ctx.r[9].s64 = ctx.r[10].s64 + 688;
	// 821AE2EC: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE2F0: 39070004  addi r8, r7, 4
	ctx.r[8].s64 = ctx.r[7].s64 + 4;
	// 821AE2F4: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE2F8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AE2FC: 7D2A402E  lwzx r9, r10, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821AE300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE304: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821AE308: 9303000C  stw r24, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 821AE30C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821AE310: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AE314: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821AE318: 409A002C  bne cr6, 0x821ae344
	if !ctx.cr[6].eq {
	pc = 0x821AE344; continue 'dispatch;
	}
	// 821AE31C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821AE320: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821AE324: 394A4780  addi r10, r10, 0x4780
	ctx.r[10].s64 = ctx.r[10].s64 + 18304;
	// 821AE328: 396B4780  addi r11, r11, 0x4780
	ctx.r[11].s64 = ctx.r[11].s64 + 18304;
	// 821AE32C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AE330: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821AE334: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE338: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE33C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE340: 48386DB8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 821AE344: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821AE348: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821AE34C: 394A4830  addi r10, r10, 0x4830
	ctx.r[10].s64 = ctx.r[10].s64 + 18480;
	// 821AE350: 396B4908  addi r11, r11, 0x4908
	ctx.r[11].s64 = ctx.r[11].s64 + 18696;
	// 821AE354: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AE358: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821AE35C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE360: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE364: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE368: 48386D90  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 821AE36C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AE370: 419A0028  beq cr6, 0x821ae398
	if ctx.cr[6].eq {
	pc = 0x821AE398; continue 'dispatch;
	}
	// 821AE374: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE378: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 821AE37C: 409A001C  bne cr6, 0x821ae398
	if !ctx.cr[6].eq {
	pc = 0x821AE398; continue 'dispatch;
	}
	// 821AE380: A17C0014  lhz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE384: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821AE388: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 821AE38C: 995C0019  stb r10, 0x19(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AE390: B17C0014  sth r11, 0x14(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 821AE394: 9B5C0025  stb r26, 0x25(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 821AE398: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AE39C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE3A0: 48386D58  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE3A8 size=176
    let mut pc: u32 = 0x821AE3A8;
    'dispatch: loop {
        match pc {
            0x821AE3A8 => {
    //   block [0x821AE3A8..0x821AE458)
	// 821AE3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE3B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE3B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE3B8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AE3BC: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AE3C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AE3C4: 419A000C  beq cr6, 0x821ae3d0
	if ctx.cr[6].eq {
	pc = 0x821AE3D0; continue 'dispatch;
	}
	// 821AE3C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AE3CC: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 821AE3D0: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AE3D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AE3D8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AE3DC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE3E0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AE3E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE3E8: 4E800421  bctrl
	ctx.lr = 0x821AE3EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE3EC: A17F00C2  lhz r11, 0xc2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(194 as u32) ) } as u64;
	// 821AE3F0: 393F0090  addi r9, r31, 0x90
	ctx.r[9].s64 = ctx.r[31].s64 + 144;
	// 821AE3F4: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE3F8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE3FC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821AE400: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AE404: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821AE408: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821AE40C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821AE410: 390B0020  addi r8, r11, 0x20
	ctx.r[8].s64 = ctx.r[11].s64 + 32;
	// 821AE414: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 821AE418: 55062036  slwi r6, r8, 4
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AE41C: 54882036  slwi r8, r4, 4
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AE420: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE424: B0BF00C2  sth r5, 0xc2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(194 as u32), ctx.r[5].u16 ) };
	// 821AE428: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE42C: 7CC65214  add r6, r6, r10
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 821AE430: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AE434: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE438: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821AE43C: 4E800421  bctrl
	ctx.lr = 0x821AE440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE440: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AE444: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AE448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE44C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE450: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE454: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE458 size=180
    let mut pc: u32 = 0x821AE458;
    'dispatch: loop {
        match pc {
            0x821AE458 => {
    //   block [0x821AE458..0x821AE50C)
	// 821AE458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE464: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE468: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AE46C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AE470: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AE474: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AE478: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821AE47C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE480: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AE484: 419A0070  beq cr6, 0x821ae4f4
	if ctx.cr[6].eq {
	pc = 0x821AE4F4; continue 'dispatch;
	}
	// 821AE488: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AE48C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AE490: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE494: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE498: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE49C: 4E800421  bctrl
	ctx.lr = 0x821AE4A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE4A0: A17F00C2  lhz r11, 0xc2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(194 as u32) ) } as u64;
	// 821AE4A4: 393F0090  addi r9, r31, 0x90
	ctx.r[9].s64 = ctx.r[31].s64 + 144;
	// 821AE4A8: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE4AC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE4B0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821AE4B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AE4B8: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821AE4BC: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821AE4C0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821AE4C4: 390B0020  addi r8, r11, 0x20
	ctx.r[8].s64 = ctx.r[11].s64 + 32;
	// 821AE4C8: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 821AE4CC: 55062036  slwi r6, r8, 4
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AE4D0: 54882036  slwi r8, r4, 4
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AE4D4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE4D8: B0BF00C2  sth r5, 0xc2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(194 as u32), ctx.r[5].u16 ) };
	// 821AE4DC: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE4E0: 7CC65214  add r6, r6, r10
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 821AE4E4: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AE4E8: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE4EC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821AE4F0: 4E800421  bctrl
	ctx.lr = 0x821AE4F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE4F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AE4F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AE4FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE504: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE510 size=164
    let mut pc: u32 = 0x821AE510;
    'dispatch: loop {
        match pc {
            0x821AE510 => {
    //   block [0x821AE510..0x821AE5B4)
	// 821AE510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE518: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE51C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE520: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AE524: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AE528: 389F00C4  addi r4, r31, 0xc4
	ctx.r[4].s64 = ctx.r[31].s64 + 196;
	// 821AE52C: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE534: 419A0014  beq cr6, 0x821ae548
	if ctx.cr[6].eq {
	pc = 0x821AE548; continue 'dispatch;
	}
	// 821AE538: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AE53C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AE540: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AE544: 4BFF3B3D  bl 0x821a2080
	ctx.lr = 0x821AE548;
	sub_821A2080(ctx, base);
	// 821AE548: A17F00C0  lhz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AE54C: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AE550: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE554: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE558: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AE55C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE560: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE564: 3D4B0006  addis r10, r11, 6
	ctx.r[10].s64 = ctx.r[11].s64 + 393216;
	// 821AE568: 394AA578  addi r10, r10, -0x5a88
	ctx.r[10].s64 = ctx.r[10].s64 + -23176;
	// 821AE56C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE574: 419A0014  beq cr6, 0x821ae588
	if ctx.cr[6].eq {
	pc = 0x821AE588; continue 'dispatch;
	}
	// 821AE578: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE57C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE580: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AE584: 419A0008  beq cr6, 0x821ae58c
	if ctx.cr[6].eq {
	pc = 0x821AE58C; continue 'dispatch;
	}
	// 821AE588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AE58C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821AE590: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AE594: 409A000C  bne cr6, 0x821ae5a0
	if !ctx.cr[6].eq {
	pc = 0x821AE5A0; continue 'dispatch;
	}
	// 821AE598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AE59C: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821AE5A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AE5A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE5A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE5AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE5B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE5B8 size=188
    let mut pc: u32 = 0x821AE5B8;
    'dispatch: loop {
        match pc {
            0x821AE5B8 => {
    //   block [0x821AE5B8..0x821AE674)
	// 821AE5B8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821AE5BC: 551F07FE  clrlwi r31, r8, 0x1f
	ctx.r[31].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 821AE5C0: 80E400C4  lwz r7, 0xc4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE5C4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AE5C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AE5CC: 409A0024  bne cr6, 0x821ae5f0
	if !ctx.cr[6].eq {
	pc = 0x821AE5F0; continue 'dispatch;
	}
	// 821AE5D0: 54A92036  slwi r9, r5, 4
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE5D4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821AE5D8: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 821AE5DC: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 821AE5E0: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821AE5E4: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821AE5E8: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821AE5EC: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821AE5F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AE5F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE5F8: 40990040  ble cr6, 0x821ae638
	if !ctx.cr[6].gt {
	pc = 0x821AE638; continue 'dispatch;
	}
	// 821AE5FC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821AE600: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821AE604: 54A82036  slwi r8, r5, 4
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AE608: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 821AE60C: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 821AE610: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AE614: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821AE618: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821AE61C: 54A5073E  clrlwi r5, r5, 0x1c
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 821AE620: E8880000  ld r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821AE624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE628: F8890000  std r4, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 821AE62C: E9080008  ld r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821AE630: F9090008  std r8, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 821AE634: 409AFFD0  bne cr6, 0x821ae604
	if !ctx.cr[6].eq {
	pc = 0x821AE604; continue 'dispatch;
	}
	// 821AE638: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AE63C: 409A0030  bne cr6, 0x821ae66c
	if !ctx.cr[6].eq {
	pc = 0x821AE66C; continue 'dispatch;
	}
	// 821AE640: 3965FFFF  addi r11, r5, -1
	ctx.r[11].s64 = ctx.r[5].s64 + -1;
	// 821AE644: 54CA2036  slwi r10, r6, 4
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE648: 556B2636  rlwinm r11, r11, 4, 0x18, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821AE64C: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 821AE650: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821AE654: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821AE658: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821AE65C: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821AE660: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821AE664: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821AE668: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821AE66C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821AE670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AE678 size=804
    let mut pc: u32 = 0x821AE678;
    'dispatch: loop {
        match pc {
            0x821AE678 => {
    //   block [0x821AE678..0x821AE99C)
	// 821AE678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE67C: 48386A3D  bl 0x825350b8
	ctx.lr = 0x821AE680;
	sub_82535080(ctx, base);
	// 821AE680: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AE684: 810400C4  lwz r8, 0xc4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE688: 54E707FE  clrlwi r7, r7, 0x1f
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821AE68C: 38880100  addi r4, r8, 0x100
	ctx.r[4].s64 = ctx.r[8].s64 + 256;
	// 821AE690: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE694: 3B86FFFF  addi r28, r6, -1
	ctx.r[28].s64 = ctx.r[6].s64 + -1;
	// 821AE698: C1AB1FF8  lfs f13, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AE69C: 409A0008  bne cr6, 0x821ae6a4
	if !ctx.cr[6].eq {
	pc = 0x821AE6A4; continue 'dispatch;
	}
	// 821AE6A0: 3B860001  addi r28, r6, 1
	ctx.r[28].s64 = ctx.r[6].s64 + 1;
	// 821AE6A4: 7F8B07B4  extsw r11, r28
	ctx.r[11].s64 = ctx.r[28].s32 as i64;
	// 821AE6A8: 395C0001  addi r10, r28, 1
	ctx.r[10].s64 = ctx.r[28].s64 + 1;
	// 821AE6AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AE6B0: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821AE6B4: F961FFD0  std r11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u64 ) };
	// 821AE6B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AE6BC: C801FFD0  lfd f0, -0x30(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821AE6C0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AE6C4: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AE6C8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE6CC: ED406024  fdivs f10, f0, f12
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 821AE6D0: 41980224  blt cr6, 0x821ae8f4
	if ctx.cr[6].lt {
	pc = 0x821AE8F4; continue 'dispatch;
	}
	// 821AE6D4: 3BBCFFFD  addi r29, r28, -3
	ctx.r[29].s64 = ctx.r[28].s64 + -3;
	// 821AE6D8: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 821AE6DC: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 821AE6E0: ED8D0372  fmuls f12, f13, f13
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE6E4: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE6E8: ED6A682A  fadds f11, f10, f13
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 821AE6EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE6F0: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821AE6F4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AE6F8: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE6FC: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE700: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE704: ED8C037C  fnmsubs f12, f12, f13, f0
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE708: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE70C: D0CBFFF8  stfs f6, -8(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821AE710: C0CA0008  lfs f6, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE714: C0AA0000  lfs f5, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE718: EDA06028  fsubs f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AE71C: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE720: ED080332  fmuls f8, f8, f12
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE724: ED870332  fmuls f12, f7, f12
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE728: C0EA0004  lfs f7, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE72C: ED274B7A  fmadds f9, f7, f13, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE730: ED06437A  fmadds f8, f6, f13, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE734: EDA5637A  fmadds f13, f5, f13, f12
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 821AE738: D1ABFFEC  stfs f13, -0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 821AE73C: D12BFFF0  stfs f9, -0x10(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821AE740: D10BFFF4  stfs f8, -0xc(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AE744: 409A0014  bne cr6, 0x821ae758
	if !ctx.cr[6].eq {
	pc = 0x821AE758; continue 'dispatch;
	}
	// 821AE748: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AE74C: 419A0014  beq cr6, 0x821ae760
	if ctx.cr[6].eq {
	pc = 0x821AE760; continue 'dispatch;
	}
	// 821AE750: 7F1E3000  cmpw cr6, r30, r6
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE754: 4098000C  bge cr6, 0x821ae760
	if !ctx.cr[6].lt {
	pc = 0x821AE760; continue 'dispatch;
	}
	// 821AE758: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821AE75C: 5545073E  clrlwi r5, r10, 0x1c
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821AE760: EDAB02F2  fmuls f13, f11, f11
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 821AE764: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE768: ED8A582A  fadds f12, f10, f11
	ctx.f[12].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 821AE76C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE770: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821AE774: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AE778: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE77C: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE780: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE784: EDAD02FC  fnmsubs f13, f13, f11, f0
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE788: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE78C: D0CB0008  stfs f6, 8(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AE790: C0AA0000  lfs f5, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE794: C0CA0008  lfs f6, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE798: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AE79C: ED290372  fmuls f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE7A0: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE7A4: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE7A8: C0EA0004  lfs f7, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE7AC: ED274AFA  fmadds f9, f7, f11, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE7B0: ED0642FA  fmadds f8, f6, f11, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE7B4: EDA56AFA  fmadds f13, f5, f11, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AE7B8: D1ABFFFC  stfs f13, -4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AE7BC: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AE7C0: D10B0004  stfs f8, 4(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AE7C4: 409A0014  bne cr6, 0x821ae7d8
	if !ctx.cr[6].eq {
	pc = 0x821AE7D8; continue 'dispatch;
	}
	// 821AE7C8: 355FFFFF  addic. r10, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AE7CC: 41820014  beq 0x821ae7e0
	if ctx.cr[0].eq {
	pc = 0x821AE7E0; continue 'dispatch;
	}
	// 821AE7D0: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE7D4: 4098000C  bge cr6, 0x821ae7e0
	if !ctx.cr[6].lt {
	pc = 0x821AE7E0; continue 'dispatch;
	}
	// 821AE7D8: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821AE7DC: 5545073E  clrlwi r5, r10, 0x1c
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821AE7E0: EDAC0332  fmuls f13, f12, f12
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE7E4: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE7E8: ED6A602A  fadds f11, f10, f12
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 821AE7EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE7F0: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821AE7F4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AE7F8: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE7FC: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE800: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE804: EDAD033C  fnmsubs f13, f13, f12, f0
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE808: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE80C: D0CB0018  stfs f6, 0x18(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821AE810: C0AA0000  lfs f5, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE814: C0CA0008  lfs f6, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE818: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AE81C: ED290372  fmuls f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE820: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE824: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE828: C0EA0004  lfs f7, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE82C: ED274B3A  fmadds f9, f7, f12, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE830: ED06433A  fmadds f8, f6, f12, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[12].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE834: EDA56B3A  fmadds f13, f5, f12, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AE838: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AE83C: D12B0010  stfs f9, 0x10(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AE840: D10B0014  stfs f8, 0x14(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821AE844: 409A0014  bne cr6, 0x821ae858
	if !ctx.cr[6].eq {
	pc = 0x821AE858; continue 'dispatch;
	}
	// 821AE848: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821AE84C: 419A0014  beq cr6, 0x821ae860
	if ctx.cr[6].eq {
	pc = 0x821AE860; continue 'dispatch;
	}
	// 821AE850: 7F1F3000  cmpw cr6, r31, r6
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE854: 4098000C  bge cr6, 0x821ae860
	if !ctx.cr[6].lt {
	pc = 0x821AE860; continue 'dispatch;
	}
	// 821AE858: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821AE85C: 5545073E  clrlwi r5, r10, 0x1c
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821AE860: EDAB02F2  fmuls f13, f11, f11
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 821AE864: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE868: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE86C: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821AE870: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AE874: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE878: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE87C: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE880: ED8D02FC  fnmsubs f12, f13, f11, f0
	ctx.f[12].f64 = -(((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE884: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE888: EDAA582A  fadds f13, f10, f11
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 821AE88C: D0CB0028  stfs f6, 0x28(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821AE890: C0AA0000  lfs f5, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE894: C0CA0008  lfs f6, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE898: ED606028  fsubs f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AE89C: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE8A0: ED080332  fmuls f8, f8, f12
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE8A4: ED870332  fmuls f12, f7, f12
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE8A8: C0EA0004  lfs f7, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE8AC: ED274AFA  fmadds f9, f7, f11, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE8B0: ED0642FA  fmadds f8, f6, f11, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE8B4: ED8562FA  fmadds f12, f5, f11, f12
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 821AE8B8: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AE8BC: D12B0020  stfs f9, 0x20(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821AE8C0: D10B0024  stfs f8, 0x24(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821AE8C4: 409A0014  bne cr6, 0x821ae8d8
	if !ctx.cr[6].eq {
	pc = 0x821AE8D8; continue 'dispatch;
	}
	// 821AE8C8: 355F0001  addic. r10, r31, 1
	ctx.xer.ca = (ctx.r[31].u32 > (!(1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AE8CC: 41820014  beq 0x821ae8e0
	if ctx.cr[0].eq {
	pc = 0x821AE8E0; continue 'dispatch;
	}
	// 821AE8D0: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE8D4: 4098000C  bge cr6, 0x821ae8e0
	if !ctx.cr[6].lt {
	pc = 0x821AE8E0; continue 'dispatch;
	}
	// 821AE8D8: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821AE8DC: 5545073E  clrlwi r5, r10, 0x1c
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821AE8E0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821AE8E4: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821AE8E8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821AE8EC: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821AE8F0: 4099FDF0  ble cr6, 0x821ae6e0
	if !ctx.cr[6].gt {
	pc = 0x821AE6E0; continue 'dispatch;
	}
	// 821AE8F4: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821AE8F8: 419900A0  bgt cr6, 0x821ae998
	if ctx.cr[6].gt {
	pc = 0x821AE998; continue 'dispatch;
	}
	// 821AE8FC: 57CB2036  slwi r11, r30, 4
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE900: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821AE904: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 821AE908: ED8D0372  fmuls f12, f13, f13
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE90C: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE910: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE914: 7D2B2214  add r9, r11, r4
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 821AE918: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821AE91C: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE920: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE924: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE928: ED8C037C  fnmsubs f12, f12, f13, f0
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE92C: C0CB000C  lfs f6, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE930: D0CA0008  stfs f6, 8(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AE934: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 821AE938: C0CB0008  lfs f6, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE93C: C0AB0000  lfs f5, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE940: ED606028  fsubs f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AE944: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE948: ED080332  fmuls f8, f8, f12
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE94C: ED870332  fmuls f12, f7, f12
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE950: C0EB0004  lfs f7, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE954: ED274AFA  fmadds f9, f7, f11, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE958: D12A0000  stfs f9, 0(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AE95C: ED0642FA  fmadds f8, f6, f11, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE960: D10A0004  stfs f8, 4(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AE964: ED8562FA  fmadds f12, f5, f11, f12
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 821AE968: D18AFFFC  stfs f12, -4(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AE96C: 409A0014  bne cr6, 0x821ae980
	if !ctx.cr[6].eq {
	pc = 0x821AE980; continue 'dispatch;
	}
	// 821AE970: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AE974: 419A0014  beq cr6, 0x821ae988
	if ctx.cr[6].eq {
	pc = 0x821AE988; continue 'dispatch;
	}
	// 821AE978: 7F1E3000  cmpw cr6, r30, r6
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE97C: 4098000C  bge cr6, 0x821ae988
	if !ctx.cr[6].lt {
	pc = 0x821AE988; continue 'dispatch;
	}
	// 821AE980: 39650001  addi r11, r5, 1
	ctx.r[11].s64 = ctx.r[5].s64 + 1;
	// 821AE984: 5565073E  clrlwi r5, r11, 0x1c
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821AE988: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821AE98C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821AE990: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821AE994: 4099FF74  ble cr6, 0x821ae908
	if !ctx.cr[6].gt {
	pc = 0x821AE908; continue 'dispatch;
	}
	// 821AE998: 48386770  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE9A0 size=344
    let mut pc: u32 = 0x821AE9A0;
    'dispatch: loop {
        match pc {
            0x821AE9A0 => {
    //   block [0x821AE9A0..0x821AEAF8)
	// 821AE9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE9A4: 48386711  bl 0x825350b4
	ctx.lr = 0x821AE9A8;
	sub_82535080(ctx, base);
	// 821AE9A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE9AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE9B0: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821AE9B4: 7FAB0734  extsh r11, r29
	ctx.r[11].s64 = ctx.r[29].s16 as i64;
	// 821AE9B8: 6148A578  ori r8, r10, 0xa578
	ctx.r[8].u64 = ctx.r[10].u64 | 42360;
	// 821AE9BC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE9C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AE9C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE9C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821AE9CC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE9D0: 7F6BF214  add r27, r11, r30
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AE9D4: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 821AE9D8: 7D7B402A  ldx r11, r27, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[8].u32)) };
	// 821AE9DC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AE9E0: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AE9E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AE9E8: 419A0014  beq cr6, 0x821ae9fc
	if ctx.cr[6].eq {
	pc = 0x821AE9FC; continue 'dispatch;
	}
	// 821AE9EC: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE9F0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AE9F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AE9F8: 419A002C  beq cr6, 0x821aea24
	if ctx.cr[6].eq {
	pc = 0x821AEA24; continue 'dispatch;
	}
	// 821AE9FC: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 821AEA00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821AEA04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AEA08: 4BFFF491  bl 0x821ade98
	ctx.lr = 0x821AEA0C;
	sub_821ADE98(ctx, base);
	// 821AEA0C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821AEA10: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AEA14: 409A0010  bne cr6, 0x821aea24
	if !ctx.cr[6].eq {
	pc = 0x821AEA24; continue 'dispatch;
	}
	// 821AEA18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AEA1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821AEA20: 483866E4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 821AEA24: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AEA28: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821AEA2C: 38EB0F9C  addi r7, r11, 0xf9c
	ctx.r[7].s64 = ctx.r[11].s64 + 3996;
	// 821AEA30: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821AEA34: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AEA38: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 821AEA3C: 481BBA55  bl 0x8236a490
	ctx.lr = 0x821AEA40;
	sub_8236A490(ctx, base);
	// 821AEA40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AEA44: 419A0010  beq cr6, 0x821aea54
	if ctx.cr[6].eq {
	pc = 0x821AEA54; continue 'dispatch;
	}
	// 821AEA48: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AEA4C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821AEA50: 48000008  b 0x821aea58
	pc = 0x821AEA58; continue 'dispatch;
	// 821AEA54: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821AEA58: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821AEA5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AEA60: 419AFFB8  beq cr6, 0x821aea18
	if ctx.cr[6].eq {
	pc = 0x821AEA18; continue 'dispatch;
	}
	// 821AEA64: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AEA68: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821AEA6C: 396B0F7C  addi r11, r11, 0xf7c
	ctx.r[11].s64 = ctx.r[11].s64 + 3964;
	// 821AEA70: 394AF3A0  addi r10, r10, -0xc60
	ctx.r[10].s64 = ctx.r[10].s64 + -3168;
	// 821AEA74: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821AEA78: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 821AEA7C: 39297D58  addi r9, r9, 0x7d58
	ctx.r[9].s64 = ctx.r[9].s64 + 32088;
	// 821AEA80: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AEA84: 3D60821B  lis r11, -0x7de5
	ctx.r[11].s64 = -2112159744;
	// 821AEA88: FBE30110  std r31, 0x110(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[31].u64 ) };
	// 821AEA8C: FBE30118  std r31, 0x118(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), ctx.r[31].u64 ) };
	// 821AEA90: 390BF948  addi r8, r11, -0x6b8
	ctx.r[8].s64 = ctx.r[11].s64 + -1720;
	// 821AEA94: FBE30120  std r31, 0x120(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[31].u64 ) };
	// 821AEA98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEA9C: FBE30128  std r31, 0x128(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[31].u64 ) };
	// 821AEAA0: 91430058  stw r10, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821AEAA4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AEAA8: 91230054  stw r9, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821AEAAC: 9103005C  stw r8, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821AEAB0: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 821AEAB4: 98E30025  stb r7, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[7].u8 ) };
	// 821AEAB8: B14300AE  sth r10, 0xae(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(174 as u32), ctx.r[10].u16 ) };
	// 821AEABC: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821AEAC0: 93C30080  stw r30, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 821AEAC4: B3A300AA  sth r29, 0xaa(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(170 as u32), ctx.r[29].u16 ) };
	// 821AEAC8: 614AA580  ori r10, r10, 0xa580
	ctx.r[10].u64 = ctx.r[10].u64 | 42368;
	// 821AEACC: FBE30120  std r31, 0x120(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[31].u64 ) };
	// 821AEAD0: FBE30128  std r31, 0x128(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[31].u64 ) };
	// 821AEAD4: B3E300AC  sth r31, 0xac(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[31].u16 ) };
	// 821AEAD8: 811C0010  lwz r8, 0x10(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AEADC: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AEAE0: A10800C2  lhz r8, 0xc2(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(194 as u32) ) } as u64;
	// 821AEAE4: B16300A8  sth r11, 0xa8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[11].u16 ) };
	// 821AEAE8: B10300A4  sth r8, 0xa4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[8].u16 ) };
	// 821AEAEC: 7D3B512A  stdx r9, r27, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u64) };
	// 821AEAF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821AEAF4: 48386610  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AEAF8 size=356
    let mut pc: u32 = 0x821AEAF8;
    'dispatch: loop {
        match pc {
            0x821AEAF8 => {
    //   block [0x821AEAF8..0x821AEC5C)
	// 821AEAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEAFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AEB00: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 821AEB04: 483874E5  bl 0x82535fe8
	ctx.lr = 0x821AEB08;
	sub_82535FB0(ctx, base);
	// 821AEB08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AEB0C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AEB10: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 821AEB14: 7CC60734  extsh r6, r6
	ctx.r[6].s64 = ctx.r[6].s16 as i64;
	// 821AEB18: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 821AEB1C: 6167BEBC  ori r7, r11, 0xbebc
	ctx.r[7].u64 = ctx.r[11].u64 | 48828;
	// 821AEB20: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821AEB24: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AEB28: 2F060100  cmpwi cr6, r6, 0x100
	ctx.cr[6].compare_i32(ctx.r[6].s32, 256, &mut ctx.xer);
	// 821AEB2C: 392BA510  addi r9, r11, -0x5af0
	ctx.r[9].s64 = ctx.r[11].s64 + -23280;
	// 821AEB30: 40980034  bge cr6, 0x821aeb64
	if !ctx.cr[6].lt {
	pc = 0x821AEB64; continue 'dispatch;
	}
	// 821AEB34: 7CAA0734  extsh r10, r5
	ctx.r[10].s64 = ctx.r[5].s16 as i64;
	// 821AEB38: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEB3C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AEB40: 396BFADC  addi r11, r11, -0x524
	ctx.r[11].s64 = ctx.r[11].s64 + -1316;
	// 821AEB44: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEB48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEB4C: 409A002C  bne cr6, 0x821aeb78
	if !ctx.cr[6].eq {
	pc = 0x821AEB78; continue 'dispatch;
	}
	// 821AEB50: 7D643A2E  lhzx r11, r4, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821AEB54: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821AEB58: 556B303E  rotlwi r11, r11, 6
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(6)) as u64;
	// 821AEB5C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AEB60: 48000018  b 0x821aeb78
	pc = 0x821AEB78; continue 'dispatch;
	// 821AEB64: 3946FF00  addi r10, r6, -0x100
	ctx.r[10].s64 = ctx.r[6].s64 + -256;
	// 821AEB68: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821AEB6C: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AEB70: 396BB650  addi r11, r11, -0x49b0
	ctx.r[11].s64 = ctx.r[11].s64 + -18864;
	// 821AEB74: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AEB78: 2F0600FF  cmpwi cr6, r6, 0xff
	ctx.cr[6].compare_i32(ctx.r[6].s32, 255, &mut ctx.xer);
	// 821AEB7C: 409A001C  bne cr6, 0x821aeb98
	if !ctx.cr[6].eq {
	pc = 0x821AEB98; continue 'dispatch;
	}
	// 821AEB80: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AEB84: 409A0014  bne cr6, 0x821aeb98
	if !ctx.cr[6].eq {
	pc = 0x821AEB98; continue 'dispatch;
	}
	// 821AEB88: 7D443A2E  lhzx r10, r4, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821AEB8C: 554A303E  rotlwi r10, r10, 6
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(6)) as u64;
	// 821AEB90: 7FCA4C2E  lfsx f30, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821AEB94: 48000038  b 0x821aebcc
	pc = 0x821AEBCC; continue 'dispatch;
	// 821AEB98: 2F0600C0  cmpwi cr6, r6, 0xc0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 192, &mut ctx.xer);
	// 821AEB9C: 40980028  bge cr6, 0x821aebc4
	if !ctx.cr[6].lt {
	pc = 0x821AEBC4; continue 'dispatch;
	}
	// 821AEBA0: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 821AEBA4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AEBA8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AEBAC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AEBB0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AEBB4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AEBB8: C00A2050  lfs f0, 0x2050(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEBBC: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AEBC0: 4800000C  b 0x821aebcc
	pc = 0x821AEBCC; continue 'dispatch;
	// 821AEBC4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AEBC8: C3CA2074  lfs f30, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821AEBCC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821AEBD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AEBD4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AEBD8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AEBDC: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEBE0: 2F0600C0  cmpwi cr6, r6, 0xc0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 192, &mut ctx.xer);
	// 821AEBE4: EC800732  fmuls f4, f0, f28
	ctx.f[4].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 821AEBE8: 419A0028  beq cr6, 0x821aec10
	if ctx.cr[6].eq {
	pc = 0x821AEC10; continue 'dispatch;
	}
	// 821AEBEC: 2F0600C1  cmpwi cr6, r6, 0xc1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 193, &mut ctx.xer);
	// 821AEBF0: 419A0020  beq cr6, 0x821aec10
	if ctx.cr[6].eq {
	pc = 0x821AEC10; continue 'dispatch;
	}
	// 821AEBF4: 2F0600C2  cmpwi cr6, r6, 0xc2
	ctx.cr[6].compare_i32(ctx.r[6].s32, 194, &mut ctx.xer);
	// 821AEBF8: 409A000C  bne cr6, 0x821aec04
	if !ctx.cr[6].eq {
	pc = 0x821AEC04; continue 'dispatch;
	}
	// 821AEBFC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821AEC00: 41980010  blt cr6, 0x821aec10
	if ctx.cr[6].lt {
	pc = 0x821AEC10; continue 'dispatch;
	}
	// 821AEC04: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEC08: EC5D0032  fmuls f2, f29, f0
	ctx.f[2].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AEC0C: 48000008  b 0x821aec14
	pc = 0x821AEC14; continue 'dispatch;
	// 821AEC10: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821AEC14: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 821AEC18: 4198000C  blt cr6, 0x821aec24
	if ctx.cr[6].lt {
	pc = 0x821AEC24; continue 'dispatch;
	}
	// 821AEC1C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821AEC20: 48000008  b 0x821aec28
	pc = 0x821AEC28; continue 'dispatch;
	// 821AEC24: C028FFFC  lfs f1, -4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AEC28: C0680004  lfs f3, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821AEC2C: 481C218D  bl 0x82370db8
	ctx.lr = 0x821AEC30;
	sub_82370DB8(ctx, base);
	// 821AEC30: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821AEC34: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 821AEC38: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 821AEC3C: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 821AEC40: 4198FF9C  blt cr6, 0x821aebdc
	if ctx.cr[6].lt {
	pc = 0x821AEBDC; continue 'dispatch;
	}
	// 821AEC44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AEC48: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 821AEC4C: 483873E9  bl 0x82536034
	ctx.lr = 0x821AEC50;
	sub_82535FFC(ctx, base);
	// 821AEC50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AEC54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AEC58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AEC60 size=1028
    let mut pc: u32 = 0x821AEC60;
    'dispatch: loop {
        match pc {
            0x821AEC60 => {
    //   block [0x821AEC60..0x821AF064)
	// 821AEC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEC64: 48386441  bl 0x825350a4
	ctx.lr = 0x821AEC68;
	sub_82535080(ctx, base);
	// 821AEC68: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821AEC6C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AEC70: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821AEC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AEC78: 56EB07BC  rlwinm r11, r23, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 821AEC7C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821AEC80: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 821AEC84: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 821AEC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEC8C: 419A0370  beq cr6, 0x821aeffc
	if ctx.cr[6].eq {
	pc = 0x821AEFFC; continue 'dispatch;
	}
	// 821AEC90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AEC94: C1BF0084  lfs f13, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AEC98: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEC9C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821AECA0: 4099035C  ble cr6, 0x821aeffc
	if !ctx.cr[6].gt {
	pc = 0x821AEFFC; continue 'dispatch;
	}
	// 821AECA4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821AECA8: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 821AECAC: 616B91F4  ori r11, r11, 0x91f4
	ctx.r[11].u64 = ctx.r[11].u64 | 37364;
	// 821AECB0: 7D385A2E  lhzx r9, r24, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AECB4: 419A0018  beq cr6, 0x821aeccc
	if ctx.cr[6].eq {
	pc = 0x821AECCC; continue 'dispatch;
	}
	// 821AECB8: A17F00AE  lhz r11, 0xae(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(174 as u32) ) } as u64;
	// 821AECBC: 7D2A0734  extsh r10, r9
	ctx.r[10].s64 = ctx.r[9].s16 as i64;
	// 821AECC0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AECC4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821AECC8: 419A0334  beq cr6, 0x821aeffc
	if ctx.cr[6].eq {
	pc = 0x821AEFFC; continue 'dispatch;
	}
	// 821AECCC: 817F0124  lwz r11, 0x124(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 821AECD0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821AECD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AECD8: 419A004C  beq cr6, 0x821aed24
	if ctx.cr[6].eq {
	pc = 0x821AED24; continue 'dispatch;
	}
	// 821AECDC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AECE0: 811F0120  lwz r8, 0x120(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 821AECE4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AECE8: 409A003C  bne cr6, 0x821aed24
	if !ctx.cr[6].eq {
	pc = 0x821AED24; continue 'dispatch;
	}
	// 821AECEC: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AECF0: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AECF4: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AECF8: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AECFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AED00: 419A0020  beq cr6, 0x821aed20
	if ctx.cr[6].eq {
	pc = 0x821AED20; continue 'dispatch;
	}
	// 821AED04: 810A0030  lwz r8, 0x30(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AED08: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AED0C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AED10: 409A0010  bne cr6, 0x821aed20
	if !ctx.cr[6].eq {
	pc = 0x821AED20; continue 'dispatch;
	}
	// 821AED14: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AED18: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AED1C: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 821AED20: FB9F0120  std r28, 0x120(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[28].u64 ) };
	// 821AED24: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 821AED28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AED2C: 419A004C  beq cr6, 0x821aed78
	if ctx.cr[6].eq {
	pc = 0x821AED78; continue 'dispatch;
	}
	// 821AED30: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AED34: 811F0128  lwz r8, 0x128(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 821AED38: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AED3C: 409A003C  bne cr6, 0x821aed78
	if !ctx.cr[6].eq {
	pc = 0x821AED78; continue 'dispatch;
	}
	// 821AED40: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AED44: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AED48: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AED4C: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AED50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AED54: 419A0020  beq cr6, 0x821aed74
	if ctx.cr[6].eq {
	pc = 0x821AED74; continue 'dispatch;
	}
	// 821AED58: 810A0030  lwz r8, 0x30(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AED5C: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AED60: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AED64: 409A0010  bne cr6, 0x821aed74
	if !ctx.cr[6].eq {
	pc = 0x821AED74; continue 'dispatch;
	}
	// 821AED68: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AED6C: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AED70: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 821AED74: FB9F0128  std r28, 0x128(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[28].u64 ) };
	// 821AED78: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 821AED7C: B13F00AE  sth r9, 0xae(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(174 as u32), ctx.r[9].u16 ) };
	// 821AED80: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AED84: 419A0064  beq cr6, 0x821aede8
	if ctx.cr[6].eq {
	pc = 0x821AEDE8; continue 'dispatch;
	}
	// 821AED88: 556A04A0  rlwinm r10, r11, 0, 0x12, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AED8C: 556B97FE  rlwinm r11, r11, 0x12, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 821AED90: 7D5A0734  extsh r26, r10
	ctx.r[26].s64 = ctx.r[10].s16 as i64;
	// 821AED94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AED98: 419A0054  beq cr6, 0x821aedec
	if ctx.cr[6].eq {
	pc = 0x821AEDEC; continue 'dispatch;
	}
	// 821AED9C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AEDA0: 616BED4E  ori r11, r11, 0xed4e
	ctx.r[11].u64 = ctx.r[11].u64 | 60750;
	// 821AEDA4: 7D785A2E  lhzx r11, r24, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEDA8: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 821AEDAC: 409A0040  bne cr6, 0x821aedec
	if !ctx.cr[6].eq {
	pc = 0x821AEDEC; continue 'dispatch;
	}
	// 821AEDB0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AEDB4: 3B200003  li r25, 3
	ctx.r[25].s64 = 3;
	// 821AEDB8: 616ABEBC  ori r10, r11, 0xbebc
	ctx.r[10].u64 = ctx.r[11].u64 | 48828;
	// 821AEDBC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AEDC0: 3B6000C1  li r27, 0xc1
	ctx.r[27].s64 = 193;
	// 821AEDC4: 3B400009  li r26, 9
	ctx.r[26].s64 = 9;
	// 821AEDC8: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AEDCC: D3FF008C  stfs f31, 0x8c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821AEDD0: 7D58522E  lhzx r10, r24, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AEDD4: 2B0A001B  cmplwi cr6, r10, 0x1b
	ctx.cr[6].compare_u32(ctx.r[10].u32, 27 as u32, &mut ctx.xer);
	// 821AEDD8: 409A0044  bne cr6, 0x821aee1c
	if !ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AEDDC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEDE0: 396B15A0  addi r11, r11, 0x15a0
	ctx.r[11].s64 = ctx.r[11].s64 + 5536;
	// 821AEDE4: 48000054  b 0x821aee38
	pc = 0x821AEE38; continue 'dispatch;
	// 821AEDE8: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	// 821AEDEC: 7F4B0734  extsh r11, r26
	ctx.r[11].s64 = ctx.r[26].s16 as i64;
	// 821AEDF0: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEDF4: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821AEDF8: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 821AEDFC: 4198000C  blt cr6, 0x821aee08
	if ctx.cr[6].lt {
	pc = 0x821AEE08; continue 'dispatch;
	}
	// 821AEE00: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821AEE04: 7D7A0734  extsh r26, r11
	ctx.r[26].s64 = ctx.r[11].s16 as i64;
	// 821AEE08: 7F4B0734  extsh r11, r26
	ctx.r[11].s64 = ctx.r[26].s16 as i64;
	// 821AEE0C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821AEE10: 41990100  bgt cr6, 0x821aef10
	if ctx.cr[6].gt {
	pc = 0x821AEF10; continue 'dispatch;
	}
	// 821AEE14: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 821AEE18: 48000108  b 0x821aef20
	pc = 0x821AEF20; continue 'dispatch;
	// 821AEE1C: 2B0A0023  cmplwi cr6, r10, 0x23
	ctx.cr[6].compare_u32(ctx.r[10].u32, 35 as u32, &mut ctx.xer);
	// 821AEE20: 409A0010  bne cr6, 0x821aee30
	if !ctx.cr[6].eq {
	pc = 0x821AEE30; continue 'dispatch;
	}
	// 821AEE24: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEE28: 396B1630  addi r11, r11, 0x1630
	ctx.r[11].s64 = ctx.r[11].s64 + 5680;
	// 821AEE2C: 4800000C  b 0x821aee38
	pc = 0x821AEE38; continue 'dispatch;
	// 821AEE30: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEE34: 396B1528  addi r11, r11, 0x1528
	ctx.r[11].s64 = ctx.r[11].s64 + 5416;
	// 821AEE38: A13F00AA  lhz r9, 0xaa(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AEE3C: 2B0A000B  cmplwi cr6, r10, 0xb
	ctx.cr[6].compare_u32(ctx.r[10].u32, 11 as u32, &mut ctx.xer);
	// 821AEE40: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 821AEE44: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AEE48: 7FC9582E  lwzx r30, r9, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEE4C: 409A0010  bne cr6, 0x821aee5c
	if !ctx.cr[6].eq {
	pc = 0x821AEE5C; continue 'dispatch;
	}
	// 821AEE50: 2F1E0017  cmpwi cr6, r30, 0x17
	ctx.cr[6].compare_i32(ctx.r[30].s32, 23, &mut ctx.xer);
	// 821AEE54: 409A0008  bne cr6, 0x821aee5c
	if !ctx.cr[6].eq {
	pc = 0x821AEE5C; continue 'dispatch;
	}
	// 821AEE58: 3BC0001F  li r30, 0x1f
	ctx.r[30].s64 = 31;
	// 821AEE5C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AEE60: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821AEE64: 390000C1  li r8, 0xc1
	ctx.r[8].s64 = 193;
	// 821AEE68: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AEE6C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821AEE70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821AEE74: C02BD218  lfs f1, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AEE78: 3D600010  lis r11, 0x10
	ctx.r[11].s64 = 1048576;
	// 821AEE7C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AEE80: 617D0100  ori r29, r11, 0x100
	ctx.r[29].u64 = ctx.r[11].u64 | 256;
	// 821AEE84: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821AEE88: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821AEE8C: 4BFF1C3D  bl 0x821a0ac8
	ctx.lr = 0x821AEE90;
	sub_821A0AC8(ctx, base);
	// 821AEE90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AEE94: 39000400  li r8, 0x400
	ctx.r[8].s64 = 1024;
	// 821AEE98: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821AEE9C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AEEA0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821AEEA4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AEEA8: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 821AEEAC: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821AEEB0: 9381008C  stw r28, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 821AEEB4: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AEEB8: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 821AEEBC: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 821AEEC0: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 821AEEC4: C02A2068  lfs f1, 0x2068(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AEEC8: 3900007C  li r8, 0x7c
	ctx.r[8].s64 = 124;
	// 821AEECC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AEED0: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 821AEED4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821AEED8: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 821AEEDC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 821AEEE0: F97F0120  std r11, 0x120(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u64 ) };
	// 821AEEE4: 4BFFC275  bl 0x821ab158
	ctx.lr = 0x821AEEE8;
	sub_821AB158(ctx, base);
	// 821AEEE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AEEEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AEEF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AEEF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AEEF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AEEFC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821AEF00: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AEF04: F97F0128  std r11, 0x128(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u64 ) };
	// 821AEF08: 481B2201  bl 0x82361108
	ctx.lr = 0x821AEF0C;
	sub_82361108(ctx, base);
	// 821AEF0C: 480000BC  b 0x821aefc8
	pc = 0x821AEFC8; continue 'dispatch;
	// 821AEF10: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821AEF14: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 821AEF18: 40990008  ble cr6, 0x821aef20
	if !ctx.cr[6].gt {
	pc = 0x821AEF20; continue 'dispatch;
	}
	// 821AEF1C: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 821AEF20: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821AEF24: 419800A0  blt cr6, 0x821aefc4
	if ctx.cr[6].lt {
	pc = 0x821AEFC4; continue 'dispatch;
	}
	// 821AEF28: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AEF2C: 616BBEBC  ori r11, r11, 0xbebc
	ctx.r[11].u64 = ctx.r[11].u64 | 48828;
	// 821AEF30: 7D585A2E  lhzx r10, r24, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEF34: 2B0A001B  cmplwi cr6, r10, 0x1b
	ctx.cr[6].compare_u32(ctx.r[10].u32, 27 as u32, &mut ctx.xer);
	// 821AEF38: 409A0010  bne cr6, 0x821aef48
	if !ctx.cr[6].eq {
	pc = 0x821AEF48; continue 'dispatch;
	}
	// 821AEF3C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEF40: 396B15A0  addi r11, r11, 0x15a0
	ctx.r[11].s64 = ctx.r[11].s64 + 5536;
	// 821AEF44: 48000020  b 0x821aef64
	pc = 0x821AEF64; continue 'dispatch;
	// 821AEF48: 2B0A0023  cmplwi cr6, r10, 0x23
	ctx.cr[6].compare_u32(ctx.r[10].u32, 35 as u32, &mut ctx.xer);
	// 821AEF4C: 409A0010  bne cr6, 0x821aef5c
	if !ctx.cr[6].eq {
	pc = 0x821AEF5C; continue 'dispatch;
	}
	// 821AEF50: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEF54: 396B1630  addi r11, r11, 0x1630
	ctx.r[11].s64 = ctx.r[11].s64 + 5680;
	// 821AEF58: 4800000C  b 0x821aef64
	pc = 0x821AEF64; continue 'dispatch;
	// 821AEF5C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEF60: 396B1528  addi r11, r11, 0x1528
	ctx.r[11].s64 = ctx.r[11].s64 + 5416;
	// 821AEF64: A13F00AA  lhz r9, 0xaa(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AEF68: 2B0A000B  cmplwi cr6, r10, 0xb
	ctx.cr[6].compare_u32(ctx.r[10].u32, 11 as u32, &mut ctx.xer);
	// 821AEF6C: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 821AEF70: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AEF74: 7CA9582E  lwzx r5, r9, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEF78: 409A0010  bne cr6, 0x821aef88
	if !ctx.cr[6].eq {
	pc = 0x821AEF88; continue 'dispatch;
	}
	// 821AEF7C: 2F050017  cmpwi cr6, r5, 0x17
	ctx.cr[6].compare_i32(ctx.r[5].s32, 23, &mut ctx.xer);
	// 821AEF80: 409A0008  bne cr6, 0x821aef88
	if !ctx.cr[6].eq {
	pc = 0x821AEF88; continue 'dispatch;
	}
	// 821AEF84: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 821AEF88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AEF8C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821AEF90: 3D400010  lis r10, 0x10
	ctx.r[10].s64 = 1048576;
	// 821AEF94: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 821AEF98: 614A0100  ori r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 256;
	// 821AEF9C: 38E0000E  li r7, 0xe
	ctx.r[7].s64 = 14;
	// 821AEFA0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821AEFA4: C02BBA38  lfs f1, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AEFA8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AEFAC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821AEFB0: 4BFF1B19  bl 0x821a0ac8
	ctx.lr = 0x821AEFB4;
	sub_821A0AC8(ctx, base);
	// 821AEFB4: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AEFB8: 3B600080  li r27, 0x80
	ctx.r[27].s64 = 128;
	// 821AEFBC: F97F0120  std r11, 0x120(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u64 ) };
	// 821AEFC0: 48000008  b 0x821aefc8
	pc = 0x821AEFC8; continue 'dispatch;
	// 821AEFC4: 3B6000FF  li r27, 0xff
	ctx.r[27].s64 = 255;
	// 821AEFC8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEFCC: 395A0001  addi r10, r26, 1
	ctx.r[10].s64 = ctx.r[26].s64 + 1;
	// 821AEFD0: 396BFC10  addi r11, r11, -0x3f0
	ctx.r[11].s64 = ctx.r[11].s64 + -1008;
	// 821AEFD4: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821AEFD8: 392B0058  addi r9, r11, 0x58
	ctx.r[9].s64 = ctx.r[11].s64 + 88;
	// 821AEFDC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AEFE0: 56E8077A  rlwinm r8, r23, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 821AEFE4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AEFE8: 7C2A4C2E  lfsx f1, r10, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AEFEC: 419A0008  beq cr6, 0x821aeff4
	if ctx.cr[6].eq {
	pc = 0x821AEFF4; continue 'dispatch;
	}
	// 821AEFF0: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	// 821AEFF4: 7C4A5C2E  lfsx f2, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AEFF8: 48000018  b 0x821af010
	pc = 0x821AF010; continue 'dispatch;
	// 821AEFFC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AF000: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821AF004: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AF008: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821AF00C: 419A004C  beq cr6, 0x821af058
	if ctx.cr[6].eq {
	pc = 0x821AF058; continue 'dispatch;
	}
	// 821AF010: 7F2B0734  extsh r11, r25
	ctx.r[11].s64 = ctx.r[25].s16 as i64;
	// 821AF014: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AF018: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF01C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821AF020: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AF024: 394A1420  addi r10, r10, 0x1420
	ctx.r[10].s64 = ctx.r[10].s64 + 5152;
	// 821AF028: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AF02C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AF030: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821AF034: 396A00C0  addi r11, r10, 0xc0
	ctx.r[11].s64 = ctx.r[10].s64 + 192;
	// 821AF038: 419A0008  beq cr6, 0x821af040
	if ctx.cr[6].eq {
	pc = 0x821AF040; continue 'dispatch;
	}
	// 821AF03C: 396A0018  addi r11, r10, 0x18
	ctx.r[11].s64 = ctx.r[10].s64 + 24;
	// 821AF040: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821AF044: 917F00A0  stw r11, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821AF048: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AF04C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AF050: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 821AF054: 4BFFFAA5  bl 0x821aeaf8
	ctx.lr = 0x821AF058;
	sub_821AEAF8(ctx, base);
	// 821AF058: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821AF05C: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821AF060: 48386094  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AF068 size=544
    let mut pc: u32 = 0x821AF068;
    'dispatch: loop {
        match pc {
            0x821AF068 => {
    //   block [0x821AF068..0x821AF288)
	// 821AF068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AF06C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AF070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AF074: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AF078: 81630124  lwz r11, 0x124(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(292 as u32) ) } as u64;
	// 821AF07C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821AF080: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 821AF084: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 821AF088: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AF08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF090: 419A004C  beq cr6, 0x821af0dc
	if ctx.cr[6].eq {
	pc = 0x821AF0DC; continue 'dispatch;
	}
	// 821AF094: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF098: 80830120  lwz r4, 0x120(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 821AF09C: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821AF0A0: 409A003C  bne cr6, 0x821af0dc
	if !ctx.cr[6].eq {
	pc = 0x821AF0DC; continue 'dispatch;
	}
	// 821AF0A4: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF0A8: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF0AC: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AF0B0: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF0B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF0B8: 419A0020  beq cr6, 0x821af0d8
	if ctx.cr[6].eq {
	pc = 0x821AF0D8; continue 'dispatch;
	}
	// 821AF0BC: 808A0030  lwz r4, 0x30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF0C0: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF0C4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF0C8: 409A0010  bne cr6, 0x821af0d8
	if !ctx.cr[6].eq {
	pc = 0x821AF0D8; continue 'dispatch;
	}
	// 821AF0CC: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF0D0: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF0D4: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 821AF0D8: F9030120  std r8, 0x120(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[8].u64 ) };
	// 821AF0DC: 8163012C  lwz r11, 0x12c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) } as u64;
	// 821AF0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF0E4: 419A004C  beq cr6, 0x821af130
	if ctx.cr[6].eq {
	pc = 0x821AF130; continue 'dispatch;
	}
	// 821AF0E8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF0EC: 80830128  lwz r4, 0x128(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(296 as u32) ) } as u64;
	// 821AF0F0: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821AF0F4: 409A003C  bne cr6, 0x821af130
	if !ctx.cr[6].eq {
	pc = 0x821AF130; continue 'dispatch;
	}
	// 821AF0F8: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF0FC: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF100: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AF104: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF108: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF10C: 419A0020  beq cr6, 0x821af12c
	if ctx.cr[6].eq {
	pc = 0x821AF12C; continue 'dispatch;
	}
	// 821AF110: 808A0030  lwz r4, 0x30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF114: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF118: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF11C: 409A0010  bne cr6, 0x821af12c
	if !ctx.cr[6].eq {
	pc = 0x821AF12C; continue 'dispatch;
	}
	// 821AF120: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF124: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF128: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 821AF12C: F9030128  std r8, 0x128(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[8].u64 ) };
	// 821AF130: 552B0420  rlwinm r11, r9, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF134: 80830080  lwz r4, 0x80(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AF138: D023008C  stfs f1, 0x8c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821AF13C: 91030098  stw r8, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[8].u32 ) };
	// 821AF140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF144: D0230088  stfs f1, 0x88(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821AF148: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AF14C: C00B294C  lfs f0, 0x294c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF150: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821AF154: 419A000C  beq cr6, 0x821af160
	if ctx.cr[6].eq {
	pc = 0x821AF160; continue 'dispatch;
	}
	// 821AF158: 60A50008  ori r5, r5, 8
	ctx.r[5].u64 = ctx.r[5].u64 | 8;
	// 821AF15C: 5529047E  clrlwi r9, r9, 0x11
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00007FFFu64;
	// 821AF160: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 821AF164: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821AF168: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AF16C: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 821AF170: C189BA38  lfs f12, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AF174: C16A1FF8  lfs f11, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF178: 409A009C  bne cr6, 0x821af214
	if !ctx.cr[6].eq {
	pc = 0x821AF214; continue 'dispatch;
	}
	// 821AF17C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AF180: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821AF184: 616BE2D4  ori r11, r11, 0xe2d4
	ctx.r[11].u64 = ctx.r[11].u64 | 58068;
	// 821AF188: 614AFAF0  ori r10, r10, 0xfaf0
	ctx.r[10].u64 = ctx.r[10].u64 | 64240;
	// 821AF18C: 7D64582E  lwzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AF190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF194: 419A0024  beq cr6, 0x821af1b8
	if ctx.cr[6].eq {
	pc = 0x821AF1B8; continue 'dispatch;
	}
	// 821AF198: A16B0038  lhz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AF19C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF1A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AF1A4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AF1A8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AF1AC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AF1B0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821AF1B4: 40980018  bge cr6, 0x821af1cc
	if !ctx.cr[6].lt {
	pc = 0x821AF1CC; continue 'dispatch;
	}
	// 821AF1B8: 7D64502E  lwzx r11, r4, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AF1BC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF1C0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF1C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF1C8: 48000060  b 0x821af228
	pc = 0x821AF228; continue 'dispatch;
	// 821AF1CC: A16300AA  lhz r11, 0xaa(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AF1D0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF1D4: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821AF1D8: 419A0020  beq cr6, 0x821af1f8
	if ctx.cr[6].eq {
	pc = 0x821AF1F8; continue 'dispatch;
	}
	// 821AF1DC: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 821AF1E0: 419A0018  beq cr6, 0x821af1f8
	if ctx.cr[6].eq {
	pc = 0x821AF1F8; continue 'dispatch;
	}
	// 821AF1E4: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 821AF1E8: 7D64502E  lwzx r11, r4, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AF1EC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF1F0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF1F4: 48000034  b 0x821af228
	pc = 0x821AF228; continue 'dispatch;
	// 821AF1F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AF1FC: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF200: 7D64502E  lwzx r11, r4, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AF204: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821AF208: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF20C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF210: 48000018  b 0x821af228
	pc = 0x821AF228; continue 'dispatch;
	// 821AF214: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF218: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AF21C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AF220: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AF224: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AF228: D1830090  stfs f12, 0x90(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821AF22C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821AF230: 41990008  bgt cr6, 0x821af238
	if ctx.cr[6].gt {
	pc = 0x821AF238; continue 'dispatch;
	}
	// 821AF234: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 821AF238: 7FEB0734  extsh r11, r31
	ctx.r[11].s64 = ctx.r[31].s16 as i64;
	// 821AF23C: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821AF240: 90A300B0  stw r5, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[5].u32 ) };
	// 821AF244: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AF248: 41990008  bgt cr6, 0x821af250
	if ctx.cr[6].gt {
	pc = 0x821AF250; continue 'dispatch;
	}
	// 821AF24C: 3BE0000A  li r31, 0xa
	ctx.r[31].s64 = 10;
	// 821AF250: 7FEB0734  extsh r11, r31
	ctx.r[11].s64 = ctx.r[31].s16 as i64;
	// 821AF254: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 821AF258: 40990008  ble cr6, 0x821af260
	if !ctx.cr[6].gt {
	pc = 0x821AF260; continue 'dispatch;
	}
	// 821AF25C: 3BE0000E  li r31, 0xe
	ctx.r[31].s64 = 14;
	// 821AF260: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821AF264: B3E300A6  sth r31, 0xa6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(166 as u32), ctx.r[31].u16 ) };
	// 821AF268: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 821AF26C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821AF270: 4BFFF9F1  bl 0x821aec60
	ctx.lr = 0x821AF274;
	sub_821AEC60(ctx, base);
	// 821AF274: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AF278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AF27C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AF280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AF284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AF288 size=240
    let mut pc: u32 = 0x821AF288;
    'dispatch: loop {
        match pc {
            0x821AF288 => {
    //   block [0x821AF288..0x821AF378)
	// 821AF288: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AF28C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821AF290: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 821AF294: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 821AF298: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF29C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821AF2A0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AF2A4: 40990058  ble cr6, 0x821af2fc
	if !ctx.cr[6].gt {
	pc = 0x821AF2FC; continue 'dispatch;
	}
	// 821AF2A8: 3924FFFF  addi r9, r4, -1
	ctx.r[9].s64 = ctx.r[4].s64 + -1;
	// 821AF2AC: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF2B0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821AF2B4: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF2B8: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF2BC: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AF2C0: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AF2C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF2C8: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AF2CC: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF2D0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AF2D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF2D8: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821AF2DC: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AF2E0: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AF2E4: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AF2E8: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 821AF2EC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821AF2F0: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AF2F4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AF2F8: 409AFFB4  bne cr6, 0x821af2ac
	if !ctx.cr[6].eq {
	pc = 0x821AF2AC; continue 'dispatch;
	}
	// 821AF2FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AF300: 3944FFFF  addi r10, r4, -1
	ctx.r[10].s64 = ctx.r[4].s64 + -1;
	// 821AF304: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF308: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821AF30C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF310: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821AF314: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821AF318: 41980058  blt cr6, 0x821af370
	if ctx.cr[6].lt {
	pc = 0x821AF370; continue 'dispatch;
	}
	// 821AF31C: 3944FFFB  addi r10, r4, -5
	ctx.r[10].s64 = ctx.r[4].s64 + -5;
	// 821AF320: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF324: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF328: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF32C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821AF330: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF334: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821AF338: C18B001C  lfs f12, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AF33C: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AF340: C16B002C  lfs f11, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF344: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AF348: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AF34C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AF350: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AF354: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AF358: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AF35C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF360: D16B002C  stfs f11, 0x2c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821AF364: D14B003C  stfs f10, 0x3c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821AF368: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821AF36C: 409AFFC4  bne cr6, 0x821af330
	if !ctx.cr[6].eq {
	pc = 0x821AF330; continue 'dispatch;
	}
	// 821AF370: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821AF374: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AF378 size=40
    let mut pc: u32 = 0x821AF378;
    'dispatch: loop {
        match pc {
            0x821AF378 => {
    //   block [0x821AF378..0x821AF3A0)
	// 821AF378: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821AF37C: 7D492050  subf r10, r9, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 821AF380: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF384: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821AF388: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AF38C: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AF390: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AF394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF398: 409AFFE8  bne cr6, 0x821af380
	if !ctx.cr[6].eq {
	pc = 0x821AF380; continue 'dispatch;
	}
	// 821AF39C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AF3A0 size=1444
    let mut pc: u32 = 0x821AF3A0;
    'dispatch: loop {
        match pc {
            0x821AF3A0 => {
    //   block [0x821AF3A0..0x821AF944)
	// 821AF3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AF3A4: 48385CE9  bl 0x8253508c
	ctx.lr = 0x821AF3A8;
	sub_82535080(ctx, base);
	// 821AF3A8: DBE1FF78  stfd f31, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 821AF3AC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AF3B0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AF3B4: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 821AF3B8: 83CBFAC0  lwz r30, -0x540(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AF3BC: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AF3C0: 923E0040  stw r17, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[17].u32 ) };
	// 821AF3C4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF3C8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AF3CC: 419A0558  beq cr6, 0x821af924
	if ctx.cr[6].eq {
	pc = 0x821AF924; continue 'dispatch;
	}
	// 821AF3D0: 825E0080  lwz r18, 0x80(r30)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AF3D4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AF3D8: 82BE00B0  lwz r21, 0xb0(r30)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AF3DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF3E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AF3E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AF3E8: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 821AF3EC: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 821AF3F0: 4BFFF871  bl 0x821aec60
	ctx.lr = 0x821AF3F4;
	sub_821AEC60(ctx, base);
	// 821AF3F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AF3F8: 82FE0010  lwz r23, 0x10(r30)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AF3FC: C01E0084  lfs f0, 0x84(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF400: A15E00A8  lhz r10, 0xa8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 821AF404: 7D5A0734  extsh r26, r10
	ctx.r[26].s64 = ctx.r[10].s16 as i64;
	// 821AF408: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AF40C: A17700C2  lhz r11, 0xc2(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(194 as u32) ) } as u64;
	// 821AF410: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821AF414: B17E00A4  sth r11, 0xa4(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[11].u16 ) };
	// 821AF418: 4099002C  ble cr6, 0x821af444
	if !ctx.cr[6].gt {
	pc = 0x821AF444; continue 'dispatch;
	}
	// 821AF41C: A17E00A6  lhz r11, 0xa6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(166 as u32) ) } as u64;
	// 821AF420: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF424: 7D7A5850  subf r11, r26, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 821AF428: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AF42C: 4099000C  ble cr6, 0x821af438
	if !ctx.cr[6].gt {
	pc = 0x821AF438; continue 'dispatch;
	}
	// 821AF430: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 821AF434: 4800000C  b 0x821af440
	pc = 0x821AF440; continue 'dispatch;
	// 821AF438: 4098000C  bge cr6, 0x821af444
	if !ctx.cr[6].lt {
	pc = 0x821AF444; continue 'dispatch;
	}
	// 821AF43C: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 821AF440: B35E00A8  sth r26, 0xa8(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[26].u16 ) };
	// 821AF444: A17E00A4  lhz r11, 0xa4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 821AF448: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	// 821AF44C: 837E0114  lwz r27, 0x114(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 821AF450: 7D790734  extsh r25, r11
	ctx.r[25].s64 = ctx.r[11].s16 as i64;
	// 821AF454: 829E009C  lwz r20, 0x9c(r30)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 821AF458: 3D600504  lis r11, 0x504
	ctx.r[11].s64 = 84148224;
	// 821AF45C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821AF460: 61784000  ori r24, r11, 0x4000
	ctx.r[24].u64 = ctx.r[11].u64 | 16384;
	// 821AF464: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821AF468: 3BEB20C0  addi r31, r11, 0x20c0
	ctx.r[31].s64 = ctx.r[11].s64 + 8384;
	// 821AF46C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AF470: 3ACBC470  addi r22, r11, -0x3b90
	ctx.r[22].s64 = ctx.r[11].s64 + -15248;
	// 821AF474: 419A01C0  beq cr6, 0x821af634
	if ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF478: 817B0030  lwz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF47C: 815E0110  lwz r10, 0x110(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 821AF480: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AF484: 409A01B0  bne cr6, 0x821af634
	if !ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF488: 2F1A0003  cmpwi cr6, r26, 3
	ctx.cr[6].compare_i32(ctx.r[26].s32, 3, &mut ctx.xer);
	// 821AF48C: 41980110  blt cr6, 0x821af59c
	if ctx.cr[6].lt {
	pc = 0x821AF59C; continue 'dispatch;
	}
	// 821AF490: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF494: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 821AF498: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF49C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF4A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AF4A4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821AF4A8: 386B18C0  addi r3, r11, 0x18c0
	ctx.r[3].s64 = ctx.r[11].s64 + 6336;
	// 821AF4AC: 4BFFF10D  bl 0x821ae5b8
	ctx.lr = 0x821AF4B0;
	sub_821AE5B8(ctx, base);
	// 821AF4B0: 56BD07FE  clrlwi r29, r21, 0x1f
	ctx.r[29].u64 = ctx.r[21].u32 as u64 & 0x00000001u64;
	// 821AF4B4: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF4B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AF4BC: 388B18C0  addi r4, r11, 0x18c0
	ctx.r[4].s64 = ctx.r[11].s64 + 6336;
	// 821AF4C0: 419A0030  beq cr6, 0x821af4f0
	if ctx.cr[6].eq {
	pc = 0x821AF4F0; continue 'dispatch;
	}
	// 821AF4C4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821AF4C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AF4CC: 4BFFC475  bl 0x821ab940
	ctx.lr = 0x821AF4D0;
	sub_821AB940(ctx, base);
	// 821AF4D0: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF4D4: 387F2720  addi r3, r31, 0x2720
	ctx.r[3].s64 = ctx.r[31].s64 + 10016;
	// 821AF4D8: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AF4DC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF4E0: 38AB18C0  addi r5, r11, 0x18c0
	ctx.r[5].s64 = ctx.r[11].s64 + 6336;
	// 821AF4E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AF4E8: 4BFFCB71  bl 0x821ac058
	ctx.lr = 0x821AF4EC;
	sub_821AC058(ctx, base);
	// 821AF4EC: 48000018  b 0x821af504
	pc = 0x821AF504; continue 'dispatch;
	// 821AF4F0: 387F2720  addi r3, r31, 0x2720
	ctx.r[3].s64 = ctx.r[31].s64 + 10016;
	// 821AF4F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF4F8: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 821AF4FC: 38BAFFFF  addi r5, r26, -1
	ctx.r[5].s64 = ctx.r[26].s64 + -1;
	// 821AF500: 4BFED431  bl 0x8219c930
	ctx.lr = 0x821AF504;
	sub_8219C930(ctx, base);
	// 821AF504: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF508: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821AF50C: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 821AF510: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF514: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AF518: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821AF51C: 386B18C0  addi r3, r11, 0x18c0
	ctx.r[3].s64 = ctx.r[11].s64 + 6336;
	// 821AF520: 4BFFF159  bl 0x821ae678
	ctx.lr = 0x821AF524;
	sub_821AE678(ctx, base);
	// 821AF524: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AF528: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF52C: 419A0038  beq cr6, 0x821af564
	if ctx.cr[6].eq {
	pc = 0x821AF564; continue 'dispatch;
	}
	// 821AF530: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821AF534: 388B18C0  addi r4, r11, 0x18c0
	ctx.r[4].s64 = ctx.r[11].s64 + 6336;
	// 821AF538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AF53C: 4BFFC405  bl 0x821ab940
	ctx.lr = 0x821AF540;
	sub_821AB940(ctx, base);
	// 821AF540: 395F2720  addi r10, r31, 0x2720
	ctx.r[10].s64 = ctx.r[31].s64 + 10016;
	// 821AF544: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF548: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AF54C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF550: 38AA18C0  addi r5, r10, 0x18c0
	ctx.r[5].s64 = ctx.r[10].s64 + 6336;
	// 821AF554: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AF558: 386B0C60  addi r3, r11, 0xc60
	ctx.r[3].s64 = ctx.r[11].s64 + 3168;
	// 821AF55C: 4BFFCAFD  bl 0x821ac058
	ctx.lr = 0x821AF560;
	sub_821AC058(ctx, base);
	// 821AF560: 48000020  b 0x821af580
	pc = 0x821AF580; continue 'dispatch;
	// 821AF564: 395F2720  addi r10, r31, 0x2720
	ctx.r[10].s64 = ctx.r[31].s64 + 10016;
	// 821AF568: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF56C: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 821AF570: 38BAFFFF  addi r5, r26, -1
	ctx.r[5].s64 = ctx.r[26].s64 + -1;
	// 821AF574: 388A18C0  addi r4, r10, 0x18c0
	ctx.r[4].s64 = ctx.r[10].s64 + 6336;
	// 821AF578: 386B0C60  addi r3, r11, 0xc60
	ctx.r[3].s64 = ctx.r[11].s64 + 3168;
	// 821AF57C: 4BFED3B5  bl 0x8219c930
	ctx.lr = 0x821AF580;
	sub_8219C930(ctx, base);
	// 821AF580: 387F2720  addi r3, r31, 0x2720
	ctx.r[3].s64 = ctx.r[31].s64 + 10016;
	// 821AF584: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AF588: 4BFFFD01  bl 0x821af288
	ctx.lr = 0x821AF58C;
	sub_821AF288(ctx, base);
	// 821AF58C: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF590: 386B0C60  addi r3, r11, 0xc60
	ctx.r[3].s64 = ctx.r[11].s64 + 3168;
	// 821AF594: 4BFFFCF5  bl 0x821af288
	ctx.lr = 0x821AF598;
	sub_821AF288(ctx, base);
	// 821AF598: 48000008  b 0x821af5a0
	pc = 0x821AF5A0; continue 'dispatch;
	// 821AF59C: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	// 821AF5A0: C01E0090  lfs f0, 0x90(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF5A4: 83BE0098  lwz r29, 0x98(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AF5A8: C1BE008C  lfs f13, 0x8c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF5AC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AF5B0: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AF5B4: B39E00AC  sth r28, 0xac(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[28].u16 ) };
	// 821AF5B8: 419A0030  beq cr6, 0x821af5e8
	if ctx.cr[6].eq {
	pc = 0x821AF5E8; continue 'dispatch;
	}
	// 821AF5BC: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF5C0: 807B00CC  lwz r3, 0xcc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AF5C4: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF5C8: 389F2720  addi r4, r31, 0x2720
	ctx.r[4].s64 = ctx.r[31].s64 + 10016;
	// 821AF5CC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF5D0: 38FE00C0  addi r7, r30, 0xc0
	ctx.r[7].s64 = ctx.r[30].s64 + 192;
	// 821AF5D4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821AF5D8: 915B00C4  stw r10, 0xc4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 821AF5DC: 38AB0C60  addi r5, r11, 0xc60
	ctx.r[5].s64 = ctx.r[11].s64 + 3168;
	// 821AF5E0: 4BFFE4B9  bl 0x821ada98
	ctx.lr = 0x821AF5E4;
	sub_821ADA98(ctx, base);
	// 821AF5E4: 48000008  b 0x821af5ec
	pc = 0x821AF5EC; continue 'dispatch;
	// 821AF5E8: 923B00C4  stw r17, 0xc4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(196 as u32), ctx.r[17].u32 ) };
	// 821AF5EC: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 821AF5F0: 419A0044  beq cr6, 0x821af634
	if ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF5F4: A1740004  lhz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF5F8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821AF5FC: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 821AF600: 917B0090  stw r11, 0x90(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821AF604: A1740004  lhz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF608: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821AF60C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF610: 7D6B3670  srawi r11, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 821AF614: 794906A0  clrldi r9, r10, 0x3a
	ctx.r[9].u64 = ctx.r[10].u64 & 0x000000000000003Fu64;
	// 821AF618: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AF61C: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF620: 81760024  lwz r11, 0x24(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AF624: 7D0A582A  ldx r8, r10, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821AF628: 7E694836  sld r9, r19, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = (ctx.r[19].u64) << ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821AF62C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AF630: 7D2A592A  stdx r9, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	// 821AF634: 83BE011C  lwz r29, 0x11c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) } as u64;
	// 821AF638: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AF63C: 419A017C  beq cr6, 0x821af7b8
	if ctx.cr[6].eq {
	pc = 0x821AF7B8; continue 'dispatch;
	}
	// 821AF640: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF644: 815E0118  lwz r10, 0x118(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF648: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AF64C: 409A016C  bne cr6, 0x821af7b8
	if !ctx.cr[6].eq {
	pc = 0x821AF7B8; continue 'dispatch;
	}
	// 821AF650: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821AF654: 816A44F0  lwz r11, 0x44f0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17648 as u32) ) } as u64;
	// 821AF658: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821AF65C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF660: 409A000C  bne cr6, 0x821af66c
	if !ctx.cr[6].eq {
	pc = 0x821AF66C; continue 'dispatch;
	}
	// 821AF664: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821AF668: 916A44F0  stw r11, 0x44f0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17648 as u32), ctx.r[11].u32 ) };
	// 821AF66C: 817E0114  lwz r11, 0x114(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 821AF670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF674: 419A0040  beq cr6, 0x821af6b4
	if ctx.cr[6].eq {
	pc = 0x821AF6B4; continue 'dispatch;
	}
	// 821AF678: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF67C: 815E0110  lwz r10, 0x110(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 821AF680: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AF684: 409A0030  bne cr6, 0x821af6b4
	if !ctx.cr[6].eq {
	pc = 0x821AF6B4; continue 'dispatch;
	}
	// 821AF688: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821AF68C: 38C000C0  li r6, 0xc0
	ctx.r[6].s64 = 192;
	// 821AF690: 386B44B0  addi r3, r11, 0x44b0
	ctx.r[3].s64 = ctx.r[11].s64 + 17584;
	// 821AF694: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AF698: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AF69C: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 821AF6A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821AF6A4: C04BBA38  lfs f2, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AF6A8: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821AF6AC: 4BFFF44D  bl 0x821aeaf8
	ctx.lr = 0x821AF6B0;
	sub_821AEAF8(ctx, base);
	// 821AF6B0: 48000008  b 0x821af6b8
	pc = 0x821AF6B8; continue 'dispatch;
	// 821AF6B4: 3B7E00C0  addi r27, r30, 0xc0
	ctx.r[27].s64 = ctx.r[30].s64 + 192;
	// 821AF6B8: 2F1A0003  cmpwi cr6, r26, 3
	ctx.cr[6].compare_i32(ctx.r[26].s32, 3, &mut ctx.xer);
	// 821AF6BC: 4198008C  blt cr6, 0x821af748
	if ctx.cr[6].lt {
	pc = 0x821AF748; continue 'dispatch;
	}
	// 821AF6C0: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF6C4: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 821AF6C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF6CC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF6D0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AF6D4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821AF6D8: 386B18C0  addi r3, r11, 0x18c0
	ctx.r[3].s64 = ctx.r[11].s64 + 6336;
	// 821AF6DC: 4BFFEEDD  bl 0x821ae5b8
	ctx.lr = 0x821AF6E0;
	sub_821AE5B8(ctx, base);
	// 821AF6E0: 56AB07FE  clrlwi r11, r21, 0x1f
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x00000001u64;
	// 821AF6E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF6E8: 419A003C  beq cr6, 0x821af724
	if ctx.cr[6].eq {
	pc = 0x821AF724; continue 'dispatch;
	}
	// 821AF6EC: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF6F0: 839D00CC  lwz r28, 0xcc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AF6F4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821AF6F8: 388B18C0  addi r4, r11, 0x18c0
	ctx.r[4].s64 = ctx.r[11].s64 + 6336;
	// 821AF6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AF700: 4BFFC241  bl 0x821ab940
	ctx.lr = 0x821AF704;
	sub_821AB940(ctx, base);
	// 821AF704: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF708: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AF70C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF710: 38AB18C0  addi r5, r11, 0x18c0
	ctx.r[5].s64 = ctx.r[11].s64 + 6336;
	// 821AF714: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AF718: 387C4A40  addi r3, r28, 0x4a40
	ctx.r[3].s64 = ctx.r[28].s64 + 19008;
	// 821AF71C: 4BFFC93D  bl 0x821ac058
	ctx.lr = 0x821AF720;
	sub_821AC058(ctx, base);
	// 821AF720: 4800002C  b 0x821af74c
	pc = 0x821AF74C; continue 'dispatch;
	// 821AF724: 817D00CC  lwz r11, 0xcc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AF728: 395F2720  addi r10, r31, 0x2720
	ctx.r[10].s64 = ctx.r[31].s64 + 10016;
	// 821AF72C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF730: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 821AF734: 38BAFFFF  addi r5, r26, -1
	ctx.r[5].s64 = ctx.r[26].s64 + -1;
	// 821AF738: 388A18C0  addi r4, r10, 0x18c0
	ctx.r[4].s64 = ctx.r[10].s64 + 6336;
	// 821AF73C: 386B4A40  addi r3, r11, 0x4a40
	ctx.r[3].s64 = ctx.r[11].s64 + 19008;
	// 821AF740: 4BFED1F1  bl 0x8219c930
	ctx.lr = 0x821AF744;
	sub_8219C930(ctx, base);
	// 821AF744: 48000008  b 0x821af74c
	pc = 0x821AF74C; continue 'dispatch;
	// 821AF748: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821AF74C: C01E0090  lfs f0, 0x90(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF750: 817E00A0  lwz r11, 0xa0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF754: C1BE008C  lfs f13, 0x8c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF758: 815E0098  lwz r10, 0x98(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AF75C: B07E00AC  sth r3, 0xac(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[3].u16 ) };
	// 821AF760: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AF764: D01D00DC  stfs f0, 0xdc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 821AF768: 907D00D0  stw r3, 0xd0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(208 as u32), ctx.r[3].u32 ) };
	// 821AF76C: 937D00D4  stw r27, 0xd4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(212 as u32), ctx.r[27].u32 ) };
	// 821AF770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF774: 419A0044  beq cr6, 0x821af7b8
	if ctx.cr[6].eq {
	pc = 0x821AF7B8; continue 'dispatch;
	}
	// 821AF778: A12B0004  lhz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF77C: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821AF780: 7D29C214  add r9, r9, r24
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[24].u64;
	// 821AF784: 913D0090  stw r9, 0x90(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 821AF788: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF78C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AF790: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF794: 7D6B3670  srawi r11, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 821AF798: 794906A0  clrldi r9, r10, 0x3a
	ctx.r[9].u64 = ctx.r[10].u64 & 0x000000000000003Fu64;
	// 821AF79C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AF7A0: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF7A4: 81760024  lwz r11, 0x24(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AF7A8: 7D0A582A  ldx r8, r10, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821AF7AC: 7E694836  sld r9, r19, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = (ctx.r[19].u64) << ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821AF7B0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AF7B4: 7D2A592A  stdx r9, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	// 821AF7B8: 56AB06F6  rlwinm r11, r21, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF7BC: C01E0084  lfs f0, 0x84(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF7C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF7C4: 409A0020  bne cr6, 0x821af7e4
	if !ctx.cr[6].eq {
	pc = 0x821AF7E4; continue 'dispatch;
	}
	// 821AF7C8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821AF7CC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821AF7D0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821AF7D4: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821AF7D8: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF7DC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF7E0: D01E0084  stfs f0, 0x84(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821AF7E4: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 821AF7E8: 419A0020  beq cr6, 0x821af808
	if ctx.cr[6].eq {
	pc = 0x821AF808; continue 'dispatch;
	}
	// 821AF7EC: 817E0098  lwz r11, 0x98(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AF7F0: A1540012  lhz r10, 0x12(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[20].u32.wrapping_add(18 as u32) ) } as u64;
	// 821AF7F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821AF7F8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821AF7FC: 41980008  blt cr6, 0x821af804
	if ctx.cr[6].lt {
	pc = 0x821AF804; continue 'dispatch;
	}
	// 821AF800: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 821AF804: 917E0098  stw r11, 0x98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AF808: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821AF80C: 41990118  bgt cr6, 0x821af924
	if ctx.cr[6].gt {
	pc = 0x821AF924; continue 'dispatch;
	}
	// 821AF810: A17E00AA  lhz r11, 0xaa(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AF814: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF818: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF81C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AF820: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AF824: 7D6B9214  add r11, r11, r18
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[18].u64;
	// 821AF828: 3D4B0006  addis r10, r11, 6
	ctx.r[10].s64 = ctx.r[11].s64 + 393216;
	// 821AF82C: 394AA580  addi r10, r10, -0x5a80
	ctx.r[10].s64 = ctx.r[10].s64 + -23168;
	// 821AF830: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF838: 419A0014  beq cr6, 0x821af84c
	if ctx.cr[6].eq {
	pc = 0x821AF84C; continue 'dispatch;
	}
	// 821AF83C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF840: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AF844: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AF848: 419A0008  beq cr6, 0x821af850
	if ctx.cr[6].eq {
	pc = 0x821AF850; continue 'dispatch;
	}
	// 821AF84C: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 821AF850: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821AF854: 409A0008  bne cr6, 0x821af85c
	if !ctx.cr[6].eq {
	pc = 0x821AF85C; continue 'dispatch;
	}
	// 821AF858: FA2A0000  std r17, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[17].u64 ) };
	// 821AF85C: C01E0094  lfs f0, 0x94(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF860: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821AF864: C1BE0090  lfs f13, 0x90(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF868: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821AF86C: 409900C8  ble cr6, 0x821af934
	if !ctx.cr[6].gt {
	pc = 0x821AF934; continue 'dispatch;
	}
	// 821AF870: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821AF874: 409900C0  ble cr6, 0x821af934
	if !ctx.cr[6].gt {
	pc = 0x821AF934; continue 'dispatch;
	}
	// 821AF878: D01E0090  stfs f0, 0x90(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821AF87C: 817E0124  lwz r11, 0x124(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(292 as u32) ) } as u64;
	// 821AF880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF884: 419A004C  beq cr6, 0x821af8d0
	if ctx.cr[6].eq {
	pc = 0x821AF8D0; continue 'dispatch;
	}
	// 821AF888: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF88C: 813E0120  lwz r9, 0x120(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 821AF890: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AF894: 409A003C  bne cr6, 0x821af8d0
	if !ctx.cr[6].eq {
	pc = 0x821AF8D0; continue 'dispatch;
	}
	// 821AF898: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF89C: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF8A0: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AF8A4: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF8A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF8AC: 419A0020  beq cr6, 0x821af8cc
	if ctx.cr[6].eq {
	pc = 0x821AF8CC; continue 'dispatch;
	}
	// 821AF8B0: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF8B4: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF8B8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF8BC: 409A0010  bne cr6, 0x821af8cc
	if !ctx.cr[6].eq {
	pc = 0x821AF8CC; continue 'dispatch;
	}
	// 821AF8C0: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF8C4: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF8C8: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 821AF8CC: FA3E0120  std r17, 0x120(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(288 as u32), ctx.r[17].u64 ) };
	// 821AF8D0: 817E012C  lwz r11, 0x12c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(300 as u32) ) } as u64;
	// 821AF8D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF8D8: 419A004C  beq cr6, 0x821af924
	if ctx.cr[6].eq {
	pc = 0x821AF924; continue 'dispatch;
	}
	// 821AF8DC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF8E0: 813E0128  lwz r9, 0x128(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(296 as u32) ) } as u64;
	// 821AF8E4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AF8E8: 409A003C  bne cr6, 0x821af924
	if !ctx.cr[6].eq {
	pc = 0x821AF924; continue 'dispatch;
	}
	// 821AF8EC: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF8F0: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF8F4: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AF8F8: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF8FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF900: 419A0020  beq cr6, 0x821af920
	if ctx.cr[6].eq {
	pc = 0x821AF920; continue 'dispatch;
	}
	// 821AF904: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF908: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF90C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF910: 409A0010  bne cr6, 0x821af920
	if !ctx.cr[6].eq {
	pc = 0x821AF920; continue 'dispatch;
	}
	// 821AF914: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF918: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF91C: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 821AF920: FA3E0128  std r17, 0x128(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(296 as u32), ctx.r[17].u64 ) };
	// 821AF924: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AF928: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AF92C: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821AF930: 483857AC  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
	// 821AF934: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AF938: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AF93C: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821AF940: 4838579C  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF948 size=268
    let mut pc: u32 = 0x821AF948;
    'dispatch: loop {
        match pc {
            0x821AF948 => {
    //   block [0x821AF948..0x821AFA54)
	// 821AF948: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AF94C: 814BFAC0  lwz r10, -0x540(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AF950: A16A00AA  lhz r11, 0xaa(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AF954: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AF958: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF95C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF960: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821AF964: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AF968: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AF96C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AF970: 3D2B0006  addis r9, r11, 6
	ctx.r[9].s64 = ctx.r[11].s64 + 393216;
	// 821AF974: 3929A580  addi r9, r9, -0x5a80
	ctx.r[9].s64 = ctx.r[9].s64 + -23168;
	// 821AF978: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF97C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF980: 419A0014  beq cr6, 0x821af994
	if ctx.cr[6].eq {
	pc = 0x821AF994; continue 'dispatch;
	}
	// 821AF984: 80EB0030  lwz r7, 0x30(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF988: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AF98C: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AF990: 419A0008  beq cr6, 0x821af998
	if ctx.cr[6].eq {
	pc = 0x821AF998; continue 'dispatch;
	}
	// 821AF994: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821AF998: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AF99C: 409A0008  bne cr6, 0x821af9a4
	if !ctx.cr[6].eq {
	pc = 0x821AF9A4; continue 'dispatch;
	}
	// 821AF9A0: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821AF9A4: 816A0124  lwz r11, 0x124(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(292 as u32) ) } as u64;
	// 821AF9A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF9AC: 419A004C  beq cr6, 0x821af9f8
	if ctx.cr[6].eq {
	pc = 0x821AF9F8; continue 'dispatch;
	}
	// 821AF9B0: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF9B4: 80EA0120  lwz r7, 0x120(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(288 as u32) ) } as u64;
	// 821AF9B8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AF9BC: 409A003C  bne cr6, 0x821af9f8
	if !ctx.cr[6].eq {
	pc = 0x821AF9F8; continue 'dispatch;
	}
	// 821AF9C0: 812B00A0  lwz r9, 0xa0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF9C4: 55290356  rlwinm r9, r9, 0, 0xd, 0xb
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF9C8: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 821AF9CC: 812B00BC  lwz r9, 0xbc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF9D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF9D4: 419A0020  beq cr6, 0x821af9f4
	if ctx.cr[6].eq {
	pc = 0x821AF9F4; continue 'dispatch;
	}
	// 821AF9D8: 80E90030  lwz r7, 0x30(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF9DC: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF9E0: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF9E4: 409A0010  bne cr6, 0x821af9f4
	if !ctx.cr[6].eq {
	pc = 0x821AF9F4; continue 'dispatch;
	}
	// 821AF9E8: 81690118  lwz r11, 0x118(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF9EC: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF9F0: 91690118  stw r11, 0x118(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 821AF9F4: F90A0120  std r8, 0x120(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(288 as u32), ctx.r[8].u64 ) };
	// 821AF9F8: 816A012C  lwz r11, 0x12c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(300 as u32) ) } as u64;
	// 821AF9FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFA00: 419A004C  beq cr6, 0x821afa4c
	if ctx.cr[6].eq {
	pc = 0x821AFA4C; continue 'dispatch;
	}
	// 821AFA04: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AFA08: 80EA0128  lwz r7, 0x128(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(296 as u32) ) } as u64;
	// 821AFA0C: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AFA10: 409A003C  bne cr6, 0x821afa4c
	if !ctx.cr[6].eq {
	pc = 0x821AFA4C; continue 'dispatch;
	}
	// 821AFA14: 812B00A0  lwz r9, 0xa0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AFA18: 55290356  rlwinm r9, r9, 0, 0xd, 0xb
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821AFA1C: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 821AFA20: 812B00BC  lwz r9, 0xbc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AFA24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AFA28: 419A0020  beq cr6, 0x821afa48
	if ctx.cr[6].eq {
	pc = 0x821AFA48; continue 'dispatch;
	}
	// 821AFA2C: 80E90030  lwz r7, 0x30(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AFA30: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AFA34: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AFA38: 409A0010  bne cr6, 0x821afa48
	if !ctx.cr[6].eq {
	pc = 0x821AFA48; continue 'dispatch;
	}
	// 821AFA3C: 81690118  lwz r11, 0x118(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AFA40: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AFA44: 91690118  stw r11, 0x118(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 821AFA48: F90A0128  std r8, 0x128(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(296 as u32), ctx.r[8].u64 ) };
	// 821AFA4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AFA50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFA58 size=60
    let mut pc: u32 = 0x821AFA58;
    'dispatch: loop {
        match pc {
            0x821AFA58 => {
    //   block [0x821AFA58..0x821AFA94)
	// 821AFA58: C1430004  lfs f10, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AFA5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AFA60: EC0A0072  fmuls f0, f10, f1
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[1].f64) as f32) as f64);
	// 821AFA64: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AFA68: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821AFA6C: 419A00D8  beq cr6, 0x821afb44
	if ctx.cr[6].eq {
		sub_821AFB44(ctx, base);
		return;
	}
	// 821AFA70: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFA74: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFA78: C1230000  lfs f9, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AFA7C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 821AFA80: EC29002A  fadds f1, f9, f0
	ctx.f[1].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 821AFA84: 40980010  bge cr6, 0x821afa94
	if !ctx.cr[6].lt {
		sub_821AFA94(ctx, base);
		return;
	}
	// 821AFA88: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821AFA8C: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 821AFA90: 48000008  b 0x821afa98
	sub_821AFA94(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFA94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFA94 size=84
    let mut pc: u32 = 0x821AFA94;
    'dispatch: loop {
        match pc {
            0x821AFA94 => {
    //   block [0x821AFA94..0x821AFAE8)
	// 821AFA94: FC006090  fmr f0, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[12].f64;
	// 821AFA98: 54EB07FE  clrlwi r11, r7, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821AFA9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFAA0: 419A0048  beq cr6, 0x821afae8
	if ctx.cr[6].eq {
		sub_821AFAE8(ctx, base);
		return;
	}
	// 821AFAA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AFAA8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821AFAAC: C18B2074  lfs f12, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFAB0: 41990014  bgt cr6, 0x821afac4
	if ctx.cr[6].gt {
	pc = 0x821AFAC4; continue 'dispatch;
	}
	// 821AFAB4: ED600828  fsubs f11, f0, f1
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 821AFAB8: ED4A0332  fmuls f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AFABC: D1430004  stfs f10, 4(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AFAC0: EC2B002A  fadds f1, f11, f0
	ctx.f[1].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 821AFAC4: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 821AFAC8: 41980074  blt cr6, 0x821afb3c
	if ctx.cr[6].lt {
		sub_821AFB1C(ctx, base);
		return;
	}
	// 821AFACC: EC016828  fsubs f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AFAD0: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AFAD4: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AFAD8: D1830004  stfs f12, 4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AFADC: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AFAE0: D0230000  stfs f1, 0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AFAE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFAE8 size=52
    let mut pc: u32 = 0x821AFAE8;
    'dispatch: loop {
        match pc {
            0x821AFAE8 => {
    //   block [0x821AFAE8..0x821AFB1C)
	// 821AFAE8: 54CB07FE  clrlwi r11, r6, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 821AFAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFAF0: 419A002C  beq cr6, 0x821afb1c
	if ctx.cr[6].eq {
		sub_821AFB1C(ctx, base);
		return;
	}
	// 821AFAF4: FF010000  fcmpu cr6, f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821AFAF8: 4199000C  bgt cr6, 0x821afb04
	if ctx.cr[6].gt {
	pc = 0x821AFB04; continue 'dispatch;
	}
	// 821AFAFC: ED800828  fsubs f12, f0, f1
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 821AFB00: EC2D6028  fsubs f1, f13, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AFB04: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 821AFB08: 41980034  blt cr6, 0x821afb3c
	if ctx.cr[6].lt {
		sub_821AFB1C(ctx, base);
		return;
	}
	// 821AFB0C: EDA16828  fsubs f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AFB10: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821AFB14: D0230000  stfs f1, 0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AFB18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFB1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFB1C size=40
    let mut pc: u32 = 0x821AFB1C;
    'dispatch: loop {
        match pc {
            0x821AFB1C => {
    //   block [0x821AFB1C..0x821AFB44)
	// 821AFB1C: FF010000  fcmpu cr6, f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821AFB20: 4199000C  bgt cr6, 0x821afb2c
	if ctx.cr[6].gt {
	pc = 0x821AFB2C; continue 'dispatch;
	}
	// 821AFB24: D1630004  stfs f11, 4(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AFB28: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 821AFB2C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 821AFB30: 4198000C  blt cr6, 0x821afb3c
	if ctx.cr[6].lt {
	pc = 0x821AFB3C; continue 'dispatch;
	}
	// 821AFB34: D1630004  stfs f11, 4(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AFB38: FC206890  fmr f1, f13
	ctx.f[1].f64 = ctx.f[13].f64;
	// 821AFB3C: D0230000  stfs f1, 0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AFB40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFB44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFB44 size=8
    let mut pc: u32 = 0x821AFB44;
    'dispatch: loop {
        match pc {
            0x821AFB44 => {
    //   block [0x821AFB44..0x821AFB4C)
	// 821AFB44: C0230000  lfs f1, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AFB48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFB50 size=56
    let mut pc: u32 = 0x821AFB50;
    'dispatch: loop {
        match pc {
            0x821AFB50 => {
    //   block [0x821AFB50..0x821AFB88)
	// 821AFB50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AFB54: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AFB58: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFB5C: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AFB60: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFB64: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFB68: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AFB6C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821AFB70: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821AFB74: C00A277C  lfs f0, 0x277c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFB78: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821AFB7C: 4098000C  bge cr6, 0x821afb88
	if !ctx.cr[6].lt {
		sub_821AFB88(ctx, base);
		return;
	}
	// 821AFB80: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821AFB84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AFB88 size=88
    let mut pc: u32 = 0x821AFB88;
    'dispatch: loop {
        match pc {
            0x821AFB88 => {
    //   block [0x821AFB88..0x821AFBE0)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AFBE0 size=668
    let mut pc: u32 = 0x821AFBE0;
    'dispatch: loop {
        match pc {
            0x821AFBE0 => {
    //   block [0x821AFBE0..0x821AFE7C)
	// 821AFBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AFBE4: 483854C9  bl 0x825350ac
	ctx.lr = 0x821AFBE8;
	sub_82535080(ctx, base);
	// 821AFBE8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 821AFBEC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821AFBF0: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AFBF4: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821AFBF8: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821AFBFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AFC00: 7F4907B4  extsw r9, r26
	ctx.r[9].s64 = ctx.r[26].s32 as i64;
	// 821AFC04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AFC08: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821AFC0C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821AFC10: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFC14: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AFC18: F92100A0  std r9, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u64 ) };
	// 821AFC1C: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821AFC20: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821AFC24: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AFC28: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821AFC2C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821AFC30: EDA2F028  fsubs f13, f2, f30
	ctx.f[13].f64 = (((ctx.f[2].f64 - ctx.f[30].f64) as f32) as f64);
	// 821AFC34: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821AFC38: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821AFC3C: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFC40: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821AFC44: C80100A0  lfd f0, 0xa0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821AFC48: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AFC4C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AFC50: EFED0024  fdivs f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821AFC54: 419A0008  beq cr6, 0x821afc5c
	if ctx.cr[6].eq {
	pc = 0x821AFC5C; continue 'dispatch;
	}
	// 821AFC58: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 821AFC5C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821AFC60: 40990208  ble cr6, 0x821afe68
	if !ctx.cr[6].gt {
	pc = 0x821AFE68; continue 'dispatch;
	}
	// 821AFC64: 54DD103A  slwi r29, r6, 2
	ctx.r[29].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821AFC68: 3B810090  addi r28, r1, 0x90
	ctx.r[28].s64 = ctx.r[1].s64 + 144;
	// 821AFC6C: 7FDDE52E  stfsx f30, r29, r28
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 821AFC70: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 821AFC74: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821AFC78: 409901E0  ble cr6, 0x821afe58
	if !ctx.cr[6].gt {
	pc = 0x821AFE58; continue 'dispatch;
	}
	// 821AFC7C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 821AFC80: C0210090  lfs f1, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AFC84: 481B820D  bl 0x82367e90
	ctx.lr = 0x821AFC88;
	sub_82367E90(ctx, base);
	// 821AFC88: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821AFC8C: C0210094  lfs f1, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AFC90: 481B8329  bl 0x82367fb8
	ctx.lr = 0x821AFC94;
	sub_82367FB8(ctx, base);
	// 821AFC94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AFC98: C0210098  lfs f1, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AFC9C: 481B844D  bl 0x823680e8
	ctx.lr = 0x821AFCA0;
	sub_823680E8(ctx, base);
	// 821AFCA0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821AFCA4: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFCA8: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFCAC: C181007C  lfs f12, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFCB0: 7D7DE42E  lfsx f11, r29, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AFE80 size=656
    let mut pc: u32 = 0x821AFE80;
    'dispatch: loop {
        match pc {
            0x821AFE80 => {
    //   block [0x821AFE80..0x821B0110)
	// 821AFE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AFE84: 48385239  bl 0x825350bc
	ctx.lr = 0x821AFE88;
	sub_82535080(ctx, base);
	// 821AFE88: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821AFE8C: 48386159  bl 0x82535fe4
	ctx.lr = 0x821AFE90;
	sub_82535FB0(ctx, base);
	// 821AFE90: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AFE94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821AFE98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AFE9C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AFEA0: 4099025C  ble cr6, 0x821b00fc
	if !ctx.cr[6].gt {
	pc = 0x821B00FC; continue 'dispatch;
	}
	// 821AFEA4: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 821AFEA8: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821AFEAC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AFEB0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AFEB4: C368D218  lfs f27, -0x2de8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821AFEB8: 3BABFBB0  addi r29, r11, -0x450
	ctx.r[29].s64 = ctx.r[11].s64 + -1104;
	// 821AFEBC: C389D468  lfs f28, -0x2b98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821AFEC0: C3EA2280  lfs f31, 0x2280(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AFEC4: 481B7275  bl 0x82367138
	ctx.lr = 0x821AFEC8;
	sub_82367138(ctx, base);
	// 821AFEC8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AFECC: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 821AFED0: C80100A8  lfd f0, 0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 821AFED4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AFED8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AFEDC: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AFEE0: 481B7259  bl 0x82367138
	ctx.lr = 0x821AFEE4;
	sub_82367138(ctx, base);
	// 821AFEE4: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AFEE8: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 821AFEEC: C8010098  lfd f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 821AFEF0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AFEF4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AFEF8: EFC007F2  fmuls f30, f0, f31
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AFEFC: 481B723D  bl 0x82367138
	ctx.lr = 0x821AFF00;
	sub_82367138(ctx, base);
	// 821AFF00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AFF04: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 821AFF08: 796B0260  clrldi r11, r11, 0x29
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000007FFFFFu64;
	// 821AFF0C: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 821AFF10: C80100A0  lfd f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821AFF14: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AFF18: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AFF1C: EFA007F2  fmuls f29, f0, f31
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AFF20: 481B7F71  bl 0x82367e90
	ctx.lr = 0x821AFF24;
	sub_82367E90(ctx, base);
	// 821AFF24: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821AFF28: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821AFF2C: 481B808D  bl 0x82367fb8
	ctx.lr = 0x821AFF30;
	sub_82367FB8(ctx, base);
	// 821AFF30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AFF34: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821AFF38: 481B81B1  bl 0x823680e8
	ctx.lr = 0x821AFF3C;
	sub_823680E8(ctx, base);
	// 821AFF3C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821AFF40: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFF44: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	// 821AFF48: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFF4C: C181007C  lfs f12, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B0110 size=132
    let mut pc: u32 = 0x821B0110;
    'dispatch: loop {
        match pc {
            0x821B0110 => {
    //   block [0x821B0110..0x821B0194)
	// 821B0110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B0114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B0118: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B011C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B0120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B0124: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B0128: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B012C: 396BFBB0  addi r11, r11, -0x450
	ctx.r[11].s64 = ctx.r[11].s64 + -1104;
	// 821B0130: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B0134: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B0138: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B013C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B0140: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B0144: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 821B0148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B014C: 4BFFFA95  bl 0x821afbe0
	ctx.lr = 0x821B0150;
	sub_821AFBE0(ctx, base);
	// 821B0150: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B0154: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B0158: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 821B015C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821B0160: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821B0164: C04BBA38  lfs f2, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B0168: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B016C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B0170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B0174: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B0178: 4BFFFA69  bl 0x821afbe0
	ctx.lr = 0x821B017C;
	sub_821AFBE0(ctx, base);
	// 821B017C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B0180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B0184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B0188: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B018C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B0190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B0198 size=496
    let mut pc: u32 = 0x821B0198;
    'dispatch: loop {
        match pc {
            0x821B0198 => {
    //   block [0x821B0198..0x821B0388)
	// 821B0198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B019C: 48384F15  bl 0x825350b0
	ctx.lr = 0x821B01A0;
	sub_82535080(ctx, base);
	// 821B01A0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821B01A4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B01A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B01AC: C0640008  lfs f3, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B01B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B01B4: C0440004  lfs f2, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B01B8: C0240000  lfs f1, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B01BC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B01C0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821B01C4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821B01C8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 821B01CC: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 821B01D0: 481B8049  bl 0x82368218
	ctx.lr = 0x821B01D4;
	sub_82368218(ctx, base);
	// 821B01D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B01D8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B01DC: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821B01E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B01E4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B01E8: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821B01EC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B01F0: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B01F4: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821B01F8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821B01FC: 419A00C0  beq cr6, 0x821b02bc
	if ctx.cr[6].eq {
	pc = 0x821B02BC; continue 'dispatch;
	}
	// 821B0200: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821B0204: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 821B0208: 393F0010  addi r9, r31, 0x10
	ctx.r[9].s64 = ctx.r[31].s64 + 16;
	// 821B020C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 821B0210: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 821B0214: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B0218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B021C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B0388 size=156
    let mut pc: u32 = 0x821B0388;
    'dispatch: loop {
        match pc {
            0x821B0388 => {
    //   block [0x821B0388..0x821B0424)
	// 821B0388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B038C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B0390: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B0394: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 821B0398: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 821B039C: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821B03A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B03A4: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 821B03A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B03AC: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 821B03B0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821B03B4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821B03B8: 48382AF1  bl 0x82532ea8
	ctx.lr = 0x821B03BC;
	sub_82532EA8(ctx, base);
	// 821B03BC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821B03C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B03C4: EDBE07B2  fmuls f13, f30, f30
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B03C8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821B03CC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B03D0: EDBF6FFA  fmadds f13, f31, f31, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B03D4: C3EB2254  lfs f31, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B03D8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B03DC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B03E0: EC40682C  fsqrts f2, f13
	ctx.f[2].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 821B03E4: 48382AC5  bl 0x82532ea8
	ctx.lr = 0x821B03E8;
	sub_82532EA8(ctx, base);
	// 821B03E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B03EC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B03F0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B03F4: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B03F8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B03FC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B0400: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B0404: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B0408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B040C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B0410: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B0414: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821B0418: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B041C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B0420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B0428 size=412
    let mut pc: u32 = 0x821B0428;
    'dispatch: loop {
        match pc {
            0x821B0428 => {
    //   block [0x821B0428..0x821B05C4)
	// 821B0428: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821B042C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821B0430: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 821B0434: 41980124  blt cr6, 0x821b0558
	if ctx.cr[6].lt {
	pc = 0x821B0558; continue 'dispatch;
	}
	// 821B0438: 3945FFFC  addi r10, r5, -4
	ctx.r[10].s64 = ctx.r[5].s64 + -4;
	// 821B043C: 39660030  addi r11, r6, 0x30
	ctx.r[11].s64 = ctx.r[6].s64 + 48;
	// 821B0440: 5549F0BE  srwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B0444: 39460010  addi r10, r6, 0x10
	ctx.r[10].s64 = ctx.r[6].s64 + 16;
	// 821B0448: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 821B044C: 39260020  addi r9, r6, 0x20
	ctx.r[9].s64 = ctx.r[6].s64 + 32;
	// 821B0450: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B0454: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 821B0458: 7CA72850  subf r5, r7, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 821B045C: 3BE00020  li r31, 0x20
	ctx.r[31].s64 = 32;
	// 821B0460: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B05C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B05C8 size=744
    let mut pc: u32 = 0x821B05C8;
    'dispatch: loop {
        match pc {
            0x821B05C8 => {
    //   block [0x821B05C8..0x821B08B0)
	// 821B05C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B05CC: 48384AF1  bl 0x825350bc
	ctx.lr = 0x821B05D0;
	sub_82535080(ctx, base);
	// 821B05D0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821B05D4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B05D8: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 821B05DC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821B05E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B05E4: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 821B05E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821B05EC: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 821B05F0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B05F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B05F8: 419A0014  beq cr6, 0x821b060c
	if ctx.cr[6].eq {
	pc = 0x821B060C; continue 'dispatch;
	}
	// 821B05FC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0600: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0604: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B0608: 419A0008  beq cr6, 0x821b0610
	if ctx.cr[6].eq {
	pc = 0x821B0610; continue 'dispatch;
	}
	// 821B060C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B0610: 392B0090  addi r9, r11, 0x90
	ctx.r[9].s64 = ctx.r[11].s64 + 144;
	// 821B0614: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821B0618: 4099005C  ble cr6, 0x821b0674
	if !ctx.cr[6].gt {
	pc = 0x821B0674; continue 'dispatch;
	}
	// 821B061C: 39090030  addi r8, r9, 0x30
	ctx.r[8].s64 = ctx.r[9].s64 + 48;
	// 821B0620: 38E90010  addi r7, r9, 0x10
	ctx.r[7].s64 = ctx.r[9].s64 + 16;
	// 821B0624: 38A90020  addi r5, r9, 0x20
	ctx.r[5].s64 = ctx.r[9].s64 + 32;
	// 821B0628: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B062C: 7CDD3050  subf r6, r29, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[29].s64;
	// 821B0630: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B08B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B08B0 size=248
    let mut pc: u32 = 0x821B08B0;
    'dispatch: loop {
        match pc {
            0x821B08B0 => {
    //   block [0x821B08B0..0x821B09A8)
	// 821B08B0: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B08B4: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 821B08B8: 38EB14B0  addi r7, r11, 0x14b0
	ctx.r[7].s64 = ctx.r[11].s64 + 5296;
	// 821B08BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B08C0: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 821B08C4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B08C8: D007000C  stfs f0, 0xc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B08CC: 40990060  ble cr6, 0x821b092c
	if !ctx.cr[6].gt {
	pc = 0x821B092C; continue 'dispatch;
	}
	// 821B08D0: 3924FFFF  addi r9, r4, -1
	ctx.r[9].s64 = ctx.r[4].s64 + -1;
	// 821B08D4: 39670018  addi r11, r7, 0x18
	ctx.r[11].s64 = ctx.r[7].s64 + 24;
	// 821B08D8: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B08DC: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 821B08E0: C16BFFFC  lfs f11, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B08E4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821B08E8: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B08EC: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B08F0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B08F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B08F8: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B08FC: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B0900: C14BFFF8  lfs f10, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B0904: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821B0908: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821B090C: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B0910: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B0914: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B0918: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 821B091C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B0920: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B0924: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821B0928: 409AFFB0  bne cr6, 0x821b08d8
	if !ctx.cr[6].eq {
	pc = 0x821B08D8; continue 'dispatch;
	}
	// 821B092C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B0930: 3944FFFF  addi r10, r4, -1
	ctx.r[10].s64 = ctx.r[4].s64 + -1;
	// 821B0934: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B0938: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821B093C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0940: 39670010  addi r11, r7, 0x10
	ctx.r[11].s64 = ctx.r[7].s64 + 16;
	// 821B0944: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B0948: 41980058  blt cr6, 0x821b09a0
	if ctx.cr[6].lt {
	pc = 0x821B09A0; continue 'dispatch;
	}
	// 821B094C: 3944FFFB  addi r10, r4, -5
	ctx.r[10].s64 = ctx.r[4].s64 + -5;
	// 821B0950: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B0954: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B0958: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B095C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821B0960: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0964: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B0968: C18B001C  lfs f12, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B096C: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B0970: C16B002C  lfs f11, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B0974: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0978: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B097C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0980: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0984: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B0988: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B098C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0990: D16B002C  stfs f11, 0x2c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821B0994: D14B003C  stfs f10, 0x3c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B0998: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821B099C: 409AFFC4  bne cr6, 0x821b0960
	if !ctx.cr[6].eq {
	pc = 0x821B0960; continue 'dispatch;
	}
	// 821B09A0: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821B09A4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B09A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B09A8 size=40
    let mut pc: u32 = 0x821B09A8;
    'dispatch: loop {
        match pc {
            0x821B09A8 => {
    //   block [0x821B09A8..0x821B09D0)
	// 821B09A8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821B09AC: 7D492050  subf r10, r9, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 821B09B0: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B09B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B09B8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B09BC: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B09C0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821B09C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B09C8: 409AFFE8  bne cr6, 0x821b09b0
	if !ctx.cr[6].eq {
	pc = 0x821B09B0; continue 'dispatch;
	}
	// 821B09CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B09D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B09D0 size=1300
    let mut pc: u32 = 0x821B09D0;
    'dispatch: loop {
        match pc {
            0x821B09D0 => {
    //   block [0x821B09D0..0x821B0EE4)
	// 821B09D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B09D4: 483846B1  bl 0x82535084
	ctx.lr = 0x821B09D8;
	sub_82535080(ctx, base);
	// 821B09D8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 821B09DC: 483855E9  bl 0x82535fc4
	ctx.lr = 0x821B09E0;
	sub_82535FB0(ctx, base);
	// 821B09E0: 3981FF00  addi r12, r1, -0x100
	ctx.r[12].s64 = ctx.r[1].s64 + -256;
	// 821B09E4: 483889B9  bl 0x8253939c
	ctx.lr = 0x821B09E8;
	sub_82539130(ctx, base);
	// 821B09E8: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B09EC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B09F0: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 821B09F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B09F8: FE601090  fmr f19, f2
	ctx.f[19].f64 = ctx.f[2].f64;
	// 821B09FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B0A00: 7CAF2B78  mr r15, r5
	ctx.r[15].u64 = ctx.r[5].u64;
	// 821B0A04: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821B0A08: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B0A0C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B0A10: C28B1FF8  lfs f20, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821B0A14: 419A0020  beq cr6, 0x821b0a34
	if ctx.cr[6].eq {
	pc = 0x821B0A34; continue 'dispatch;
	}
	// 821B0A18: C3670000  lfs f27, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821B0A1C: C3870004  lfs f28, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B0A20: C0070008  lfs f0, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B0A24: C1A70014  lfs f13, 0x14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0A28: EF00D828  fsubs f24, f0, f27
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[27].f64) as f32) as f64);
	// 821B0A2C: EF2DE028  fsubs f25, f13, f28
	ctx.f[25].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 821B0A30: 48000014  b 0x821b0a44
	pc = 0x821B0A44; continue 'dispatch;
	// 821B0A34: FF80A090  fmr f28, f20
	ctx.f[28].f64 = ctx.f[20].f64;
	// 821B0A38: FF60A090  fmr f27, f20
	ctx.f[27].f64 = ctx.f[20].f64;
	// 821B0A3C: FF20F890  fmr f25, f31
	ctx.f[25].f64 = ctx.f[31].f64;
	// 821B0A40: FF00F890  fmr f24, f31
	ctx.f[24].f64 = ctx.f[31].f64;
	// 821B0A44: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 821B0A48: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B0A4C: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 821B0A50: C3A9BFFC  lfs f29, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B0A54: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0A58: EED8DF7A  fmadds f22, f24, f29, f27
	ctx.f[22].f64 = (((ctx.f[24].f64 * ctx.f[29].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B0A5C: EEB9E77A  fmadds f21, f25, f29, f28
	ctx.f[21].f64 = (((ctx.f[25].f64 * ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64);
	// 821B0A60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0A64: 419A0014  beq cr6, 0x821b0a78
	if ctx.cr[6].eq {
	pc = 0x821B0A78; continue 'dispatch;
	}
	// 821B0A68: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0A6C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A70: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B0A74: 419A0008  beq cr6, 0x821b0a7c
	if ctx.cr[6].eq {
	pc = 0x821B0A7C; continue 'dispatch;
	}
	// 821B0A78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B0A7C: 392B0090  addi r9, r11, 0x90
	ctx.r[9].s64 = ctx.r[11].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B0EE8 size=448
    let mut pc: u32 = 0x821B0EE8;
    'dispatch: loop {
        match pc {
            0x821B0EE8 => {
    //   block [0x821B0EE8..0x821B10A8)
	// 821B0EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B0EEC: 483841CD  bl 0x825350b8
	ctx.lr = 0x821B0EF0;
	sub_82535080(ctx, base);
	// 821B0EF0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821B0EF4: 483850DD  bl 0x82535fd0
	ctx.lr = 0x821B0EF8;
	sub_82535FB0(ctx, base);
	// 821B0EF8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B0EFC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B0F00: FEE00890  fmr f23, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[23].f64 = ctx.f[1].f64;
	// 821B0F04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0F08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B0F0C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821B0F10: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B0F14: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B0F18: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B0F1C: 419A0020  beq cr6, 0x821b0f3c
	if ctx.cr[6].eq {
	pc = 0x821B0F3C; continue 'dispatch;
	}
	// 821B0F20: C3450000  lfs f26, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821B0F24: C3650004  lfs f27, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821B0F28: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B0F2C: C1A50014  lfs f13, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0F30: EF00D028  fsubs f24, f0, f26
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 821B0F34: EF2DD828  fsubs f25, f13, f27
	ctx.f[25].f64 = (((ctx.f[13].f64 - ctx.f[27].f64) as f32) as f64);
	// 821B0F38: 48000014  b 0x821b0f4c
	pc = 0x821B0F4C; continue 'dispatch;
	// 821B0F3C: FF60F090  fmr f27, f30
	ctx.f[27].f64 = ctx.f[30].f64;
	// 821B0F40: FF40F090  fmr f26, f30
	ctx.f[26].f64 = ctx.f[30].f64;
	// 821B0F44: FF20F890  fmr f25, f31
	ctx.f[25].f64 = ctx.f[31].f64;
	// 821B0F48: FF00F890  fmr f24, f31
	ctx.f[24].f64 = ctx.f[31].f64;
	// 821B0F4C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B0F50: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B0F54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0F58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B0F5C: C2C92490  lfs f22, 0x2490(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9360 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821B0F60: 2F1D0020  cmpwi cr6, r29, 0x20
	ctx.cr[6].compare_i32(ctx.r[29].s32, 32, &mut ctx.xer);
	// 821B0F64: C38A2048  lfs f28, 0x2048(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B0F68: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B0F6C: 409A000C  bne cr6, 0x821b0f78
	if !ctx.cr[6].eq {
	pc = 0x821B0F78; continue 'dispatch;
	}
	// 821B0F70: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821B0F74: 4800000C  b 0x821b0f80
	pc = 0x821B0F80; continue 'dispatch;
	// 821B0F78: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B0F7C: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821B0F80: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B0F84: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821B0F88: FF0DE800  fcmpu cr6, f13, f29
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[29].f64);
	// 821B0F8C: 41980064  blt cr6, 0x821b0ff0
	if ctx.cr[6].lt {
	pc = 0x821B0FF0; continue 'dispatch;
	}
	// 821B0F90: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 821B0F94: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821B0F98: 4098003C  bge cr6, 0x821b0fd4
	if !ctx.cr[6].lt {
	pc = 0x821B0FD4; continue 'dispatch;
	}
	// 821B0F9C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B0FA0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B0FA4: 4098000C  bge cr6, 0x821b0fb0
	if !ctx.cr[6].lt {
	pc = 0x821B0FB0; continue 'dispatch;
	}
	// 821B0FA8: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B0FAC: 48000040  b 0x821b0fec
	pc = 0x821B0FEC; continue 'dispatch;
	// 821B0FB0: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821B0FB4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B0FB8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B0FBC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B0FC0: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B0FC4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B0FC8: 41980024  blt cr6, 0x821b0fec
	if ctx.cr[6].lt {
	pc = 0x821B0FEC; continue 'dispatch;
	}
	// 821B0FCC: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 821B0FD0: 4800001C  b 0x821b0fec
	pc = 0x821B0FEC; continue 'dispatch;
	// 821B0FD4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B0FD8: 41980014  blt cr6, 0x821b0fec
	if ctx.cr[6].lt {
	pc = 0x821B0FEC; continue 'dispatch;
	}
	// 821B0FDC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821B0FE0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B0FE4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B0FE8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B0FEC: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 821B0FF0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821B0FF4: EC2005B2  fmuls f1, f0, f22
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 821B0FF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B0FFC: 4BF60DD5  bl 0x82111dd0
	ctx.lr = 0x821B1000;
	sub_82111DD0(ctx, base);
	// 821B1000: C19F0000  lfs f12, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B1004: D19E0000  stfs f12, 0(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1008: 397E0030  addi r11, r30, 0x30
	ctx.r[11].s64 = ctx.r[30].s64 + 48;
	// 821B100C: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B1010: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821B1014: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B1018: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B101C: 2F1D0020  cmpwi cr6, r29, 0x20
	ctx.cr[6].compare_i32(ctx.r[29].s32, 32, &mut ctx.xer);
	// 821B1020: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1024: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B1028: ED80F82A  fadds f12, f0, f31
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821B102C: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B1030: EC00FFBA  fmadds f0, f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64);
	// 821B1034: ED6DF828  fsubs f11, f13, f31
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B1038: D2FE001C  stfs f23, 0x1c(r30)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B103C: EDADFFB8  fmsubs f13, f13, f30, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B1040: ED8C0772  fmuls f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 821B1044: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821B1048: ED6B0732  fmuls f11, f11, f28
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[28].f64) as f32) as f64);
	// 821B104C: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 821B1050: ED8CD63A  fmadds f12, f12, f24, f26
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[24].f64 + ctx.f[26].f64) as f32) as f64);
	// 821B1054: EC00D63A  fmadds f0, f0, f24, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[26].f64) as f32) as f64);
	// 821B1058: D01E0020  stfs f0, 0x20(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B105C: ED6BDE7A  fmadds f11, f11, f25, f27
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[25].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B1060: EC0DDE7A  fmadds f0, f13, f25, f27
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B1064: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B1068: C01F0200  lfs f0, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B106C: 3BCB0030  addi r30, r11, 0x30
	ctx.r[30].s64 = ctx.r[11].s64 + 48;
	// 821B1070: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1074: C01F0204  lfs f0, 0x204(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1078: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B107C: C01F0208  lfs f0, 0x208(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1080: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B1084: D18B0020  stfs f12, 0x20(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B1088: D16B0024  stfs f11, 0x24(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B108C: D2EB001C  stfs f23, 0x1c(r11)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B1090: 4099FEDC  ble cr6, 0x821b0f6c
	if !ctx.cr[6].gt {
	pc = 0x821B0F6C; continue 'dispatch;
	}
	// 821B1094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B1098: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821B109C: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821B10A0: 48384F7D  bl 0x8253601c
	ctx.lr = 0x821B10A4;
	sub_82535FFC(ctx, base);
	// 821B10A4: 48384064  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B10A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B10A8 size=480
    let mut pc: u32 = 0x821B10A8;
    'dispatch: loop {
        match pc {
            0x821B10A8 => {
    //   block [0x821B10A8..0x821B1288)
	// 821B10A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B10AC: 48384005  bl 0x825350b0
	ctx.lr = 0x821B10B0;
	sub_82535080(ctx, base);
	// 821B10B0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821B10B4: 48384F11  bl 0x82535fc4
	ctx.lr = 0x821B10B8;
	sub_82535FB0(ctx, base);
	// 821B10B8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B10BC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B10C0: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821B10C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B10C8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B10CC: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 821B10D0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821B10D4: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B10D8: C26B1FF8  lfs f19, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821B10DC: 419A0020  beq cr6, 0x821b10fc
	if ctx.cr[6].eq {
	pc = 0x821B10FC; continue 'dispatch;
	}
	// 821B10E0: C3660000  lfs f27, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821B10E4: C3860004  lfs f28, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B10E8: C0060008  lfs f0, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B10EC: C1A60014  lfs f13, 0x14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B10F0: EF00D828  fsubs f24, f0, f27
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[27].f64) as f32) as f64);
	// 821B10F4: EF2DE028  fsubs f25, f13, f28
	ctx.f[25].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 821B10F8: 48000014  b 0x821b110c
	pc = 0x821B110C; continue 'dispatch;
	// 821B10FC: FF809890  fmr f28, f19
	ctx.f[28].f64 = ctx.f[19].f64;
	// 821B1100: FF609890  fmr f27, f19
	ctx.f[27].f64 = ctx.f[19].f64;
	// 821B1104: FF20F890  fmr f25, f31
	ctx.f[25].f64 = ctx.f[31].f64;
	// 821B1108: FF00F890  fmr f24, f31
	ctx.f[24].f64 = ctx.f[31].f64;
	// 821B110C: 7F6A07B4  extsw r10, r27
	ctx.r[10].s64 = ctx.r[27].s32 as i64;
	// 821B1110: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1114: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821B1118: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 821B111C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 821B1120: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 821B1124: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B1128: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821B112C: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B1130: EEB8DF7A  fmadds f21, f24, f29, f27
	ctx.f[21].f64 = (((ctx.f[24].f64 * ctx.f[29].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B1134: EE99E77A  fmadds f20, f25, f29, f28
	ctx.f[20].f64 = (((ctx.f[25].f64 * ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64);
	// 821B1138: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B113C: EEFE0024  fdivs f23, f30, f0
	ctx.f[23].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B1140: 40990138  ble cr6, 0x821b1278
	if !ctx.cr[6].gt {
	pc = 0x821B1278; continue 'dispatch;
	}
	// 821B1144: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B1148: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B114C: 396B14B0  addi r11, r11, 0x14b0
	ctx.r[11].s64 = ctx.r[11].s64 + 5296;
	// 821B1150: 3BCB0008  addi r30, r11, 8
	ctx.r[30].s64 = ctx.r[11].s64 + 8;
	// 821B1154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1158: C2CA2490  lfs f22, 0x2490(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9360 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821B115C: C34B2048  lfs f26, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821B1160: 7F8B0034  cntlzw r11, r28
	ctx.r[11].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 821B1164: 9343005C  stw r26, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 821B1168: 3BE30030  addi r31, r3, 0x30
	ctx.r[31].s64 = ctx.r[3].s64 + 48;
	// 821B116C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B1170: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 821B1174: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1178: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B117C: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1180: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B1184: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1188: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 821B118C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B1190: D2A30020  stfs f21, 0x20(r3)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B1194: D2830024  stfs f20, 0x24(r3)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B1198: D3C3001C  stfs f30, 0x1c(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B119C: C01EFFF8  lfs f0, -8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B11A0: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B11A4: C01EFFFC  lfs f0, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B11A8: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B11AC: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B11B0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B11B4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B11B8: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821B11BC: FF0DE800  fcmpu cr6, f13, f29
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[29].f64);
	// 821B11C0: 41980064  blt cr6, 0x821b1224
	if ctx.cr[6].lt {
	pc = 0x821B1224; continue 'dispatch;
	}
	// 821B11C4: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 821B11C8: FF009800  fcmpu cr6, f0, f19
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[19].f64);
	// 821B11CC: 4098003C  bge cr6, 0x821b1208
	if !ctx.cr[6].lt {
	pc = 0x821B1208; continue 'dispatch;
	}
	// 821B11D0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B11D4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B11D8: 4098000C  bge cr6, 0x821b11e4
	if !ctx.cr[6].lt {
	pc = 0x821B11E4; continue 'dispatch;
	}
	// 821B11DC: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B11E0: 48000040  b 0x821b1220
	pc = 0x821B1220; continue 'dispatch;
	// 821B11E4: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821B11E8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B11EC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B11F0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B11F4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B11F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B11FC: 41980024  blt cr6, 0x821b1220
	if ctx.cr[6].lt {
	pc = 0x821B1220; continue 'dispatch;
	}
	// 821B1200: FC009890  fmr f0, f19
	ctx.f[0].f64 = ctx.f[19].f64;
	// 821B1204: 4800001C  b 0x821b1220
	pc = 0x821B1220; continue 'dispatch;
	// 821B1208: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B120C: 41980014  blt cr6, 0x821b1220
	if ctx.cr[6].lt {
	pc = 0x821B1220; continue 'dispatch;
	}
	// 821B1210: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821B1214: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B1218: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B121C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B1220: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 821B1224: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821B1228: EC2005B2  fmuls f1, f0, f22
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 821B122C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B1230: 4BF60BA1  bl 0x82111dd0
	ctx.lr = 0x821B1234;
	sub_82111DD0(ctx, base);
	// 821B1234: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1238: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B123C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821B1240: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B1244: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821B1248: D3DF001C  stfs f30, 0x1c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B124C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821B1250: EFDEB828  fsubs f30, f30, f23
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[23].f64) as f32) as f64);
	// 821B1254: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821B1258: 7F1CD800  cmpw cr6, r28, r27
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[27].s32, &mut ctx.xer);
	// 821B125C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821B1260: EDAD06B2  fmuls f13, f13, f26
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[26].f64) as f32) as f64);
	// 821B1264: EC00DE3A  fmadds f0, f0, f24, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B1268: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B126C: EC0DE67A  fmadds f0, f13, f25, f28
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64 + ctx.f[28].f64) as f32) as f64);
	// 821B1270: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B1274: 4198FEEC  blt cr6, 0x821b1160
	if ctx.cr[6].lt {
	pc = 0x821B1160; continue 'dispatch;
	}
	// 821B1278: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B127C: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821B1280: 48384D91  bl 0x82536010
	ctx.lr = 0x821B1284;
	sub_82535FFC(ctx, base);
	// 821B1284: 48383E7C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1288 size=656
    let mut pc: u32 = 0x821B1288;
    'dispatch: loop {
        match pc {
            0x821B1288 => {
    //   block [0x821B1288..0x821B1518)
	// 821B1288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B128C: 48383E29  bl 0x825350b4
	ctx.lr = 0x821B1290;
	sub_82535080(ctx, base);
	// 821B1290: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 821B1294: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821B1298: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821B129C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B12A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B12A4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821B12A8: 54BD057E  clrlwi r29, r5, 0x15
	ctx.r[29].u64 = ctx.r[5].u32 as u64 & 0x000007FFu64;
	// 821B12AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B12B0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821B12B4: 54A90428  rlwinm r9, r5, 0, 0x10, 0x14
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821B12B8: FB7C0000  std r27, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 821B12BC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821B12C0: 419A01A8  beq cr6, 0x821b1468
	if ctx.cr[6].eq {
	pc = 0x821B1468; continue 'dispatch;
	}
	// 821B12C4: 2F1D0059  cmpwi cr6, r29, 0x59
	ctx.cr[6].compare_i32(ctx.r[29].s32, 89, &mut ctx.xer);
	// 821B12C8: 419A0108  beq cr6, 0x821b13d0
	if ctx.cr[6].eq {
	pc = 0x821B13D0; continue 'dispatch;
	}
	// 821B12CC: 2F1D005A  cmpwi cr6, r29, 0x5a
	ctx.cr[6].compare_i32(ctx.r[29].s32, 90, &mut ctx.xer);
	// 821B12D0: 419A00F0  beq cr6, 0x821b13c0
	if ctx.cr[6].eq {
	pc = 0x821B13C0; continue 'dispatch;
	}
	// 821B12D4: 2F1D0058  cmpwi cr6, r29, 0x58
	ctx.cr[6].compare_i32(ctx.r[29].s32, 88, &mut ctx.xer);
	// 821B12D8: 41980028  blt cr6, 0x821b1300
	if ctx.cr[6].lt {
	pc = 0x821B1300; continue 'dispatch;
	}
	// 821B12DC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821B12E0: 397DFFA8  addi r11, r29, -0x58
	ctx.r[11].s64 = ctx.r[29].s64 + -88;
	// 821B12E4: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 821B12E8: 390A0002  addi r8, r10, 2
	ctx.r[8].s64 = ctx.r[10].s64 + 2;
	// 821B12EC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B12F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B12F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B12F8: 7D6B422E  lhzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B12FC: 7D7D0734  extsh r29, r11
	ctx.r[29].s64 = ctx.r[11].s16 as i64;
	// 821B1300: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B1304: 419A01FC  beq cr6, 0x821b1500
	if ctx.cr[6].eq {
	pc = 0x821B1500; continue 'dispatch;
	}
	// 821B1308: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B130C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B1310: 419A007C  beq cr6, 0x821b138c
	if ctx.cr[6].eq {
	pc = 0x821B138C; continue 'dispatch;
	}
	// 821B1314: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B1318: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B131C: 386B14A0  addi r3, r11, 0x14a0
	ctx.r[3].s64 = ctx.r[11].s64 + 5280;
	// 821B1320: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B1324: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B1328: 4BFF27E1  bl 0x821a3b08
	ctx.lr = 0x821B132C;
	sub_821A3B08(ctx, base);
	// 821B132C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B1330: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B1334: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B1338: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B133C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B1340: 4E800421  bctrl
	ctx.lr = 0x821B1344;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B1344: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B1348: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 821B134C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 821B1350: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1518 size=540
    let mut pc: u32 = 0x821B1518;
    'dispatch: loop {
        match pc {
            0x821B1518 => {
    //   block [0x821B1518..0x821B1734)
	// 821B1518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B151C: 48383B91  bl 0x825350ac
	ctx.lr = 0x821B1520;
	sub_82535080(ctx, base);
	// 821B1520: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B1528: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B152C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821B1530: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B1534: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821B1538: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821B153C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 821B1540: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B1544: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821B1548: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B154C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 821B1550: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 821B1554: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 821B1558: 93BF0044  stw r29, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[29].u32 ) };
	// 821B155C: 409A0010  bne cr6, 0x821b156c
	if !ctx.cr[6].eq {
	pc = 0x821B156C; continue 'dispatch;
	}
	// 821B1560: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B1564: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B1568: 48383B94  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
	// 821B156C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B1570: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1574: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821B1578: 388B0FA4  addi r4, r11, 0xfa4
	ctx.r[4].s64 = ctx.r[11].s64 + 4004;
	// 821B157C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B1580: 48381C11  bl 0x82533190
	ctx.lr = 0x821B1584;
	sub_82533190(ctx, base);
	// 821B1584: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B1588: 419A0010  beq cr6, 0x821b1598
	if ctx.cr[6].eq {
	pc = 0x821B1598; continue 'dispatch;
	}
	// 821B158C: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1590: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B1594: 48383B68  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
	// 821B1598: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B159C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B15A0: 2F0B0102  cmpwi cr6, r11, 0x102
	ctx.cr[6].compare_i32(ctx.r[11].s32, 258, &mut ctx.xer);
	// 821B15A4: 409AFFE8  bne cr6, 0x821b158c
	if !ctx.cr[6].eq {
	pc = 0x821B158C; continue 'dispatch;
	}
	// 821B15A8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821B15AC: 419A00AC  beq cr6, 0x821b1658
	if ctx.cr[6].eq {
	pc = 0x821B1658; continue 'dispatch;
	}
	// 821B15B0: 3B9F004C  addi r28, r31, 0x4c
	ctx.r[28].s64 = ctx.r[31].s64 + 76;
	// 821B15B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B15B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B15BC: 409A000C  bne cr6, 0x821b15c8
	if !ctx.cr[6].eq {
	pc = 0x821B15C8; continue 'dispatch;
	}
	// 821B15C0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B15C4: 4800002C  b 0x821b15f0
	pc = 0x821B15F0; continue 'dispatch;
	// 821B15C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B15CC: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B15D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B15D4: 419A000C  beq cr6, 0x821b15e0
	if ctx.cr[6].eq {
	pc = 0x821B15E0; continue 'dispatch;
	}
	// 821B15D8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B15DC: 48000014  b 0x821b15f0
	pc = 0x821B15F0; continue 'dispatch;
	// 821B15E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B15E4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B15E8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B15EC: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 821B15F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B15F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B15F8: 419A001C  beq cr6, 0x821b1614
	if ctx.cr[6].eq {
	pc = 0x821B1614; continue 'dispatch;
	}
	// 821B15FC: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B1600: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1604: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821B1608: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B160C: 419A0008  beq cr6, 0x821b1614
	if ctx.cr[6].eq {
	pc = 0x821B1614; continue 'dispatch;
	}
	// 821B1610: 4BF6BA49  bl 0x8211d058
	ctx.lr = 0x821B1614;
	sub_8211D058(ctx, base);
	// 821B1614: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B1618: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821B161C: 38CB0FA8  addi r6, r11, 0xfa8
	ctx.r[6].s64 = ctx.r[11].s64 + 4008;
	// 821B1620: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1624: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B1628: 386BDBE0  addi r3, r11, -0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + -9248;
	// 821B162C: 48043CBD  bl 0x821f52e8
	ctx.lr = 0x821B1630;
	sub_821F52E8(ctx, base);
	// 821B1630: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B1634: 419AFF58  beq cr6, 0x821b158c
	if ctx.cr[6].eq {
	pc = 0x821B158C; continue 'dispatch;
	}
	// 821B1638: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B163C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821B1640: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B1644: 4807BDA5  bl 0x8222d3e8
	ctx.lr = 0x821B1648;
	sub_8222D3E8(ctx, base);
	// 821B1648: 48383509  bl 0x82534b50
	ctx.lr = 0x821B164C;
	sub_82534B50(ctx, base);
	// 821B164C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B1650: 4807BD99  bl 0x8222d3e8
	ctx.lr = 0x821B1654;
	sub_8222D3E8(ctx, base);
	// 821B1654: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B1658: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821B165C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1660: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821B1664: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821B1668: E96AFB60  ld r11, -0x4a0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-1184 as u32) ) };
	// 821B166C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821B1670: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B1674: F96AFB60  std r11, -0x4a0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-1184 as u32), ctx.r[11].u64 ) };
	// 821B1678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B167C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B1680: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821B1684: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1688: 814A0024  lwz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B168C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B1690: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821B1694: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1698: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B169C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16A0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821B16A4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16A8: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B16AC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16B0: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B16B4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16B8: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B16BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16C0: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821B16C4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16C8: 814A0034  lwz r10, 0x34(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B16CC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16D0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821B16D4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16D8: 814A0038  lwz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B16DC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16E0: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 821B16E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16E8: 394B0040  addi r10, r11, 0x40
	ctx.r[10].s64 = ctx.r[11].s64 + 64;
	// 821B16EC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821B16F0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B16F4: F93F0058  std r9, 0x58(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 821B16F8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821B16FC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B1700: 419A000C  beq cr6, 0x821b170c
	if ctx.cr[6].eq {
	pc = 0x821B170C; continue 'dispatch;
	}
	// 821B1704: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B1708: F97B0000  std r11, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B170C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B1710: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1714: 614ABEC8  ori r10, r10, 0xbec8
	ctx.r[10].u64 = ctx.r[10].u64 | 48840;
	// 821B1718: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B171C: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 821B1720: 7D79522E  lhzx r11, r25, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B1724: 93BF0048  stw r29, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[29].u32 ) };
	// 821B1728: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 821B172C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B1730: 483839CC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1738 size=156
    let mut pc: u32 = 0x821B1738;
    'dispatch: loop {
        match pc {
            0x821B1738 => {
    //   block [0x821B1738..0x821B17D4)
	// 821B1738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B173C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B1744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1748: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B174C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B1750: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B1754: 397E004C  addi r11, r30, 0x4c
	ctx.r[11].s64 = ctx.r[30].s64 + 76;
	// 821B1758: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B175C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1760: 409A000C  bne cr6, 0x821b176c
	if !ctx.cr[6].eq {
	pc = 0x821B176C; continue 'dispatch;
	}
	// 821B1764: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 821B1768: 4800002C  b 0x821b1794
	pc = 0x821B1794; continue 'dispatch;
	// 821B176C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1770: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1774: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B1778: 419A000C  beq cr6, 0x821b1784
	if ctx.cr[6].eq {
	pc = 0x821B1784; continue 'dispatch;
	}
	// 821B177C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 821B1780: 48000014  b 0x821b1794
	pc = 0x821B1794; continue 'dispatch;
	// 821B1784: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1788: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821B178C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821B1790: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	// 821B1794: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B1798: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B179C: 419A001C  beq cr6, 0x821b17b8
	if ctx.cr[6].eq {
	pc = 0x821B17B8; continue 'dispatch;
	}
	// 821B17A0: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 821B17A4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B17A8: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821B17AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B17B0: 419A0008  beq cr6, 0x821b17b8
	if ctx.cr[6].eq {
	pc = 0x821B17B8; continue 'dispatch;
	}
	// 821B17B4: 4BF6B8A5  bl 0x8211d058
	ctx.lr = 0x821B17B8;
	sub_8211D058(ctx, base);
	// 821B17B8: 93FE003C  stw r31, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 821B17BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B17C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B17C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B17C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B17CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B17D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B17D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B17D8 size=24
    let mut pc: u32 = 0x821B17D8;
    'dispatch: loop {
        match pc {
            0x821B17D8 => {
    //   block [0x821B17D8..0x821B17F0)
	// 821B17D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B17DC: 419A0014  beq cr6, 0x821b17f0
	if ctx.cr[6].eq {
		sub_821B17F0(ctx, base);
		return;
	}
	// 821B17E0: E9680000  ld r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821B17E4: E9430058  ld r10, 0x58(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	// 821B17E8: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 821B17EC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B17F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B17F0 size=12
    let mut pc: u32 = 0x821B17F0;
    'dispatch: loop {
        match pc {
            0x821B17F0 => {
    //   block [0x821B17F0..0x821B17FC)
	// 821B17F0: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B17F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B17F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B17FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B17FC size=16
    let mut pc: u32 = 0x821B17FC;
    'dispatch: loop {
        match pc {
            0x821B17FC => {
    //   block [0x821B17FC..0x821B180C)
	// 821B17FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1800: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B1804: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B1808: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B180C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B180C size=8
    let mut pc: u32 = 0x821B180C;
    'dispatch: loop {
        match pc {
            0x821B180C => {
    //   block [0x821B180C..0x821B1814)
	// 821B180C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821B1810: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1814(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1814 size=20
    let mut pc: u32 = 0x821B1814;
    'dispatch: loop {
        match pc {
            0x821B1814 => {
    //   block [0x821B1814..0x821B1828)
	// 821B1814: 39450008  addi r10, r5, 8
	ctx.r[10].s64 = ctx.r[5].s64 + 8;
	// 821B1818: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B181C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1820: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B1824: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1828 size=24
    let mut pc: u32 = 0x821B1828;
    'dispatch: loop {
        match pc {
            0x821B1828 => {
    //   block [0x821B1828..0x821B1840)
	// 821B1828: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B182C: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B1830: 616BBEC8  ori r11, r11, 0xbec8
	ctx.r[11].u64 = ctx.r[11].u64 | 48840;
	// 821B1834: 7D645A2E  lhzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1838: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B183C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B1840 size=52
    let mut pc: u32 = 0x821B1840;
    'dispatch: loop {
        match pc {
            0x821B1840 => {
    //   block [0x821B1840..0x821B1874)
	// 821B1840: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B1844: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821B1848: C00BCFEC  lfs f0, -0x3014(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B184C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B1850: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B1854: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 821B1858: C00B06A4  lfs f0, 0x6a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B185C: 90A3002C  stw r5, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[5].u32 ) };
	// 821B1860: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821B1864: 90C30030  stw r6, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[6].u32 ) };
	// 821B1868: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B186C: 9143003C  stw r10, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 821B1870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1878 size=428
    let mut pc: u32 = 0x821B1878;
    'dispatch: loop {
        match pc {
            0x821B1878 => {
    //   block [0x821B1878..0x821B1A24)
	// 821B1878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B187C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1880: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1884: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B1888: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B188C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B1890: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1894: C14A1FF8  lfs f10, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B1898: D1460000  stfs f10, 0(r6)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B189C: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 821B18A0: 91250000  stw r9, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B18A4: 409A0170  bne cr6, 0x821b1a14
	if !ctx.cr[6].eq {
	pc = 0x821B1A14; continue 'dispatch;
	}
	// 821B18A8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B18AC: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B18B0: 614ABEC8  ori r10, r10, 0xbec8
	ctx.r[10].u64 = ctx.r[10].u64 | 48840;
	// 821B18B4: 7D44522E  lhzx r10, r4, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B18B8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B18BC: 409A0158  bne cr6, 0x821b1a14
	if !ctx.cr[6].eq {
	pc = 0x821B1A14; continue 'dispatch;
	}
	// 821B18C0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821B18C4: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B18C8: FC00581E  fctiwz f0, f11
	ctx.f[0].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 821B18CC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B18D0: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B18D4: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 821B18D8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B18DC: 7C003FAE  stfiwx f0, 0, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32, tmp.u32) };
	// 821B18E0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B18E4: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B18E8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B18EC: 1D4A0054  mulli r10, r10, 0x54
	ctx.r[10].s64 = ctx.r[10].s64 * 84;
	// 821B18F0: 7CEA4A14  add r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B18F4: A1070000  lhz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B18F8: A0670002  lhz r3, 2(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B18FC: 7D0A0734  extsh r10, r8
	ctx.r[10].s64 = ctx.r[8].s16 as i64;
	// 821B1900: 7C680734  extsh r8, r3
	ctx.r[8].s64 = ctx.r[3].s16 as i64;
	// 821B1904: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B1908: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821B190C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B1910: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1914: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821B1918: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B191C: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 821B1920: 40980098  bge cr6, 0x821b19b8
	if !ctx.cr[6].lt {
	pc = 0x821B19B8; continue 'dispatch;
	}
	// 821B1924: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1928: 1D4A000E  mulli r10, r10, 0xe
	ctx.r[10].s64 = ctx.r[10].s64 * 14;
	// 821B192C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B1930: 3D206666  lis r9, 0x6666
	ctx.r[9].s64 = 1717960704;
	// 821B1934: 61286667  ori r8, r9, 0x6667
	ctx.r[8].u64 = ctx.r[9].u64 | 26215;
	// 821B1938: A12A0002  lhz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B193C: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1940: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821B1944: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B1948: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821B194C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B1950: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1954: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821B1958: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B195C: C00923BC  lfs f0, 0x23bc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1960: 7D2A4096  mulhw r9, r10, r8
	ctx.r[9].s64 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) >> 32);
	// 821B1964: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B1968: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821B196C: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 821B1970: C9A82008  lfd f13, 0x2008(r8)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8200 as u32) ) };
	// 821B1974: 55280FFE  srwi r8, r9, 0x1f
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(31);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B1978: FD80682E  fsel f12, f0, f0, f13
	ctx.f[12].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 821B197C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821B1980: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821B1984: C8082000  lfd f0, 0x2000(r8)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8192 as u32) ) };
	// 821B1988: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B198C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821B1990: FD2C0028  fsub f9, f12, f0
	ctx.f[9].f64 = ctx.f[12].f64 - ctx.f[0].f64;
	// 821B1994: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821B1998: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B199C: FD89602E  fsel f12, f9, f0, f12
	ctx.f[12].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 821B19A0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821B19A4: FDAC6B2E  fsel f13, f12, f12, f13
	ctx.f[13].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[13].f64 };
	// 821B19A8: FD8D0028  fsub f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 821B19AC: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 821B19B0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B19B4: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B19B8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B19BC: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 821B19C0: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B19C4: A1470002  lhz r10, 2(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B19C8: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821B19CC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821B19D0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821B19D4: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B19D8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B19DC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B19E0: C1AACFEC  lfs f13, -0x3014(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B19E4: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B19E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B19EC: 41980028  blt cr6, 0x821b1a14
	if ctx.cr[6].lt {
	pc = 0x821B1A14; continue 'dispatch;
	}
	// 821B19F0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B19F4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B19F8: D14B0034  stfs f10, 0x34(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B19FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1A00: 912B003C  stw r9, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 821B1A04: 419A0010  beq cr6, 0x821b1a14
	if ctx.cr[6].eq {
	pc = 0x821B1A14; continue 'dispatch;
	}
	// 821B1A08: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821B1A0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B1A10: 4E800421  bctrl
	ctx.lr = 0x821B1A14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B1A14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1A18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1A1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1A28 size=140
    let mut pc: u32 = 0x821B1A28;
    'dispatch: loop {
        match pc {
            0x821B1A28 => {
    //   block [0x821B1A28..0x821B1AB4)
	// 821B1A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1A30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1A34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1A38: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B1A3C: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B1A40: 614ABEC8  ori r10, r10, 0xbec8
	ctx.r[10].u64 = ctx.r[10].u64 | 48840;
	// 821B1A44: 6129BE64  ori r9, r9, 0xbe64
	ctx.r[9].u64 = ctx.r[9].u64 | 48740;
	// 821B1A48: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B1A4C: 7D43522E  lhzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B1A50: 7FE348AE  lbzx r31, r3, r9
	ctx.r[31].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B1A54: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 821B1A58: 409A0008  bne cr6, 0x821b1a60
	if !ctx.cr[6].eq {
	pc = 0x821B1A60; continue 'dispatch;
	}
	// 821B1A5C: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 821B1A60: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B1A64: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821B1A68: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821B1A6C: 394ACB28  addi r10, r10, -0x34d8
	ctx.r[10].s64 = ctx.r[10].s64 + -13528;
	// 821B1A70: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821B1A74: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821B1A78: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 821B1A7C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1A80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B1A84: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B1A88: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B1A8C: 4BFFFA8D  bl 0x821b1518
	ctx.lr = 0x821B1A90;
	sub_821B1518(ctx, base);
	// 821B1A90: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 821B1A94: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B1A98: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B1A9C: 386BFFFF  addi r3, r11, -1
	ctx.r[3].s64 = ctx.r[11].s64 + -1;
	// 821B1AA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1AA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1AA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1AAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1AB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1AB8 size=416
    let mut pc: u32 = 0x821B1AB8;
    'dispatch: loop {
        match pc {
            0x821B1AB8 => {
    //   block [0x821B1AB8..0x821B1C58)
	// 821B1AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1ABC: 483835FD  bl 0x825350b8
	ctx.lr = 0x821B1AC0;
	sub_82535080(ctx, base);
	// 821B1AC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1AC4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1AC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B1ACC: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821B1AD0: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821B1AD4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821B1AD8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821B1ADC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821B1AE0: 7D5D58AE  lbzx r10, r29, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1AE4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1AE8: 6167BEC8  ori r7, r11, 0xbec8
	ctx.r[7].u64 = ctx.r[11].u64 | 48840;
	// 821B1AEC: 409A0054  bne cr6, 0x821b1b40
	if !ctx.cr[6].eq {
	pc = 0x821B1B40; continue 'dispatch;
	}
	// 821B1AF0: 7D3D3A14  add r9, r29, r7
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[7].u64;
	// 821B1AF4: A1690000  lhz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1AF8: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 821B1AFC: 419A0028  beq cr6, 0x821b1b24
	if ctx.cr[6].eq {
	pc = 0x821B1B24; continue 'dispatch;
	}
	// 821B1B00: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 821B1B04: 409A0018  bne cr6, 0x821b1b1c
	if !ctx.cr[6].eq {
	pc = 0x821B1B1C; continue 'dispatch;
	}
	// 821B1B08: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1B0C: 616BED6A  ori r11, r11, 0xed6a
	ctx.r[11].u64 = ctx.r[11].u64 | 60778;
	// 821B1B10: 7D7D5A2E  lhzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1B18: 409A000C  bne cr6, 0x821b1b24
	if !ctx.cr[6].eq {
	pc = 0x821B1B24; continue 'dispatch;
	}
	// 821B1B1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1B20: 48000008  b 0x821b1b28
	pc = 0x821B1B28; continue 'dispatch;
	// 821B1B24: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B1B28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1B30: 419A0010  beq cr6, 0x821b1b40
	if ctx.cr[6].eq {
	pc = 0x821B1B40; continue 'dispatch;
	}
	// 821B1B34: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 821B1B38: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821B1B3C: B1690000  sth r11, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 821B1B40: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1B44: 3BEBCB28  addi r31, r11, -0x34d8
	ctx.r[31].s64 = ctx.r[11].s64 + -13528;
	// 821B1B48: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1B4C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B1B50: 557E2834  slwi r30, r11, 5
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B1B54: 7D3EFA14  add r9, r30, r31
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 821B1B58: 8169003C  lwz r11, 0x3c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1B5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1B60: 409A000C  bne cr6, 0x821b1b6c
	if !ctx.cr[6].eq {
	pc = 0x821B1B6C; continue 'dispatch;
	}
	// 821B1B64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B1B68: 4800000C  b 0x821b1b74
	pc = 0x821B1B74; continue 'dispatch;
	// 821B1B6C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1B70: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B1B74: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B1B78: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B1B7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1B80: 2F0B001D  cmpwi cr6, r11, 0x1d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 29, &mut ctx.xer);
	// 821B1B84: 409A000C  bne cr6, 0x821b1b90
	if !ctx.cr[6].eq {
	pc = 0x821B1B90; continue 'dispatch;
	}
	// 821B1B88: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821B1B8C: 4800000C  b 0x821b1b98
	pc = 0x821B1B98; continue 'dispatch;
	// 821B1B90: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1B94: 409900B8  ble cr6, 0x821b1c4c
	if !ctx.cr[6].gt {
	pc = 0x821B1C4C; continue 'dispatch;
	}
	// 821B1B98: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B1B9C: 4098004C  bge cr6, 0x821b1be8
	if !ctx.cr[6].lt {
	pc = 0x821B1BE8; continue 'dispatch;
	}
	// 821B1BA0: 397F003C  addi r11, r31, 0x3c
	ctx.r[11].s64 = ctx.r[31].s64 + 60;
	// 821B1BA4: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1BA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1BAC: 419A007C  beq cr6, 0x821b1c28
	if ctx.cr[6].eq {
	pc = 0x821B1C28; continue 'dispatch;
	}
	// 821B1BB0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1BB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B1BB8: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821B1BBC: 4BFFFC1D  bl 0x821b17d8
	ctx.lr = 0x821B1BC0;
	sub_821B17D8(ctx, base);
	// 821B1BC0: 397F0120  addi r11, r31, 0x120
	ctx.r[11].s64 = ctx.r[31].s64 + 288;
	// 821B1BC4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821B1BC8: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1BCC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1BD0: 419A0058  beq cr6, 0x821b1c28
	if ctx.cr[6].eq {
	pc = 0x821B1C28; continue 'dispatch;
	}
	// 821B1BD4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B1BD8: 938B003C  stw r28, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 821B1BDC: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1BE0: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B1BE4: 48000044  b 0x821b1c28
	pc = 0x821B1C28; continue 'dispatch;
	// 821B1BE8: 397F015C  addi r11, r31, 0x15c
	ctx.r[11].s64 = ctx.r[31].s64 + 348;
	// 821B1BEC: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1BF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1BF4: 419A0034  beq cr6, 0x821b1c28
	if ctx.cr[6].eq {
	pc = 0x821B1C28; continue 'dispatch;
	}
	// 821B1BF8: 397F0120  addi r11, r31, 0x120
	ctx.r[11].s64 = ctx.r[31].s64 + 288;
	// 821B1BFC: 7CAA2050  subf r5, r10, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 821B1C00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B1C04: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821B1C08: 4BFFFBD1  bl 0x821b17d8
	ctx.lr = 0x821B1C0C;
	sub_821B17D8(ctx, base);
	// 821B1C0C: 8169003C  lwz r11, 0x3c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1C10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1C14: 419A0014  beq cr6, 0x821b1c28
	if ctx.cr[6].eq {
	pc = 0x821B1C28; continue 'dispatch;
	}
	// 821B1C18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1C1C: 9389003C  stw r28, 0x3c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 821B1C20: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1C24: D0090034  stfs f0, 0x34(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B1C28: 7D7D3A14  add r11, r29, r7
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[7].u64;
	// 821B1C2C: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1C30: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 821B1C34: 409A000C  bne cr6, 0x821b1c40
	if !ctx.cr[6].eq {
	pc = 0x821B1C40; continue 'dispatch;
	}
	// 821B1C38: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B1C3C: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 821B1C40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B1C44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B1C48: 483834C0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821B1C4C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821B1C50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B1C54: 483834B4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B1C58 size=88
    let mut pc: u32 = 0x821B1C58;
    'dispatch: loop {
        match pc {
            0x821B1C58 => {
    //   block [0x821B1C58..0x821B1CB0)
	// 821B1C58: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B1C5C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B1C60: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 821B1C64: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B1C68: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 821B1C6C: 6129BEC8  ori r9, r9, 0xbec8
	ctx.r[9].u64 = ctx.r[9].u64 | 48840;
	// 821B1C70: 6108BE64  ori r8, r8, 0xbe64
	ctx.r[8].u64 = ctx.r[8].u64 | 48740;
	// 821B1C74: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1C78: 7D4B4A2E  lhzx r10, r11, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B1C7C: 7D2B40AE  lbzx r9, r11, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B1C80: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B1C84: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 821B1C88: 419A0028  beq cr6, 0x821b1cb0
	if ctx.cr[6].eq {
		sub_821B1CB0(ctx, base);
		return;
	}
	// 821B1C8C: 2B0A0023  cmplwi cr6, r10, 0x23
	ctx.cr[6].compare_u32(ctx.r[10].u32, 35 as u32, &mut ctx.xer);
	// 821B1C90: 409A0018  bne cr6, 0x821b1ca8
	if !ctx.cr[6].eq {
	pc = 0x821B1CA8; continue 'dispatch;
	}
	// 821B1C94: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B1C98: 614AED6A  ori r10, r10, 0xed6a
	ctx.r[10].u64 = ctx.r[10].u64 | 60778;
	// 821B1C9C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B1CA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1CA4: 409A000C  bne cr6, 0x821b1cb0
	if !ctx.cr[6].eq {
		sub_821B1CB0(ctx, base);
		return;
	}
	// 821B1CA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1CAC: 48000008  b 0x821b1cb4
	sub_821B1CB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B1CB0 size=136
    let mut pc: u32 = 0x821B1CB0;
    'dispatch: loop {
        match pc {
            0x821B1CB0 => {
    //   block [0x821B1CB0..0x821B1D38)
	// 821B1CB0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821B1CB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1CB8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B1CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1CC0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1CC4: 396BCB28  addi r11, r11, -0x34d8
	ctx.r[11].s64 = ctx.r[11].s64 + -13528;
	// 821B1CC8: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1CCC: 419A0034  beq cr6, 0x821b1d00
	if ctx.cr[6].eq {
	pc = 0x821B1D00; continue 'dispatch;
	}
	// 821B1CD0: 814B00FC  lwz r10, 0xfc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 821B1CD4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1CD8: 419A0010  beq cr6, 0x821b1ce8
	if ctx.cr[6].eq {
	pc = 0x821B1CE8; continue 'dispatch;
	}
	// 821B1CDC: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821B1CE0: D00B00F4  stfs f0, 0xf4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 821B1CE4: 914B00FC  stw r10, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	// 821B1CE8: 814B021C  lwz r10, 0x21c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(540 as u32) ) } as u64;
	// 821B1CEC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1CF0: 419A0010  beq cr6, 0x821b1d00
	if ctx.cr[6].eq {
	pc = 0x821B1D00; continue 'dispatch;
	}
	// 821B1CF4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821B1CF8: D00B0214  stfs f0, 0x214(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(532 as u32), tmp.u32 ) };
	// 821B1CFC: 914B021C  stw r10, 0x21c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(540 as u32), ctx.r[10].u32 ) };
	// 821B1D00: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B1D04: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821B1D08: 55492834  slwi r9, r10, 5
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B1D0C: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821B1D10: 80EA003C  lwz r7, 0x3c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1D14: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821B1D18: 419A000C  beq cr6, 0x821b1d24
	if ctx.cr[6].eq {
	pc = 0x821B1D24; continue 'dispatch;
	}
	// 821B1D1C: D00A0034  stfs f0, 0x34(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B1D20: 910A003C  stw r8, 0x3c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 821B1D24: 396B0120  addi r11, r11, 0x120
	ctx.r[11].s64 = ctx.r[11].s64 + 288;
	// 821B1D28: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821B1D2C: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1D30: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1D34: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B1D38 size=12
    let mut pc: u32 = 0x821B1D38;
    'dispatch: loop {
        match pc {
            0x821B1D38 => {
    //   block [0x821B1D38..0x821B1D44)
	// 821B1D38: D00B0034  stfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B1D3C: 910B003C  stw r8, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 821B1D40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1D48 size=344
    let mut pc: u32 = 0x821B1D48;
    'dispatch: loop {
        match pc {
            0x821B1D48 => {
    //   block [0x821B1D48..0x821B1EA0)
	// 821B1D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1D4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1D50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1D54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1D58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1D5C: 3FE30002  addis r31, r3, 2
	ctx.r[31].s64 = ctx.r[3].s64 + 131072;
	// 821B1D60: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821B1D64: 3BFFBEC8  addi r31, r31, -0x4138
	ctx.r[31].s64 = ctx.r[31].s64 + -16696;
	// 821B1D68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B1D6C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1D70: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1D74: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821B1D78: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1D7C: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B1D80: 7D2358AE  lbzx r9, r3, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1D84: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1D88: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 821B1D8C: 419A0028  beq cr6, 0x821b1db4
	if ctx.cr[6].eq {
	pc = 0x821B1DB4; continue 'dispatch;
	}
	// 821B1D90: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 821B1D94: 409A0018  bne cr6, 0x821b1dac
	if !ctx.cr[6].eq {
	pc = 0x821B1DAC; continue 'dispatch;
	}
	// 821B1D98: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1D9C: 616BED6A  ori r11, r11, 0xed6a
	ctx.r[11].u64 = ctx.r[11].u64 | 60778;
	// 821B1DA0: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1DA8: 409A000C  bne cr6, 0x821b1db4
	if !ctx.cr[6].eq {
	pc = 0x821B1DB4; continue 'dispatch;
	}
	// 821B1DAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1DB0: 48000008  b 0x821b1db8
	pc = 0x821B1DB8; continue 'dispatch;
	// 821B1DB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1DB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1DC0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1DC4: 396BCB28  addi r11, r11, -0x34d8
	ctx.r[11].s64 = ctx.r[11].s64 + -13528;
	// 821B1DC8: 419A0084  beq cr6, 0x821b1e4c
	if ctx.cr[6].eq {
	pc = 0x821B1E4C; continue 'dispatch;
	}
	// 821B1DCC: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 821B1DD0: B15F0000  sth r10, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 821B1DD4: 814B00FC  lwz r10, 0xfc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 821B1DD8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821B1DDC: 409A0030  bne cr6, 0x821b1e0c
	if !ctx.cr[6].eq {
	pc = 0x821B1E0C; continue 'dispatch;
	}
	// 821B1DE0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1DE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B1DE8: 386B00C0  addi r3, r11, 0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + 192;
	// 821B1DEC: 4BFFFA8D  bl 0x821b1878
	ctx.lr = 0x821B1DF0;
	sub_821B1878(ctx, base);
	// 821B1DF0: 39600023  li r11, 0x23
	ctx.r[11].s64 = 35;
	// 821B1DF4: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 821B1DF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1E04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1E08: 4E800020  blr
	return;
	// 821B1E0C: 814B021C  lwz r10, 0x21c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(540 as u32) ) } as u64;
	// 821B1E10: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821B1E14: 409A0030  bne cr6, 0x821b1e44
	if !ctx.cr[6].eq {
	pc = 0x821B1E44; continue 'dispatch;
	}
	// 821B1E18: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1E1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B1E20: 386B01E0  addi r3, r11, 0x1e0
	ctx.r[3].s64 = ctx.r[11].s64 + 480;
	// 821B1E24: 4BFFFA55  bl 0x821b1878
	ctx.lr = 0x821B1E28;
	sub_821B1878(ctx, base);
	// 821B1E28: 39600023  li r11, 0x23
	ctx.r[11].s64 = 35;
	// 821B1E2C: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 821B1E30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1E3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1E40: 4E800020  blr
	return;
	// 821B1E44: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B1E48: B15F0000  sth r10, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 821B1E4C: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B1E50: 390B003C  addi r8, r11, 0x3c
	ctx.r[8].s64 = ctx.r[11].s64 + 60;
	// 821B1E54: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821B1E58: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B1E5C: 7D2A402E  lwzx r9, r10, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B1E60: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 821B1E64: 419A0018  beq cr6, 0x821b1e7c
	if ctx.cr[6].eq {
	pc = 0x821B1E7C; continue 'dispatch;
	}
	// 821B1E68: 392B015C  addi r9, r11, 0x15c
	ctx.r[9].s64 = ctx.r[11].s64 + 348;
	// 821B1E6C: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B1E70: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 821B1E74: 409A0018  bne cr6, 0x821b1e8c
	if !ctx.cr[6].eq {
	pc = 0x821B1E8C; continue 'dispatch;
	}
	// 821B1E78: 396B0120  addi r11, r11, 0x120
	ctx.r[11].s64 = ctx.r[11].s64 + 288;
	// 821B1E7C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1E80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B1E84: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B1E88: 4BFFF9F1  bl 0x821b1878
	ctx.lr = 0x821B1E8C;
	sub_821B1878(ctx, base);
	// 821B1E8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1E90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1E94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1E98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1E9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1EA0 size=96
    let mut pc: u32 = 0x821B1EA0;
    'dispatch: loop {
        match pc {
            0x821B1EA0 => {
    //   block [0x821B1EA0..0x821B1F00)
	// 821B1EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1EA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B1EAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1EB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1EB4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1EB8: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B1EBC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1EC0: 3BEBCB28  addi r31, r11, -0x34d8
	ctx.r[31].s64 = ctx.r[11].s64 + -13528;
	// 821B1EC4: 7D6350AE  lbzx r11, r3, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B1EC8: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821B1ECC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B1ED0: 557E2834  slwi r30, r11, 5
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B1ED4: 7C7EFA14  add r3, r30, r31
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 821B1ED8: 4BFFF861  bl 0x821b1738
	ctx.lr = 0x821B1EDC;
	sub_821B1738(ctx, base);
	// 821B1EDC: 397F0120  addi r11, r31, 0x120
	ctx.r[11].s64 = ctx.r[31].s64 + 288;
	// 821B1EE0: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821B1EE4: 4BFFF855  bl 0x821b1738
	ctx.lr = 0x821B1EE8;
	sub_821B1738(ctx, base);
	// 821B1EE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B1EEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1EF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1EF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B1EF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1F00 size=312
    let mut pc: u32 = 0x821B1F00;
    'dispatch: loop {
        match pc {
            0x821B1F00 => {
    //   block [0x821B1F00..0x821B2038)
	// 821B1F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1F04: 483831AD  bl 0x825350b0
	ctx.lr = 0x821B1F08;
	sub_82535080(ctx, base);
	// 821B1F08: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821B1F0C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1F10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B1F14: 3B800007  li r28, 7
	ctx.r[28].s64 = 7;
	// 821B1F18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B1F1C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1F20: 3B6B0100  addi r27, r11, 0x100
	ctx.r[27].s64 = ctx.r[11].s64 + 256;
	// 821B1F24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1F28: 3B5B1BC8  addi r26, r27, 0x1bc8
	ctx.r[26].s64 = ctx.r[27].s64 + 7112;
	// 821B1F2C: 3BFA000C  addi r31, r26, 0xc
	ctx.r[31].s64 = ctx.r[26].s64 + 12;
	// 821B1F30: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B1F34: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1F38: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 821B1F3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1F40: 915FFFF8  stw r10, -8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[10].u32 ) };
	// 821B1F44: 419A0018  beq cr6, 0x821b1f5c
	if ctx.cr[6].eq {
	pc = 0x821B1F5C; continue 'dispatch;
	}
	// 821B1F48: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1F4C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1F50: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1F54: 41990010  bgt cr6, 0x821b1f64
	if ctx.cr[6].gt {
	pc = 0x821B1F64; continue 'dispatch;
	}
	// 821B1F58: 48000008  b 0x821b1f60
	pc = 0x821B1F60; continue 'dispatch;
	// 821B1F5C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1F60: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1F64: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821B1F68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1F6C: 419A0018  beq cr6, 0x821b1f84
	if ctx.cr[6].eq {
	pc = 0x821B1F84; continue 'dispatch;
	}
	// 821B1F70: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1F74: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1F78: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1F7C: 41990010  bgt cr6, 0x821b1f8c
	if ctx.cr[6].gt {
	pc = 0x821B1F8C; continue 'dispatch;
	}
	// 821B1F80: 48000008  b 0x821b1f88
	pc = 0x821B1F88; continue 'dispatch;
	// 821B1F84: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1F88: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1F8C: 387FFFF4  addi r3, r31, -0xc
	ctx.r[3].s64 = ctx.r[31].s64 + -12;
	// 821B1F90: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1F94: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B1F98: 4BF72381  bl 0x82124318
	ctx.lr = 0x821B1F9C;
	sub_82124318(ctx, base);
	// 821B1F9C: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 821B1FA0: 3BFF00A8  addi r31, r31, 0xa8
	ctx.r[31].s64 = ctx.r[31].s64 + 168;
	// 821B1FA4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B1FA8: 409AFF8C  bne cr6, 0x821b1f34
	if !ctx.cr[6].eq {
	pc = 0x821B1F34; continue 'dispatch;
	}
	// 821B1FAC: 387A0348  addi r3, r26, 0x348
	ctx.r[3].s64 = ctx.r[26].s64 + 840;
	// 821B1FB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B1FB4: 4BF72365  bl 0x82124318
	ctx.lr = 0x821B1FB8;
	sub_82124318(ctx, base);
	// 821B1FB8: 397B02BC  addi r11, r27, 0x2bc
	ctx.r[11].s64 = ctx.r[27].s64 + 700;
	// 821B1FBC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821B1FC0: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B1FC4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B1FC8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B1FCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B1FD0: 4200FFF8  bdnz 0x821b1fc8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B1FC8; continue 'dispatch;
	}
	// 821B1FD4: D3FB1BC4  stfs f31, 0x1bc4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(7108 as u32), tmp.u32 ) };
	// 821B1FD8: 93DB1BC0  stw r30, 0x1bc0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(7104 as u32), ctx.r[30].u32 ) };
	// 821B1FDC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1FE4: 419A0030  beq cr6, 0x821b2014
	if ctx.cr[6].eq {
	pc = 0x821B2014; continue 'dispatch;
	}
	// 821B1FE8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1FF0: 419A0024  beq cr6, 0x821b2014
	if ctx.cr[6].eq {
	pc = 0x821B2014; continue 'dispatch;
	}
	// 821B1FF4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B1FF8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B1FFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B2000: 816BFB08  lwz r11, -0x4f8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1272 as u32) ) } as u64;
	// 821B2004: D3FD003C  stfs f31, 0x3c(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B2008: 93DD0030  stw r30, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 821B200C: 917D0038  stw r11, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 821B2010: 480010A9  bl 0x821b30b8
	ctx.lr = 0x821B2014;
	sub_821B30B8(ctx, base);
	// 821B2014: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B2018: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821B201C: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B2020: D01D0040  stfs f0, 0x40(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821B2024: 915D0024  stw r10, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821B2028: D01D0044  stfs f0, 0x44(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821B202C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B2030: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821B2034: 483830CC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B2038 size=3844
    let mut pc: u32 = 0x821B2038;
    'dispatch: loop {
        match pc {
            0x821B2038 => {
    //   block [0x821B2038..0x821B2F3C)
	// 821B2038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B203C: 4838306D  bl 0x825350a8
	ctx.lr = 0x821B2040;
	sub_82535080(ctx, base);
	// 821B2040: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 821B2044: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 821B2048: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821B204C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2050: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B2054: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821B2058: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821B205C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821B2060: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821B2064: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2068: 3B8B0100  addi r28, r11, 0x100
	ctx.r[28].s64 = ctx.r[11].s64 + 256;
	// 821B206C: 3BFC1BC8  addi r31, r28, 0x1bc8
	ctx.r[31].s64 = ctx.r[28].s64 + 7112;
	// 821B2070: 419A0030  beq cr6, 0x821b20a0
	if ctx.cr[6].eq {
	pc = 0x821B20A0; continue 'dispatch;
	}
	// 821B2074: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B2078: 616B9CC0  ori r11, r11, 0x9cc0
	ctx.r[11].u64 = ctx.r[11].u64 | 40128;
	// 821B207C: 7D78582E  lwzx r11, r24, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B2080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B2084: 419A0014  beq cr6, 0x821b2098
	if ctx.cr[6].eq {
	pc = 0x821B2098; continue 'dispatch;
	}
	// 821B2088: 817B0048  lwz r11, 0x48(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B208C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B2090: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821B2094: 4199001C  bgt cr6, 0x821b20b0
	if ctx.cr[6].gt {
	pc = 0x821B20B0; continue 'dispatch;
	}
	// 821B2098: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B209C: 48000014  b 0x821b20b0
	pc = 0x821B20B0; continue 'dispatch;
	// 821B20A0: 817B0048  lwz r11, 0x48(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B20A4: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 821B20A8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821B20AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B20B0: 917B0028  stw r11, 0x28(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 821B20B4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B20B8: 815B0024  lwz r10, 0x24(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B20BC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B20C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B20C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B20C8: C3A91FF8  lfs f29, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B20CC: C3CABA38  lfs f30, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B20D0: 419A00DC  beq cr6, 0x821b21ac
	if ctx.cr[6].eq {
	pc = 0x821B21AC; continue 'dispatch;
	}
	// 821B20D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B20D8: 419A0048  beq cr6, 0x821b2120
	if ctx.cr[6].eq {
	pc = 0x821B2120; continue 'dispatch;
	}
	// 821B20DC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821B20E0: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 821B20E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B20E8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821B20EC: 4BF7222D  bl 0x82124318
	ctx.lr = 0x821B20F0;
	sub_82124318(ctx, base);
	// 821B20F0: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 821B20F4: 3BBD00A8  addi r29, r29, 0xa8
	ctx.r[29].s64 = ctx.r[29].s64 + 168;
	// 821B20F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B20FC: 409AFFE8  bne cr6, 0x821b20e4
	if !ctx.cr[6].eq {
	pc = 0x821B20E4; continue 'dispatch;
	}
	// 821B2100: 397C02BC  addi r11, r28, 0x2bc
	ctx.r[11].s64 = ctx.r[28].s64 + 700;
	// 821B2104: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821B2108: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B210C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B2110: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B2114: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B2118: 4200FFF8  bdnz 0x821b2110
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B2110; continue 'dispatch;
	}
	// 821B211C: 48000090  b 0x821b21ac
	pc = 0x821B21AC; continue 'dispatch;
	// 821B2120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B2124: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821B2128: 4BF721F1  bl 0x82124318
	ctx.lr = 0x821B212C;
	sub_82124318(ctx, base);
	// 821B212C: 3880004F  li r4, 0x4f
	ctx.r[4].s64 = 79;
	// 821B2130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B2134: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821B2138: 4BF72189  bl 0x821242c0
	ctx.lr = 0x821B213C;
	sub_821242C0(ctx, base);
	// 821B213C: 38800043  li r4, 0x43
	ctx.r[4].s64 = 67;
	// 821B2140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B2144: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821B2148: 4BF72179  bl 0x821242c0
	ctx.lr = 0x821B214C;
	sub_821242C0(ctx, base);
	// 821B214C: 3D203F59  lis r9, 0x3f59
	ctx.r[9].s64 = 1062797312;
	// 821B2150: 397C02BC  addi r11, r28, 0x2bc
	ctx.r[11].s64 = ctx.r[28].s64 + 700;
	// 821B2154: 6129999A  ori r9, r9, 0x999a
	ctx.r[9].u64 = ctx.r[9].u64 | 39322;
	// 821B2158: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B215C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B2160: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B2164: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B2168: 4200FFF8  bdnz 0x821b2160
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B2160; continue 'dispatch;
	}
	// 821B216C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B2170: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821B2174: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B2178: 614A8654  ori r10, r10, 0x8654
	ctx.r[10].u64 = ctx.r[10].u64 | 34388;
	// 821B217C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B2180: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 821B2184: 419A000C  beq cr6, 0x821b2190
	if ctx.cr[6].eq {
	pc = 0x821B2190; continue 'dispatch;
	}
	// 821B2188: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 821B218C: 409A0020  bne cr6, 0x821b21ac
	if !ctx.cr[6].eq {
	pc = 0x821B21AC; continue 'dispatch;
	}
	// 821B2190: 397C031C  addi r11, r28, 0x31c
	ctx.r[11].s64 = ctx.r[28].s64 + 796;
	// 821B2194: 3D203F40  lis r9, 0x3f40
	ctx.r[9].s64 = 1061158912;
	// 821B2198: 3940000B  li r10, 0xb
	ctx.r[10].s64 = 11;
	// 821B219C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B21A0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B21A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B21A8: 4200FFF8  bdnz 0x821b21a0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B21A0; continue 'dispatch;
	}
	// 821B21AC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821B21B0: 419A0024  beq cr6, 0x821b21d4
	if ctx.cr[6].eq {
	pc = 0x821B21D4; continue 'dispatch;
	}
	// 821B21B4: 81780030  lwz r11, 0x30(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B21B8: 38780030  addi r3, r24, 0x30
	ctx.r[3].s64 = ctx.r[24].s64 + 48;
	// 821B21BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B21C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B21C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B21C8: 4E800421  bctrl
	ctx.lr = 0x821B21CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B21CC: 907C2060  stw r3, 0x2060(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8288 as u32), ctx.r[3].u32 ) };
	// 821B21D0: 48000008  b 0x821b21d8
	pc = 0x821B21D8; continue 'dispatch;
	// 821B21D4: 933C2060  stw r25, 0x2060(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8288 as u32), ctx.r[25].u32 ) };
	// 821B21D8: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B21DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B21E0: 419A0010  beq cr6, 0x821b21f0
	if ctx.cr[6].eq {
	pc = 0x821B21F0; continue 'dispatch;
	}
	// 821B21E4: D3BB0014  stfs f29, 0x14(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B21E8: D3BB003C  stfs f29, 0x3c(r27)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B21EC: D3DB0040  stfs f30, 0x40(r27)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821B21F0: C01B0014  lfs f0, 0x14(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B21F4: 397F0150  addi r11, r31, 0x150
	ctx.r[11].s64 = ctx.r[31].s64 + 336;
	// 821B21F8: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 821B21FC: 4098000C  bge cr6, 0x821b2208
	if !ctx.cr[6].lt {
	pc = 0x821B2208; continue 'dispatch;
	}
	// 821B2200: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821B2204: 48000010  b 0x821b2214
	pc = 0x821B2214; continue 'dispatch;
	// 821B2208: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821B220C: 40990008  ble cr6, 0x821b2214
	if !ctx.cr[6].gt {
	pc = 0x821B2214; continue 'dispatch;
	}
	// 821B2210: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 821B2214: C1BB0044  lfs f13, 0x44(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2218: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B221C: EDBE6828  fsubs f13, f30, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B2220: C3EA2150  lfs f31, 0x2150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8528 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B2224: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2228: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B222C: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 821B2230: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B2234: EDBE0028  fsubs f13, f30, f0
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B2238: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B223C: 40980014  bge cr6, 0x821b2250
	if !ctx.cr[6].lt {
	pc = 0x821B2250; continue 'dispatch;
	}
	// 821B2240: 3980FF7F  li r12, -0x81
	ctx.r[12].s64 = -129;
	// 821B2244: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2248: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B224C: 48000010  b 0x821b225c
	pc = 0x821B225C; continue 'dispatch;
	// 821B2250: 614A0080  ori r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 128;
	// 821B2254: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2258: D1BF0034  stfs f13, 0x34(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B225C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2260: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2264: 40980014  bge cr6, 0x821b2278
	if !ctx.cr[6].lt {
	pc = 0x821B2278; continue 'dispatch;
	}
	// 821B2268: 3980FF7F  li r12, -0x81
	ctx.r[12].s64 = -129;
	// 821B226C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2270: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2274: 48000010  b 0x821b2284
	pc = 0x821B2284; continue 'dispatch;
	// 821B2278: 614A0080  ori r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 128;
	// 821B227C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2280: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B2284: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2288: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B228C: 40980014  bge cr6, 0x821b22a0
	if !ctx.cr[6].lt {
	pc = 0x821B22A0; continue 'dispatch;
	}
	// 821B2290: 3980FEFF  li r12, -0x101
	ctx.r[12].s64 = -257;
	// 821B2294: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2298: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B229C: 48000010  b 0x821b22ac
	pc = 0x821B22AC; continue 'dispatch;
	// 821B22A0: 614A0100  ori r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 256;
	// 821B22A4: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22A8: D1BF0038  stfs f13, 0x38(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B22AC: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B22B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B22B4: 40980014  bge cr6, 0x821b22c8
	if !ctx.cr[6].lt {
	pc = 0x821B22C8; continue 'dispatch;
	}
	// 821B22B8: 3980FEFF  li r12, -0x101
	ctx.r[12].s64 = -257;
	// 821B22BC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B22C0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22C4: 48000010  b 0x821b22d4
	pc = 0x821B22D4; continue 'dispatch;
	// 821B22C8: 614A0100  ori r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 256;
	// 821B22CC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22D0: D00B0038  stfs f0, 0x38(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B22D4: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B22D8: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B22DC: 40980018  bge cr6, 0x821b22f4
	if !ctx.cr[6].lt {
	pc = 0x821B22F4; continue 'dispatch;
	}
	// 821B22E0: 3D80FFF7  lis r12, -9
	ctx.r[12].s64 = -589824;
	// 821B22E4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B22E8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B22EC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22F0: 48000010  b 0x821b2300
	pc = 0x821B2300; continue 'dispatch;
	// 821B22F4: 654A0008  oris r10, r10, 8
	ctx.r[10].u64 = ctx.r[10].u64 | 524288;
	// 821B22F8: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22FC: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B2300: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2304: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2308: 40980018  bge cr6, 0x821b2320
	if !ctx.cr[6].lt {
	pc = 0x821B2320; continue 'dispatch;
	}
	// 821B230C: 3D80FFF7  lis r12, -9
	ctx.r[12].s64 = -589824;
	// 821B2310: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2314: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2318: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B231C: 48000010  b 0x821b232c
	pc = 0x821B232C; continue 'dispatch;
	// 821B2320: 654A0008  oris r10, r10, 8
	ctx.r[10].u64 = ctx.r[10].u64 | 524288;
	// 821B2324: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2328: D00B0064  stfs f0, 0x64(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B232C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2330: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B2334: 40980018  bge cr6, 0x821b234c
	if !ctx.cr[6].lt {
	pc = 0x821B234C; continue 'dispatch;
	}
	// 821B2338: 3D80FFEF  lis r12, -0x11
	ctx.r[12].s64 = -1114112;
	// 821B233C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2340: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2344: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2348: 48000010  b 0x821b2358
	pc = 0x821B2358; continue 'dispatch;
	// 821B234C: 654A0010  oris r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 1048576;
	// 821B2350: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2354: D1BF0068  stfs f13, 0x68(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821B2358: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B235C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2360: 40980018  bge cr6, 0x821b2378
	if !ctx.cr[6].lt {
	pc = 0x821B2378; continue 'dispatch;
	}
	// 821B2364: 3D80FFEF  lis r12, -0x11
	ctx.r[12].s64 = -1114112;
	// 821B2368: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B236C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2370: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2374: 48000010  b 0x821b2384
	pc = 0x821B2384; continue 'dispatch;
	// 821B2378: 654A0010  oris r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 1048576;
	// 821B237C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2380: D00B0068  stfs f0, 0x68(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821B2384: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821B2388: 419A0738  beq cr6, 0x821b2ac0
	if ctx.cr[6].eq {
	pc = 0x821B2AC0; continue 'dispatch;
	}
	// 821B238C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B2390: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 821B2394: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821B2398: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B239C: 4BFFF9AD  bl 0x821b1d48
	ctx.lr = 0x821B23A0;
	sub_821B1D48(ctx, base);
	// 821B23A0: C01B0034  lfs f0, 0x34(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B23A4: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B23A8: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B23AC: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B23B0: 397F00A8  addi r11, r31, 0xa8
	ctx.r[11].s64 = ctx.r[31].s64 + 168;
	// 821B23B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B23B8: EDBE0028  fsubs f13, f30, f0
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B23BC: 419A0010  beq cr6, 0x821b23cc
	if ctx.cr[6].eq {
	pc = 0x821B23CC; continue 'dispatch;
	}
	// 821B23C0: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B23C4: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821B23C8: 48000008  b 0x821b23d0
	pc = 0x821B23D0; continue 'dispatch;
	// 821B23CC: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821B23D0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B23D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B23D8: 419A0024  beq cr6, 0x821b23fc
	if ctx.cr[6].eq {
	pc = 0x821B23FC; continue 'dispatch;
	}
	// 821B23DC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B23E0: 41980010  blt cr6, 0x821b23f0
	if ctx.cr[6].lt {
	pc = 0x821B23F0; continue 'dispatch;
	}
	// 821B23E4: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B23E8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B23EC: 41980014  blt cr6, 0x821b2400
	if ctx.cr[6].lt {
	pc = 0x821B2400; continue 'dispatch;
	}
	// 821B23F0: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B23F4: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 821B23F8: 4800000C  b 0x821b2404
	pc = 0x821B2404; continue 'dispatch;
	// 821B23FC: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2400: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821B2404: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2408: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B240C: 40980010  bge cr6, 0x821b241c
	if !ctx.cr[6].lt {
	pc = 0x821B241C; continue 'dispatch;
	}
	// 821B2410: 794A07A4  rldicr r10, r10, 0, 0x3e
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(0) & 0xFFFFFFFFFFFFFFFE;
	// 821B2414: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2418: 48000010  b 0x821b2428
	pc = 0x821B2428; continue 'dispatch;
	// 821B241C: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 821B2420: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2424: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B2428: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B242C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2430: 40980010  bge cr6, 0x821b2440
	if !ctx.cr[6].lt {
	pc = 0x821B2440; continue 'dispatch;
	}
	// 821B2434: 794A07A4  rldicr r10, r10, 0, 0x3e
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(0) & 0xFFFFFFFFFFFFFFFE;
	// 821B2438: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B243C: 48000010  b 0x821b244c
	pc = 0x821B244C; continue 'dispatch;
	// 821B2440: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 821B2444: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2448: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B244C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2450: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B2454: 40980014  bge cr6, 0x821b2468
	if !ctx.cr[6].lt {
	pc = 0x821B2468; continue 'dispatch;
	}
	// 821B2458: 3980FFFD  li r12, -3
	ctx.r[12].s64 = -3;
	// 821B245C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2460: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2464: 48000010  b 0x821b2474
	pc = 0x821B2474; continue 'dispatch;
	// 821B2468: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 821B246C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2470: D1BF001C  stfs f13, 0x1c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B2474: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2478: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B247C: 40980014  bge cr6, 0x821b2490
	if !ctx.cr[6].lt {
	pc = 0x821B2490; continue 'dispatch;
	}
	// 821B2480: 3980FFFD  li r12, -3
	ctx.r[12].s64 = -3;
	// 821B2484: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2488: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B248C: 48000010  b 0x821b249c
	pc = 0x821B249C; continue 'dispatch;
	// 821B2490: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 821B2494: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2498: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B249C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B24A0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B24A4: 40980014  bge cr6, 0x821b24b8
	if !ctx.cr[6].lt {
	pc = 0x821B24B8; continue 'dispatch;
	}
	// 821B24A8: 3980EFFF  li r12, -0x1001
	ctx.r[12].s64 = -4097;
	// 821B24AC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B24B0: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B24B4: 48000010  b 0x821b24c4
	pc = 0x821B24C4; continue 'dispatch;
	// 821B24B8: 614A1000  ori r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 4096;
	// 821B24BC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B24C0: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821B24C4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B24C8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B24CC: 40980014  bge cr6, 0x821b24e0
	if !ctx.cr[6].lt {
	pc = 0x821B24E0; continue 'dispatch;
	}
	// 821B24D0: 3980EFFF  li r12, -0x1001
	ctx.r[12].s64 = -4097;
	// 821B24D4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B24D8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B24DC: 48000010  b 0x821b24ec
	pc = 0x821B24EC; continue 'dispatch;
	// 821B24E0: 614A1000  ori r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 4096;
	// 821B24E4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B24E8: D00B0048  stfs f0, 0x48(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821B24EC: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B24F0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B24F4: 40980014  bge cr6, 0x821b2508
	if !ctx.cr[6].lt {
	pc = 0x821B2508; continue 'dispatch;
	}
	// 821B24F8: 3980DFFF  li r12, -0x2001
	ctx.r[12].s64 = -8193;
	// 821B24FC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2500: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2504: 48000010  b 0x821b2514
	pc = 0x821B2514; continue 'dispatch;
	// 821B2508: 614A2000  ori r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 8192;
	// 821B250C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2510: D1BF004C  stfs f13, 0x4c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821B2514: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2518: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B251C: 40980014  bge cr6, 0x821b2530
	if !ctx.cr[6].lt {
	pc = 0x821B2530; continue 'dispatch;
	}
	// 821B2520: 3980DFFF  li r12, -0x2001
	ctx.r[12].s64 = -8193;
	// 821B2524: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2528: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B252C: 48000010  b 0x821b253c
	pc = 0x821B253C; continue 'dispatch;
	// 821B2530: 614A2000  ori r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 8192;
	// 821B2534: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2538: D00B004C  stfs f0, 0x4c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821B253C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2540: EC1E6028  fsubs f0, f30, f12
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B2544: 397F01F8  addi r11, r31, 0x1f8
	ctx.r[11].s64 = ctx.r[31].s64 + 504;
	// 821B2548: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B254C: 419A0018  beq cr6, 0x821b2564
	if ctx.cr[6].eq {
	pc = 0x821B2564; continue 'dispatch;
	}
	// 821B2550: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B2554: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B2558: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 821B255C: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821B2560: 48000008  b 0x821b2568
	pc = 0x821B2568; continue 'dispatch;
	// 821B2564: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821B2568: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B256C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B2570: 419A0024  beq cr6, 0x821b2594
	if ctx.cr[6].eq {
	pc = 0x821B2594; continue 'dispatch;
	}
	// 821B2574: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B2578: 41980010  blt cr6, 0x821b2588
	if ctx.cr[6].lt {
	pc = 0x821B2588; continue 'dispatch;
	}
	// 821B257C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2580: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B2584: 41980014  blt cr6, 0x821b2598
	if ctx.cr[6].lt {
	pc = 0x821B2598; continue 'dispatch;
	}
	// 821B2588: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B258C: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 821B2590: 4800000C  b 0x821b259c
	pc = 0x821B259C; continue 'dispatch;
	// 821B2594: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2598: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821B259C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B25A0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B25A4: 40980014  bge cr6, 0x821b25b8
	if !ctx.cr[6].lt {
	pc = 0x821B25B8; continue 'dispatch;
	}
	// 821B25A8: 3980FDFF  li r12, -0x201
	ctx.r[12].s64 = -513;
	// 821B25AC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B25B0: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B25B4: 48000010  b 0x821b25c4
	pc = 0x821B25C4; continue 'dispatch;
	// 821B25B8: 614A0200  ori r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 512;
	// 821B25BC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B25C0: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B25C4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B25C8: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B25CC: 40980014  bge cr6, 0x821b25e0
	if !ctx.cr[6].lt {
	pc = 0x821B25E0; continue 'dispatch;
	}
	// 821B25D0: 3980FDFF  li r12, -0x201
	ctx.r[12].s64 = -513;
	// 821B25D4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B25D8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B25DC: 48000010  b 0x821b25ec
	pc = 0x821B25EC; continue 'dispatch;
	// 821B25E0: 614A0200  ori r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 512;
	// 821B25E4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B25E8: D18B003C  stfs f12, 0x3c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B25EC: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B25F0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B25F4: 40980014  bge cr6, 0x821b2608
	if !ctx.cr[6].lt {
	pc = 0x821B2608; continue 'dispatch;
	}
	// 821B25F8: 3980FBFF  li r12, -0x401
	ctx.r[12].s64 = -1025;
	// 821B25FC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2600: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2604: 48000010  b 0x821b2614
	pc = 0x821B2614; continue 'dispatch;
	// 821B2608: 614A0400  ori r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 1024;
	// 821B260C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2610: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821B2614: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2618: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B261C: 40980014  bge cr6, 0x821b2630
	if !ctx.cr[6].lt {
	pc = 0x821B2630; continue 'dispatch;
	}
	// 821B2620: 3980FBFF  li r12, -0x401
	ctx.r[12].s64 = -1025;
	// 821B2624: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2628: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B262C: 48000010  b 0x821b263c
	pc = 0x821B263C; continue 'dispatch;
	// 821B2630: 614A0400  ori r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 1024;
	// 821B2634: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2638: D18B0040  stfs f12, 0x40(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821B263C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2640: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2644: 40980014  bge cr6, 0x821b2658
	if !ctx.cr[6].lt {
	pc = 0x821B2658; continue 'dispatch;
	}
	// 821B2648: 3980F7FF  li r12, -0x801
	ctx.r[12].s64 = -2049;
	// 821B264C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2650: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2654: 48000010  b 0x821b2664
	pc = 0x821B2664; continue 'dispatch;
	// 821B2658: 614A0800  ori r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 2048;
	// 821B265C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2660: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821B2664: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2668: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B266C: 40980014  bge cr6, 0x821b2680
	if !ctx.cr[6].lt {
	pc = 0x821B2680; continue 'dispatch;
	}
	// 821B2670: 3980F7FF  li r12, -0x801
	ctx.r[12].s64 = -2049;
	// 821B2674: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2678: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B267C: 48000010  b 0x821b268c
	pc = 0x821B268C; continue 'dispatch;
	// 821B2680: 614A0800  ori r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 2048;
	// 821B2684: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2688: D18B0044  stfs f12, 0x44(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821B268C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2690: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2694: 40980018  bge cr6, 0x821b26ac
	if !ctx.cr[6].lt {
	pc = 0x821B26AC; continue 'dispatch;
	}
	// 821B2698: 3D80FFDF  lis r12, -0x21
	ctx.r[12].s64 = -2162688;
	// 821B269C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B26A0: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B26A4: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B26A8: 48000010  b 0x821b26b8
	pc = 0x821B26B8; continue 'dispatch;
	// 821B26AC: 654A0020  oris r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 2097152;
	// 821B26B0: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B26B4: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B26B8: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B26BC: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B26C0: 40980018  bge cr6, 0x821b26d8
	if !ctx.cr[6].lt {
	pc = 0x821B26D8; continue 'dispatch;
	}
	// 821B26C4: 3D80FFDF  lis r12, -0x21
	ctx.r[12].s64 = -2162688;
	// 821B26C8: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B26CC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B26D0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B26D4: 48000010  b 0x821b26e4
	pc = 0x821B26E4; continue 'dispatch;
	// 821B26D8: 654A0020  oris r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 2097152;
	// 821B26DC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B26E0: D18B006C  stfs f12, 0x6c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B26E4: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B26E8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B26EC: 40980018  bge cr6, 0x821b2704
	if !ctx.cr[6].lt {
	pc = 0x821B2704; continue 'dispatch;
	}
	// 821B26F0: 3D80FFBF  lis r12, -0x41
	ctx.r[12].s64 = -4259840;
	// 821B26F4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B26F8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B26FC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2700: 48000010  b 0x821b2710
	pc = 0x821B2710; continue 'dispatch;
	// 821B2704: 654A0040  oris r10, r10, 0x40
	ctx.r[10].u64 = ctx.r[10].u64 | 4194304;
	// 821B2708: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B270C: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821B2710: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2714: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2718: 40980018  bge cr6, 0x821b2730
	if !ctx.cr[6].lt {
	pc = 0x821B2730; continue 'dispatch;
	}
	// 821B271C: 3D80FFBF  lis r12, -0x41
	ctx.r[12].s64 = -4259840;
	// 821B2720: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2724: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2728: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B272C: 48000010  b 0x821b273c
	pc = 0x821B273C; continue 'dispatch;
	// 821B2730: 654A0040  oris r10, r10, 0x40
	ctx.r[10].u64 = ctx.r[10].u64 | 4194304;
	// 821B2734: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2738: D18B0070  stfs f12, 0x70(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821B273C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2740: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2744: 40980018  bge cr6, 0x821b275c
	if !ctx.cr[6].lt {
	pc = 0x821B275C; continue 'dispatch;
	}
	// 821B2748: 3D80FF7F  lis r12, -0x81
	ctx.r[12].s64 = -8454144;
	// 821B274C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2750: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2754: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2758: 48000010  b 0x821b2768
	pc = 0x821B2768; continue 'dispatch;
	// 821B275C: 654A0080  oris r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 8388608;
	// 821B2760: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2764: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B2768: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B276C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2770: 40980018  bge cr6, 0x821b2788
	if !ctx.cr[6].lt {
	pc = 0x821B2788; continue 'dispatch;
	}
	// 821B2774: 3D80FF7F  lis r12, -0x81
	ctx.r[12].s64 = -8454144;
	// 821B2778: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B277C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2780: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2784: 48000010  b 0x821b2794
	pc = 0x821B2794; continue 'dispatch;
	// 821B2788: 654A0080  oris r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 8388608;
	// 821B278C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2790: D18B0074  stfs f12, 0x74(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B2794: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2798: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B279C: 40980018  bge cr6, 0x821b27b4
	if !ctx.cr[6].lt {
	pc = 0x821B27B4; continue 'dispatch;
	}
	// 821B27A0: 3D80FEFF  lis r12, -0x101
	ctx.r[12].s64 = -16842752;
	// 821B27A4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B27A8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B27AC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B27B0: 48000010  b 0x821b27c0
	pc = 0x821B27C0; continue 'dispatch;
	// 821B27B4: 654A0100  oris r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 16777216;
	// 821B27B8: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B27BC: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821B27C0: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B27C4: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B27C8: 40980018  bge cr6, 0x821b27e0
	if !ctx.cr[6].lt {
	pc = 0x821B27E0; continue 'dispatch;
	}
	// 821B27CC: 3D80FEFF  lis r12, -0x101
	ctx.r[12].s64 = -16842752;
	// 821B27D0: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B27D4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B27D8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B27DC: 48000010  b 0x821b27ec
	pc = 0x821B27EC; continue 'dispatch;
	// 821B27E0: 654A0100  oris r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 16777216;
	// 821B27E4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B27E8: D18B0078  stfs f12, 0x78(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821B27EC: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B27F0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B27F4: 40980018  bge cr6, 0x821b280c
	if !ctx.cr[6].lt {
	pc = 0x821B280C; continue 'dispatch;
	}
	// 821B27F8: 3D80FDFF  lis r12, -0x201
	ctx.r[12].s64 = -33619968;
	// 821B27FC: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2800: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2804: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2808: 48000010  b 0x821b2818
	pc = 0x821B2818; continue 'dispatch;
	// 821B280C: 654A0200  oris r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 33554432;
	// 821B2810: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2814: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821B2818: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B281C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2820: 40980018  bge cr6, 0x821b2838
	if !ctx.cr[6].lt {
	pc = 0x821B2838; continue 'dispatch;
	}
	// 821B2824: 3D80FDFF  lis r12, -0x201
	ctx.r[12].s64 = -33619968;
	// 821B2828: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B282C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2830: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2834: 48000010  b 0x821b2844
	pc = 0x821B2844; continue 'dispatch;
	// 821B2838: 654A0200  oris r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 33554432;
	// 821B283C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2840: D18B007C  stfs f12, 0x7c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821B2844: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2848: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B284C: 40980018  bge cr6, 0x821b2864
	if !ctx.cr[6].lt {
	pc = 0x821B2864; continue 'dispatch;
	}
	// 821B2850: 3D80FBFF  lis r12, -0x401
	ctx.r[12].s64 = -67174400;
	// 821B2854: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2858: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B285C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2860: 48000010  b 0x821b2870
	pc = 0x821B2870; continue 'dispatch;
	// 821B2864: 654A0400  oris r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 67108864;
	// 821B2868: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B286C: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821B2870: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2874: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2878: 40980018  bge cr6, 0x821b2890
	if !ctx.cr[6].lt {
	pc = 0x821B2890; continue 'dispatch;
	}
	// 821B287C: 3D80FBFF  lis r12, -0x401
	ctx.r[12].s64 = -67174400;
	// 821B2880: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2884: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2888: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B288C: 48000010  b 0x821b289c
	pc = 0x821B289C; continue 'dispatch;
	// 821B2890: 654A0400  oris r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 67108864;
	// 821B2894: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2898: D18B0080  stfs f12, 0x80(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821B289C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B28A0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B28A4: 40980018  bge cr6, 0x821b28bc
	if !ctx.cr[6].lt {
	pc = 0x821B28BC; continue 'dispatch;
	}
	// 821B28A8: 3D80F7FF  lis r12, -0x801
	ctx.r[12].s64 = -134283264;
	// 821B28AC: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B28B0: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B28B4: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B28B8: 48000010  b 0x821b28c8
	pc = 0x821B28C8; continue 'dispatch;
	// 821B28BC: 654A0800  oris r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 134217728;
	// 821B28C0: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B28C4: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821B28C8: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B28CC: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B28D0: 40980018  bge cr6, 0x821b28e8
	if !ctx.cr[6].lt {
	pc = 0x821B28E8; continue 'dispatch;
	}
	// 821B28D4: 3D80F7FF  lis r12, -0x801
	ctx.r[12].s64 = -134283264;
	// 821B28D8: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B28DC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B28E0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B28E4: 48000010  b 0x821b28f4
	pc = 0x821B28F4; continue 'dispatch;
	// 821B28E8: 654A0800  oris r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 134217728;
	// 821B28EC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B28F0: D18B0084  stfs f12, 0x84(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821B28F4: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B28F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B28FC: 40980018  bge cr6, 0x821b2914
	if !ctx.cr[6].lt {
	pc = 0x821B2914; continue 'dispatch;
	}
	// 821B2900: 3D80EFFF  lis r12, -0x1001
	ctx.r[12].s64 = -268500992;
	// 821B2904: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2908: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B290C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2910: 48000010  b 0x821b2920
	pc = 0x821B2920; continue 'dispatch;
	// 821B2914: 654A1000  oris r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 268435456;
	// 821B2918: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B291C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821B2920: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2924: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2928: 40980018  bge cr6, 0x821b2940
	if !ctx.cr[6].lt {
	pc = 0x821B2940; continue 'dispatch;
	}
	// 821B292C: 3D80EFFF  lis r12, -0x1001
	ctx.r[12].s64 = -268500992;
	// 821B2930: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2934: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2938: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B293C: 48000010  b 0x821b294c
	pc = 0x821B294C; continue 'dispatch;
	// 821B2940: 654A1000  oris r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 268435456;
	// 821B2944: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2948: D18B0088  stfs f12, 0x88(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821B294C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2950: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2954: 40980018  bge cr6, 0x821b296c
	if !ctx.cr[6].lt {
	pc = 0x821B296C; continue 'dispatch;
	}
	// 821B2958: 3D80DFFF  lis r12, -0x2001
	ctx.r[12].s64 = -536936448;
	// 821B295C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2960: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2964: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2968: 48000010  b 0x821b2978
	pc = 0x821B2978; continue 'dispatch;
	// 821B296C: 654A2000  oris r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 536870912;
	// 821B2970: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2974: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821B2978: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B297C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2980: 40980018  bge cr6, 0x821b2998
	if !ctx.cr[6].lt {
	pc = 0x821B2998; continue 'dispatch;
	}
	// 821B2984: 3D80DFFF  lis r12, -0x2001
	ctx.r[12].s64 = -536936448;
	// 821B2988: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B298C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2990: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2994: 48000010  b 0x821b29a4
	pc = 0x821B29A4; continue 'dispatch;
	// 821B2998: 654A2000  oris r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 536870912;
	// 821B299C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29A0: D18B008C  stfs f12, 0x8c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821B29A4: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B29A8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B29AC: 40980018  bge cr6, 0x821b29c4
	if !ctx.cr[6].lt {
	pc = 0x821B29C4; continue 'dispatch;
	}
	// 821B29B0: 3D80BFFF  lis r12, -0x4001
	ctx.r[12].s64 = -1073807360;
	// 821B29B4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B29B8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B29BC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29C0: 48000010  b 0x821b29d0
	pc = 0x821B29D0; continue 'dispatch;
	// 821B29C4: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 821B29C8: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29CC: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821B29D0: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B29D4: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B29D8: 40980018  bge cr6, 0x821b29f0
	if !ctx.cr[6].lt {
	pc = 0x821B29F0; continue 'dispatch;
	}
	// 821B29DC: 3D80BFFF  lis r12, -0x4001
	ctx.r[12].s64 = -1073807360;
	// 821B29E0: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B29E4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B29E8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29EC: 48000010  b 0x821b29fc
	pc = 0x821B29FC; continue 'dispatch;
	// 821B29F0: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 821B29F4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29F8: D18B0090  stfs f12, 0x90(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821B29FC: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2A00: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2A04: 40980018  bge cr6, 0x821b2a1c
	if !ctx.cr[6].lt {
	pc = 0x821B2A1C; continue 'dispatch;
	}
	// 821B2A08: 3980FFFE  li r12, -2
	ctx.r[12].s64 = -2;
	// 821B2A0C: 798CFFE4  rldicr r12, r12, 0x1f, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(31) & 0xFFFFFFFFFFFFFFFF;
	// 821B2A10: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2A14: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2A18: 48000010  b 0x821b2a28
	pc = 0x821B2A28; continue 'dispatch;
	// 821B2A1C: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 821B2A20: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2A24: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821B2A28: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2A2C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2A30: 40980018  bge cr6, 0x821b2a48
	if !ctx.cr[6].lt {
	pc = 0x821B2A48; continue 'dispatch;
	}
	// 821B2A34: 3980FFFE  li r12, -2
	ctx.r[12].s64 = -2;
	// 821B2A38: 798CFFE4  rldicr r12, r12, 0x1f, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(31) & 0xFFFFFFFFFFFFFFFF;
	// 821B2A3C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2A40: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2A44: 48000010  b 0x821b2a54
	pc = 0x821B2A54; continue 'dispatch;
	// 821B2A48: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 821B2A4C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2A50: D18B0094  stfs f12, 0x94(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821B2A54: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821B2A58: 390B0098  addi r8, r11, 0x98
	ctx.r[8].s64 = ctx.r[11].s64 + 152;
	// 821B2A5C: 7CEBF850  subf r7, r11, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 821B2A60: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 821B2A64: E8DF0010  ld r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2A68: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2A6C: 7F4A5036  sld r10, r26, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[26].u64) << ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821B2A70: 40980010  bge cr6, 0x821b2a80
	if !ctx.cr[6].lt {
	pc = 0x821B2A80; continue 'dispatch;
	}
	// 821B2A74: 7CC65078  andc r6, r6, r10
	ctx.r[6].u64 = ctx.r[6].u64 & !ctx.r[10].u64;
	// 821B2A78: F8DF0010  std r6, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821B2A7C: 48000010  b 0x821b2a8c
	pc = 0x821B2A8C; continue 'dispatch;
	// 821B2A80: 7D463378  or r6, r10, r6
	ctx.r[6].u64 = ctx.r[10].u64 | ctx.r[6].u64;
	// 821B2A84: F8DF0010  std r6, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821B2A88: 7C07452E  stfsx f0, r7, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 821B2A8C: E8CB0010  ld r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2A90: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2A94: 40980010  bge cr6, 0x821b2aa4
	if !ctx.cr[6].lt {
	pc = 0x821B2AA4; continue 'dispatch;
	}
	// 821B2A98: 7CCA5078  andc r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 & !ctx.r[10].u64;
	// 821B2A9C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2AA0: 48000010  b 0x821b2ab0
	pc = 0x821B2AB0; continue 'dispatch;
	// 821B2AA4: 7CCA5378  or r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 | ctx.r[10].u64;
	// 821B2AA8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2AAC: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B2AB0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821B2AB4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 821B2AB8: 2F090022  cmpwi cr6, r9, 0x22
	ctx.cr[6].compare_i32(ctx.r[9].s32, 34, &mut ctx.xer);
	// 821B2ABC: 4099FFA4  ble cr6, 0x821b2a60
	if !ctx.cr[6].gt {
	pc = 0x821B2A60; continue 'dispatch;
	}
	// 821B2AC0: C01B003C  lfs f0, 0x3c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B2AC4: C1BB0040  lfs f13, 0x40(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2AC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B2ACC: 419A03A4  beq cr6, 0x821b2e70
	if ctx.cr[6].eq {
	pc = 0x821B2E70; continue 'dispatch;
	}
	// 821B2AD0: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2AD4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2AD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B2ADC: 396B1F68  addi r11, r11, 0x1f68
	ctx.r[11].s64 = ctx.r[11].s64 + 8040;
	// 821B2AE0: 419A0014  beq cr6, 0x821b2af4
	if ctx.cr[6].eq {
	pc = 0x821B2AF4; continue 'dispatch;
	}
	// 821B2AE4: 813B0038  lwz r9, 0x38(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B2AE8: 7D4950AE  lbzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B2AEC: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821B2AF0: 48000008  b 0x821b2af8
	pc = 0x821B2AF8; continue 'dispatch;
	// 821B2AF4: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821B2AF8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2AFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B2B00: 419A0024  beq cr6, 0x821b2b24
	if ctx.cr[6].eq {
	pc = 0x821B2B24; continue 'dispatch;
	}
	// 821B2B04: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B2B08: 41980010  blt cr6, 0x821b2b18
	if ctx.cr[6].lt {
	pc = 0x821B2B18; continue 'dispatch;
	}
	// 821B2B0C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2B10: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B2B14: 41980014  blt cr6, 0x821b2b28
	if ctx.cr[6].lt {
	pc = 0x821B2B28; continue 'dispatch;
	}
	// 821B2B18: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2B1C: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 821B2B20: 4800000C  b 0x821b2b2c
	pc = 0x821B2B2C; continue 'dispatch;
	// 821B2B24: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2B28: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821B2B2C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2B30: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2B34: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2B38: 40980010  bge cr6, 0x821b2b48
	if !ctx.cr[6].lt {
	pc = 0x821B2B48; continue 'dispatch;
	}
	// 821B2B3C: 794A07A4  rldicr r10, r10, 0, 0x3e
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(0) & 0xFFFFFFFFFFFFFFFE;
	// 821B2B40: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B44: 48000010  b 0x821b2b54
	pc = 0x821B2B54; continue 'dispatch;
	// 821B2B48: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 821B2B4C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B50: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B2B54: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2B58: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2B5C: 40980014  bge cr6, 0x821b2b70
	if !ctx.cr[6].lt {
	pc = 0x821B2B70; continue 'dispatch;
	}
	// 821B2B60: 3980FFFD  li r12, -3
	ctx.r[12].s64 = -3;
	// 821B2B64: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2B68: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B6C: 48000010  b 0x821b2b7c
	pc = 0x821B2B7C; continue 'dispatch;
	// 821B2B70: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 821B2B74: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B78: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B2B7C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2B80: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2B84: 40980014  bge cr6, 0x821b2b98
	if !ctx.cr[6].lt {
	pc = 0x821B2B98; continue 'dispatch;
	}
	// 821B2B88: 3980EFFF  li r12, -0x1001
	ctx.r[12].s64 = -4097;
	// 821B2B8C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2B90: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B94: 48000010  b 0x821b2ba4
	pc = 0x821B2BA4; continue 'dispatch;
	// 821B2B98: 614A1000  ori r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 4096;
	// 821B2B9C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BA0: D00B0048  stfs f0, 0x48(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821B2BA4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2BA8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2BAC: 40980014  bge cr6, 0x821b2bc0
	if !ctx.cr[6].lt {
	pc = 0x821B2BC0; continue 'dispatch;
	}
	// 821B2BB0: 3980DFFF  li r12, -0x2001
	ctx.r[12].s64 = -8193;
	// 821B2BB4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2BB8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BBC: 48000010  b 0x821b2bcc
	pc = 0x821B2BCC; continue 'dispatch;
	// 821B2BC0: 614A2000  ori r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 8192;
	// 821B2BC4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BC8: D00B004C  stfs f0, 0x4c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821B2BCC: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2BD0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2BD4: 40980014  bge cr6, 0x821b2be8
	if !ctx.cr[6].lt {
	pc = 0x821B2BE8; continue 'dispatch;
	}
	// 821B2BD8: 3980FDFF  li r12, -0x201
	ctx.r[12].s64 = -513;
	// 821B2BDC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2BE0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BE4: 48000010  b 0x821b2bf4
	pc = 0x821B2BF4; continue 'dispatch;
	// 821B2BE8: 614A0200  ori r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 512;
	// 821B2BEC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BF0: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B2BF4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2BF8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2BFC: 40980014  bge cr6, 0x821b2c10
	if !ctx.cr[6].lt {
	pc = 0x821B2C10; continue 'dispatch;
	}
	// 821B2C00: 3980FBFF  li r12, -0x401
	ctx.r[12].s64 = -1025;
	// 821B2C04: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2C08: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C0C: 48000010  b 0x821b2c1c
	pc = 0x821B2C1C; continue 'dispatch;
	// 821B2C10: 614A0400  ori r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 1024;
	// 821B2C14: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C18: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821B2C1C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2C20: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2C24: 40980014  bge cr6, 0x821b2c38
	if !ctx.cr[6].lt {
	pc = 0x821B2C38; continue 'dispatch;
	}
	// 821B2C28: 3980F7FF  li r12, -0x801
	ctx.r[12].s64 = -2049;
	// 821B2C2C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2C30: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C34: 48000010  b 0x821b2c44
	pc = 0x821B2C44; continue 'dispatch;
	// 821B2C38: 614A0800  ori r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 2048;
	// 821B2C3C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C40: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821B2C44: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2C48: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2C4C: 40980018  bge cr6, 0x821b2c64
	if !ctx.cr[6].lt {
	pc = 0x821B2C64; continue 'dispatch;
	}
	// 821B2C50: 3D80FFDF  lis r12, -0x21
	ctx.r[12].s64 = -2162688;
	// 821B2C54: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2C58: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2C5C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C60: 48000010  b 0x821b2c70
	pc = 0x821B2C70; continue 'dispatch;
	// 821B2C64: 654A0020  oris r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 2097152;
	// 821B2C68: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C6C: D00B006C  stfs f0, 0x6c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B2C70: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2C74: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2C78: 40980018  bge cr6, 0x821b2c90
	if !ctx.cr[6].lt {
	pc = 0x821B2C90; continue 'dispatch;
	}
	// 821B2C7C: 3D80FFBF  lis r12, -0x41
	ctx.r[12].s64 = -4259840;
	// 821B2C80: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2C84: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2C88: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C8C: 48000010  b 0x821b2c9c
	pc = 0x821B2C9C; continue 'dispatch;
	// 821B2C90: 654A0040  oris r10, r10, 0x40
	ctx.r[10].u64 = ctx.r[10].u64 | 4194304;
	// 821B2C94: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C98: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821B2C9C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2CA0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2CA4: 40980018  bge cr6, 0x821b2cbc
	if !ctx.cr[6].lt {
	pc = 0x821B2CBC; continue 'dispatch;
	}
	// 821B2CA8: 3D80FF7F  lis r12, -0x81
	ctx.r[12].s64 = -8454144;
	// 821B2CAC: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2CB0: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2CB4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2CB8: 48000010  b 0x821b2cc8
	pc = 0x821B2CC8; continue 'dispatch;
	// 821B2CBC: 654A0080  oris r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 8388608;
	// 821B2CC0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2CC4: D00B0074  stfs f0, 0x74(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B2CC8: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2CCC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2CD0: 40980018  bge cr6, 0x821b2ce8
	if !ctx.cr[6].lt {
	pc = 0x821B2CE8; continue 'dispatch;
	}
	// 821B2CD4: 3D80FEFF  lis r12, -0x101
	ctx.r[12].s64 = -16842752;
	// 821B2CD8: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2CDC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2CE0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2CE4: 48000010  b 0x821b2cf4
	pc = 0x821B2CF4; continue 'dispatch;
	// 821B2CE8: 654A0100  oris r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 16777216;
	// 821B2CEC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2CF0: D00B0078  stfs f0, 0x78(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821B2CF4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2CF8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2CFC: 40980018  bge cr6, 0x821b2d14
	if !ctx.cr[6].lt {
	pc = 0x821B2D14; continue 'dispatch;
	}
	// 821B2D00: 3D80FDFF  lis r12, -0x201
	ctx.r[12].s64 = -33619968;
	// 821B2D04: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2D08: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2D0C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D10: 48000010  b 0x821b2d20
	pc = 0x821B2D20; continue 'dispatch;
	// 821B2D14: 654A0200  oris r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 33554432;
	// 821B2D18: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D1C: D00B007C  stfs f0, 0x7c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821B2D20: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2D24: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2D28: 40980018  bge cr6, 0x821b2d40
	if !ctx.cr[6].lt {
	pc = 0x821B2D40; continue 'dispatch;
	}
	// 821B2D2C: 3D80FBFF  lis r12, -0x401
	ctx.r[12].s64 = -67174400;
	// 821B2D30: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2D34: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2D38: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D3C: 48000010  b 0x821b2d4c
	pc = 0x821B2D4C; continue 'dispatch;
	// 821B2D40: 654A0400  oris r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 67108864;
	// 821B2D44: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D48: D00B0080  stfs f0, 0x80(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821B2D4C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2D50: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2D54: 40980018  bge cr6, 0x821b2d6c
	if !ctx.cr[6].lt {
	pc = 0x821B2D6C; continue 'dispatch;
	}
	// 821B2D58: 3D80F7FF  lis r12, -0x801
	ctx.r[12].s64 = -134283264;
	// 821B2D5C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2D60: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2D64: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D68: 48000010  b 0x821b2d78
	pc = 0x821B2D78; continue 'dispatch;
	// 821B2D6C: 654A0800  oris r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 134217728;
	// 821B2D70: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D74: D00B0084  stfs f0, 0x84(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821B2D78: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2D7C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2D80: 40980018  bge cr6, 0x821b2d98
	if !ctx.cr[6].lt {
	pc = 0x821B2D98; continue 'dispatch;
	}
	// 821B2D84: 3D80EFFF  lis r12, -0x1001
	ctx.r[12].s64 = -268500992;
	// 821B2D88: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2D8C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2D90: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D94: 48000010  b 0x821b2da4
	pc = 0x821B2DA4; continue 'dispatch;
	// 821B2D98: 654A1000  oris r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 268435456;
	// 821B2D9C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DA0: D00B0088  stfs f0, 0x88(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821B2DA4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2DA8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2DAC: 40980018  bge cr6, 0x821b2dc4
	if !ctx.cr[6].lt {
	pc = 0x821B2DC4; continue 'dispatch;
	}
	// 821B2DB0: 3D80DFFF  lis r12, -0x2001
	ctx.r[12].s64 = -536936448;
	// 821B2DB4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2DB8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2DBC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DC0: 48000010  b 0x821b2dd0
	pc = 0x821B2DD0; continue 'dispatch;
	// 821B2DC4: 654A2000  oris r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 536870912;
	// 821B2DC8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DCC: D00B008C  stfs f0, 0x8c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821B2DD0: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2DD4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2DD8: 40980018  bge cr6, 0x821b2df0
	if !ctx.cr[6].lt {
	pc = 0x821B2DF0; continue 'dispatch;
	}
	// 821B2DDC: 3D80BFFF  lis r12, -0x4001
	ctx.r[12].s64 = -1073807360;
	// 821B2DE0: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2DE4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2DE8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DEC: 48000010  b 0x821b2dfc
	pc = 0x821B2DFC; continue 'dispatch;
	// 821B2DF0: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 821B2DF4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DF8: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821B2DFC: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2E00: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2E04: 40980018  bge cr6, 0x821b2e1c
	if !ctx.cr[6].lt {
	pc = 0x821B2E1C; continue 'dispatch;
	}
	// 821B2E08: 3980FFFE  li r12, -2
	ctx.r[12].s64 = -2;
	// 821B2E0C: 798CFFE4  rldicr r12, r12, 0x1f, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(31) & 0xFFFFFFFFFFFFFFFF;
	// 821B2E10: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2E14: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2E18: 48000010  b 0x821b2e28
	pc = 0x821B2E28; continue 'dispatch;
	// 821B2E1C: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 821B2E20: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2E24: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821B2E28: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821B2E2C: 392B0098  addi r9, r11, 0x98
	ctx.r[9].s64 = ctx.r[11].s64 + 152;
	// 821B2E30: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 821B2E34: E8EB0010  ld r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2E38: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2E3C: 7F484036  sld r8, r26, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = (ctx.r[26].u64) << ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 821B2E40: 40980010  bge cr6, 0x821b2e50
	if !ctx.cr[6].lt {
	pc = 0x821B2E50; continue 'dispatch;
	}
	// 821B2E44: 7CE84078  andc r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 & !ctx.r[8].u64;
	// 821B2E48: F90B0010  std r8, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 821B2E4C: 48000010  b 0x821b2e5c
	pc = 0x821B2E5C; continue 'dispatch;
	// 821B2E50: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821B2E54: F90B0010  std r8, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 821B2E58: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B2E5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B2E60: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821B2E64: 2F0A0022  cmpwi cr6, r10, 0x22
	ctx.cr[6].compare_i32(ctx.r[10].s32, 34, &mut ctx.xer);
	// 821B2E68: 4099FFC8  ble cr6, 0x821b2e30
	if !ctx.cr[6].gt {
	pc = 0x821B2E30; continue 'dispatch;
	}
	// 821B2E6C: D01B0040  stfs f0, 0x40(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821B2E70: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2E74: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2E78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B2E7C: 396B20B8  addi r11, r11, 0x20b8
	ctx.r[11].s64 = ctx.r[11].s64 + 8376;
	// 821B2E80: 419A0010  beq cr6, 0x821b2e90
	if ctx.cr[6].eq {
	pc = 0x821B2E90; continue 'dispatch;
	}
	// 821B2E84: 894A002B  lbz r10, 0x2b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(43 as u32) ) } as u64;
	// 821B2E88: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821B2E8C: 48000008  b 0x821b2e94
	pc = 0x821B2E94; continue 'dispatch;
	// 821B2E90: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821B2E94: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2E98: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B2E9C: 419A0024  beq cr6, 0x821b2ec0
	if ctx.cr[6].eq {
	pc = 0x821B2EC0; continue 'dispatch;
	}
	// 821B2EA0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B2EA4: 41980010  blt cr6, 0x821b2eb4
	if ctx.cr[6].lt {
	pc = 0x821B2EB4; continue 'dispatch;
	}
	// 821B2EA8: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2EAC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B2EB0: 41980014  blt cr6, 0x821b2ec4
	if ctx.cr[6].lt {
	pc = 0x821B2EC4; continue 'dispatch;
	}
	// 821B2EB4: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2EB8: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 821B2EBC: 4800000C  b 0x821b2ec8
	pc = 0x821B2EC8; continue 'dispatch;
	// 821B2EC0: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2EC4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821B2EC8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B2ECC: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2ED0: 614AED6A  ori r10, r10, 0xed6a
	ctx.r[10].u64 = ctx.r[10].u64 | 60778;
	// 821B2ED4: 7D58522E  lhzx r10, r24, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B2ED8: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 821B2EDC: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2EE0: 419A0024  beq cr6, 0x821b2f04
	if ctx.cr[6].eq {
	pc = 0x821B2F04; continue 'dispatch;
	}
	// 821B2EE4: 3980FFEF  li r12, -0x11
	ctx.r[12].s64 = -17;
	// 821B2EE8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2EEC: 3D80FFFE  lis r12, -2
	ctx.r[12].s64 = -131072;
	// 821B2EF0: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2EF4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2EF8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2EFC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2F00: 48000020  b 0x821b2f20
	pc = 0x821B2F20; continue 'dispatch;
	// 821B2F04: 614A0010  ori r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 16;
	// 821B2F08: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2F0C: D3CB0028  stfs f30, 0x28(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821B2F10: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2F14: 654A0001  oris r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 65536;
	// 821B2F18: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2F1C: D3CB0058  stfs f30, 0x58(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B2F20: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B2F24: 917B0024  stw r11, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821B2F28: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B2F2C: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821B2F30: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821B2F34: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821B2F38: 483821C0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B2F40 size=372
    let mut pc: u32 = 0x821B2F40;
    'dispatch: loop {
        match pc {
            0x821B2F40 => {
    //   block [0x821B2F40..0x821B30B4)
	// 821B2F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B2F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B2F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B2F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B2F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2F54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B2F58: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B2F5C: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 821B2F60: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B2F64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B2F68: C00B06A4  lfs f0, 0x6a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B2F6C: 409A0120  bne cr6, 0x821b308c
	if !ctx.cr[6].eq {
	pc = 0x821B308C; continue 'dispatch;
	}
	// 821B2F70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2F74: 356B1CC8  addic. r11, r11, 0x1cc8
	ctx.xer.ca = (ctx.r[11].u32 > (!(7368 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + 7368;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B2F78: 41820114  beq 0x821b308c
	if ctx.cr[0].eq {
	pc = 0x821B308C; continue 'dispatch;
	}
	// 821B2F7C: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B2F80: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821B2F84: 419A0108  beq cr6, 0x821b308c
	if ctx.cr[6].eq {
	pc = 0x821B308C; continue 'dispatch;
	}
	// 821B2F88: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B2F8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B2F90: ED4C0032  fmuls f10, f12, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B2F94: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2F98: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B2F9C: EC0D502A  fadds f0, f13, f10
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 821B2FA0: C1AB9F78  lfs f13, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2FA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B2FA8: C16B2074  lfs f11, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B2FAC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B2FB0: 40990050  ble cr6, 0x821b3000
	if !ctx.cr[6].gt {
	pc = 0x821B3000; continue 'dispatch;
	}
	// 821B2FB4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B2FB8: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B2FBC: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B2FC0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B2FC4: 481B4175  bl 0x82367138
	ctx.lr = 0x821B2FC8;
	sub_82367138(ctx, base);
	// 821B2FC8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B2FCC: C1ABD2B0  lfs f13, -0x2d50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2FD0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821B2FD4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B2FD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B2FDC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B2FE0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821B2FE4: FD206018  frsp f9, f12
	ctx.f[9].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821B2FE8: C18B2280  lfs f12, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B2FEC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B2FF0: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B2FF4: C18BD760  lfs f12, -0x28a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10400 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B2FF8: EDA9637E  fnmadds f13, f9, f13, f12
	ctx.f[13].f64 = -(ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[12].f64);
	// 821B2FFC: D1BF0020  stfs f13, 0x20(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B3000: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 821B3004: 409A004C  bne cr6, 0x821b3050
	if !ctx.cr[6].eq {
	pc = 0x821B3050; continue 'dispatch;
	}
	// 821B3008: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821B300C: 40990044  ble cr6, 0x821b3050
	if !ctx.cr[6].gt {
	pc = 0x821B3050; continue 'dispatch;
	}
	// 821B3010: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3014: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3018: FF0A6800  fcmpu cr6, f10, f13
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
	// 821B301C: 40980034  bge cr6, 0x821b3050
	if !ctx.cr[6].lt {
	pc = 0x821B3050; continue 'dispatch;
	}
	// 821B3020: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3024: C1ABD6C8  lfs f13, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3028: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B302C: 40980024  bge cr6, 0x821b3050
	if !ctx.cr[6].lt {
	pc = 0x821B3050; continue 'dispatch;
	}
	// 821B3030: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B3034: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B3038: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B303C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B3040: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B3044: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B3048: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B304C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B3050: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3054: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B3058: 40980030  bge cr6, 0x821b3088
	if !ctx.cr[6].lt {
	pc = 0x821B3088; continue 'dispatch;
	}
	// 821B305C: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B3060: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 821B3064: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B3068: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B306C: 419A0038  beq cr6, 0x821b30a4
	if ctx.cr[6].eq {
	pc = 0x821B30A4; continue 'dispatch;
	}
	// 821B3070: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 821B3074: 419A0030  beq cr6, 0x821b30a4
	if ctx.cr[6].eq {
	pc = 0x821B30A4; continue 'dispatch;
	}
	// 821B3078: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B307C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B3080: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B3084: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B3088: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B308C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B3090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B3094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B3098: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B309C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B30A0: 4E800020  blr
	return;
	// 821B30A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B30A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B30AC: 4800000D  bl 0x821b30b8
	ctx.lr = 0x821B30B0;
	sub_821B30B8(ctx, base);
	// 821B30B0: 4BFFFFDC  b 0x821b308c
	pc = 0x821B308C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B30B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B30B8 size=332
    let mut pc: u32 = 0x821B30B8;
    'dispatch: loop {
        match pc {
            0x821B30B8 => {
    //   block [0x821B30B8..0x821B3204)
	// 821B30B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B30BC: 48381FFD  bl 0x825350b8
	ctx.lr = 0x821B30C0;
	sub_82535080(ctx, base);
	// 821B30C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B30C4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B30C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B30CC: 3BABF9E4  addi r29, r11, -0x61c
	ctx.r[29].s64 = ctx.r[11].s64 + -1564;
	// 821B30D0: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B30D4: 397D00DC  addi r11, r29, 0xdc
	ctx.r[11].s64 = ctx.r[29].s64 + 220;
	// 821B30D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B30DC: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 821B30E0: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 821B30E4: 7C1E5C2E  lfsx f0, r30, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B30E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B30EC: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B30F0: 939F001C  stw r28, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
	// 821B30F4: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B30F8: 41980018  blt cr6, 0x821b3110
	if ctx.cr[6].lt {
	pc = 0x821B3110; continue 'dispatch;
	}
	// 821B30FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3100: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B3104: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3108: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B310C: 48000094  b 0x821b31a0
	pc = 0x821B31A0; continue 'dispatch;
	// 821B3110: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 821B3114: 419A004C  beq cr6, 0x821b3160
	if ctx.cr[6].eq {
	pc = 0x821B3160; continue 'dispatch;
	}
	// 821B3118: 2F040003  cmpwi cr6, r4, 3
	ctx.cr[6].compare_i32(ctx.r[4].s32, 3, &mut ctx.xer);
	// 821B311C: 419A0044  beq cr6, 0x821b3160
	if ctx.cr[6].eq {
	pc = 0x821B3160; continue 'dispatch;
	}
	// 821B3120: 481B4019  bl 0x82367138
	ctx.lr = 0x821B3124;
	sub_82367138(ctx, base);
	// 821B3124: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B3128: C00BD2B0  lfs f0, -0x2d50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B312C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821B3130: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B3134: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3138: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B313C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B3140: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B3144: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3148: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B314C: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B3150: C1ABD760  lfs f13, -0x28a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3154: EC0B683E  fnmadds f0, f11, f0, f13
	ctx.f[0].f64 = -(ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64);
	// 821B3158: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B315C: 48000040  b 0x821b319c
	pc = 0x821B319C; continue 'dispatch;
	// 821B3160: D19F0014  stfs f12, 0x14(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B3164: 481B3FD5  bl 0x82367138
	ctx.lr = 0x821B3168;
	sub_82367138(ctx, base);
	// 821B3168: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B316C: C00BD2B0  lfs f0, -0x2d50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3170: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821B3174: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B3178: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B317C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B3180: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B3184: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B3188: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B318C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B3190: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B3194: C1ABD760  lfs f13, -0x28a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3198: EC0B683E  fnmadds f0, f11, f0, f13
	ctx.f[0].f64 = -(ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64);
	// 821B319C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B31A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B31A4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B31A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B31AC: 419A0014  beq cr6, 0x821b31c0
	if ctx.cr[6].eq {
	pc = 0x821B31C0; continue 'dispatch;
	}
	// 821B31B0: 7D3EE82E  lwzx r9, r30, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821B31B4: 7D6958AE  lbzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B31B8: 556B067E  clrlwi r11, r11, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 821B31BC: 48000008  b 0x821b31c4
	pc = 0x821B31C4; continue 'dispatch;
	// 821B31C0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B31C4: 812A1E1C  lwz r9, 0x1e1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(7708 as u32) ) } as u64;
	// 821B31C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B31CC: 419A0028  beq cr6, 0x821b31f4
	if ctx.cr[6].eq {
	pc = 0x821B31F4; continue 'dispatch;
	}
	// 821B31D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B31D4: 41980010  blt cr6, 0x821b31e4
	if ctx.cr[6].lt {
	pc = 0x821B31E4; continue 'dispatch;
	}
	// 821B31D8: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B31DC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B31E0: 41980018  blt cr6, 0x821b31f8
	if ctx.cr[6].lt {
	pc = 0x821B31F8; continue 'dispatch;
	}
	// 821B31E4: D18A1E24  stfs f12, 0x1e24(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(7716 as u32), tmp.u32 ) };
	// 821B31E8: 938A1E20  stw r28, 0x1e20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(7712 as u32), ctx.r[28].u32 ) };
	// 821B31EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B31F0: 48381F18  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821B31F4: D18A1E24  stfs f12, 0x1e24(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(7716 as u32), tmp.u32 ) };
	// 821B31F8: 916A1E20  stw r11, 0x1e20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(7712 as u32), ctx.r[11].u32 ) };
	// 821B31FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B3200: 48381F08  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3208 size=312
    let mut pc: u32 = 0x821B3208;
    'dispatch: loop {
        match pc {
            0x821B3208 => {
    //   block [0x821B3208..0x821B3340)
	// 821B3208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B320C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B3210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B3214: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3218: 3FE30006  addis r31, r3, 6
	ctx.r[31].s64 = ctx.r[3].s64 + 393216;
	// 821B321C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821B3220: 3BFFA910  addi r31, r31, -0x56f0
	ctx.r[31].s64 = ctx.r[31].s64 + -22256;
	// 821B3224: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3228: 419A0030  beq cr6, 0x821b3258
	if ctx.cr[6].eq {
	pc = 0x821B3258; continue 'dispatch;
	}
	// 821B322C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B3230: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3234: 419A0010  beq cr6, 0x821b3244
	if ctx.cr[6].eq {
	pc = 0x821B3244; continue 'dispatch;
	}
	// 821B3238: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821B323C: 409A0008  bne cr6, 0x821b3244
	if !ctx.cr[6].eq {
	pc = 0x821B3244; continue 'dispatch;
	}
	// 821B3240: 909F0030  stw r4, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[4].u32 ) };
	// 821B3244: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821B3248: 90BF002C  stw r5, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[5].u32 ) };
	// 821B324C: 409A0010  bne cr6, 0x821b325c
	if !ctx.cr[6].eq {
	pc = 0x821B325C; continue 'dispatch;
	}
	// 821B3250: 480000F1  bl 0x821b3340
	ctx.lr = 0x821B3254;
	sub_821B3340(ctx, base);
	// 821B3254: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B3258: 90BF0030  stw r5, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[5].u32 ) };
	// 821B325C: 2F050016  cmpwi cr6, r5, 0x16
	ctx.cr[6].compare_i32(ctx.r[5].s32, 22, &mut ctx.xer);
	// 821B3260: 4198000C  blt cr6, 0x821b326c
	if ctx.cr[6].lt {
	pc = 0x821B326C; continue 'dispatch;
	}
	// 821B3264: 3885FFEC  addi r4, r5, -0x14
	ctx.r[4].s64 = ctx.r[5].s64 + -20;
	// 821B3268: 480000BC  b 0x821b3324
	pc = 0x821B3324; continue 'dispatch;
	// 821B326C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B3270: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3274: 3D008288  lis r8, -0x7d78
	ctx.r[8].s64 = -2105016320;
	// 821B3278: 394BFB08  addi r10, r11, -0x4f8
	ctx.r[10].s64 = ctx.r[11].s64 + -1272;
	// 821B327C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3280: 54A7103A  slwi r7, r5, 2
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B3284: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 821B3288: 39291CC8  addi r9, r9, 0x1cc8
	ctx.r[9].s64 = ctx.r[9].s64 + 7368;
	// 821B328C: C1A8D4DC  lfs f13, -0x2b24(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3290: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821B3294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3298: 7D47502E  lwzx r10, r7, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B329C: D1BF0034  stfs f13, 0x34(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B32A0: 90DF0038  stw r6, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[6].u32 ) };
	// 821B32A4: C0081FF8  lfs f0, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B32A8: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B32AC: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821B32B0: 419A0010  beq cr6, 0x821b32c0
	if ctx.cr[6].eq {
	pc = 0x821B32C0; continue 'dispatch;
	}
	// 821B32B4: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B32B8: 556B067E  clrlwi r11, r11, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 821B32BC: 48000008  b 0x821b32c4
	pc = 0x821B32C4; continue 'dispatch;
	// 821B32C0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821B32C4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B32C8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B32CC: 419A0024  beq cr6, 0x821b32f0
	if ctx.cr[6].eq {
	pc = 0x821B32F0; continue 'dispatch;
	}
	// 821B32D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B32D4: 41980010  blt cr6, 0x821b32e4
	if ctx.cr[6].lt {
	pc = 0x821B32E4; continue 'dispatch;
	}
	// 821B32D8: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B32DC: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B32E0: 41980014  blt cr6, 0x821b32f4
	if ctx.cr[6].lt {
	pc = 0x821B32F4; continue 'dispatch;
	}
	// 821B32E4: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B32E8: 90890008  stw r4, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821B32EC: 4800000C  b 0x821b32f8
	pc = 0x821B32F8; continue 'dispatch;
	// 821B32F0: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B32F4: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B32F8: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B32FC: 2F0A001A  cmpwi cr6, r10, 0x1a
	ctx.cr[6].compare_i32(ctx.r[10].s32, 26, &mut ctx.xer);
	// 821B3300: 419A0020  beq cr6, 0x821b3320
	if ctx.cr[6].eq {
	pc = 0x821B3320; continue 'dispatch;
	}
	// 821B3304: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3308: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B330C: 419A000C  beq cr6, 0x821b3318
	if ctx.cr[6].eq {
	pc = 0x821B3318; continue 'dispatch;
	}
	// 821B3310: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B3314: 41980018  blt cr6, 0x821b332c
	if ctx.cr[6].lt {
	pc = 0x821B332C; continue 'dispatch;
	}
	// 821B3318: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B331C: 48000008  b 0x821b3324
	pc = 0x821B3324; continue 'dispatch;
	// 821B3320: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B3328: 4BFFFD91  bl 0x821b30b8
	ctx.lr = 0x821B332C;
	sub_821B30B8(ctx, base);
	// 821B332C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B3330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B3334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B3338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B333C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3340 size=144
    let mut pc: u32 = 0x821B3340;
    'dispatch: loop {
        match pc {
            0x821B3340 => {
    //   block [0x821B3340..0x821B33D0)
	// 821B3340: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3344: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B3348: 616BBEB8  ori r11, r11, 0xbeb8
	ctx.r[11].u64 = ctx.r[11].u64 | 48824;
	// 821B334C: 7CE35A2E  lhzx r7, r3, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3350: 2F070023  cmpwi cr6, r7, 0x23
	ctx.cr[6].compare_i32(ctx.r[7].s32, 35, &mut ctx.xer);
	// 821B3354: 409A0024  bne cr6, 0x821b3378
	if !ctx.cr[6].eq {
	pc = 0x821B3378; continue 'dispatch;
	}
	// 821B3358: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B335C: 616BED6A  ori r11, r11, 0xed6a
	ctx.r[11].u64 = ctx.r[11].u64 | 60778;
	// 821B3360: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3364: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B3368: 419A000C  beq cr6, 0x821b3374
	if ctx.cr[6].eq {
	pc = 0x821B3374; continue 'dispatch;
	}
	// 821B336C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B3370: 409A0008  bne cr6, 0x821b3378
	if !ctx.cr[6].eq {
	pc = 0x821B3378; continue 'dispatch;
	}
	// 821B3374: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821B3378: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B337C: 6168D380  ori r8, r11, 0xd380
	ctx.r[8].u64 = ctx.r[11].u64 | 54144;
	// 821B3380: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B3384: 392BBFF0  addi r9, r11, -0x4010
	ctx.r[9].s64 = ctx.r[11].s64 + -16400;
	// 821B3388: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B338C: 616B85E4  ori r11, r11, 0x85e4
	ctx.r[11].u64 = ctx.r[11].u64 | 34276;
	// 821B3390: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3394: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B3398: 419A01DC  beq cr6, 0x821b3574
	if ctx.cr[6].eq {
		sub_821B3560(ctx, base);
		return;
	}
	// 821B339C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B33A0: 616BA95C  ori r11, r11, 0xa95c
	ctx.r[11].u64 = ctx.r[11].u64 | 43356;
	// 821B33A4: 7D43582E  lwzx r10, r3, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B33A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B33AC: 409A0024  bne cr6, 0x821b33d0
	if !ctx.cr[6].eq {
		sub_821B33D0(ctx, base);
		return;
	}
	// 821B33B0: 7D63422E  lhzx r11, r3, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B33B4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B33B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B33BC: 419A000C  beq cr6, 0x821b33c8
	if ctx.cr[6].eq {
	pc = 0x821B33C8; continue 'dispatch;
	}
	// 821B33C0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B33C4: 409A000C  bne cr6, 0x821b33d0
	if !ctx.cr[6].eq {
		sub_821B33D0(ctx, base);
		return;
	}
	// 821B33C8: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821B33CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B33D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B33D0 size=28
    let mut pc: u32 = 0x821B33D0;
    'dispatch: loop {
        match pc {
            0x821B33D0 => {
    //   block [0x821B33D0..0x821B33EC)
	// 821B33D0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B33D4: 616BEB32  ori r11, r11, 0xeb32
	ctx.r[11].u64 = ctx.r[11].u64 | 60210;
	// 821B33D8: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B33DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B33E0: 419A000C  beq cr6, 0x821b33ec
	if ctx.cr[6].eq {
		sub_821B33EC(ctx, base);
		return;
	}
	// 821B33E4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821B33E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B33EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B33EC size=48
    let mut pc: u32 = 0x821B33EC;
    'dispatch: loop {
        match pc {
            0x821B33EC => {
    //   block [0x821B33EC..0x821B341C)
	// 821B33EC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B33F0: 616BEB03  ori r11, r11, 0xeb03
	ctx.r[11].u64 = ctx.r[11].u64 | 60163;
	// 821B33F4: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B33F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B33FC: 419A0044  beq cr6, 0x821b3440
	if ctx.cr[6].eq {
		sub_821B3440(ctx, base);
		return;
	}
	// 821B3400: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B3404: 409A0018  bne cr6, 0x821b341c
	if !ctx.cr[6].eq {
		sub_821B341C(ctx, base);
		return;
	}
	// 821B3408: 7D63422E  lhzx r11, r3, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B340C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3410: 409A000C  bne cr6, 0x821b341c
	if !ctx.cr[6].eq {
		sub_821B341C(ctx, base);
		return;
	}
	// 821B3414: 3860000B  li r3, 0xb
	ctx.r[3].s64 = 11;
	// 821B3418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B341C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B341C size=36
    let mut pc: u32 = 0x821B341C;
    'dispatch: loop {
        match pc {
            0x821B341C => {
    //   block [0x821B341C..0x821B3440)
	// 821B341C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3420: 616BBED4  ori r11, r11, 0xbed4
	ctx.r[11].u64 = ctx.r[11].u64 | 48852;
	// 821B3424: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3428: 896B0006  lbz r11, 6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 821B342C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B3430: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B3434: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B3438: 386B0003  addi r3, r11, 3
	ctx.r[3].s64 = ctx.r[11].s64 + 3;
	// 821B343C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3440 size=120
    let mut pc: u32 = 0x821B3440;
    'dispatch: loop {
        match pc {
            0x821B3440 => {
    //   block [0x821B3440..0x821B34B8)
	// 821B3440: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B3444: 616B8654  ori r11, r11, 0x8654
	ctx.r[11].u64 = ctx.r[11].u64 | 34388;
	// 821B3448: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B344C: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 821B3450: 409A0010  bne cr6, 0x821b3460
	if !ctx.cr[6].eq {
	pc = 0x821B3460; continue 'dispatch;
	}
	// 821B3454: 81690010  lwz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3458: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B345C: 419AFF6C  beq cr6, 0x821b33c8
	if ctx.cr[6].eq {
		sub_821B3340(ctx, base);
		return;
	}
	// 821B3460: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3464: 616BEB59  ori r11, r11, 0xeb59
	ctx.r[11].u64 = ctx.r[11].u64 | 60249;
	// 821B3468: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B346C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3470: 409AFF58  bne cr6, 0x821b33c8
	if !ctx.cr[6].eq {
		sub_821B3340(ctx, base);
		return;
	}
	// 821B3474: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3478: 616BED3A  ori r11, r11, 0xed3a
	ctx.r[11].u64 = ctx.r[11].u64 | 60730;
	// 821B347C: 7D435A2E  lhzx r10, r3, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3480: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3484: 616BED48  ori r11, r11, 0xed48
	ctx.r[11].u64 = ctx.r[11].u64 | 60744;
	// 821B3488: 2B0A0014  cmplwi cr6, r10, 0x14
	ctx.cr[6].compare_u32(ctx.r[10].u32, 20 as u32, &mut ctx.xer);
	// 821B348C: 409A0040  bne cr6, 0x821b34cc
	if !ctx.cr[6].eq {
		sub_821B34B8(ctx, base);
		return;
	}
	// 821B3490: 7CA35A2E  lhzx r5, r3, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3494: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B3498: 409A0020  bne cr6, 0x821b34b8
	if !ctx.cr[6].eq {
		sub_821B34B8(ctx, base);
		return;
	}
	// 821B349C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B34A0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821B34A4: 616B8658  ori r11, r11, 0x8658
	ctx.r[11].u64 = ctx.r[11].u64 | 34392;
	// 821B34A8: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B34AC: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 821B34B0: 51630FBC  rlwimi r3, r11, 1, 0x1e, 0x1e
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x0000000000000002) | (ctx.r[3].u64 & 0xFFFFFFFFFFFFFFFD);
	// 821B34B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B34B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B34B8 size=48
    let mut pc: u32 = 0x821B34B8;
    'dispatch: loop {
        match pc {
            0x821B34B8 => {
    //   block [0x821B34B8..0x821B34E8)
	// 821B34B8: 2B0A0014  cmplwi cr6, r10, 0x14
	ctx.cr[6].compare_u32(ctx.r[10].u32, 20 as u32, &mut ctx.xer);
	// 821B34BC: 409A0010  bne cr6, 0x821b34cc
	if !ctx.cr[6].eq {
	pc = 0x821B34CC; continue 'dispatch;
	}
	// 821B34C0: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B34C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B34C8: 409A02C8  bne cr6, 0x821b3790
	if !ctx.cr[6].eq {
		sub_821B35B4(ctx, base);
		return;
	}
	// 821B34CC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B34D0: 616BEB1B  ori r11, r11, 0xeb1b
	ctx.r[11].u64 = ctx.r[11].u64 | 60187;
	// 821B34D4: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B34D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B34DC: 419A000C  beq cr6, 0x821b34e8
	if ctx.cr[6].eq {
		sub_821B34E8(ctx, base);
		return;
	}
	// 821B34E0: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821B34E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B34E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B34E8 size=96
    let mut pc: u32 = 0x821B34E8;
    'dispatch: loop {
        match pc {
            0x821B34E8 => {
    //   block [0x821B34E8..0x821B3548)
	// 821B34E8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B34EC: 616BEB0F  ori r11, r11, 0xeb0f
	ctx.r[11].u64 = ctx.r[11].u64 | 60175;
	// 821B34F0: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B34F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B34F8: 419A0068  beq cr6, 0x821b3560
	if ctx.cr[6].eq {
		sub_821B3560(ctx, base);
		return;
	}
	// 821B34FC: 3D630002  addis r11, r3, 2
	ctx.r[11].s64 = ctx.r[3].s64 + 131072;
	// 821B3500: 396BD340  addi r11, r11, -0x2cc0
	ctx.r[11].s64 = ctx.r[11].s64 + -11456;
	// 821B3504: C00B002C  lfs f0, 0x2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3508: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B350C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 821B3510: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B3514: C00BE360  lfs f0, -0x1ca0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3518: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B351C: 4198002C  blt cr6, 0x821b3548
	if ctx.cr[6].lt {
		sub_821B3548(ctx, base);
		return;
	}
	// 821B3520: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3524: 616BEDC4  ori r11, r11, 0xedc4
	ctx.r[11].u64 = ctx.r[11].u64 | 60868;
	// 821B3528: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B352C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B3530: 2F0B00C8  cmpwi cr6, r11, 0xc8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 200, &mut ctx.xer);
	// 821B3534: 41980014  blt cr6, 0x821b3548
	if ctx.cr[6].lt {
		sub_821B3548(ctx, base);
		return;
	}
	// 821B3538: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 821B353C: 409AFFA4  bne cr6, 0x821b34e0
	if !ctx.cr[6].eq {
		sub_821B34B8(ctx, base);
		return;
	}
	// 821B3540: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 821B3544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3548 size=24
    let mut pc: u32 = 0x821B3548;
    'dispatch: loop {
        match pc {
            0x821B3548 => {
    //   block [0x821B3548..0x821B3560)
	// 821B3548: 2F070023  cmpwi cr6, r7, 0x23
	ctx.cr[6].compare_i32(ctx.r[7].s32, 35, &mut ctx.xer);
	// 821B354C: 409AFFF4  bne cr6, 0x821b3540
	if !ctx.cr[6].eq {
		sub_821B34E8(ctx, base);
		return;
	}
	// 821B3550: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821B3554: 409AFFEC  bne cr6, 0x821b3540
	if !ctx.cr[6].eq {
		sub_821B34E8(ctx, base);
		return;
	}
	// 821B3558: 3860000A  li r3, 0xa
	ctx.r[3].s64 = 10;
	// 821B355C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3560 size=84
    let mut pc: u32 = 0x821B3560;
    'dispatch: loop {
        match pc {
            0x821B3560 => {
    //   block [0x821B3560..0x821B35B4)
	// 821B3560: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3564: 616BEB0E  ori r11, r11, 0xeb0e
	ctx.r[11].u64 = ctx.r[11].u64 | 60174;
	// 821B3568: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B356C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3570: 409AFE58  bne cr6, 0x821b33c8
	if !ctx.cr[6].eq {
		sub_821B3340(ctx, base);
		return;
	}
	// 821B3574: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B3578: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 821B357C: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3580: 7D6B422E  lhzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B3584: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B3588: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B358C: 419A0114  beq cr6, 0x821b36a0
	if ctx.cr[6].eq {
		sub_821B35B4(ctx, base);
		return;
	}
	// 821B3590: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B3594: 419A0020  beq cr6, 0x821b35b4
	if ctx.cr[6].eq {
		sub_821B35B4(ctx, base);
		return;
	}
	// 821B3598: 2F070023  cmpwi cr6, r7, 0x23
	ctx.cr[6].compare_i32(ctx.r[7].s32, 35, &mut ctx.xer);
	// 821B359C: 409A01EC  bne cr6, 0x821b3788
	if !ctx.cr[6].eq {
		sub_821B35B4(ctx, base);
		return;
	}
	// 821B35A0: 7CCB0034  cntlzw r11, r6
	ctx.r[11].u64 = if ctx.r[6].u32 == 0 { 32 } else { ctx.r[6].u32.leading_zeros() as u64 };
	// 821B35A4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B35A8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 821B35AC: 386B0012  addi r3, r11, 0x12
	ctx.r[3].s64 = ctx.r[11].s64 + 18;
	// 821B35B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B35B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B35B4 size=484
    let mut pc: u32 = 0x821B35B4;
    'dispatch: loop {
        match pc {
            0x821B35B4 => {
    //   block [0x821B35B4..0x821B3698)
	// 821B35B4: 3967FFFF  addi r11, r7, -1
	ctx.r[11].s64 = ctx.r[7].s64 + -1;
	// 821B35B8: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 821B35BC: 419901C4  bgt cr6, 0x821b3780
	if ctx.cr[6].gt {
	pc = 0x821B3780; continue 'dispatch;
	}
	// 821B35C0: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821B35C4: 398C35D8  addi r12, r12, 0x35d8
	ctx.r[12].s64 = ctx.r[12].s64 + 13784;
	// 821B35C8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B35CC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B35D0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B35D4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		1 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		2 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		3 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		4 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		5 => {
	pc = 0x821B3698; continue 'dispatch;
		},
		6 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		7 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		8 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		9 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		10 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		11 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		12 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		13 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		14 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		15 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		16 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		17 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		18 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		19 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		20 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		21 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		22 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		23 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		24 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		25 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		26 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		27 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		28 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		29 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		30 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		31 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		32 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		33 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		34 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		35 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		36 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		37 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		38 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		39 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		40 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		41 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		42 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		43 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		44 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		45 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		46 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		47 => {
	pc = 0x821B3788; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B35D8: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B35DC: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B35E0: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B35E4: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B35E8: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B35EC: 821B3698  lwz r16, 0x3698(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13976 as u32) ) } as u64;
	// 821B35F0: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B35F4: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B35F8: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B35FC: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3600: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3604: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3608: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B360C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3610: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3614: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3618: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B361C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3620: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3624: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3628: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B362C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3630: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3634: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3638: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B363C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3640: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3644: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3648: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B364C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3650: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3654: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3658: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B365C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3660: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3664: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3668: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B366C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3670: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3674: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3678: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B367C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3680: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3684: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3688: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B368C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3690: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3694: 821B3788  lwz r16, 0x3788(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14216 as u32) ) } as u64;
            }
            0x821B3698 => {
    //   block [0x821B3698..0x821B3780)
	// 821B3698: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 821B369C: 4E800020  blr
	return;
	// 821B36A0: 3967FFFE  addi r11, r7, -2
	ctx.r[11].s64 = ctx.r[7].s64 + -2;
	// 821B36A4: 2B0B002E  cmplwi cr6, r11, 0x2e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 46 as u32, &mut ctx.xer);
	// 821B36A8: 419900E8  bgt cr6, 0x821b3790
	if ctx.cr[6].gt {
	pc = 0x821B3790; continue 'dispatch;
	}
	// 821B36AC: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821B36B0: 398C36C4  addi r12, r12, 0x36c4
	ctx.r[12].s64 = ctx.r[12].s64 + 14020;
	// 821B36B4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B36B8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B36BC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B36C0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		1 => {
	pc = 0x821B3788; continue 'dispatch;
		},
		2 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		3 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		4 => {
	pc = 0x821B3698; continue 'dispatch;
		},
		5 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		6 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		7 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		8 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		9 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		10 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		11 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		12 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		13 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		14 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		15 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		16 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		17 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		18 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		19 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		20 => {
	pc = 0x821B3698; continue 'dispatch;
		},
		21 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		22 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		23 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		24 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		25 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		26 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		27 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		28 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		29 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		30 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		31 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		32 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		33 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		34 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		35 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		36 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		37 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		38 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		39 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		40 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		41 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		42 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		43 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		44 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		45 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		46 => {
	pc = 0x821B3788; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B36C4: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B36C8: 821B3788  lwz r16, 0x3788(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14216 as u32) ) } as u64;
	// 821B36CC: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36D0: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36D4: 821B3698  lwz r16, 0x3698(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13976 as u32) ) } as u64;
	// 821B36D8: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36DC: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36E0: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36E4: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36E8: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B36EC: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36F0: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B36F4: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36F8: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36FC: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3700: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3704: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3708: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B370C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3710: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3714: 821B3698  lwz r16, 0x3698(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13976 as u32) ) } as u64;
	// 821B3718: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B371C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3720: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3724: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3728: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B372C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3730: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3734: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3738: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B373C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3740: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3744: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3748: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B374C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3750: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3754: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3758: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B375C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3760: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3764: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3768: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B376C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3770: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3774: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3778: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B377C: 821B3788  lwz r16, 0x3788(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14216 as u32) ) } as u64;
            }
            0x821B3780 => {
    //   block [0x821B3780..0x821B3788)
	// 821B3780: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821B3784: 4E800020  blr
	return;
            }
            0x821B3788 => {
    //   block [0x821B3788..0x821B3790)
	// 821B3788: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B378C: 4E800020  blr
	return;
            }
            0x821B3790 => {
    //   block [0x821B3790..0x821B3798)
	// 821B3790: 38600007  li r3, 7
	ctx.r[3].s64 = 7;
	// 821B3794: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3798 size=220
    let mut pc: u32 = 0x821B3798;
    'dispatch: loop {
        match pc {
            0x821B3798 => {
    //   block [0x821B3798..0x821B3874)
	// 821B3798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B379C: 48381909  bl 0x825350a4
	ctx.lr = 0x821B37A0;
	sub_82535080(ctx, base);
	// 821B37A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B37A4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B37A8: 38A00C40  li r5, 0xc40
	ctx.r[5].s64 = 3136;
	// 821B37AC: 3BCBCF90  addi r30, r11, -0x3070
	ctx.r[30].s64 = ctx.r[11].s64 + -12400;
	// 821B37B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B37B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B37B8: 48381A19  bl 0x825351d0
	ctx.lr = 0x821B37BC;
	sub_825351D0(ctx, base);
	// 821B37BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B37C0: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 821B37C4: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 821B37C8: 3B0000A6  li r24, 0xa6
	ctx.r[24].s64 = 166;
	// 821B37CC: 3B200015  li r25, 0x15
	ctx.r[25].s64 = 21;
	// 821B37D0: 3B400011  li r26, 0x11
	ctx.r[26].s64 = 17;
	// 821B37D4: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 821B37D8: 3B80000F  li r28, 0xf
	ctx.r[28].s64 = 15;
	// 821B37DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B37E0: B2FFFFFC  sth r23, -4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[23].u16 ) };
	// 821B37E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B37E8: B31FFFFE  sth r24, -2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(-2 as u32), ctx.r[24].u16 ) };
	// 821B37EC: B33F0000  sth r25, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 821B37F0: B35F0002  sth r26, 2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[26].u16 ) };
	// 821B37F4: B37F0004  sth r27, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 821B37F8: B39F0006  sth r28, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[28].u16 ) };
	// 821B37FC: 4800007D  bl 0x821b3878
	ctx.lr = 0x821B3800;
	sub_821B3878(ctx, base);
	// 821B3800: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 821B3804: 397E001C  addi r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 + 28;
	// 821B3808: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821B380C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B3810: 4198FFCC  blt cr6, 0x821b37dc
	if ctx.cr[6].lt {
	pc = 0x821B37DC; continue 'dispatch;
	}
	// 821B3814: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B3818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B381C: C00BD4DC  lfs f0, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3820: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3824: D01E07F0  stfs f0, 0x7f0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2032 as u32), tmp.u32 ) };
	// 821B3828: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B382C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3830: D01E0800  stfs f0, 0x800(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 821B3834: D01E0804  stfs f0, 0x804(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 821B3838: D01E0808  stfs f0, 0x808(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2056 as u32), tmp.u32 ) };
	// 821B383C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3840: D1BE080C  stfs f13, 0x80c(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2060 as u32), tmp.u32 ) };
	// 821B3844: D01E0810  stfs f0, 0x810(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2064 as u32), tmp.u32 ) };
	// 821B3848: D01E0814  stfs f0, 0x814(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2068 as u32), tmp.u32 ) };
	// 821B384C: D01E0818  stfs f0, 0x818(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2072 as u32), tmp.u32 ) };
	// 821B3850: D1BE081C  stfs f13, 0x81c(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2076 as u32), tmp.u32 ) };
	// 821B3854: D01E0820  stfs f0, 0x820(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2080 as u32), tmp.u32 ) };
	// 821B3858: 480007B9  bl 0x821b4010
	ctx.lr = 0x821B385C;
	sub_821B4010(ctx, base);
	// 821B385C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3860: C00B2190  lfs f0, 0x2190(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3864: D01E0C34  stfs f0, 0xc34(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3124 as u32), tmp.u32 ) };
	// 821B3868: 48000121  bl 0x821b3988
	ctx.lr = 0x821B386C;
	sub_821B3988(ctx, base);
	// 821B386C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B3870: 48381884  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B3878 size=268
    let mut pc: u32 = 0x821B3878;
    'dispatch: loop {
        match pc {
            0x821B3878 => {
    //   block [0x821B3878..0x821B3984)
	// 821B3878: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821B387C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821B3880: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B3884: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 821B3888: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B388C: 1D440310  mulli r10, r4, 0x310
	ctx.r[10].s64 = ctx.r[4].s64 * 784;
	// 821B3890: C0061FF8  lfs f0, 0x1ff8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3894: 38EB06A2  addi r7, r11, 0x6a2
	ctx.r[7].s64 = ctx.r[11].s64 + 1698;
	// 821B3898: 1D040031  mulli r8, r4, 0x31
	ctx.r[8].s64 = ctx.r[4].s64 * 49;
	// 821B389C: 392B0028  addi r9, r11, 0x28
	ctx.r[9].s64 = ctx.r[11].s64 + 40;
	// 821B38A0: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 821B38A4: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B38A8: 38E00031  li r7, 0x31
	ctx.r[7].s64 = 49;
	// 821B38AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B38B0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 821B38B4: D009FFF8  stfs f0, -8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821B38B8: D009FFFC  stfs f0, -4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821B38BC: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B38C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B38C4: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B38C8: 9948FF9E  stb r10, -0x62(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(-98 as u32), ctx.r[10].u8 ) };
	// 821B38CC: 99480000  stb r10, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821B38D0: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 821B38D4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821B38D8: 409AFFD8  bne cr6, 0x821b38b0
	if !ctx.cr[6].eq {
	pc = 0x821B38B0; continue 'dispatch;
	}
	// 821B38DC: 390B07D0  addi r8, r11, 0x7d0
	ctx.r[8].s64 = ctx.r[11].s64 + 2000;
	// 821B38E0: 54892036  slwi r9, r4, 4
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B38E4: 38EB0798  addi r7, r11, 0x798
	ctx.r[7].s64 = ctx.r[11].s64 + 1944;
	// 821B38E8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821B38EC: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821B38F0: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821B38F4: 38AB0778  addi r5, r11, 0x778
	ctx.r[5].s64 = ctx.r[11].s64 + 1912;
	// 821B38F8: 5483103A  slwi r3, r4, 2
	ctx.r[3].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821B38FC: 3BEB0780  addi r31, r11, 0x780
	ctx.r[31].s64 = ctx.r[11].s64 + 1920;
	// 821B3900: C1A8BA38  lfs f13, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3904: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B3908: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B390C: 7C062D2E  stfsx f0, r6, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 821B3910: 38CB0790  addi r6, r11, 0x790
	ctx.r[6].s64 = ctx.r[11].s64 + 1936;
	// 821B3914: 5485103A  slwi r5, r4, 2
	ctx.r[5].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821B3918: 7C03FD2E  stfsx f0, r3, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821B391C: 386B07B0  addi r3, r11, 0x7b0
	ctx.r[3].s64 = ctx.r[11].s64 + 1968;
	// 821B3920: 7D48392E  stwx r10, r8, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u32) };
	// 821B3924: 390B0788  addi r8, r11, 0x788
	ctx.r[8].s64 = ctx.r[11].s64 + 1928;
	// 821B3928: 5487103A  slwi r7, r4, 2
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B392C: 3BEB07B8  addi r31, r11, 0x7b8
	ctx.r[31].s64 = ctx.r[11].s64 + 1976;
	// 821B3930: 7D45192E  stwx r10, r5, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 821B3934: 5485103A  slwi r5, r4, 2
	ctx.r[5].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821B3938: 7D5E412E  stwx r10, r30, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 821B393C: 386B07C8  addi r3, r11, 0x7c8
	ctx.r[3].s64 = ctx.r[11].s64 + 1992;
	// 821B3940: 7D47312E  stwx r10, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[10].u32) };
	// 821B3944: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B3948: 5487103A  slwi r7, r4, 2
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B394C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B3950: 38CB07A8  addi r6, r11, 0x7a8
	ctx.r[6].s64 = ctx.r[11].s64 + 1960;
	// 821B3954: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B3958: 5484103A  slwi r4, r4, 2
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B395C: D0090008  stfs f0, 8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B3960: 396B0824  addi r11, r11, 0x824
	ctx.r[11].s64 = ctx.r[11].s64 + 2084;
	// 821B3964: D1A9000C  stfs f13, 0xc(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B3968: 7D48F92E  stwx r10, r8, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 821B396C: 7D45192E  stwx r10, r5, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 821B3970: 7D47312E  stwx r10, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[10].u32) };
	// 821B3974: 7D44592E  stwx r10, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 821B3978: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B397C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821B3980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B3988 size=104
    let mut pc: u32 = 0x821B3988;
    'dispatch: loop {
        match pc {
            0x821B3988 => {
    //   block [0x821B3988..0x821B39F0)
	// 821B3988: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B398C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B3990: 38CBCF90  addi r6, r11, -0x3070
	ctx.r[6].s64 = ctx.r[11].s64 + -12400;
	// 821B3994: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B3998: 39660028  addi r11, r6, 0x28
	ctx.r[11].s64 = ctx.r[6].s64 + 40;
	// 821B399C: 394606A2  addi r10, r6, 0x6a2
	ctx.r[10].s64 = ctx.r[6].s64 + 1698;
	// 821B39A0: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B39A4: 39060770  addi r8, r6, 0x770
	ctx.r[8].s64 = ctx.r[6].s64 + 1904;
	// 821B39A8: 39200031  li r9, 0x31
	ctx.r[9].s64 = 49;
	// 821B39AC: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821B39B0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821B39B4: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821B39B8: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821B39BC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B39C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B39C4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B39C8: 98EAFF9E  stb r7, -0x62(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-98 as u32), ctx.r[7].u8 ) };
	// 821B39CC: 98EA0000  stb r7, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 821B39D0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821B39D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B39D8: 409AFFD8  bne cr6, 0x821b39b0
	if !ctx.cr[6].eq {
	pc = 0x821B39B0; continue 'dispatch;
	}
	// 821B39DC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 821B39E0: 39260778  addi r9, r6, 0x778
	ctx.r[9].s64 = ctx.r[6].s64 + 1912;
	// 821B39E4: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B39E8: 4198FFC0  blt cr6, 0x821b39a8
	if ctx.cr[6].lt {
	pc = 0x821B39A8; continue 'dispatch;
	}
	// 821B39EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B39F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B39F0 size=780
    let mut pc: u32 = 0x821B39F0;
    'dispatch: loop {
        match pc {
            0x821B39F0 => {
    //   block [0x821B39F0..0x821B3CFC)
	// 821B39F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B39F4: 483816B9  bl 0x825350ac
	ctx.lr = 0x821B39F8;
	sub_82535080(ctx, base);
	// 821B39F8: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821B39FC: 483825ED  bl 0x82535fe8
	ctx.lr = 0x821B3A00;
	sub_82535FB0(ctx, base);
	// 821B3A00: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 821B3A04: 483859A1  bl 0x825393a4
	ctx.lr = 0x821B3A08;
	sub_82539130(ctx, base);
	// 821B3A08: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3A0C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3A10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B3A14: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B3A18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3A1C: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B3A20: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821B3A24: 61299B74  ori r9, r9, 0x9b74
	ctx.r[9].u64 = ctx.r[9].u64 | 39796;
	// 821B3A28: 7F7E50AE  lbzx r27, r30, r10
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B3A2C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B3A30: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B3A34: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821B3A38: 577F103E  rotlwi r31, r27, 2
	ctx.r[31].u64 = ((ctx.r[27].u32).rotate_left(2)) as u64;
	// 821B3A3C: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 821B3A40: 396B3420  addi r11, r11, 0x3420
	ctx.r[11].s64 = ctx.r[11].s64 + 13344;
	// 821B3A44: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 821B3A48: 7C1E4C2E  lfsx f0, r30, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3A4C: FF80F890  fmr f28, f31
	ctx.f[28].f64 = ctx.f[31].f64;
	// 821B3A50: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 821B3A54: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3A58: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B3A5C: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 821B3A60: C1AA2570  lfs f13, 0x2570(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9584 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3A64: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 821B3A68: 40990008  ble cr6, 0x821b3a70
	if !ctx.cr[6].gt {
	pc = 0x821B3A70; continue 'dispatch;
	}
	// 821B3A6C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 821B3A70: 7C1F5D2E  stfsx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821B3A74: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B3A78: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B3A7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3A80: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3A84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B3A88: 4E800421  bctrl
	ctx.lr = 0x821B3A8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B3A8C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B3A90: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821B3A94: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821B3A98: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821B3A9C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B3AA0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B3AA4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B3AA8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B3AAC: 4200FFF0  bdnz 0x821b3a9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B3A9C; continue 'dispatch;
	}
	// 821B3AB0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B3AB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B3AB8: 481B41D1  bl 0x82367c88
	ctx.lr = 0x821B3ABC;
	sub_82367C88(ctx, base);
	// 821B3ABC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B3AC0: 3B8B0FBC  addi r28, r11, 0xfbc
	ctx.r[28].s64 = ctx.r[11].s64 + 4028;
	// 821B3AC4: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 821B3AC8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3D00 size=316
    let mut pc: u32 = 0x821B3D00;
    'dispatch: loop {
        match pc {
            0x821B3D00 => {
    //   block [0x821B3D00..0x821B3E3C)
	// 821B3D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B3D04: 483813B9  bl 0x825350bc
	ctx.lr = 0x821B3D08;
	sub_82535080(ctx, base);
	// 821B3D08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3D0C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B3D10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B3D14: 3BABCF90  addi r29, r11, -0x3070
	ctx.r[29].s64 = ctx.r[11].s64 + -12400;
	// 821B3D18: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B3D1C: 395D07A0  addi r10, r29, 0x7a0
	ctx.r[10].s64 = ctx.r[29].s64 + 1952;
	// 821B3D20: 57C7103A  slwi r7, r30, 2
	ctx.r[7].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B3D24: 38DD0798  addi r6, r29, 0x798
	ctx.r[6].s64 = ctx.r[29].s64 + 1944;
	// 821B3D28: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B3D2C: 7C8B512E  stwx r4, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[4].u32) };
	// 821B3D30: 7D67302E  lwzx r11, r7, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821B3D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3D38: 419A0008  beq cr6, 0x821b3d40
	if ctx.cr[6].eq {
	pc = 0x821B3D40; continue 'dispatch;
	}
	// 821B3D3C: 392B0030  addi r9, r11, 0x30
	ctx.r[9].s64 = ctx.r[11].s64 + 48;
	// 821B3D40: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B3D44: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B3D48: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 821B3D4C: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B3D50: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3D54: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3D58: 391D0710  addi r8, r29, 0x710
	ctx.r[8].s64 = ctx.r[29].s64 + 1808;
	// 821B3D5C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B3D60: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821B3D64: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821B3D68: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821B3D6C: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821B3D70: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821B3D74: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B3D78: 7FE7302E  lwzx r31, r7, r6
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821B3D7C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3D80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B3D84: 4E800421  bctrl
	ctx.lr = 0x821B3D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B3D88: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3D8C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B3D90: 393D07D0  addi r9, r29, 0x7d0
	ctx.r[9].s64 = ctx.r[29].s64 + 2000;
	// 821B3D94: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3D98: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B3D9C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B3DA0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B3DA4: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3DA8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B3DAC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B3DB0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3E40 size=336
    let mut pc: u32 = 0x821B3E40;
    'dispatch: loop {
        match pc {
            0x821B3E40 => {
    //   block [0x821B3E40..0x821B3F90)
	// 821B3E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B3E44: 48381279  bl 0x825350bc
	ctx.lr = 0x821B3E48;
	sub_82535080(ctx, base);
	// 821B3E48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3E4C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3E50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B3E54: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B3E58: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B3E5C: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 821B3E60: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B3E64: 61288410  ori r8, r9, 0x8410
	ctx.r[8].u64 = ctx.r[9].u64 | 33808;
	// 821B3E68: 7D5E50AE  lbzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B3E6C: 392B0750  addi r9, r11, 0x750
	ctx.r[9].s64 = ctx.r[11].s64 + 1872;
	// 821B3E70: 3BBE0030  addi r29, r30, 0x30
	ctx.r[29].s64 = ctx.r[30].s64 + 48;
	// 821B3E74: 554B203E  rotlwi r11, r10, 4
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(4)) as u64;
	// 821B3E78: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B3E7C: 7FEB4A14  add r31, r11, r9
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821B3E80: 7C1E442E  lfsx f0, r30, r8
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3E84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3E88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3E8C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B3E90: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3E94: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B3E98: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B3E9C: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B3EA0: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B3EA4: C18BD4DC  lfs f12, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B3EA8: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B3EAC: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B3EB0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B3EB4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B3EBC: 4E800421  bctrl
	ctx.lr = 0x821B3EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B3EC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B3EC4: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3F90 size=24
    let mut pc: u32 = 0x821B3F90;
    'dispatch: loop {
        match pc {
            0x821B3F90 => {
    //   block [0x821B3F90..0x821B3FA8)
	// 821B3F90: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821B3F94: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821B3F98: 38EACF90  addi r7, r10, -0x3070
	ctx.r[7].s64 = ctx.r[10].s64 + -12400;
	// 821B3F9C: 89270C30  lbz r9, 0xc30(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B3FA0: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 821B3FA4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3FA8 size=32
    let mut pc: u32 = 0x821B3FA8;
    'dispatch: loop {
        match pc {
            0x821B3FA8 => {
    //   block [0x821B3FA8..0x821B3FC8)
	// 821B3FA8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B3FAC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B3FB0: 40990028  ble cr6, 0x821b3fd8
	if !ctx.cr[6].gt {
		sub_821B3FC8(ctx, base);
		return;
	}
	// 821B3FB4: A0CB0002  lhz r6, 2(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B3FB8: 39470832  addi r10, r7, 0x832
	ctx.r[10].s64 = ctx.r[7].s64 + 2098;
	// 821B3FBC: A0AA0000  lhz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3FC0: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B3FC4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3FC8 size=72
    let mut pc: u32 = 0x821B3FC8;
    'dispatch: loop {
        match pc {
            0x821B3FC8 => {
    //   block [0x821B3FC8..0x821B4010)
	// 821B3FC8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821B3FCC: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 821B3FD0: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B3FD4: 4198FFE8  blt cr6, 0x821b3fbc
	if ctx.cr[6].lt {
		sub_821B3FA8(ctx, base);
		return;
	}
	// 821B3FD8: 552A3032  slwi r10, r9, 6
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B3FDC: 39070830  addi r8, r7, 0x830
	ctx.r[8].s64 = ctx.r[7].s64 + 2096;
	// 821B3FE0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821B3FE4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B3FE8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821B3FEC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B3FF0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B3FF4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B3FF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B3FFC: 4200FFF0  bdnz 0x821b3fec
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B3FEC; continue 'dispatch;
	}
	// 821B4000: 89670C30  lbz r11, 0xc30(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B4004: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B4008: 99670C30  stb r11, 0xc30(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(3120 as u32), ctx.r[11].u8 ) };
	// 821B400C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B4010 size=128
    let mut pc: u32 = 0x821B4010;
    'dispatch: loop {
        match pc {
            0x821B4010 => {
    //   block [0x821B4010..0x821B4090)
	// 821B4010: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4014: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 821B4018: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 821B401C: 390BCF90  addi r8, r11, -0x3070
	ctx.r[8].s64 = ctx.r[11].s64 + -12400;
	// 821B4020: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 821B4024: 39680848  addi r11, r8, 0x848
	ctx.r[11].s64 = ctx.r[8].s64 + 2120;
	// 821B4028: C0061FF8  lfs f0, 0x1ff8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B402C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B4030: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B4034: B12BFFEA  sth r9, -0x16(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-22 as u32), ctx.r[9].u16 ) };
	// 821B4038: 38C80C48  addi r6, r8, 0xc48
	ctx.r[6].s64 = ctx.r[8].s64 + 3144;
	// 821B403C: 994BFFE8  stb r10, -0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), ctx.r[10].u8 ) };
	// 821B4040: 994BFFE9  stb r10, -0x17(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-23 as u32), ctx.r[10].u8 ) };
	// 821B4044: 914BFFEC  stw r10, -0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), ctx.r[10].u32 ) };
	// 821B4048: 90EBFFF0  stw r7, -0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), ctx.r[7].u32 ) };
	// 821B404C: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821B4050: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821B4054: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B4058: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B405C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B4060: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B4064: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821B4068: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B406C: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B4070: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B4074: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B4078: D00B0024  stfs f0, 0x24(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B407C: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821B4080: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821B4084: 4198FFB0  blt cr6, 0x821b4034
	if ctx.cr[6].lt {
	pc = 0x821B4034; continue 'dispatch;
	}
	// 821B4088: 99480C30  stb r10, 0xc30(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3120 as u32), ctx.r[10].u8 ) };
	// 821B408C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4090 size=564
    let mut pc: u32 = 0x821B4090;
    'dispatch: loop {
        match pc {
            0x821B4090 => {
    //   block [0x821B4090..0x821B42C4)
	// 821B4090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4094: 48381025  bl 0x825350b8
	ctx.lr = 0x821B4098;
	sub_82535080(ctx, base);
	// 821B4098: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B409C: E9440000  ld r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 821B40A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B40A4: E9240008  ld r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 821B40A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B40AC: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821B40B0: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821B40B4: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B40B8: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B40BC: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B40C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B40C4: C06B1FF8  lfs f3, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B40C8: D0610054  stfs f3, 0x54(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B40CC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B40D0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821B40D4: FF001800  fcmpu cr6, f0, f3
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[3].f64);
	// 821B40D8: 40990064  ble cr6, 0x821b413c
	if !ctx.cr[6].gt {
	pc = 0x821B413C; continue 'dispatch;
	}
	// 821B40DC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B40E0: 1181038C  vspltisw v12, 1
	for i in 0..4 {
		ctx.v[12].u32[i] = 1;
	}
	// 821B40E4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821B40E8: 1161634A  vcfsx v11, v12, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[11].f32[i] = (ctx.v[12].s32[i] as f32) * scale;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B42C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B42C8 size=352
    let mut pc: u32 = 0x821B42C8;
    'dispatch: loop {
        match pc {
            0x821B42C8 => {
    //   block [0x821B42C8..0x821B4428)
	// 821B42C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B42CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B42D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B42D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B42D8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821B42DC: 48381D0D  bl 0x82535fe8
	ctx.lr = 0x821B42E0;
	sub_82535FB0(ctx, base);
	// 821B42E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B42E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B42E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B42EC: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B42F0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B42F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B42F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B42FC: 4E800421  bctrl
	ctx.lr = 0x821B4300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4300: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4304: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4308: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 821B430C: 39630038  addi r11, r3, 0x38
	ctx.r[11].s64 = ctx.r[3].s64 + 56;
	// 821B4310: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B4314: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B4318: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B431C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4320: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B4324: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4328: C12B0040  lfs f9, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B432C: ED4A002A  fadds f10, f10, f0
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4330: C10B0078  lfs f8, 0x78(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B4334: ED29682A  fadds f9, f9, f13
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4338: C0EB0080  lfs f7, 0x80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B433C: ED00402A  fadds f8, f0, f8
	ctx.f[8].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 821B4340: C0CB00B8  lfs f6, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B4344: ECE7682A  fadds f7, f7, f13
	ctx.f[7].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4348: C0AB00C0  lfs f5, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821B434C: ECC6002A  fadds f6, f6, f0
	ctx.f[6].f64 = ((ctx.f[6].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4350: C08B00F8  lfs f4, 0xf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821B4354: ECA5682A  fadds f5, f5, f13
	ctx.f[5].f64 = ((ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4358: C06B0100  lfs f3, 0x100(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B435C: EC80202A  fadds f4, f0, f4
	ctx.f[4].f64 = ((ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64;
	// 821B4360: C04B0138  lfs f2, 0x138(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(312 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B4364: EC63682A  fadds f3, f3, f13
	ctx.f[3].f64 = ((ctx.f[3].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4368: C02B0140  lfs f1, 0x140(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B436C: EC42002A  fadds f2, f2, f0
	ctx.f[2].f64 = ((ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4370: C3EB0178  lfs f31, 0x178(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(376 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B4374: EC21682A  fadds f1, f1, f13
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4378: C3CB0180  lfs f30, 0x180(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(384 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B437C: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821B4380: C3AB01B8  lfs f29, 0x1b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B4384: EFDE682A  fadds f30, f30, f13
	ctx.f[30].f64 = ((ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4388: C38B01C0  lfs f28, 0x1c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(448 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B438C: EFBD002A  fadds f29, f29, f0
	ctx.f[29].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4390: EF9C682A  fadds f28, f28, f13
	ctx.f[28].f64 = ((ctx.f[28].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4394: D18BFFF8  stfs f12, -8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821B4398: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B439C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B43A0: D14B0038  stfs f10, 0x38(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B43A4: D12B0040  stfs f9, 0x40(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821B43A8: D10B0078  stfs f8, 0x78(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821B43AC: D0EB0080  stfs f7, 0x80(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821B43B0: D0CB00B8  stfs f6, 0xb8(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821B43B4: D0AB00C0  stfs f5, 0xc0(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 821B43B8: D08B00F8  stfs f4, 0xf8(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 821B43BC: D06B0100  stfs f3, 0x100(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 821B43C0: D04B0138  stfs f2, 0x138(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 821B43C4: D02B0140  stfs f1, 0x140(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 821B43C8: D3EB0178  stfs f31, 0x178(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821B43CC: D3CB0180  stfs f30, 0x180(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 821B43D0: D3AB01B8  stfs f29, 0x1b8(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 821B43D4: D38B01C0  stfs f28, 0x1c0(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 821B43D8: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821B43DC: 409AFF34  bne cr6, 0x821b4310
	if !ctx.cr[6].eq {
	pc = 0x821B4310; continue 'dispatch;
	}
	// 821B43E0: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B43E4: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821B43E8: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 821B43EC: 616B9248  ori r11, r11, 0x9248
	ctx.r[11].u64 = ctx.r[11].u64 | 37448;
	// 821B43F0: 614A924C  ori r10, r10, 0x924c
	ctx.r[10].u64 = ctx.r[10].u64 | 37452;
	// 821B43F4: 61299244  ori r9, r9, 0x9244
	ctx.r[9].u64 = ctx.r[9].u64 | 37444;
	// 821B43F8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B43FC: 7C1E5D2E  stfsx f0, r30, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821B4400: 7DBE552E  stfsx f13, r30, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 821B4404: 7D1E492E  stwx r8, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 821B4408: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B440C: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821B4410: 48381C25  bl 0x82536034
	ctx.lr = 0x821B4414;
	sub_82535FFC(ctx, base);
	// 821B4414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B4418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B441C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B4420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B4424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B4428 size=92
    let mut pc: u32 = 0x821B4428;
    'dispatch: loop {
        match pc {
            0x821B4428 => {
    //   block [0x821B4428..0x821B4484)
	// 821B4428: FDA00A10  fabs f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 821B442C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4430: C00B25B0  lfs f0, 0x25b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9648 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4434: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4438: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B443C: C94B2008  lfd f10, 0x2008(r11)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 821B4440: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4444: C96B2000  lfd f11, 0x2000(r11)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 821B4448: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B444C: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B4450: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B4454: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B4458: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B445C: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 821B4460: 40980024  bge cr6, 0x821b4484
	if !ctx.cr[6].lt {
		sub_821B4484(ctx, base);
		return;
	}
	// 821B4464: C1ABD4DC  lfs f13, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4468: EDAD1024  fdivs f13, f13, f2
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[2].f64) as f32) as f64;
	// 821B446C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B4470: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B4474: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B4478: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B447C: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B4480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4484(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B4484 size=44
    let mut pc: u32 = 0x821B4484;
    'dispatch: loop {
        match pc {
            0x821B4484 => {
    //   block [0x821B4484..0x821B44B0)
	// 821B4484: C18BD4DC  lfs f12, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B4488: EDA2602A  fadds f13, f2, f12
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[12].f64) as f32) as f64;
	// 821B448C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B4490: 40980020  bge cr6, 0x821b44b0
	if !ctx.cr[6].lt {
		sub_821B44B0(ctx, base);
		return;
	}
	// 821B4494: EDAC1028  fsubs f13, f12, f2
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B4498: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B449C: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B44A0: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B44A4: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B44A8: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B44AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B44B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B44B0 size=68
    let mut pc: u32 = 0x821B44B0;
    'dispatch: loop {
        match pc {
            0x821B44B0 => {
    //   block [0x821B44B0..0x821B44F4)
	// 821B44B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B44B4: C1ABD6C8  lfs f13, -0x2938(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B44B8: EDA2682A  fadds f13, f2, f13
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B44BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B44C0: 40980034  bge cr6, 0x821b44f4
	if !ctx.cr[6].lt {
		sub_821B44F4(ctx, base);
		return;
	}
	// 821B44C4: EDA01028  fsubs f13, f0, f2
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B44C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B44CC: C00B2164  lfs f0, 0x2164(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B44D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B44D4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B44D8: C00B20D8  lfs f0, 0x20d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8408 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B44DC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B44E0: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B44E4: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B44E8: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B44EC: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B44F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B44F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B44F4 size=56
    let mut pc: u32 = 0x821B44F4;
    'dispatch: loop {
        match pc {
            0x821B44F4 => {
    //   block [0x821B44F4..0x821B452C)
	// 821B44F4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B44F8: C1ABD6D0  lfs f13, -0x2930(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B44FC: EDA2682A  fadds f13, f2, f13
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4500: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B4504: 40980028  bge cr6, 0x821b452c
	if !ctx.cr[6].lt {
		sub_821B452C(ctx, base);
		return;
	}
	// 821B4508: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B450C: C1ABD468  lfs f13, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4510: EDAD1028  fsubs f13, f13, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B4514: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4518: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B451C: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B4520: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B4524: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B4528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B452C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B452C size=64
    let mut pc: u32 = 0x821B452C;
    'dispatch: loop {
        match pc {
            0x821B452C => {
    //   block [0x821B452C..0x821B456C)
	// 821B452C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4530: C1AB20C8  lfs f13, 0x20c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4534: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B4538: ED2D1028  fsubs f9, f13, f2
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B453C: C1ABD468  lfs f13, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4540: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4544: EDA06B3A  fmadds f13, f0, f12, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B4548: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B454C: EC004824  fdivs f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 821B4550: EDAD1028  fsubs f13, f13, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B4554: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B4558: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B455C: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B4560: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B4564: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B4568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B4570 size=84
    let mut pc: u32 = 0x821B4570;
    'dispatch: loop {
        match pc {
            0x821B4570 => {
    //   block [0x821B4570..0x821B45C4)
	// 821B4570: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821B4574: E9230008  ld r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 821B4578: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 821B457C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4580: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B4584: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821B4588: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821B458C: 419A0038  beq cr6, 0x821b45c4
	if ctx.cr[6].eq {
		sub_821B45C4(ctx, base);
		return;
	}
	// 821B4590: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B4594: 556BA73E  rlwinm r11, r11, 0x14, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 821B4598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B459C: 419A0028  beq cr6, 0x821b45c4
	if ctx.cr[6].eq {
		sub_821B45C4(ctx, base);
		return;
	}
	// 821B45A0: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821B45A4: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 821B45A8: 394ACF90  addi r10, r10, -0x3070
	ctx.r[10].s64 = ctx.r[10].s64 + -12400;
	// 821B45AC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B45B0: 394A07F0  addi r10, r10, 0x7f0
	ctx.r[10].s64 = ctx.r[10].s64 + 2032;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B45C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B45C4 size=88
    let mut pc: u32 = 0x821B45C4;
    'dispatch: loop {
        match pc {
            0x821B45C4 => {
    //   block [0x821B45C4..0x821B461C)
	// 821B45C4: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4620 size=360
    let mut pc: u32 = 0x821B4620;
    'dispatch: loop {
        match pc {
            0x821B4620 => {
    //   block [0x821B4620..0x821B4788)
	// 821B4620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4624: 48380A91  bl 0x825350b4
	ctx.lr = 0x821B4628;
	sub_82535080(ctx, base);
	// 821B4628: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821B462C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821B4630: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4634: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4638: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B463C: 3F7F0002  addis r27, r31, 2
	ctx.r[27].s64 = ctx.r[31].s64 + 131072;
	// 821B4640: 3BABCF90  addi r29, r11, -0x3070
	ctx.r[29].s64 = ctx.r[11].s64 + -12400;
	// 821B4644: 3B7BBE64  addi r27, r27, -0x419c
	ctx.r[27].s64 = ctx.r[27].s64 + -16796;
	// 821B4648: 391D0750  addi r8, r29, 0x750
	ctx.r[8].s64 = ctx.r[29].s64 + 1872;
	// 821B464C: 393D0798  addi r9, r29, 0x798
	ctx.r[9].s64 = ctx.r[29].s64 + 1944;
	// 821B4650: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B4654: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B4658: 895B0000  lbz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B465C: 5547103E  rotlwi r7, r10, 2
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821B4660: 554A203E  rotlwi r10, r10, 4
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(4)) as u64;
	// 821B4664: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B4668: 7D27482E  lwzx r9, r7, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B466C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B4670: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B4674: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821B4678: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821B467C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B4680: 419A00E4  beq cr6, 0x821b4764
	if ctx.cr[6].eq {
	pc = 0x821B4764; continue 'dispatch;
	}
	// 821B4684: 3BC90030  addi r30, r9, 0x30
	ctx.r[30].s64 = ctx.r[9].s64 + 48;
	// 821B4688: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B468C: 419A00D8  beq cr6, 0x821b4764
	if ctx.cr[6].eq {
	pc = 0x821B4764; continue 'dispatch;
	}
	// 821B4690: C05E0008  lfs f2, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B4694: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4698: 4837E811  bl 0x82532ea8
	ctx.lr = 0x821B469C;
	sub_82532EA8(ctx, base);
	// 821B469C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B46A0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B46A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B46A8: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 821B46AC: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B46B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B46B4: C3EB2254  lfs f31, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B46B8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B46BC: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B46C0: 4BF88C19  bl 0x8213d2d8
	ctx.lr = 0x821B46C4;
	sub_8213D2D8(ctx, base);
	// 821B46C4: C1810058  lfs f12, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B46C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B46CC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B46D0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B46D4: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B46D8: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B46DC: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B46E0: C15E0004  lfs f10, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B46E4: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B46E8: EDAA02FA  fmadds f13, f10, f11, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B46EC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B46F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B46F4: C18BBA38  lfs f12, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B46F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B46FC: 41980014  blt cr6, 0x821b4710
	if ctx.cr[6].lt {
	pc = 0x821B4710; continue 'dispatch;
	}
	// 821B4700: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4704: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 821B4708: C3CB2074  lfs f30, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B470C: 4800001C  b 0x821b4728
	pc = 0x821B4728; continue 'dispatch;
	// 821B4710: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4718: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 821B471C: C02BBFFC  lfs f1, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4720: 4BF88BB9  bl 0x8213d2d8
	ctx.lr = 0x821B4724;
	sub_8213D2D8(ctx, base);
	// 821B4724: FFC06090  fmr f30, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[12].f64;
	// 821B4728: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B472C: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 821B4730: EC00603C  fnmsubs f0, f0, f0, f12
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B4734: EC40002C  fsqrts f2, f0
	ctx.f[2].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821B4738: 4837E771  bl 0x82532ea8
	ctx.lr = 0x821B473C;
	sub_82532EA8(ctx, base);
	// 821B473C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4740: 3C7F0006  addis r3, r31, 6
	ctx.r[3].s64 = ctx.r[31].s64 + 393216;
	// 821B4744: 3863A510  addi r3, r3, -0x5af0
	ctx.r[3].s64 = ctx.r[3].s64 + -23280;
	// 821B4748: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B474C: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B4750: 481B3741  bl 0x82367e90
	ctx.lr = 0x821B4754;
	sub_82367E90(ctx, base);
	// 821B4754: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B4758: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B475C: 616BA550  ori r11, r11, 0xa550
	ctx.r[11].u64 = ctx.r[11].u64 | 42320;
	// 821B4760: 7D5F592E  stwx r10, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 821B4764: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4768: 395D0788  addi r10, r29, 0x788
	ctx.r[10].s64 = ctx.r[29].s64 + 1928;
	// 821B476C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B4770: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B4774: 7F8B512E  stwx r28, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[28].u32) };
	// 821B4778: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B477C: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821B4780: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B4784: 48380980  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4788 size=240
    let mut pc: u32 = 0x821B4788;
    'dispatch: loop {
        match pc {
            0x821B4788 => {
    //   block [0x821B4788..0x821B4878)
	// 821B4788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B478C: 4838092D  bl 0x825350b8
	ctx.lr = 0x821B4790;
	sub_82535080(ctx, base);
	// 821B4790: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821B4794: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821B4798: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B479C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B47A0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B47A4: 3F9F0002  addis r28, r31, 2
	ctx.r[28].s64 = ctx.r[31].s64 + 131072;
	// 821B47A8: 3BABCF90  addi r29, r11, -0x3070
	ctx.r[29].s64 = ctx.r[11].s64 + -12400;
	// 821B47AC: 3B9CBE64  addi r28, r28, -0x419c
	ctx.r[28].s64 = ctx.r[28].s64 + -16796;
	// 821B47B0: 395D0710  addi r10, r29, 0x710
	ctx.r[10].s64 = ctx.r[29].s64 + 1808;
	// 821B47B4: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B47B8: 556B203E  rotlwi r11, r11, 4
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 821B47BC: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B47C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B47C4: 419A0090  beq cr6, 0x821b4854
	if ctx.cr[6].eq {
	pc = 0x821B4854; continue 'dispatch;
	}
	// 821B47C8: C05E0008  lfs f2, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B47CC: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B47D0: 4837E6D9  bl 0x82532ea8
	ctx.lr = 0x821B47D4;
	sub_82532EA8(ctx, base);
	// 821B47D4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B47D8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B47DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B47E0: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 821B47E4: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B47E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B47EC: C3EB2254  lfs f31, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B47F0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B47F4: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B47F8: 4BF88AE1  bl 0x8213d2d8
	ctx.lr = 0x821B47FC;
	sub_8213D2D8(ctx, base);
	// 821B47FC: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4800: 395D0788  addi r10, r29, 0x788
	ctx.r[10].s64 = ctx.r[29].s64 + 1928;
	// 821B4804: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B4808: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B480C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B4810: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B4814: C18ABA38  lfs f12, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B4818: 409A004C  bne cr6, 0x821b4864
	if !ctx.cr[6].eq {
	pc = 0x821B4864; continue 'dispatch;
	}
	// 821B481C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4820: C02BBFFC  lfs f1, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4824: 4BF88AB5  bl 0x8213d2d8
	ctx.lr = 0x821B4828;
	sub_8213D2D8(ctx, base);
	// 821B4828: FFC06090  fmr f30, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[12].f64;
	// 821B482C: C03E0004  lfs f1, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4830: EC01607C  fnmsubs f0, f1, f1, f12
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[1].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B4834: EC40002C  fsqrts f2, f0
	ctx.f[2].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821B4838: 4837E671  bl 0x82532ea8
	ctx.lr = 0x821B483C;
	sub_82532EA8(ctx, base);
	// 821B483C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4840: 3C7F0006  addis r3, r31, 6
	ctx.r[3].s64 = ctx.r[31].s64 + 393216;
	// 821B4844: 3863A510  addi r3, r3, -0x5af0
	ctx.r[3].s64 = ctx.r[3].s64 + -23280;
	// 821B4848: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B484C: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B4850: 481B3641  bl 0x82367e90
	ctx.lr = 0x821B4854;
	sub_82367E90(ctx, base);
	// 821B4854: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B4858: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B485C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B4860: 483808A8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821B4864: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B4868: 409AFFC0  bne cr6, 0x821b4828
	if !ctx.cr[6].eq {
	pc = 0x821B4828; continue 'dispatch;
	}
	// 821B486C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4870: C3CB2074  lfs f30, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B4874: 4BFFFFB8  b 0x821b482c
	pc = 0x821B482C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4878 size=644
    let mut pc: u32 = 0x821B4878;
    'dispatch: loop {
        match pc {
            0x821B4878 => {
    //   block [0x821B4878..0x821B4AFC)
	// 821B4878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B487C: 4838083D  bl 0x825350b8
	ctx.lr = 0x821B4880;
	sub_82535080(ctx, base);
	// 821B4880: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821B4884: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821B4888: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821B488C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4890: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4898: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B489C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B48A0: 896B0001  lbz r11, 1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B48A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B48A8: 409A001C  bne cr6, 0x821b48c4
	if !ctx.cr[6].eq {
	pc = 0x821B48C4; continue 'dispatch;
	}
	// 821B48AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B48B0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B48B4: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821B48B8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B48BC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B48C0: 48380848  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821B48C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B48C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B48CC: 386BCD68  addi r3, r11, -0x3298
	ctx.r[3].s64 = ctx.r[11].s64 + -12952;
	// 821B48D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B48D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B48D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B48DC: 48003895  bl 0x821b8170
	ctx.lr = 0x821B48E0;
	sub_821B8170(ctx, base);
	// 821B48E0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B48E4: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 821B48E8: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 821B48EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B48F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B48F4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B48F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B48FC: 4E800421  bctrl
	ctx.lr = 0x821B4900;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4900: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4904: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821B4908: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B490C: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4910: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B4914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4918: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B491C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821B4920: 419A0060  beq cr6, 0x821b4980
	if ctx.cr[6].eq {
	pc = 0x821B4980; continue 'dispatch;
	}
	// 821B4924: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B4928: 554AC73E  rlwinm r10, r10, 0x18, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B492C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821B4930: 419A0050  beq cr6, 0x821b4980
	if ctx.cr[6].eq {
	pc = 0x821B4980; continue 'dispatch;
	}
	// 821B4934: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821B4938: 419A0014  beq cr6, 0x821b494c
	if ctx.cr[6].eq {
	pc = 0x821B494C; continue 'dispatch;
	}
	// 821B493C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B4940: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B4944: 2F0B003A  cmpwi cr6, r11, 0x3a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 58, &mut ctx.xer);
	// 821B4948: 419A0038  beq cr6, 0x821b4980
	if ctx.cr[6].eq {
	pc = 0x821B4980; continue 'dispatch;
	}
	// 821B494C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B4950: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 821B4954: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4958: 394BCF90  addi r10, r11, -0x3070
	ctx.r[10].s64 = ctx.r[11].s64 + -12400;
	// 821B495C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 821B4960: 7D1F48AE  lbzx r8, r31, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B4964: 392A0730  addi r9, r10, 0x730
	ctx.r[9].s64 = ctx.r[10].s64 + 1840;
	// 821B4968: 550A203E  rotlwi r10, r8, 4
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(4)) as u64;
	// 821B496C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B4970: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B4974: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B4978: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B497C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B4980: 3FBF0002  addis r29, r31, 2
	ctx.r[29].s64 = ctx.r[31].s64 + 131072;
	// 821B4984: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4988: 3BBDEB32  addi r29, r29, -0x14ce
	ctx.r[29].s64 = ctx.r[29].s64 + -5326;
	// 821B498C: C3CB2190  lfs f30, 0x2190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B4990: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B4994: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4998: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821B499C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B49A0: 419A00D0  beq cr6, 0x821b4a70
	if ctx.cr[6].eq {
	pc = 0x821B4A70; continue 'dispatch;
	}
	// 821B49A4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B49A8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B49AC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821B49B0: 616B8410  ori r11, r11, 0x8410
	ctx.r[11].u64 = ctx.r[11].u64 | 33808;
	// 821B49B4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B49B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B49BC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B49C0: 7C1F5C2E  lfsx f0, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B49C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B49C8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B49CC: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B49D0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B49D4: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B49D8: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B49DC: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821B49E0: C3EBD4DC  lfs f31, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B49E4: ED8007F2  fmuls f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B49E8: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B49EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B49F0: 4E800421  bctrl
	ctx.lr = 0x821B49F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B49F4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821B49F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B49FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B4A00: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 821B4A04: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 821B4A08: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4B00 size=204
    let mut pc: u32 = 0x821B4B00;
    'dispatch: loop {
        match pc {
            0x821B4B00 => {
    //   block [0x821B4B00..0x821B4BCC)
	// 821B4B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4B04: 483805B9  bl 0x825350bc
	ctx.lr = 0x821B4B08;
	sub_82535080(ctx, base);
	// 821B4B08: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821B4B0C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4B10: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4B14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B4B18: 3BEBCF90  addi r31, r11, -0x3070
	ctx.r[31].s64 = ctx.r[11].s64 + -12400;
	// 821B4B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4B20: 4BFFEC79  bl 0x821b3798
	ctx.lr = 0x821B4B24;
	sub_821B3798(ctx, base);
	// 821B4B24: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4B28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B4B2C: 3BCBCD68  addi r30, r11, -0x3298
	ctx.r[30].s64 = ctx.r[11].s64 + -12952;
	// 821B4B30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4B34: 48004165  bl 0x821b8c98
	ctx.lr = 0x821B4B38;
	sub_821B8C98(ctx, base);
	// 821B4B38: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B4B3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4B40: 409A0018  bne cr6, 0x821b4b58
	if !ctx.cr[6].eq {
	pc = 0x821B4B58; continue 'dispatch;
	}
	// 821B4B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4B48: 48004631  bl 0x821b9178
	ctx.lr = 0x821B4B4C;
	sub_821B9178(ctx, base);
	// 821B4B4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B4B50: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B4B54: 483805B8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821B4B58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4B5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B4B60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B4B64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B4B68: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B4B6C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4B70: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821B4B74: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B4B78: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B4B7C: 994B0001  stb r10, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 821B4B80: 994B0002  stb r10, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 821B4B84: 994B0003  stb r10, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 821B4B88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B4B8C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B4B90: 480029A1  bl 0x821b7530
	ctx.lr = 0x821B4B94;
	sub_821B7530(ctx, base);
	// 821B4B94: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821B4B98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4B9C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821B4BA0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821B4BA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B4BA8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B4BAC: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4BB0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B4BB4: D01F0820  stfs f0, 0x820(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2080 as u32), tmp.u32 ) };
	// 821B4BB8: 48002979  bl 0x821b7530
	ctx.lr = 0x821B4BBC;
	sub_821B7530(ctx, base);
	// 821B4BBC: D03F0C34  stfs f1, 0xc34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3124 as u32), tmp.u32 ) };
	// 821B4BC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B4BC4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B4BC8: 48380544  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4BD0 size=196
    let mut pc: u32 = 0x821B4BD0;
    'dispatch: loop {
        match pc {
            0x821B4BD0 => {
    //   block [0x821B4BD0..0x821B4C94)
	// 821B4BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B4BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B4BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B4BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4BE8: 3FDF0002  addis r30, r31, 2
	ctx.r[30].s64 = ctx.r[31].s64 + 131072;
	// 821B4BEC: 3BDEBE64  addi r30, r30, -0x419c
	ctx.r[30].s64 = ctx.r[30].s64 + -16796;
	// 821B4BF0: 889E0000  lbz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4BF4: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 821B4BF8: 40980084  bge cr6, 0x821b4c7c
	if !ctx.cr[6].lt {
	pc = 0x821B4C7C; continue 'dispatch;
	}
	// 821B4BFC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4C00: 386BCF90  addi r3, r11, -0x3070
	ctx.r[3].s64 = ctx.r[11].s64 + -12400;
	// 821B4C04: 4BFFEC75  bl 0x821b3878
	ctx.lr = 0x821B4C08;
	sub_821B3878(ctx, base);
	// 821B4C08: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4C0C: 893E0000  lbz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4C10: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B4C14: 396BCD68  addi r11, r11, -0x3298
	ctx.r[11].s64 = ctx.r[11].s64 + -12952;
	// 821B4C18: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821B4C1C: 396B020C  addi r11, r11, 0x20c
	ctx.r[11].s64 = ctx.r[11].s64 + 524;
	// 821B4C20: 386A1090  addi r3, r10, 0x1090
	ctx.r[3].s64 = ctx.r[10].s64 + 4240;
	// 821B4C24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B4C28: 7FC959AE  stbx r30, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u8) };
	// 821B4C2C: 4BFE5EAD  bl 0x8219aad8
	ctx.lr = 0x821B4C30;
	sub_8219AAD8(ctx, base);
	// 821B4C30: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B4C34: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B4C38: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B4C3C: 616BEB33  ori r11, r11, 0xeb33
	ctx.r[11].u64 = ctx.r[11].u64 | 60211;
	// 821B4C40: 614AEB34  ori r10, r10, 0xeb34
	ctx.r[10].u64 = ctx.r[10].u64 | 60212;
	// 821B4C44: 6129EB32  ori r9, r9, 0xeb32
	ctx.r[9].u64 = ctx.r[9].u64 | 60210;
	// 821B4C48: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821B4C4C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4C50: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 821B4C54: 7FDF59AE  stbx r30, r31, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u8) };
	// 821B4C58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4C5C: 7FDF51AE  stbx r30, r31, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u8) };
	// 821B4C60: 7FDF49AE  stbx r30, r31, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u8) };
	// 821B4C64: 4BF719B5  bl 0x82126618
	ctx.lr = 0x821B4C68;
	sub_82126618(ctx, base);
	// 821B4C68: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821B4C6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4C70: 3880003B  li r4, 0x3b
	ctx.r[4].s64 = 59;
	// 821B4C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4C78: 4BF719A1  bl 0x82126618
	ctx.lr = 0x821B4C7C;
	sub_82126618(ctx, base);
	// 821B4C7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B4C80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B4C84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B4C88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B4C8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B4C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4C98 size=224
    let mut pc: u32 = 0x821B4C98;
    'dispatch: loop {
        match pc {
            0x821B4C98 => {
    //   block [0x821B4C98..0x821B4D78)
	// 821B4C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4C9C: 48380421  bl 0x825350bc
	ctx.lr = 0x821B4CA0;
	sub_82535080(ctx, base);
	// 821B4CA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4CA4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4CA8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B4CAC: 3BEBCF90  addi r31, r11, -0x3070
	ctx.r[31].s64 = ctx.r[11].s64 + -12400;
	// 821B4CB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B4CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4CB8: 4BFFECD1  bl 0x821b3988
	ctx.lr = 0x821B4CBC;
	sub_821B3988(ctx, base);
	// 821B4CBC: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821B4CC0: 4BFFFF11  bl 0x821b4bd0
	ctx.lr = 0x821B4CC4;
	sub_821B4BD0(ctx, base);
	// 821B4CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4CC8: 4BFFFF09  bl 0x821b4bd0
	ctx.lr = 0x821B4CCC;
	sub_821B4BD0(ctx, base);
	// 821B4CCC: 895F0C30  lbz r10, 0xc30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B4CD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B4CD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4CD8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B4CDC: 419A0020  beq cr6, 0x821b4cfc
	if ctx.cr[6].eq {
	pc = 0x821B4CFC; continue 'dispatch;
	}
	// 821B4CE0: 395F0831  addi r10, r31, 0x831
	ctx.r[10].s64 = ctx.r[31].s64 + 2097;
	// 821B4CE4: 9BCA0000  stb r30, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 821B4CE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B4CEC: 893F0C30  lbz r9, 0xc30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B4CF0: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 821B4CF4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B4CF8: 4198FFEC  blt cr6, 0x821b4ce4
	if ctx.cr[6].lt {
	pc = 0x821B4CE4; continue 'dispatch;
	}
	// 821B4CFC: 48137865  bl 0x822ec560
	ctx.lr = 0x821B4D00;
	sub_822EC560(ctx, base);
	// 821B4D00: 48138431  bl 0x822ed130
	ctx.lr = 0x821B4D04;
	sub_822ED130(ctx, base);
	// 821B4D04: 481396DD  bl 0x822ee3e0
	ctx.lr = 0x821B4D08;
	sub_822EE3E0(ctx, base);
	// 821B4D08: 48138429  bl 0x822ed130
	ctx.lr = 0x821B4D0C;
	sub_822ED130(ctx, base);
	// 821B4D0C: 4813976D  bl 0x822ee478
	ctx.lr = 0x821B4D10;
	sub_822EE478(ctx, base);
	// 821B4D10: 3BBF0830  addi r29, r31, 0x830
	ctx.r[29].s64 = ctx.r[31].s64 + 2096;
	// 821B4D14: 897F0C30  lbz r11, 0xc30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B4D18: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 821B4D1C: 40990008  ble cr6, 0x821b4d24
	if !ctx.cr[6].gt {
	pc = 0x821B4D24; continue 'dispatch;
	}
	// 821B4D20: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 821B4D24: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B4D28: 4098003C  bge cr6, 0x821b4d64
	if !ctx.cr[6].lt {
	pc = 0x821B4D64; continue 'dispatch;
	}
	// 821B4D2C: 2F1E0010  cmpwi cr6, r30, 0x10
	ctx.cr[6].compare_i32(ctx.r[30].s32, 16, &mut ctx.xer);
	// 821B4D30: 397F0830  addi r11, r31, 0x830
	ctx.r[11].s64 = ctx.r[31].s64 + 2096;
	// 821B4D34: 40980008  bge cr6, 0x821b4d3c
	if !ctx.cr[6].lt {
	pc = 0x821B4D3C; continue 'dispatch;
	}
	// 821B4D38: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B4D3C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B4D40: A06B0002  lhz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B4D44: 38EB0030  addi r7, r11, 0x30
	ctx.r[7].s64 = ctx.r[11].s64 + 48;
	// 821B4D48: 38CB0020  addi r6, r11, 0x20
	ctx.r[6].s64 = ctx.r[11].s64 + 32;
	// 821B4D4C: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 821B4D50: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 821B4D54: 481376D5  bl 0x822ec428
	ctx.lr = 0x821B4D58;
	sub_822EC428(ctx, base);
	// 821B4D58: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821B4D5C: 3BBD0040  addi r29, r29, 0x40
	ctx.r[29].s64 = ctx.r[29].s64 + 64;
	// 821B4D60: 4BFFFFB4  b 0x821b4d14
	pc = 0x821B4D14; continue 'dispatch;
	// 821B4D64: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B4D68: C02BD5B0  lfs f1, -0x2a50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4D6C: 48137A2D  bl 0x822ec798
	ctx.lr = 0x821B4D70;
	sub_822EC798(ctx, base);
	// 821B4D70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B4D74: 48380398  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4D78 size=252
    let mut pc: u32 = 0x821B4D78;
    'dispatch: loop {
        match pc {
            0x821B4D78 => {
    //   block [0x821B4D78..0x821B4E74)
	// 821B4D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4D7C: 48380321  bl 0x8253509c
	ctx.lr = 0x821B4D80;
	sub_82535080(ctx, base);
	// 821B4D80: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4D84: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4D88: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821B4D8C: 3BCBCD68  addi r30, r11, -0x3298
	ctx.r[30].s64 = ctx.r[11].s64 + -12952;
	// 821B4D90: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B4D94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4D98: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 821B4D9C: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4DA0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821B4DA4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821B4DA8: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 821B4DAC: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 821B4DB0: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 821B4DB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B4DB8: 48003361  bl 0x821b8118
	ctx.lr = 0x821B4DBC;
	sub_821B8118(ctx, base);
	// 821B4DBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4DC0: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4DC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4DC8: 48003351  bl 0x821b8118
	ctx.lr = 0x821B4DCC;
	sub_821B8118(ctx, base);
	// 821B4DCC: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 821B4DD0: 7F1FA800  cmpw cr6, r31, r21
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[21].s32, &mut ctx.xer);
	// 821B4DD4: 41990058  bgt cr6, 0x821b4e2c
	if ctx.cr[6].gt {
	pc = 0x821B4E2C; continue 'dispatch;
	}
	// 821B4DD8: 7F1FA800  cmpw cr6, r31, r21
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[21].s32, &mut ctx.xer);
	// 821B4DDC: 4199008C  bgt cr6, 0x821b4e68
	if ctx.cr[6].gt {
	pc = 0x821B4E68; continue 'dispatch;
	}
	// 821B4DE0: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821B4DE4: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 821B4DE8: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821B4DEC: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 821B4DF0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821B4DF4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B4DF8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B4DFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821B4E00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B4E04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4E08: 48003B31  bl 0x821b8938
	ctx.lr = 0x821B4E0C;
	sub_821B8938(ctx, base);
	// 821B4E0C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821B4E10: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B4E14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B4E18: 419AFFC0  beq cr6, 0x821b4dd8
	if ctx.cr[6].eq {
	pc = 0x821B4DD8; continue 'dispatch;
	}
	// 821B4E1C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B4E20: 483802CC  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
	// 821B4E24: 7F1FA800  cmpw cr6, r31, r21
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[21].s32, &mut ctx.xer);
	// 821B4E28: 41980040  blt cr6, 0x821b4e68
	if ctx.cr[6].lt {
	pc = 0x821B4E68; continue 'dispatch;
	}
	// 821B4E2C: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821B4E30: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 821B4E34: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821B4E38: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 821B4E3C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821B4E40: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B4E44: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B4E48: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821B4E4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B4E50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4E54: 48003AE5  bl 0x821b8938
	ctx.lr = 0x821B4E58;
	sub_821B8938(ctx, base);
	// 821B4E58: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821B4E5C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 821B4E60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B4E64: 419AFFC0  beq cr6, 0x821b4e24
	if ctx.cr[6].eq {
	pc = 0x821B4E24; continue 'dispatch;
	}
	// 821B4E68: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821B4E6C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B4E70: 4838027C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4E78 size=332
    let mut pc: u32 = 0x821B4E78;
    'dispatch: loop {
        match pc {
            0x821B4E78 => {
    //   block [0x821B4E78..0x821B4FC4)
	// 821B4E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4E7C: 4838020D  bl 0x82535088
	ctx.lr = 0x821B4E80;
	sub_82535080(ctx, base);
	// 821B4E80: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4E84: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4E88: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B4E8C: 3ACBCF90  addi r22, r11, -0x3070
	ctx.r[22].s64 = ctx.r[11].s64 + -12400;
	// 821B4E90: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4E94: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821B4E98: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B4E9C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821B4EA0: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 821B4EA4: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 821B4EA8: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 821B4EAC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821B4EB0: 3B760800  addi r27, r22, 0x800
	ctx.r[27].s64 = ctx.r[22].s64 + 2048;
	// 821B4EB4: 3A8BCD68  addi r20, r11, -0x3298
	ctx.r[20].s64 = ctx.r[11].s64 + -12952;
	// 821B4EB8: 39740209  addi r11, r20, 0x209
	ctx.r[11].s64 = ctx.r[20].s64 + 521;
	// 821B4EBC: 7D7C58AE  lbzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B4EC0: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821B4EC4: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821B4EC8: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821B4ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4ED0: 419A0084  beq cr6, 0x821b4f54
	if ctx.cr[6].eq {
	pc = 0x821B4F54; continue 'dispatch;
	}
	// 821B4ED4: EA7E0000  ld r19, 0(r30)
	ctx.r[19].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821B4ED8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B4EDC: EA3E0008  ld r17, 8(r30)
	ctx.r[17].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821B4EE0: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 821B4EE4: EA5D0000  ld r18, 0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4FC8 size=140
    let mut pc: u32 = 0x821B4FC8;
    'dispatch: loop {
        match pc {
            0x821B4FC8 => {
    //   block [0x821B4FC8..0x821B5054)
	// 821B4FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4FCC: 483800E9  bl 0x825350b4
	ctx.lr = 0x821B4FD0;
	sub_82535080(ctx, base);
	// 821B4FD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4FD4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821B4FD8: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 821B4FDC: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 821B4FE0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 821B4FE4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B4FE8: EB8B0000  ld r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B4FEC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B4FF0: EB6A0000  ld r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B4FF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B4FF8: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B4FFC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821B5000: FB9F0000  std r28, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821B5004: FB7E0000  std r27, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 821B5008: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B500C: F95E0008  std r10, 8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B5010: 4BFFFE69  bl 0x821b4e78
	ctx.lr = 0x821B5014;
	sub_821B4E78(ctx, base);
	// 821B5014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B5018: 419A0034  beq cr6, 0x821b504c
	if ctx.cr[6].eq {
	pc = 0x821B504C; continue 'dispatch;
	}
	// 821B501C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5020: 556AA73E  rlwinm r10, r11, 0x14, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 821B5024: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B5028: 419A0024  beq cr6, 0x821b504c
	if ctx.cr[6].eq {
	pc = 0x821B504C; continue 'dispatch;
	}
	// 821B502C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5058 size=500
    let mut pc: u32 = 0x821B5058;
    'dispatch: loop {
        match pc {
            0x821B5058 => {
    //   block [0x821B5058..0x821B524C)
	// 821B5058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B505C: 48380055  bl 0x825350b0
	ctx.lr = 0x821B5060;
	sub_82535080(ctx, base);
	// 821B5060: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5064: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B5068: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B506C: 3F5D0002  addis r26, r29, 2
	ctx.r[26].s64 = ctx.r[29].s64 + 131072;
	// 821B5070: 396BA92C  addi r11, r11, -0x56d4
	ctx.r[11].s64 = ctx.r[11].s64 + -22228;
	// 821B5074: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821B5078: 3B5AEB32  addi r26, r26, -0x14ce
	ctx.r[26].s64 = ctx.r[26].s64 + -5326;
	// 821B507C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B5080: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B5084: 614ABE64  ori r10, r10, 0xbe64
	ctx.r[10].u64 = ctx.r[10].u64 | 48740;
	// 821B5088: 7F86582E  lwzx r28, r6, r11
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B508C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B5090: 897A0000  lbz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5098: 7F7D50AE  lbzx r27, r29, r10
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B509C: 409A000C  bne cr6, 0x821b50a8
	if !ctx.cr[6].eq {
	pc = 0x821B50A8; continue 'dispatch;
	}
	// 821B50A0: 3960003B  li r11, 0x3b
	ctx.r[11].s64 = 59;
	// 821B50A4: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B50A8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821B50AC: 419800E0  blt cr6, 0x821b518c
	if ctx.cr[6].lt {
	pc = 0x821B518C; continue 'dispatch;
	}
	// 821B50B0: 419A0018  beq cr6, 0x821b50c8
	if ctx.cr[6].eq {
	pc = 0x821B50C8; continue 'dispatch;
	}
	// 821B50B4: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 821B50B8: 419800D4  blt cr6, 0x821b518c
	if ctx.cr[6].lt {
	pc = 0x821B518C; continue 'dispatch;
	}
	// 821B50BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B50C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B50C4: 4838003C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 821B50C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B50CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B50D0: 3B8BCF90  addi r28, r11, -0x3070
	ctx.r[28].s64 = ctx.r[11].s64 + -12400;
	// 821B50D4: 576B083C  slwi r11, r27, 1
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B50D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B50DC: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 821B50E0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821B50E4: 557B103A  slwi r27, r11, 2
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 821B50E8: 7C9BE22E  lhzx r4, r27, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821B50EC: 480028DD  bl 0x821b79c8
	ctx.lr = 0x821B50F0;
	sub_821B79C8(ctx, base);
	// 821B50F0: 397C0002  addi r11, r28, 2
	ctx.r[11].s64 = ctx.r[28].s64 + 2;
	// 821B50F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B50F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B50FC: 7C9B5A2E  lhzx r4, r27, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5100: 480028C9  bl 0x821b79c8
	ctx.lr = 0x821B5104;
	sub_821B79C8(ctx, base);
	// 821B5104: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5108: C1BC0818  lfs f13, 0x818(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2072 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B510C: C17C0808  lfs f11, 0x808(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2056 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B5110: C11E0008  lfs f8, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B5114: C15F0008  lfs f10, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B5118: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B511C: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B5120: ED2D0332  fmuls f9, f13, f12
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B5124: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5128: ED8B4B3A  fmadds f12, f11, f12, f9
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B512C: ED2D0372  fmuls f9, f13, f13
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B5130: ED686028  fsubs f11, f8, f12
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B5134: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B5138: ED6B4AFA  fmadds f11, f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B513C: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B5140: ED60582C  fsqrts f11, f11
	ctx.f[11].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 821B5144: ED80603A  fmadds f12, f0, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821B5148: ED80602C  fsqrts f12, f12
	ctx.f[12].f64 = ((ctx.f[12].f64).sqrt() as f32) as f64;
	// 821B514C: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 821B5150: 409900D0  ble cr6, 0x821b5220
	if !ctx.cr[6].gt {
	pc = 0x821B5220; continue 'dispatch;
	}
	// 821B5154: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B5158: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B515C: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B5160: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B5164: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B5168: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B516C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5170: D17F0008  stfs f11, 8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B5174: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B5178: D1BE000C  stfs f13, 0xc(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B517C: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B5180: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B5184: D15E0008  stfs f10, 8(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B5188: 48000098  b 0x821b5220
	pc = 0x821B5220; continue 'dispatch;
	// 821B518C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B5190: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B5194: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B5198: 48002831  bl 0x821b79c8
	ctx.lr = 0x821B519C;
	sub_821B79C8(ctx, base);
	// 821B519C: 1D7B0031  mulli r11, r27, 0x31
	ctx.r[11].s64 = ctx.r[27].s64 * 49;
	// 821B51A0: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821B51A4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821B51A8: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821B51AC: 394ACF90  addi r10, r10, -0x3070
	ctx.r[10].s64 = ctx.r[10].s64 + -12400;
	// 821B51B0: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B51B4: 392A0020  addi r9, r10, 0x20
	ctx.r[9].s64 = ctx.r[10].s64 + 32;
	// 821B51B8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821B51BC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B51C0: F93F0000  std r9, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B51C4: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B51C8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B51CC: 409A0054  bne cr6, 0x821b5220
	if !ctx.cr[6].eq {
	pc = 0x821B5220; continue 'dispatch;
	}
	// 821B51D0: 897A0000  lbz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B51D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B51D8: 409A0048  bne cr6, 0x821b5220
	if !ctx.cr[6].eq {
	pc = 0x821B5220; continue 'dispatch;
	}
	// 821B51DC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B51E0: 616BEB33  ori r11, r11, 0xeb33
	ctx.r[11].u64 = ctx.r[11].u64 | 60211;
	// 821B51E4: 7D7D58AE  lbzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B51E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B51EC: 409A0034  bne cr6, 0x821b5220
	if !ctx.cr[6].eq {
	pc = 0x821B5220; continue 'dispatch;
	}
	// 821B51F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B51F4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B51F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B51FC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B5200: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B5204: C1AA0808  lfs f13, 0x808(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2056 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5208: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B520C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B5210: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B5214: C18A0818  lfs f12, 0x818(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2072 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B5218: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B521C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B5220: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5224: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5228: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B522C: C00B2238  lfs f0, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5230: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B5234: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B5238: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B523C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B5240: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B5244: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B5248: 4837FEB8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5250 size=452
    let mut pc: u32 = 0x821B5250;
    'dispatch: loop {
        match pc {
            0x821B5250 => {
    //   block [0x821B5250..0x821B5414)
	// 821B5250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5254: 4837FE69  bl 0x825350bc
	ctx.lr = 0x821B5258;
	sub_82535080(ctx, base);
	// 821B5258: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B525C: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 821B5260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B5264: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 821B5268: 2F1E003A  cmpwi cr6, r30, 0x3a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 58, &mut ctx.xer);
	// 821B526C: 419A00EC  beq cr6, 0x821b5358
	if ctx.cr[6].eq {
	pc = 0x821B5358; continue 'dispatch;
	}
	// 821B5270: 2F1E003B  cmpwi cr6, r30, 0x3b
	ctx.cr[6].compare_i32(ctx.r[30].s32, 59, &mut ctx.xer);
	// 821B5274: 419A0074  beq cr6, 0x821b52e8
	if ctx.cr[6].eq {
	pc = 0x821B52E8; continue 'dispatch;
	}
	// 821B5278: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 821B527C: 409A0164  bne cr6, 0x821b53e0
	if !ctx.cr[6].eq {
	pc = 0x821B53E0; continue 'dispatch;
	}
	// 821B5280: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 821B5284: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821B5288: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B528C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821B5290: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5418 size=104
    let mut pc: u32 = 0x821B5418;
    'dispatch: loop {
        match pc {
            0x821B5418 => {
    //   block [0x821B5418..0x821B5480)
	// 821B5418: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B541C: 390BCD68  addi r8, r11, -0x3298
	ctx.r[8].s64 = ctx.r[11].s64 + -12952;
	// 821B5420: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5428: 419A004C  beq cr6, 0x821b5474
	if ctx.cr[6].eq {
	pc = 0x821B5474; continue 'dispatch;
	}
	// 821B542C: A16B002C  lhz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B5430: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B5434: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B5438: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B543C: 40990038  ble cr6, 0x821b5474
	if !ctx.cr[6].gt {
	pc = 0x821B5474; continue 'dispatch;
	}
	// 821B5440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B5444: 81280204  lwz r9, 0x204(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(516 as u32) ) } as u64;
	// 821B5448: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B544C: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821B5450: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821B5454: 80E9001C  lwz r7, 0x1c(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5458: 54E70626  rlwinm r7, r7, 0, 0x18, 0x13
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821B545C: 90E9001C  stw r7, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 821B5460: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5464: A129002C  lhz r9, 0x2c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B5468: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 821B546C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B5470: 4198FFD4  blt cr6, 0x821b5444
	if ctx.cr[6].lt {
	pc = 0x821B5444; continue 'dispatch;
	}
	// 821B5474: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B5478: 386BCF90  addi r3, r11, -0x3070
	ctx.r[3].s64 = ctx.r[11].s64 + -12400;
	// 821B547C: 4BFFEB94  b 0x821b4010
	sub_821B4010(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5480 size=212
    let mut pc: u32 = 0x821B5480;
    'dispatch: loop {
        match pc {
            0x821B5480 => {
    //   block [0x821B5480..0x821B5554)
	// 821B5480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5488: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B548C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B5490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5494: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B5498: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821B549C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B54A0: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821B54A4: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B54A8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821B54AC: 419A0080  beq cr6, 0x821b552c
	if ctx.cr[6].eq {
	pc = 0x821B552C; continue 'dispatch;
	}
	// 821B54B0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B54B4: 3BCBCF90  addi r30, r11, -0x3070
	ctx.r[30].s64 = ctx.r[11].s64 + -12400;
	// 821B54B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B54BC: 893E0C30  lbz r9, 0xc30(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B54C0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B54C4: 40990028  ble cr6, 0x821b54ec
	if !ctx.cr[6].gt {
	pc = 0x821B54EC; continue 'dispatch;
	}
	// 821B54C8: 5468043E  clrlwi r8, r3, 0x10
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 821B54CC: 395E0832  addi r10, r30, 0x832
	ctx.r[10].s64 = ctx.r[30].s64 + 2098;
	// 821B54D0: A0EA0000  lhz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B54D4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B54D8: 419A006C  beq cr6, 0x821b5544
	if ctx.cr[6].eq {
	pc = 0x821B5544; continue 'dispatch;
	}
	// 821B54DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B54E0: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 821B54E4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B54E8: 4198FFE8  blt cr6, 0x821b54d0
	if ctx.cr[6].lt {
	pc = 0x821B54D0; continue 'dispatch;
	}
	// 821B54EC: 3BFE0830  addi r31, r30, 0x830
	ctx.r[31].s64 = ctx.r[30].s64 + 2096;
	// 821B54F0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B54F4: A09F0002  lhz r4, 2(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B54F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B54FC: 386BCD68  addi r3, r11, -0x3298
	ctx.r[3].s64 = ctx.r[11].s64 + -12952;
	// 821B5500: 48003CD1  bl 0x821b91d0
	ctx.lr = 0x821B5504;
	sub_821B91D0(ctx, base);
	// 821B5504: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B5508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B550C: 419A0020  beq cr6, 0x821b552c
	if ctx.cr[6].eq {
	pc = 0x821B552C; continue 'dispatch;
	}
	// 821B5510: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B5514: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5518: 393E07C8  addi r9, r30, 0x7c8
	ctx.r[9].s64 = ctx.r[30].s64 + 1992;
	// 821B551C: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 821B5520: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821B5524: 816B0688  lwz r11, 0x688(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B5528: 7D6A492E  stwx r11, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	// 821B552C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B5530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B5534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5538: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B553C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B5540: 4E800020  blr
	return;
	// 821B5544: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B5548: 395E0830  addi r10, r30, 0x830
	ctx.r[10].s64 = ctx.r[30].s64 + 2096;
	// 821B554C: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B5550: 4BFFFFA0  b 0x821b54f0
	pc = 0x821B54F0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5558 size=1440
    let mut pc: u32 = 0x821B5558;
    'dispatch: loop {
        match pc {
            0x821B5558 => {
    //   block [0x821B5558..0x821B55B0)
	// 821B5558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B555C: 4837FB51  bl 0x825350ac
	ctx.lr = 0x821B5560;
	sub_82535080(ctx, base);
	// 821B5560: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5564: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B5568: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B556C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B5570: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5574: 556AE73E  rlwinm r10, r11, 0x1c, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5578: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 821B557C: 419903E4  bgt cr6, 0x821b5960
	if ctx.cr[6].gt {
	pc = 0x821B5960; continue 'dispatch;
	}
	// 821B5580: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821B5584: 398C5598  addi r12, r12, 0x5598
	ctx.r[12].s64 = ctx.r[12].s64 + 21912;
	// 821B5588: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B558C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B5590: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B5594: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x821B55B0; continue 'dispatch;
		},
		1 => {
	pc = 0x821B5644; continue 'dispatch;
		},
		2 => {
	pc = 0x821B57B8; continue 'dispatch;
		},
		3 => {
	pc = 0x821B5AF0; continue 'dispatch;
		},
		4 => {
	pc = 0x821B5960; continue 'dispatch;
		},
		5 => {
	pc = 0x821B5644; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B5598: 821B55B0  lwz r16, 0x55b0(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(21936 as u32) ) } as u64;
	// 821B559C: 821B5644  lwz r16, 0x5644(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(22084 as u32) ) } as u64;
	// 821B55A0: 821B57B8  lwz r16, 0x57b8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(22456 as u32) ) } as u64;
	// 821B55A4: 821B5AF0  lwz r16, 0x5af0(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(23280 as u32) ) } as u64;
	// 821B55A8: 821B5960  lwz r16, 0x5960(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(22880 as u32) ) } as u64;
	// 821B55AC: 821B5644  lwz r16, 0x5644(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(22084 as u32) ) } as u64;
            }
            0x821B55B0 => {
    //   block [0x821B55B0..0x821B5644)
	// 821B55B0: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B55B4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B55B8: 419A0538  beq cr6, 0x821b5af0
	if ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B55BC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B55C0: 419A0530  beq cr6, 0x821b5af0
	if ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B55C4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B55C8: 557FE63E  rlwinm r31, r11, 0x1c, 0x18, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B55CC: 2F1F003C  cmpwi cr6, r31, 0x3c
	ctx.cr[6].compare_i32(ctx.r[31].s32, 60, &mut ctx.xer);
	// 821B55D0: 419A0520  beq cr6, 0x821b5af0
	if ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B55D4: 2F1F003A  cmpwi cr6, r31, 0x3a
	ctx.cr[6].compare_i32(ctx.r[31].s32, 58, &mut ctx.xer);
	// 821B55D8: 419A0518  beq cr6, 0x821b5af0
	if ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B55DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B55E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B55E4: 481AC83D  bl 0x82361e20
	ctx.lr = 0x821B55E8;
	sub_82361E20(ctx, base);
	// 821B55E8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B55EC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821B55F0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B55F4: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821B55F8: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B55FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B5600: 409A04F0  bne cr6, 0x821b5af0
	if !ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B5604: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 821B5608: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821B560C: 38C00050  li r6, 0x50
	ctx.r[6].s64 = 80;
	// 821B5610: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 821B5614: 386B45D8  addi r3, r11, 0x45d8
	ctx.r[3].s64 = ctx.r[11].s64 + 17880;
	// 821B5618: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B561C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B5620: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 821B5624: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B5628: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B562C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 821B5630: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 821B5634: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B5638: 4BFC73E1  bl 0x8217ca18
	ctx.lr = 0x821B563C;
	sub_8217CA18(ctx, base);
	// 821B563C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821B5640: 4837FABC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x821B5644 => {
    //   block [0x821B5644..0x821B57B8)
	// 821B5644: 556B052E  rlwinm r11, r11, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B5648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B564C: 409A04A4  bne cr6, 0x821b5af0
	if !ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B5650: 3FB90002  addis r29, r25, 2
	ctx.r[29].s64 = ctx.r[25].s64 + 131072;
	// 821B5654: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5658: 3B9F0030  addi r28, r31, 0x30
	ctx.r[28].s64 = ctx.r[31].s64 + 48;
	// 821B565C: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5660: 3BBD9C30  addi r29, r29, -0x63d0
	ctx.r[29].s64 = ctx.r[29].s64 + -25552;
	// 821B5664: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5668: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B566C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B5670: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821B5674: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B5678: 48136DB1  bl 0x822ec428
	ctx.lr = 0x821B567C;
	sub_822EC428(ctx, base);
	// 821B567C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5680: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5684: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5688: 419A006C  beq cr6, 0x821b56f4
	if ctx.cr[6].eq {
	pc = 0x821B56F4; continue 'dispatch;
	}
	// 821B568C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5690: 419A0014  beq cr6, 0x821b56a4
	if ctx.cr[6].eq {
	pc = 0x821B56A4; continue 'dispatch;
	}
	// 821B5694: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5698: 557BE63E  rlwinm r27, r11, 0x1c, 0x18, 0x1f
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B569C: 2F1B003C  cmpwi cr6, r27, 0x3c
	ctx.cr[6].compare_i32(ctx.r[27].s32, 60, &mut ctx.xer);
	// 821B56A0: 409A0008  bne cr6, 0x821b56a8
	if !ctx.cr[6].eq {
	pc = 0x821B56A8; continue 'dispatch;
	}
	// 821B56A4: 3B600013  li r27, 0x13
	ctx.r[27].s64 = 19;
	// 821B56A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B56AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B56B0: 481AC771  bl 0x82361e20
	ctx.lr = 0x821B56B4;
	sub_82361E20(ctx, base);
	// 821B56B4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B56B8: 3B4BBFF0  addi r26, r11, -0x4010
	ctx.r[26].s64 = ctx.r[11].s64 + -16400;
	// 821B56BC: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B56C0: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 821B56C4: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B56C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B56CC: 409A005C  bne cr6, 0x821b5728
	if !ctx.cr[6].eq {
	pc = 0x821B5728; continue 'dispatch;
	}
	// 821B56D0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B56D4: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B56D8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B56DC: 419A0028  beq cr6, 0x821b5704
	if ctx.cr[6].eq {
	pc = 0x821B5704; continue 'dispatch;
	}
	// 821B56E0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B56E4: 419A0018  beq cr6, 0x821b56fc
	if ctx.cr[6].eq {
	pc = 0x821B56FC; continue 'dispatch;
	}
	// 821B56E8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B56EC: 5566E63E  rlwinm r6, r11, 0x1c, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B56F0: 48000018  b 0x821b5708
	pc = 0x821B5708; continue 'dispatch;
	// 821B56F4: 3B60003A  li r27, 0x3a
	ctx.r[27].s64 = 58;
	// 821B56F8: 4BFFFFB0  b 0x821b56a8
	pc = 0x821B56A8; continue 'dispatch;
	// 821B56FC: 38C0003C  li r6, 0x3c
	ctx.r[6].s64 = 60;
	// 821B5700: 48000008  b 0x821b5708
	pc = 0x821B5708; continue 'dispatch;
	// 821B5704: 38C0003A  li r6, 0x3a
	ctx.r[6].s64 = 58;
	// 821B5708: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821B570C: A0BF002E  lhz r5, 0x2e(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5710: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 821B5714: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821B5718: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B571C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B5720: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5724: 48001AE5  bl 0x821b7208
	ctx.lr = 0x821B5728;
	sub_821B7208(ctx, base);
	// 821B5728: A17F002E  lhz r11, 0x2e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B572C: 3CE00003  lis r7, 3
	ctx.r[7].s64 = 196608;
	// 821B5730: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821B5734: E8BC0008  ld r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 821B5738: 60E79460  ori r7, r7, 0x9460
	ctx.r[7].u64 = ctx.r[7].u64 | 37984;
	// 821B573C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821B5740: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821B5744: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 821B5748: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B574C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B5750: 6166BE64  ori r6, r11, 0xbe64
	ctx.r[6].u64 = ctx.r[11].u64 | 48740;
	// 821B5754: 7CFA382E  lwzx r7, r26, r7
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821B5758: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B575C: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B5760: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 821B5764: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B5768: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B576C: E8FE0008  ld r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821B5770: 386BCF90  addi r3, r11, -0x3070
	ctx.r[3].s64 = ctx.r[11].s64 + -12400;
	// 821B5774: 7D7930AE  lbzx r11, r25, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821B5778: E8DC0000  ld r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 821B577C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 821B5780: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821B5784: EBDD0000  ld r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821B5788: EBBD0008  ld r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821B578C: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B5790: F8EA0008  std r7, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821B5794: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821B5798: F8A90008  std r5, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821B579C: FBC80000  std r30, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821B57A0: FBA80008  std r29, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 821B57A4: 4BFFE7ED  bl 0x821b3f90
	ctx.lr = 0x821B57A8;
	sub_821B3F90(ctx, base);
	// 821B57A8: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B57AC: 4BFFFCD5  bl 0x821b5480
	ctx.lr = 0x821B57B0;
	sub_821B5480(ctx, base);
	// 821B57B0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821B57B4: 4837F948  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x821B57B8 => {
    //   block [0x821B57B8..0x821B5960)
	// 821B57B8: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B57BC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B57C0: 419A0020  beq cr6, 0x821b57e0
	if ctx.cr[6].eq {
	pc = 0x821B57E0; continue 'dispatch;
	}
	// 821B57C4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B57C8: 419A0010  beq cr6, 0x821b57d8
	if ctx.cr[6].eq {
	pc = 0x821B57D8; continue 'dispatch;
	}
	// 821B57CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B57D0: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B57D4: 48000010  b 0x821b57e4
	pc = 0x821B57E4; continue 'dispatch;
	// 821B57D8: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 821B57DC: 48000008  b 0x821b57e4
	pc = 0x821B57E4; continue 'dispatch;
	// 821B57E0: 3880003A  li r4, 0x3a
	ctx.r[4].s64 = 58;
	// 821B57E4: 3F990002  addis r28, r25, 2
	ctx.r[28].s64 = ctx.r[25].s64 + 131072;
	// 821B57E8: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B57EC: 3BBF0030  addi r29, r31, 0x30
	ctx.r[29].s64 = ctx.r[31].s64 + 48;
	// 821B57F0: 3B9C9C30  addi r28, r28, -0x63d0
	ctx.r[28].s64 = ctx.r[28].s64 + -25552;
	// 821B57F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B57F8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B57FC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821B5800: 48136CB9  bl 0x822ec4b8
	ctx.lr = 0x821B5804;
	sub_822EC4B8(ctx, base);
	// 821B5804: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5808: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B580C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5810: 419A0020  beq cr6, 0x821b5830
	if ctx.cr[6].eq {
	pc = 0x821B5830; continue 'dispatch;
	}
	// 821B5814: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5818: 419A0010  beq cr6, 0x821b5828
	if ctx.cr[6].eq {
	pc = 0x821B5828; continue 'dispatch;
	}
	// 821B581C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5820: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5824: 48000010  b 0x821b5834
	pc = 0x821B5834; continue 'dispatch;
	// 821B5828: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 821B582C: 48000008  b 0x821b5834
	pc = 0x821B5834; continue 'dispatch;
	// 821B5830: 3880003A  li r4, 0x3a
	ctx.r[4].s64 = 58;
	// 821B5834: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B5838: 481AC5E9  bl 0x82361e20
	ctx.lr = 0x821B583C;
	sub_82361E20(ctx, base);
	// 821B583C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B5840: 3B6BBFF0  addi r27, r11, -0x4010
	ctx.r[27].s64 = ctx.r[11].s64 + -16400;
	// 821B5844: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B5848: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 821B584C: 7D7B5A2E  lhzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5850: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B5854: 409A0078  bne cr6, 0x821b58cc
	if !ctx.cr[6].eq {
	pc = 0x821B58CC; continue 'dispatch;
	}
	// 821B5858: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B585C: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5860: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5864: 419A0020  beq cr6, 0x821b5884
	if ctx.cr[6].eq {
	pc = 0x821B5884; continue 'dispatch;
	}
	// 821B5868: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B586C: 419A0010  beq cr6, 0x821b587c
	if ctx.cr[6].eq {
	pc = 0x821B587C; continue 'dispatch;
	}
	// 821B5870: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5874: 554AE63E  rlwinm r10, r10, 0x1c, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821B5878: 48000010  b 0x821b5888
	pc = 0x821B5888; continue 'dispatch;
	// 821B587C: 3940003C  li r10, 0x3c
	ctx.r[10].s64 = 60;
	// 821B5880: 48000008  b 0x821b5888
	pc = 0x821B5888; continue 'dispatch;
	// 821B5884: 3940003A  li r10, 0x3a
	ctx.r[10].s64 = 58;
	// 821B5888: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B588C: 419A0020  beq cr6, 0x821b58ac
	if ctx.cr[6].eq {
	pc = 0x821B58AC; continue 'dispatch;
	}
	// 821B5890: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5894: 419A0010  beq cr6, 0x821b58a4
	if ctx.cr[6].eq {
	pc = 0x821B58A4; continue 'dispatch;
	}
	// 821B5898: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B589C: 5566E63E  rlwinm r6, r11, 0x1c, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B58A0: 48000010  b 0x821b58b0
	pc = 0x821B58B0; continue 'dispatch;
	// 821B58A4: 38C0003C  li r6, 0x3c
	ctx.r[6].s64 = 60;
	// 821B58A8: 48000008  b 0x821b58b0
	pc = 0x821B58B0; continue 'dispatch;
	// 821B58AC: 38C0003A  li r6, 0x3a
	ctx.r[6].s64 = 58;
	// 821B58B0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821B58B4: A0BF002E  lhz r5, 0x2e(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B58B8: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 821B58BC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B58C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B58C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B58C8: 48001941  bl 0x821b7208
	ctx.lr = 0x821B58CC;
	sub_821B7208(ctx, base);
	// 821B58CC: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 821B58D0: A17F002E  lhz r11, 0x2e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B58D4: E8DD0000  ld r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821B58D8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821B58DC: 6107BE64  ori r7, r8, 0xbe64
	ctx.r[7].u64 = ctx.r[8].u64 | 48740;
	// 821B58E0: E8BD0008  ld r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821B58E4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B58E8: EBBC0008  ld r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 821B58EC: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 821B58F0: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 821B58F4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821B58F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B58FC: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	// 821B5900: 3D000003  lis r8, 3
	ctx.r[8].s64 = 196608;
	// 821B5904: 61089460  ori r8, r8, 0x9460
	ctx.r[8].u64 = ctx.r[8].u64 | 37984;
	// 821B5908: 7D1B402E  lwzx r8, r27, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B590C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821B5910: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B5914: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 821B5918: 3D0082CF  lis r8, -0x7d31
	ctx.r[8].s64 = -2100363264;
	// 821B591C: 3868CF90  addi r3, r8, -0x3070
	ctx.r[3].s64 = ctx.r[8].s64 + -12400;
	// 821B5920: 7D1938AE  lbzx r8, r25, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821B5924: E8FE0008  ld r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821B5928: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 821B592C: E91E0000  ld r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821B5930: EBDC0000  ld r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 821B5934: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821B5938: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821B593C: F8CA0000  std r6, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821B5940: F8AA0008  std r5, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821B5944: FBC90000  std r30, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821B5948: FBA90008  std r29, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 821B594C: 4BFFE645  bl 0x821b3f90
	ctx.lr = 0x821B5950;
	sub_821B3F90(ctx, base);
	// 821B5950: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5954: 4BFFFB2D  bl 0x821b5480
	ctx.lr = 0x821B5958;
	sub_821B5480(ctx, base);
	// 821B5958: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821B595C: 4837F7A0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x821B5960 => {
    //   block [0x821B5960..0x821B5AF0)
	// 821B5960: 556B052E  rlwinm r11, r11, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B5964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5968: 409A0188  bne cr6, 0x821b5af0
	if !ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B596C: 3FB90002  addis r29, r25, 2
	ctx.r[29].s64 = ctx.r[25].s64 + 131072;
	// 821B5970: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5974: 3B9F0030  addi r28, r31, 0x30
	ctx.r[28].s64 = ctx.r[31].s64 + 48;
	// 821B5978: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B597C: 3BBD9C30  addi r29, r29, -0x63d0
	ctx.r[29].s64 = ctx.r[29].s64 + -25552;
	// 821B5980: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5984: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B5988: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821B598C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B5990: 48136B29  bl 0x822ec4b8
	ctx.lr = 0x821B5994;
	sub_822EC4B8(ctx, base);
	// 821B5994: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5998: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B599C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B59A0: 419A0020  beq cr6, 0x821b59c0
	if ctx.cr[6].eq {
	pc = 0x821B59C0; continue 'dispatch;
	}
	// 821B59A4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B59A8: 419A0010  beq cr6, 0x821b59b8
	if ctx.cr[6].eq {
	pc = 0x821B59B8; continue 'dispatch;
	}
	// 821B59AC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B59B0: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B59B4: 48000010  b 0x821b59c4
	pc = 0x821B59C4; continue 'dispatch;
	// 821B59B8: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 821B59BC: 48000008  b 0x821b59c4
	pc = 0x821B59C4; continue 'dispatch;
	// 821B59C0: 3880003A  li r4, 0x3a
	ctx.r[4].s64 = 58;
	// 821B59C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B59C8: 481AC459  bl 0x82361e20
	ctx.lr = 0x821B59CC;
	sub_82361E20(ctx, base);
	// 821B59CC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B59D0: 3B6BBFF0  addi r27, r11, -0x4010
	ctx.r[27].s64 = ctx.r[11].s64 + -16400;
	// 821B59D4: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B59D8: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 821B59DC: 7D7B5A2E  lhzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B59E0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B59E4: 409A0078  bne cr6, 0x821b5a5c
	if !ctx.cr[6].eq {
	pc = 0x821B5A5C; continue 'dispatch;
	}
	// 821B59E8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B59EC: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B59F0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B59F4: 419A0020  beq cr6, 0x821b5a14
	if ctx.cr[6].eq {
	pc = 0x821B5A14; continue 'dispatch;
	}
	// 821B59F8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B59FC: 419A0010  beq cr6, 0x821b5a0c
	if ctx.cr[6].eq {
	pc = 0x821B5A0C; continue 'dispatch;
	}
	// 821B5A00: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5A04: 554AE63E  rlwinm r10, r10, 0x1c, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821B5A08: 48000010  b 0x821b5a18
	pc = 0x821B5A18; continue 'dispatch;
	// 821B5A0C: 3940003C  li r10, 0x3c
	ctx.r[10].s64 = 60;
	// 821B5A10: 48000008  b 0x821b5a18
	pc = 0x821B5A18; continue 'dispatch;
	// 821B5A14: 3940003A  li r10, 0x3a
	ctx.r[10].s64 = 58;
	// 821B5A18: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5A1C: 419A0020  beq cr6, 0x821b5a3c
	if ctx.cr[6].eq {
	pc = 0x821B5A3C; continue 'dispatch;
	}
	// 821B5A20: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5A24: 419A0010  beq cr6, 0x821b5a34
	if ctx.cr[6].eq {
	pc = 0x821B5A34; continue 'dispatch;
	}
	// 821B5A28: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5A2C: 5566E63E  rlwinm r6, r11, 0x1c, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5A30: 48000010  b 0x821b5a40
	pc = 0x821B5A40; continue 'dispatch;
	// 821B5A34: 38C0003C  li r6, 0x3c
	ctx.r[6].s64 = 60;
	// 821B5A38: 48000008  b 0x821b5a40
	pc = 0x821B5A40; continue 'dispatch;
	// 821B5A3C: 38C0003A  li r6, 0x3a
	ctx.r[6].s64 = 58;
	// 821B5A40: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 821B5A44: A0BF002E  lhz r5, 0x2e(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5A48: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821B5A4C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B5A50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B5A54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5A58: 480017B1  bl 0x821b7208
	ctx.lr = 0x821B5A5C;
	sub_821B7208(ctx, base);
	// 821B5A5C: A17F002E  lhz r11, 0x2e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5A60: 3CE00003  lis r7, 3
	ctx.r[7].s64 = 196608;
	// 821B5A64: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821B5A68: E8BC0008  ld r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 821B5A6C: 60E79460  ori r7, r7, 0x9460
	ctx.r[7].u64 = ctx.r[7].u64 | 37984;
	// 821B5A70: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821B5A74: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821B5A78: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 821B5A7C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5A80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B5A84: 6166BE64  ori r6, r11, 0xbe64
	ctx.r[6].u64 = ctx.r[11].u64 | 48740;
	// 821B5A88: 7CFB382E  lwzx r7, r27, r7
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821B5A8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B5A90: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B5A94: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 821B5A98: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B5A9C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B5AA0: E8FE0008  ld r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821B5AA4: 386BCF90  addi r3, r11, -0x3070
	ctx.r[3].s64 = ctx.r[11].s64 + -12400;
	// 821B5AA8: 7D7930AE  lbzx r11, r25, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821B5AAC: E8DC0000  ld r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 821B5AB0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 821B5AB4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821B5AB8: EBDD0000  ld r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821B5ABC: EBBD0008  ld r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821B5AC0: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B5AC4: F8EA0008  std r7, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821B5AC8: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821B5ACC: F8A90008  std r5, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821B5AD0: FBC80000  std r30, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821B5AD4: FBA80008  std r29, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 821B5AD8: 4BFFE4B9  bl 0x821b3f90
	ctx.lr = 0x821B5ADC;
	sub_821B3F90(ctx, base);
	// 821B5ADC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B5AE0: A09F002E  lhz r4, 0x2e(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5AE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B5AE8: 386BCD68  addi r3, r11, -0x3298
	ctx.r[3].s64 = ctx.r[11].s64 + -12952;
	// 821B5AEC: 480036E5  bl 0x821b91d0
	ctx.lr = 0x821B5AF0;
	sub_821B91D0(ctx, base);
            }
            0x821B5AF0 => {
    //   block [0x821B5AF0..0x821B5AF8)
	// 821B5AF0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821B5AF4: 4837F608  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5AF8 size=564
    let mut pc: u32 = 0x821B5AF8;
    'dispatch: loop {
        match pc {
            0x821B5AF8 => {
    //   block [0x821B5AF8..0x821B5D2C)
	// 821B5AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5AFC: 4837F5A1  bl 0x8253509c
	ctx.lr = 0x821B5B00;
	sub_82535080(ctx, base);
	// 821B5B00: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B5B08: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5B0C: 3F3F0002  addis r25, r31, 2
	ctx.r[25].s64 = ctx.r[31].s64 + 131072;
	// 821B5B10: 616BEB32  ori r11, r11, 0xeb32
	ctx.r[11].u64 = ctx.r[11].u64 | 60210;
	// 821B5B14: 3B39BE64  addi r25, r25, -0x419c
	ctx.r[25].s64 = ctx.r[25].s64 + -16796;
	// 821B5B18: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 821B5B1C: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 821B5B20: 7D364B78  mr r22, r9
	ctx.r[22].u64 = ctx.r[9].u64;
	// 821B5B24: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5B28: 8B190000  lbz r24, 0(r25)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5B30: 419A001C  beq cr6, 0x821b5b4c
	if ctx.cr[6].eq {
	pc = 0x821B5B4C; continue 'dispatch;
	}
	// 821B5B34: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821B5B38: 409A0014  bne cr6, 0x821b5b4c
	if !ctx.cr[6].eq {
	pc = 0x821B5B4C; continue 'dispatch;
	}
	// 821B5B3C: 8177001C  lwz r11, 0x1c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5B40: 556B0636  rlwinm r11, r11, 0, 0x18, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B5B44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5B48: 409A01CC  bne cr6, 0x821b5d14
	if !ctx.cr[6].eq {
	pc = 0x821B5D14; continue 'dispatch;
	}
	// 821B5B4C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B5B50: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B5B54: 396BA92C  addi r11, r11, -0x56d4
	ctx.r[11].s64 = ctx.r[11].s64 + -22228;
	// 821B5B58: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821B5B5C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5B60: 409A0050  bne cr6, 0x821b5bb0
	if !ctx.cr[6].eq {
	pc = 0x821B5BB0; continue 'dispatch;
	}
	// 821B5B64: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B5B68: 614AEB27  ori r10, r10, 0xeb27
	ctx.r[10].u64 = ctx.r[10].u64 | 60199;
	// 821B5B6C: 7D5F50AE  lbzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B5B70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B5B74: 419A003C  beq cr6, 0x821b5bb0
	if ctx.cr[6].eq {
	pc = 0x821B5BB0; continue 'dispatch;
	}
	// 821B5B78: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B5B7C: 419A002C  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5B80: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5B84: 419A0024  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5B88: 2F0B0026  cmpwi cr6, r11, 0x26
	ctx.cr[6].compare_i32(ctx.r[11].s32, 38, &mut ctx.xer);
	// 821B5B8C: 419A001C  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5B90: 2F0B0025  cmpwi cr6, r11, 0x25
	ctx.cr[6].compare_i32(ctx.r[11].s32, 37, &mut ctx.xer);
	// 821B5B94: 419A0014  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5B98: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821B5B9C: 419A000C  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5BA0: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 821B5BA4: 409A000C  bne cr6, 0x821b5bb0
	if !ctx.cr[6].eq {
	pc = 0x821B5BB0; continue 'dispatch;
	}
	// 821B5BA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B5BAC: 48000008  b 0x821b5bb4
	pc = 0x821B5BB4; continue 'dispatch;
	// 821B5BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B5BB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5BBC: 419A0168  beq cr6, 0x821b5d24
	if ctx.cr[6].eq {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5BC0: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821B5BC4: 40980160  bge cr6, 0x821b5d24
	if !ctx.cr[6].lt {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5BC8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B5BCC: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821B5BD0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B5BD4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B5BD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B5BDC: 4E800421  bctrl
	ctx.lr = 0x821B5BE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B5BE0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B5BE4: 571C103A  slwi r28, r24, 2
	ctx.r[28].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 821B5BE8: 3B6BCF90  addi r27, r11, -0x3070
	ctx.r[27].s64 = ctx.r[11].s64 + -12400;
	// 821B5BEC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5BF0: 395B0778  addi r10, r27, 0x778
	ctx.r[10].s64 = ctx.r[27].s64 + 1912;
	// 821B5BF4: 616BD33C  ori r11, r11, 0xd33c
	ctx.r[11].u64 = ctx.r[11].u64 | 54076;
	// 821B5BF8: 7C1C542E  lfsx f0, r28, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5BFC: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821B5C00: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5C04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5C08: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5C0C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B5C10: C1AB2054  lfs f13, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5C14: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 821B5C18: 4098010C  bge cr6, 0x821b5d24
	if !ctx.cr[6].lt {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5C1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5C20: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5C24: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B5C28: 409900FC  ble cr6, 0x821b5d24
	if !ctx.cr[6].gt {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5C2C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B5C30: C1ABD5B0  lfs f13, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5C34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B5C38: 409800EC  bge cr6, 0x821b5d24
	if !ctx.cr[6].lt {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5C3C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B5C40: 3B5B07A0  addi r26, r27, 0x7a0
	ctx.r[26].s64 = ctx.r[27].s64 + 1952;
	// 821B5C44: 3BAB0C40  addi r29, r11, 0xc40
	ctx.r[29].s64 = ctx.r[11].s64 + 3136;
	// 821B5C48: 7D5CD02E  lwzx r10, r28, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 821B5C4C: 809D0688  lwz r4, 0x688(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B5C50: 7D6A2050  subf r11, r10, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 821B5C54: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 821B5C58: 40990084  ble cr6, 0x821b5cdc
	if !ctx.cr[6].gt {
	pc = 0x821B5CDC; continue 'dispatch;
	}
	// 821B5C5C: 8177001C  lwz r11, 0x1c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5C60: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5C64: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5C68: 419A0020  beq cr6, 0x821b5c88
	if ctx.cr[6].eq {
	pc = 0x821B5C88; continue 'dispatch;
	}
	// 821B5C6C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5C70: 419A0010  beq cr6, 0x821b5c80
	if ctx.cr[6].eq {
	pc = 0x821B5C80; continue 'dispatch;
	}
	// 821B5C74: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5C78: 557EE63E  rlwinm r30, r11, 0x1c, 0x18, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5C7C: 48000010  b 0x821b5c8c
	pc = 0x821B5C8C; continue 'dispatch;
	// 821B5C80: 3BC0003C  li r30, 0x3c
	ctx.r[30].s64 = 60;
	// 821B5C84: 48000008  b 0x821b5c8c
	pc = 0x821B5C8C; continue 'dispatch;
	// 821B5C88: 3BC0003A  li r30, 0x3a
	ctx.r[30].s64 = 58;
	// 821B5C8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B5C90: 88790000  lbz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5C94: 4800009D  bl 0x821b5d30
	ctx.lr = 0x821B5C98;
	sub_821B5D30(ctx, base);
	// 821B5C98: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B5C9C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821B5CA0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B5CA4: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821B5CA8: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B5CAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B5CB0: 409A0028  bne cr6, 0x821b5cd8
	if !ctx.cr[6].eq {
	pc = 0x821B5CD8; continue 'dispatch;
	}
	// 821B5CB4: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 821B5CB8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821B5CBC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821B5CC0: 386B45D8  addi r3, r11, 0x45d8
	ctx.r[3].s64 = ctx.r[11].s64 + 17880;
	// 821B5CC4: 89790000  lbz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5CC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B5CCC: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 821B5CD0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 821B5CD4: 4BFC6D45  bl 0x8217ca18
	ctx.lr = 0x821B5CD8;
	sub_8217CA18(ctx, base);
	// 821B5CD8: 809D0688  lwz r4, 0x688(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B5CDC: 7D7CD02E  lwzx r11, r28, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 821B5CE0: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 821B5CE4: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 821B5CE8: 4099000C  ble cr6, 0x821b5cf4
	if !ctx.cr[6].gt {
	pc = 0x821B5CF4; continue 'dispatch;
	}
	// 821B5CEC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B5CF0: 4BFFE011  bl 0x821b3d00
	ctx.lr = 0x821B5CF4;
	sub_821B3D00(ctx, base);
	// 821B5CF4: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5CF8: 395B0788  addi r10, r27, 0x788
	ctx.r[10].s64 = ctx.r[27].s64 + 1928;
	// 821B5CFC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821B5D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B5D04: 7D7C512E  stwx r11, r28, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B5D08: 4BFFE919  bl 0x821b4620
	ctx.lr = 0x821B5D0C;
	sub_821B4620(ctx, base);
	// 821B5D0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B5D10: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B5D14: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821B5D18: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821B5D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B5D20: 4BFFF839  bl 0x821b5558
	ctx.lr = 0x821B5D24;
	sub_821B5558(ctx, base);
	// 821B5D24: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B5D28: 4837F3C4  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5D30 size=100
    let mut pc: u32 = 0x821B5D30;
    'dispatch: loop {
        match pc {
            0x821B5D30 => {
    //   block [0x821B5D30..0x821B5D94)
	// 821B5D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5D38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5D3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B5D40: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821B5D44: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B5D48: 5467103A  slwi r7, r3, 2
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B5D4C: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 821B5D50: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B5D54: C04ABFFC  lfs f2, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B5D58: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B5D5C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B5D60: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821B5D64: 38A000A4  li r5, 0xa4
	ctx.r[5].s64 = 164;
	// 821B5D68: 7C87582E  lwzx r4, r7, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5D6C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821B5D70: C02ABA38  lfs f1, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B5D74: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821B5D78: 386A1090  addi r3, r10, 0x1090
	ctx.r[3].s64 = ctx.r[10].s64 + 4240;
	// 821B5D7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B5D80: 4BFE5A89  bl 0x8219b808
	ctx.lr = 0x821B5D84;
	sub_8219B808(ctx, base);
	// 821B5D84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B5D88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B5D8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5D98 size=268
    let mut pc: u32 = 0x821B5D98;
    'dispatch: loop {
        match pc {
            0x821B5D98 => {
    //   block [0x821B5D98..0x821B5EA4)
	// 821B5D98: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 821B5D9C: 41980108  blt cr6, 0x821b5ea4
	if ctx.cr[6].lt {
		sub_821B5EA4(ctx, base);
		return;
	}
	// 821B5DA0: 409A017C  bne cr6, 0x821b5f1c
	if !ctx.cr[6].eq {
		sub_821B5F1C(ctx, base);
		return;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5EA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5EA4 size=80
    let mut pc: u32 = 0x821B5EA4;
    'dispatch: loop {
        match pc {
            0x821B5EA4 => {
    //   block [0x821B5EA4..0x821B5EF4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5EF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5EF4 size=40
    let mut pc: u32 = 0x821B5EF4;
    'dispatch: loop {
        match pc {
            0x821B5EF4 => {
    //   block [0x821B5EF4..0x821B5F1C)
	// 821B5EF4: 8167000C  lwz r11, 0xc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5EF8: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5EFC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B5F00: 409A001C  bne cr6, 0x821b5f1c
	if !ctx.cr[6].eq {
		sub_821B5F1C(ctx, base);
		return;
	}
	// 821B5F04: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5F08: 616BEB32  ori r11, r11, 0xeb32
	ctx.r[11].u64 = ctx.r[11].u64 | 60210;
	// 821B5F0C: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5F10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5F18: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5F1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5F1C size=8
    let mut pc: u32 = 0x821B5F1C;
    'dispatch: loop {
        match pc {
            0x821B5F1C => {
    //   block [0x821B5F1C..0x821B5F24)
	// 821B5F1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B5F20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5F28 size=1348
    let mut pc: u32 = 0x821B5F28;
    'dispatch: loop {
        match pc {
            0x821B5F28 => {
    //   block [0x821B5F28..0x821B646C)
	// 821B5F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5F2C: 4837F171  bl 0x8253509c
	ctx.lr = 0x821B5F30;
	sub_82535080(ctx, base);
	// 821B5F30: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 821B5F34: 483800A1  bl 0x82535fd4
	ctx.lr = 0x821B5F38;
	sub_82535FB0(ctx, base);
	// 821B5F38: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5F3C: 3BE80030  addi r31, r8, 0x30
	ctx.r[31].s64 = ctx.r[8].s64 + 48;
	// 821B5F40: FEE00890  fmr f23, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[23].f64 = ctx.f[1].f64;
	// 821B5F44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5F48: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B5F4C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821B5F50: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B5F54: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5F58: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 821B5F5C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821B5F60: C3EB2238  lfs f31, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B5F64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B5F68: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B5F6C: 41980008  blt cr6, 0x821b5f74
	if ctx.cr[6].lt {
	pc = 0x821B5F74; continue 'dispatch;
	}
	// 821B5F70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B5F74: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5F78: 83C101CC  lwz r30, 0x1cc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 821B5F7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5F80: 812101C4  lwz r9, 0x1c4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 821B5F84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B5F88: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821B5F8C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821B5F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B5F94: C06B1FF8  lfs f3, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B5F98: 419A0048  beq cr6, 0x821b5fe0
	if ctx.cr[6].eq {
	pc = 0x821B5FE0; continue 'dispatch;
	}
	// 821B5F9C: EB0A0000  ld r24, 0(r10)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B5FA0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 821B5FA4: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821B5FA8: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 821B5FAC: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5FB0: FB0B0000  std r24, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u64 ) };
	// 821B5FB4: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B5FB8: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B5FBC: 48003305  bl 0x821b92c0
	ctx.lr = 0x821B5FC0;
	sub_821B92C0(ctx, base);
	// 821B5FC0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B5FC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5FC8: 409A00B8  bne cr6, 0x821b6080
	if !ctx.cr[6].eq {
	pc = 0x821B6080; continue 'dispatch;
	}
	// 821B5FCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5FD0: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 821B5FD4: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 821B5FD8: 48380049  bl 0x82536020
	ctx.lr = 0x821B5FDC;
	sub_82535FFC(ctx, base);
	// 821B5FDC: 4837F110  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
	// 821B5FE0: EB1F0000  ld r24, 0(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 821B5FE4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B5FE8: EAFF0008  ld r23, 8(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B6470 size=880
    let mut pc: u32 = 0x821B6470;
    'dispatch: loop {
        match pc {
            0x821B6470 => {
    //   block [0x821B6470..0x821B67E0)
	// 821B6470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6474: 4837EC19  bl 0x8253508c
	ctx.lr = 0x821B6478;
	sub_82535080(ctx, base);
	// 821B6478: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 821B647C: 4837FB6D  bl 0x82535fe8
	ctx.lr = 0x821B6480;
	sub_82535FB0(ctx, base);
	// 821B6480: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6484: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821B6488: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B648C: 56EA103A  slwi r10, r23, 2
	ctx.r[10].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B6490: 396BA92C  addi r11, r11, -0x56d4
	ctx.r[11].s64 = ctx.r[11].s64 + -22228;
	// 821B6494: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B6498: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 821B649C: 3F5F0002  addis r26, r31, 2
	ctx.r[26].s64 = ctx.r[31].s64 + 131072;
	// 821B64A0: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821B64A4: 7FCA582E  lwzx r30, r10, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B64A8: 3960003F  li r11, 0x3f
	ctx.r[11].s64 = 63;
	// 821B64AC: 3B5ABE64  addi r26, r26, -0x419c
	ctx.r[26].s64 = ctx.r[26].s64 + -16796;
	// 821B64B0: 7CF23B78  mr r18, r7
	ctx.r[18].u64 = ctx.r[7].u64;
	// 821B64B4: 7D114378  mr r17, r8
	ctx.r[17].u64 = ctx.r[8].u64;
	// 821B64B8: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 821B64BC: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821B64C0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821B64C4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821B64C8: 8ABA0000  lbz r21, 0(r26)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B64CC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821B64D0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821B64D4: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821B64D8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 821B64DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B64E0: 4BFFEB79  bl 0x821b5058
	ctx.lr = 0x821B64E4;
	sub_821B5058(ctx, base);
	// 821B64E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B64E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B64EC: 409A0018  bne cr6, 0x821b6504
	if !ctx.cr[6].eq {
	pc = 0x821B6504; continue 'dispatch;
	}
	// 821B64F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B64F4: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 821B64F8: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 821B64FC: 4837FB39  bl 0x82536034
	ctx.lr = 0x821B6500;
	sub_82535FFC(ctx, base);
	// 821B6500: 4837EBDC  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
	// 821B6504: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B6508: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B650C: 3900003F  li r8, 0x3f
	ctx.r[8].s64 = 63;
	// 821B6510: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6514: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B6518: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 821B651C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B6520: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6524: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B6528: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B652C: 4BFFE94D  bl 0x821b4e78
	ctx.lr = 0x821B6530;
	sub_821B4E78(ctx, base);
	// 821B6530: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B6534: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B6538: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 821B653C: 3BABCF90  addi r29, r11, -0x3070
	ctx.r[29].s64 = ctx.r[11].s64 + -12400;
	// 821B6540: 409A0010  bne cr6, 0x821b6550
	if !ctx.cr[6].eq {
	pc = 0x821B6550; continue 'dispatch;
	}
	// 821B6544: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B654C: 4BFFD8F5  bl 0x821b3e40
	ctx.lr = 0x821B6550;
	sub_821B3E40(ctx, base);
	// 821B6550: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B6554: 419AFF9C  beq cr6, 0x821b64f0
	if ctx.cr[6].eq {
	pc = 0x821B64F0; continue 'dispatch;
	}
	// 821B6558: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B655C: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B6560: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B6564: 419A0020  beq cr6, 0x821b6584
	if ctx.cr[6].eq {
	pc = 0x821B6584; continue 'dispatch;
	}
	// 821B6568: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B656C: 419A0010  beq cr6, 0x821b657c
	if ctx.cr[6].eq {
	pc = 0x821B657C; continue 'dispatch;
	}
	// 821B6570: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B6574: 5574E63E  rlwinm r20, r11, 0x1c, 0x18, 0x1f
	ctx.r[20].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B6578: 48000010  b 0x821b6588
	pc = 0x821B6588; continue 'dispatch;
	// 821B657C: 3A80003C  li r20, 0x3c
	ctx.r[20].s64 = 60;
	// 821B6580: 48000008  b 0x821b6588
	pc = 0x821B6588; continue 'dispatch;
	// 821B6584: 3A80003A  li r20, 0x3a
	ctx.r[20].s64 = 58;
	// 821B6588: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B658C: 56BE103A  slwi r30, r21, 2
	ctx.r[30].u32 = ctx.r[21].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B6590: 3B6B0C40  addi r27, r11, 0xc40
	ctx.r[27].s64 = ctx.r[11].s64 + 3136;
	// 821B6594: 3B1D07A8  addi r24, r29, 0x7a8
	ctx.r[24].s64 = ctx.r[29].s64 + 1960;
	// 821B6598: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B659C: 817B0688  lwz r11, 0x688(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B65A0: 7D5EC02E  lwzx r10, r30, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 821B65A4: C389213C  lfs f28, 0x213c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8508 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B65A8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B65AC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B65B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B65B4: C3EA210C  lfs f31, 0x210c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8460 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B65B8: C3CB2254  lfs f30, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B65BC: 4098008C  bge cr6, 0x821b6648
	if !ctx.cr[6].lt {
	pc = 0x821B6648; continue 'dispatch;
	}
	// 821B65C0: C05C0038  lfs f2, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B65C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B65C8: C1A10088  lfs f13, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B65CC: EDA20372  fmuls f13, f2, f13
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B65D0: C0010080  lfs f0, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B65D4: C03C0030  lfs f1, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B65D8: EDA1683A  fmadds f13, f1, f0, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B65DC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B65E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B65E4: 40980064  bge cr6, 0x821b6648
	if !ctx.cr[6].lt {
	pc = 0x821B6648; continue 'dispatch;
	}
	// 821B65E8: 897A0000  lbz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B65EC: 3B3D0780  addi r25, r29, 0x780
	ctx.r[25].s64 = ctx.r[29].s64 + 1920;
	// 821B65F0: 557A103E  rotlwi r26, r11, 2
	ctx.r[26].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B65F4: 4837C8B5  bl 0x82532ea8
	ctx.lr = 0x821B65F8;
	sub_82532EA8(ctx, base);
	// 821B65F8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B65FC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6600: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 821B6604: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6608: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B660C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B6610: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B6614: 7C1ACD2E  stfsx f0, r26, r25
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32), tmp.u32) };
	// 821B6618: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 821B661C: 4099000C  ble cr6, 0x821b6628
	if !ctx.cr[6].gt {
	pc = 0x821B6628; continue 'dispatch;
	}
	// 821B6620: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B6624: 48000018  b 0x821b663c
	pc = 0x821B663C; continue 'dispatch;
	// 821B6628: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B662C: C1AB25B4  lfs f13, 0x25b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9652 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6630: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B6634: 4098000C  bge cr6, 0x821b6640
	if !ctx.cr[6].lt {
	pc = 0x821B6640; continue 'dispatch;
	}
	// 821B6638: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821B663C: 7C1ACD2E  stfsx f0, r26, r25
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32), tmp.u32) };
	// 821B6640: 817B0688  lwz r11, 0x688(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B6644: 7D7EC12E  stwx r11, r30, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[24].u32), ctx.r[11].u32) };
	// 821B6648: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 821B664C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821B6650: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	// 821B6654: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821B6658: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821B665C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821B6660: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 821B6664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6668: 4BFFEBE9  bl 0x821b5250
	ctx.lr = 0x821B666C;
	sub_821B5250(ctx, base);
	// 821B666C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B6670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6674: 419AFE7C  beq cr6, 0x821b64f0
	if ctx.cr[6].eq {
	pc = 0x821B64F0; continue 'dispatch;
	}
	// 821B6678: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B667C: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 821B6680: 91730000  stw r11, 0(r19)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B6684: 409A00C8  bne cr6, 0x821b674c
	if !ctx.cr[6].eq {
	pc = 0x821B674C; continue 'dispatch;
	}
	// 821B6688: 3B5D0824  addi r26, r29, 0x824
	ctx.r[26].s64 = ctx.r[29].s64 + 2084;
	// 821B668C: 817B0688  lwz r11, 0x688(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B6690: 7D5ED02E  lwzx r10, r30, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 821B6694: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B6698: 409800B4  bge cr6, 0x821b674c
	if !ctx.cr[6].lt {
	pc = 0x821B674C; continue 'dispatch;
	}
	// 821B669C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B66A0: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821B66A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B66A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B66AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B66B0: 4E800421  bctrl
	ctx.lr = 0x821B66B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B66B4: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B66B8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821B66BC: 393D0030  addi r9, r29, 0x30
	ctx.r[9].s64 = ctx.r[29].s64 + 48;
	// 821B66C0: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B66C4: 1D550310  mulli r10, r21, 0x310
	ctx.r[10].s64 = ctx.r[21].s64 * 784;
	// 821B66C8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821B66CC: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B66D0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B66D4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B66D8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821B66DC: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B67E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B67E0 size=144
    let mut pc: u32 = 0x821B67E0;
    'dispatch: loop {
        match pc {
            0x821B67E0 => {
    //   block [0x821B67E0..0x821B6870)
	// 821B67E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B67E4: 4837E8D1  bl 0x825350b4
	ctx.lr = 0x821B67E8;
	sub_82535080(ctx, base);
	// 821B67E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B67EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B67F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B67F4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B67F8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B67FC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821B6800: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821B6804: 7FEB0034  cntlzw r11, r31
	ctx.r[11].u64 = if ctx.r[31].u32 == 0 { 32 } else { ctx.r[31].u32.leading_zeros() as u64 };
	// 821B6808: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B680C: 5568DFFE  rlwinm r8, r11, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B6810: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B6814: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821B6818: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B681C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B6820: 4BFFFC51  bl 0x821b6470
	ctx.lr = 0x821B6824;
	sub_821B6470(ctx, base);
	// 821B6824: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B6828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B682C: 409A0010  bne cr6, 0x821b683c
	if !ctx.cr[6].eq {
	pc = 0x821B683C; continue 'dispatch;
	}
	// 821B6830: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B6834: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 821B6838: 4198FFCC  blt cr6, 0x821b6804
	if ctx.cr[6].lt {
	pc = 0x821B6804; continue 'dispatch;
	}
	// 821B683C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6840: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B6844: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B6848: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B684C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821B6850: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B6854: 7D5E50AE  lbzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B6858: 390B0640  addi r8, r11, 0x640
	ctx.r[8].s64 = ctx.r[11].s64 + 1600;
	// 821B685C: 1D6A0031  mulli r11, r10, 0x31
	ctx.r[11].s64 = ctx.r[10].s64 * 49;
	// 821B6860: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821B6864: 7D2B41AE  stbx r9, r11, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u8) };
	// 821B6868: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B686C: 4837E898  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B6870 size=2068
    let mut pc: u32 = 0x821B6870;
    'dispatch: loop {
        match pc {
            0x821B6870 => {
    //   block [0x821B6870..0x821B7084)
	// 821B6870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6874: 4837E80D  bl 0x82535080
	ctx.lr = 0x821B6878;
	sub_82535080(ctx, base);
	// 821B6878: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 821B687C: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821B6880: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6884: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B6888: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B688C: 3DDA0006  addis r14, r26, 6
	ctx.r[14].s64 = ctx.r[26].s64 + 393216;
	// 821B6890: 616BEB1C  ori r11, r11, 0xeb1c
	ctx.r[11].u64 = ctx.r[11].u64 | 60188;
	// 821B6894: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B6898: 39CEA9C0  addi r14, r14, -0x5640
	ctx.r[14].s64 = ctx.r[14].s64 + -22080;
	// 821B689C: 614ABE64  ori r10, r10, 0xbe64
	ctx.r[10].u64 = ctx.r[10].u64 | 48740;
	// 821B68A0: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 821B68A4: 7D3A58AE  lbzx r9, r26, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B68A8: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 821B68AC: 83EE0000  lwz r31, 0(r14)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B68B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B68B4: 7EFA50AE  lbzx r23, r26, r10
	ctx.r[23].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B68B8: 92610050  stw r19, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[19].u32 ) };
	// 821B68BC: 409A0014  bne cr6, 0x821b68d0
	if !ctx.cr[6].eq {
	pc = 0x821B68D0; continue 'dispatch;
	}
	// 821B68C0: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B68C4: 7E7E9B78  mr r30, r19
	ctx.r[30].u64 = ctx.r[19].u64;
	// 821B68C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B68CC: 419A0008  beq cr6, 0x821b68d4
	if ctx.cr[6].eq {
	pc = 0x821B68D4; continue 'dispatch;
	}
	// 821B68D0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821B68D4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821B68D8: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 821B68DC: 419A000C  beq cr6, 0x821b68e8
	if ctx.cr[6].eq {
	pc = 0x821B68E8; continue 'dispatch;
	}
	// 821B68E0: 2F170001  cmpwi cr6, r23, 1
	ctx.cr[6].compare_i32(ctx.r[23].s32, 1, &mut ctx.xer);
	// 821B68E4: 409A078C  bne cr6, 0x821b7070
	if !ctx.cr[6].eq {
	pc = 0x821B7070; continue 'dispatch;
	}
	// 821B68E8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B68EC: 56F6103A  slwi r22, r23, 2
	ctx.r[22].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[22].u64 = ctx.r[22].u32 as u64;
	// 821B68F0: 3A8BCF90  addi r20, r11, -0x3070
	ctx.r[20].s64 = ctx.r[11].s64 + -12400;
	// 821B68F4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B68F8: 393407C8  addi r9, r20, 0x7c8
	ctx.r[9].s64 = ctx.r[20].s64 + 1992;
	// 821B68FC: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B6900: 7E76492E  stwx r19, r22, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[9].u32), ctx.r[19].u32) };
	// 821B6904: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 821B6908: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B690C: 419A0764  beq cr6, 0x821b7070
	if ctx.cr[6].eq {
	pc = 0x821B7070; continue 'dispatch;
	}
	// 821B6910: 896B0001  lbz r11, 1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B6914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6918: 419A0758  beq cr6, 0x821b7070
	if ctx.cr[6].eq {
	pc = 0x821B7070; continue 'dispatch;
	}
	// 821B691C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B6920: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821B6924: 4BFFD0CD  bl 0x821b39f0
	ctx.lr = 0x821B6928;
	sub_821B39F0(ctx, base);
	// 821B6928: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B692C: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B6930: 616BEB31  ori r11, r11, 0xeb31
	ctx.r[11].u64 = ctx.r[11].u64 | 60209;
	// 821B6934: 6130EB20  ori r16, r9, 0xeb20
	ctx.r[16].u64 = ctx.r[9].u64 | 60192;
	// 821B6938: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B693C: 6135EB04  ori r21, r9, 0xeb04
	ctx.r[21].u64 = ctx.r[9].u64 | 60164;
	// 821B6940: 7D5A58AE  lbzx r10, r26, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6944: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B6948: 612FEB32  ori r15, r9, 0xeb32
	ctx.r[15].u64 = ctx.r[9].u64 | 60210;
	// 821B694C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6950: 409A0024  bne cr6, 0x821b6974
	if !ctx.cr[6].eq {
	pc = 0x821B6974; continue 'dispatch;
	}
	// 821B6954: 7D3F58AE  lbzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6958: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B695C: 409A0018  bne cr6, 0x821b6974
	if !ctx.cr[6].eq {
	pc = 0x821B6974; continue 'dispatch;
	}
	// 821B6960: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821B6964: 409A0058  bne cr6, 0x821b69bc
	if !ctx.cr[6].eq {
	pc = 0x821B69BC; continue 'dispatch;
	}
	// 821B6968: 7D7F78AE  lbzx r11, r31, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 821B696C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6970: 48000044  b 0x821b69b4
	pc = 0x821B69B4; continue 'dispatch;
	// 821B6974: 7D3F78AE  lbzx r9, r31, r15
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 821B6978: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B697C: 409A0028  bne cr6, 0x821b69a4
	if !ctx.cr[6].eq {
	pc = 0x821B69A4; continue 'dispatch;
	}
	// 821B6980: 7D3F80AE  lbzx r9, r31, r16
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[16].u32)) } as u64;
	// 821B6984: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B6988: 409A0010  bne cr6, 0x821b6998
	if !ctx.cr[6].eq {
	pc = 0x821B6998; continue 'dispatch;
	}
	// 821B698C: 7D3FA8AE  lbzx r9, r31, r21
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821B6990: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B6994: 419A0028  beq cr6, 0x821b69bc
	if ctx.cr[6].eq {
	pc = 0x821B69BC; continue 'dispatch;
	}
	// 821B6998: 7D3F58AE  lbzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B699C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B69A0: 419A001C  beq cr6, 0x821b69bc
	if ctx.cr[6].eq {
	pc = 0x821B69BC; continue 'dispatch;
	}
	// 821B69A4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821B69A8: 419A0010  beq cr6, 0x821b69b8
	if ctx.cr[6].eq {
	pc = 0x821B69B8; continue 'dispatch;
	}
	// 821B69AC: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B69B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B69B4: 419A0008  beq cr6, 0x821b69bc
	if ctx.cr[6].eq {
	pc = 0x821B69BC; continue 'dispatch;
	}
	// 821B69B8: 7E719B78  mr r17, r19
	ctx.r[17].u64 = ctx.r[19].u64;
	// 821B69BC: 3FDA0002  addis r30, r26, 2
	ctx.r[30].s64 = ctx.r[26].s64 + 131072;
	// 821B69C0: 3BDEED28  addi r30, r30, -0x12d8
	ctx.r[30].s64 = ctx.r[30].s64 + -4824;
	// 821B69C4: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B69C8: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 821B69CC: 409A00A4  bne cr6, 0x821b6a70
	if !ctx.cr[6].eq {
	pc = 0x821B6A70; continue 'dispatch;
	}
	// 821B69D0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B69D4: 3D20829E  lis r9, -0x7d62
	ctx.r[9].s64 = -2103574528;
	// 821B69D8: 396BFA00  addi r11, r11, -0x600
	ctx.r[11].s64 = ctx.r[11].s64 + -1536;
	// 821B69DC: 39296210  addi r9, r9, 0x6210
	ctx.r[9].s64 = ctx.r[9].s64 + 25104;
	// 821B69E0: 386B0060  addi r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 + 96;
	// 821B69E4: 56EA2036  slwi r10, r23, 4
	ctx.r[10].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B69E8: 390B0020  addi r8, r11, 0x20
	ctx.r[8].s64 = ctx.r[11].s64 + 32;
	// 821B69EC: 3BEB0030  addi r31, r11, 0x30
	ctx.r[31].s64 = ctx.r[11].s64 + 48;
	// 821B69F0: 388B0090  addi r4, r11, 0x90
	ctx.r[4].s64 = ctx.r[11].s64 + 144;
	// 821B69F4: 7E76492E  stwx r19, r22, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[9].u32), ctx.r[19].u32) };
	// 821B69F8: 7C6A1A14  add r3, r10, r3
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 821B69FC: 38EB0050  addi r7, r11, 0x50
	ctx.r[7].s64 = ctx.r[11].s64 + 80;
	// 821B6A00: 38CB0080  addi r6, r11, 0x80
	ctx.r[6].s64 = ctx.r[11].s64 + 128;
	// 821B6A04: 38AB00B0  addi r5, r11, 0xb0
	ctx.r[5].s64 = ctx.r[11].s64 + 176;
	// 821B6A08: 3BA90018  addi r29, r9, 0x18
	ctx.r[29].s64 = ctx.r[9].s64 + 24;
	// 821B6A0C: 3B890010  addi r28, r9, 0x10
	ctx.r[28].s64 = ctx.r[9].s64 + 16;
	// 821B6A10: 3B690008  addi r27, r9, 8
	ctx.r[27].s64 = ctx.r[9].s64 + 8;
	// 821B6A14: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B6A18: 7D2AFA14  add r9, r10, r31
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821B6A1C: 7C8A2214  add r4, r10, r4
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821B6A20: 7E76E92E  stwx r19, r22, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[29].u32), ctx.r[19].u32) };
	// 821B6A24: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B6A28: E8680000  ld r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821B6A2C: 7E76E12E  stwx r19, r22, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[28].u32), ctx.r[19].u32) };
	// 821B6A30: 7E76D92E  stwx r19, r22, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[27].u32), ctx.r[19].u32) };
	// 821B6A34: F86B0000  std r3, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 821B6A38: E9080008  ld r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821B6A3C: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 821B6A40: E9670000  ld r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B6A44: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B6A48: E9670008  ld r11, 8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 821B6A4C: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B6A50: E9660000  ld r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 821B6A54: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B6A58: E9660008  ld r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	// 821B6A5C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B6A60: E9650000  ld r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 821B6A64: F9640000  std r11, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B6A68: E9650008  ld r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 821B6A6C: F9640008  std r11, 8(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B6A70: 39540770  addi r10, r20, 0x770
	ctx.r[10].s64 = ctx.r[20].s64 + 1904;
	// 821B6A74: 7D76502E  lwzx r11, r22, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B6A78: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821B6A7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6A80: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B6A84: 3B0BA92C  addi r24, r11, -0x56d4
	ctx.r[24].s64 = ctx.r[11].s64 + -22228;
	// 821B6A88: 7D36512E  stwx r9, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 821B6A8C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B6A90: 6152EB03  ori r18, r10, 0xeb03
	ctx.r[18].u64 = ctx.r[10].u64 | 60163;
	// 821B6A94: 40990194  ble cr6, 0x821b6c28
	if !ctx.cr[6].gt {
	pc = 0x821B6C28; continue 'dispatch;
	}
	// 821B6A98: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6A9C: 616BEDAE  ori r11, r11, 0xedae
	ctx.r[11].u64 = ctx.r[11].u64 | 60846;
	// 821B6AA0: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6AA8: 419A0018  beq cr6, 0x821b6ac0
	if ctx.cr[6].eq {
	pc = 0x821B6AC0; continue 'dispatch;
	}
	// 821B6AAC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6AB0: 616BED4C  ori r11, r11, 0xed4c
	ctx.r[11].u64 = ctx.r[11].u64 | 60748;
	// 821B6AB4: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6ABC: 419A0028  beq cr6, 0x821b6ae4
	if ctx.cr[6].eq {
	pc = 0x821B6AE4; continue 'dispatch;
	}
	// 821B6AC0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6AC4: 616BED2C  ori r11, r11, 0xed2c
	ctx.r[11].u64 = ctx.r[11].u64 | 60716;
	// 821B6AC8: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6ACC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821B6AD0: 40980014  bge cr6, 0x821b6ae4
	if !ctx.cr[6].lt {
	pc = 0x821B6AE4; continue 'dispatch;
	}
	// 821B6AD4: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6AD8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6ADC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821B6AE0: 41990018  bgt cr6, 0x821b6af8
	if ctx.cr[6].gt {
	pc = 0x821B6AF8; continue 'dispatch;
	}
	// 821B6AE4: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 821B6AE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B6AEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B6AF0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6AF4: 4BFFFCED  bl 0x821b67e0
	ctx.lr = 0x821B6AF8;
	sub_821B67E0(ctx, base);
	// 821B6AF8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6AFC: 3F3A0002  addis r25, r26, 2
	ctx.r[25].s64 = ctx.r[26].s64 + 131072;
	// 821B6B00: 617BEB3F  ori r27, r11, 0xeb3f
	ctx.r[27].u64 = ctx.r[11].u64 | 60223;
	// 821B6B04: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6B08: 7E7E9B78  mr r30, r19
	ctx.r[30].u64 = ctx.r[19].u64;
	// 821B6B0C: 3B39EB27  addi r25, r25, -0x14d9
	ctx.r[25].s64 = ctx.r[25].s64 + -5337;
	// 821B6B10: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 821B6B14: 617CED3C  ori r28, r11, 0xed3c
	ctx.r[28].u64 = ctx.r[11].u64 | 60732;
	// 821B6B18: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6B1C: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 821B6B20: 409A003C  bne cr6, 0x821b6b5c
	if !ctx.cr[6].eq {
	pc = 0x821B6B5C; continue 'dispatch;
	}
	// 821B6B24: 7D7A90AE  lbzx r11, r26, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821B6B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B2C: 409A001C  bne cr6, 0x821b6b48
	if !ctx.cr[6].eq {
	pc = 0x821B6B48; continue 'dispatch;
	}
	// 821B6B30: 7D7A80AE  lbzx r11, r26, r16
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[16].u32)) } as u64;
	// 821B6B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B38: 409A0010  bne cr6, 0x821b6b48
	if !ctx.cr[6].eq {
	pc = 0x821B6B48; continue 'dispatch;
	}
	// 821B6B3C: 7D7AA8AE  lbzx r11, r26, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821B6B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B44: 419A0018  beq cr6, 0x821b6b5c
	if ctx.cr[6].eq {
	pc = 0x821B6B5C; continue 'dispatch;
	}
	// 821B6B48: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 821B6B4C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B6B50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B6B54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6B58: 4BFFFC89  bl 0x821b67e0
	ctx.lr = 0x821B6B5C;
	sub_821B67E0(ctx, base);
	// 821B6B5C: 89790000  lbz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B64: 419A0014  beq cr6, 0x821b6b78
	if ctx.cr[6].eq {
	pc = 0x821B6B78; continue 'dispatch;
	}
	// 821B6B68: 2F1F0021  cmpwi cr6, r31, 0x21
	ctx.cr[6].compare_i32(ctx.r[31].s32, 33, &mut ctx.xer);
	// 821B6B6C: 4198000C  blt cr6, 0x821b6b78
	if ctx.cr[6].lt {
	pc = 0x821B6B78; continue 'dispatch;
	}
	// 821B6B70: 2F1F0024  cmpwi cr6, r31, 0x24
	ctx.cr[6].compare_i32(ctx.r[31].s32, 36, &mut ctx.xer);
	// 821B6B74: 409900A0  ble cr6, 0x821b6c14
	if !ctx.cr[6].gt {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6B78: 2F1F002D  cmpwi cr6, r31, 0x2d
	ctx.cr[6].compare_i32(ctx.r[31].s32, 45, &mut ctx.xer);
	// 821B6B7C: 41980074  blt cr6, 0x821b6bf0
	if ctx.cr[6].lt {
	pc = 0x821B6BF0; continue 'dispatch;
	}
	// 821B6B80: 7D7A90AE  lbzx r11, r26, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821B6B84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B88: 409A008C  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6B8C: 7D7AD8AE  lbzx r11, r26, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 821B6B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B94: 409A0080  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6B98: 7D7AA8AE  lbzx r11, r26, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821B6B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6BA0: 409A0074  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6BA4: 7D7A80AE  lbzx r11, r26, r16
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[16].u32)) } as u64;
	// 821B6BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6BAC: 409A0068  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6BB0: 562B063E  clrlwi r11, r17, 0x18
	ctx.r[11].u64 = ctx.r[17].u32 as u64 & 0x000000FFu64;
	// 821B6BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6BB8: 409A0038  bne cr6, 0x821b6bf0
	if !ctx.cr[6].eq {
	pc = 0x821B6BF0; continue 'dispatch;
	}
	// 821B6BBC: 7D7AE22E  lhzx r11, r26, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821B6BC0: 2F1F0030  cmpwi cr6, r31, 0x30
	ctx.cr[6].compare_i32(ctx.r[31].s32, 48, &mut ctx.xer);
	// 821B6BC4: 409A000C  bne cr6, 0x821b6bd0
	if !ctx.cr[6].eq {
	pc = 0x821B6BD0; continue 'dispatch;
	}
	// 821B6BC8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B6BCC: 48000020  b 0x821b6bec
	pc = 0x821B6BEC; continue 'dispatch;
	// 821B6BD0: 2F1F002E  cmpwi cr6, r31, 0x2e
	ctx.cr[6].compare_i32(ctx.r[31].s32, 46, &mut ctx.xer);
	// 821B6BD4: 409A000C  bne cr6, 0x821b6be0
	if !ctx.cr[6].eq {
	pc = 0x821B6BE0; continue 'dispatch;
	}
	// 821B6BD8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821B6BDC: 48000010  b 0x821b6bec
	pc = 0x821B6BEC; continue 'dispatch;
	// 821B6BE0: 2F1F002F  cmpwi cr6, r31, 0x2f
	ctx.cr[6].compare_i32(ctx.r[31].s32, 47, &mut ctx.xer);
	// 821B6BE4: 409A000C  bne cr6, 0x821b6bf0
	if !ctx.cr[6].eq {
	pc = 0x821B6BF0; continue 'dispatch;
	}
	// 821B6BE8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B6BEC: 419A0028  beq cr6, 0x821b6c14
	if ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6BF0: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 821B6BF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6BF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B6BFC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6C00: 4BFFFBE1  bl 0x821b67e0
	ctx.lr = 0x821B6C04;
	sub_821B67E0(ctx, base);
	// 821B6C04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B6C08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6C0C: 409A0008  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6C10: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821B6C14: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B6C18: 3978003C  addi r11, r24, 0x3c
	ctx.r[11].s64 = ctx.r[24].s64 + 60;
	// 821B6C1C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821B6C20: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B6C24: 4198FEF4  blt cr6, 0x821b6b18
	if ctx.cr[6].lt {
	pc = 0x821B6B18; continue 'dispatch;
	}
	// 821B6C28: 56EA2036  slwi r10, r23, 4
	ctx.r[10].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B6C2C: 397406A2  addi r11, r20, 0x6a2
	ctx.r[11].s64 = ctx.r[20].s64 + 1698;
	// 821B6C30: 1FB70031  mulli r29, r23, 0x31
	ctx.r[29].s64 = ctx.r[23].s64 * 49;
	// 821B6C34: 39340750  addi r9, r20, 0x750
	ctx.r[9].s64 = ctx.r[20].s64 + 1872;
	// 821B6C38: 7F7D5A14  add r27, r29, r11
	ctx.r[27].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821B6C3C: 7F8A4A14  add r28, r10, r9
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B6C40: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B6C44: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B6C48: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 821B6C4C: C3CBD4DC  lfs f30, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B6C50: C3EA2190  lfs f31, 0x2190(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8592 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B6C54: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6C58: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B6C5C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6C60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6C64: 48000D65  bl 0x821b79c8
	ctx.lr = 0x821B6C68;
	sub_821B79C8(ctx, base);
	// 821B6C68: 7D5DFA14  add r10, r29, r31
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821B6C6C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821B6C70: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821B6C74: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B6C78: 39340020  addi r9, r20, 0x20
	ctx.r[9].s64 = ctx.r[20].s64 + 32;
	// 821B6C7C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B6C80: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B6C84: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B6C88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B6C8C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B6C90: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B6C94: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B6C98: 4BFFD3F9  bl 0x821b4090
	ctx.lr = 0x821B6C9C;
	sub_821B4090(ctx, base);
	// 821B6C9C: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 821B6CA0: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 821B6CA4: 41990008  bgt cr6, 0x821b6cac
	if ctx.cr[6].gt {
	pc = 0x821B6CAC; continue 'dispatch;
	}
	// 821B6CA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B6CAC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B6CB0: 7D7BF9AE  stbx r11, r27, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u8) };
	// 821B6CB4: 3958003C  addi r10, r24, 0x3c
	ctx.r[10].s64 = ctx.r[24].s64 + 60;
	// 821B6CB8: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B6CBC: 4198FF98  blt cr6, 0x821b6c54
	if ctx.cr[6].lt {
	pc = 0x821B6C54; continue 'dispatch;
	}
	// 821B6CC0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6CC4: 616BED3A  ori r11, r11, 0xed3a
	ctx.r[11].u64 = ctx.r[11].u64 | 60730;
	// 821B6CC8: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6CCC: 2F0B0011  cmpwi cr6, r11, 0x11
	ctx.cr[6].compare_i32(ctx.r[11].s32, 17, &mut ctx.xer);
	// 821B6CD0: 419A0010  beq cr6, 0x821b6ce0
	if ctx.cr[6].eq {
	pc = 0x821B6CE0; continue 'dispatch;
	}
	// 821B6CD4: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 821B6CD8: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 821B6CDC: 409A0008  bne cr6, 0x821b6ce4
	if !ctx.cr[6].eq {
	pc = 0x821B6CE4; continue 'dispatch;
	}
	// 821B6CE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B6CE4: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B6CE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B6CEC: 419A000C  beq cr6, 0x821b6cf8
	if ctx.cr[6].eq {
	pc = 0x821B6CF8; continue 'dispatch;
	}
	// 821B6CF0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6CF4: 4BFFDA95  bl 0x821b4788
	ctx.lr = 0x821B6CF8;
	sub_821B4788(ctx, base);
	// 821B6CF8: 395407B0  addi r10, r20, 0x7b0
	ctx.r[10].s64 = ctx.r[20].s64 + 1968;
	// 821B6CFC: 7D76502E  lwzx r11, r22, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B6D00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6D04: 409A0018  bne cr6, 0x821b6d1c
	if !ctx.cr[6].eq {
	pc = 0x821B6D1C; continue 'dispatch;
	}
	// 821B6D08: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 821B6D0C: 409A0038  bne cr6, 0x821b6d44
	if !ctx.cr[6].eq {
	pc = 0x821B6D44; continue 'dispatch;
	}
	// 821B6D10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B6D14: 7D76512E  stwx r11, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B6D18: 4800002C  b 0x821b6d44
	pc = 0x821B6D44; continue 'dispatch;
	// 821B6D1C: 40990018  ble cr6, 0x821b6d34
	if !ctx.cr[6].gt {
	pc = 0x821B6D34; continue 'dispatch;
	}
	// 821B6D20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B6D24: 409A0020  bne cr6, 0x821b6d44
	if !ctx.cr[6].eq {
	pc = 0x821B6D44; continue 'dispatch;
	}
	// 821B6D28: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821B6D2C: 7D76512E  stwx r11, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B6D30: 48000014  b 0x821b6d44
	pc = 0x821B6D44; continue 'dispatch;
	// 821B6D34: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 821B6D38: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B6D3C: 41980008  blt cr6, 0x821b6d44
	if ctx.cr[6].lt {
	pc = 0x821B6D44; continue 'dispatch;
	}
	// 821B6D40: 7E76512E  stwx r19, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[19].u32) };
	// 821B6D44: 7D76502E  lwzx r11, r22, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B6D48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6D4C: 419A01E0  beq cr6, 0x821b6f2c
	if ctx.cr[6].eq {
	pc = 0x821B6F2C; continue 'dispatch;
	}
	// 821B6D50: 40990030  ble cr6, 0x821b6d80
	if !ctx.cr[6].gt {
	pc = 0x821B6D80; continue 'dispatch;
	}
	// 821B6D54: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 821B6D58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B6D5C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821B6D60: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B6D64: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821B6D68: 7D76512E  stwx r11, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B6D6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B6D70: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B6D74: C00B2144  lfs f0, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6D78: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B6D7C: 48000034  b 0x821b6db0
	pc = 0x821B6DB0; continue 'dispatch;
	// 821B6D80: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 821B6D84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6D88: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B6D8C: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 821B6D90: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B6D94: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B6D98: 7D76512E  stwx r11, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B6D9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B6DA0: C0092050  lfs f0, 0x2050(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6DA4: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B6DA8: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6DAC: EFEC683A  fmadds f31, f12, f0, f13
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B6DB0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6DB4: 616BEB12  ori r11, r11, 0xeb12
	ctx.r[11].u64 = ctx.r[11].u64 | 60178;
	// 821B6DB8: 7D7A58AE  lbzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6DC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B6DC4: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 821B6DC8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6DCC: 419A000C  beq cr6, 0x821b6dd8
	if ctx.cr[6].eq {
	pc = 0x821B6DD8; continue 'dispatch;
	}
	// 821B6DD0: FFE06890  fmr f31, f13
	ctx.f[31].f64 = ctx.f[13].f64;
	// 821B6DD4: 48000028  b 0x821b6dfc
	pc = 0x821B6DFC; continue 'dispatch;
	// 821B6DD8: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 821B6DDC: 4098000C  bge cr6, 0x821b6de8
	if !ctx.cr[6].lt {
	pc = 0x821B6DE8; continue 'dispatch;
	}
	// 821B6DE0: FFE06890  fmr f31, f13
	ctx.f[31].f64 = ctx.f[13].f64;
	// 821B6DE4: 48000018  b 0x821b6dfc
	pc = 0x821B6DFC; continue 'dispatch;
	// 821B6DE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B6DEC: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6DF0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821B6DF4: 40990008  ble cr6, 0x821b6dfc
	if !ctx.cr[6].gt {
	pc = 0x821B6DFC; continue 'dispatch;
	}
	// 821B6DF8: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 821B6DFC: 39740798  addi r11, r20, 0x798
	ctx.r[11].s64 = ctx.r[20].s64 + 1944;
	// 821B6E00: 7FF6582E  lwzx r31, r22, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6E04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B6E08: 419A0124  beq cr6, 0x821b6f2c
	if ctx.cr[6].eq {
	pc = 0x821B6F2C; continue 'dispatch;
	}
	// 821B6E0C: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 821B6E10: 4099011C  ble cr6, 0x821b6f2c
	if !ctx.cr[6].gt {
	pc = 0x821B6F2C; continue 'dispatch;
	}
	// 821B6E14: 39740788  addi r11, r20, 0x788
	ctx.r[11].s64 = ctx.r[20].s64 + 1928;
	// 821B6E18: 815A0030  lwz r10, 0x30(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B6E1C: 387A0030  addi r3, r26, 0x30
	ctx.r[3].s64 = ctx.r[26].s64 + 48;
	// 821B6E20: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B6E24: 7D76582E  lwzx r11, r22, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6E28: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B6E2C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B6E30: 616B8410  ori r11, r11, 0x8410
	ctx.r[11].u64 = ctx.r[11].u64 | 33808;
	// 821B6E34: 7C1A5C2E  lfsx f0, r26, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6E38: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B6E3C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B6E40: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B6E44: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821B6E48: 419A0018  beq cr6, 0x821b6e60
	if ctx.cr[6].eq {
	pc = 0x821B6E60; continue 'dispatch;
	}
	// 821B6E4C: ED8007B2  fmuls f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B6E50: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6E54: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B6E58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B6E5C: 4800001C  b 0x821b6e78
	pc = 0x821B6E78; continue 'dispatch;
	// 821B6E60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B6E64: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6E68: C18B2584  lfs f12, 0x2584(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9604 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B6E6C: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B6E70: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B6E74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B6E78: 4E800421  bctrl
	ctx.lr = 0x821B6E7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B6E7C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7088 size=380
    let mut pc: u32 = 0x821B7088;
    'dispatch: loop {
        match pc {
            0x821B7088 => {
    //   block [0x821B7088..0x821B7204)
	// 821B7088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B708C: 4837E029  bl 0x825350b4
	ctx.lr = 0x821B7090;
	sub_82535080(ctx, base);
	// 821B7090: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7094: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7098: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B709C: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B70A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B70A4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B70A8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821B70AC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 821B70B0: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B70B4: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B70B8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B70BC: 40990018  ble cr6, 0x821b70d4
	if !ctx.cr[6].gt {
	pc = 0x821B70D4; continue 'dispatch;
	}
	// 821B70C0: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B70C4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B70C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B70CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B70D0: 41990008  bgt cr6, 0x821b70d8
	if ctx.cr[6].gt {
	pc = 0x821B70D8; continue 'dispatch;
	}
	// 821B70D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B70D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B70DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B70E0: 419A00C4  beq cr6, 0x821b71a4
	if ctx.cr[6].eq {
	pc = 0x821B71A4; continue 'dispatch;
	}
	// 821B70E4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B70E8: 616BEB1C  ori r11, r11, 0xeb1c
	ctx.r[11].u64 = ctx.r[11].u64 | 60188;
	// 821B70EC: 7D5E58AE  lbzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B70F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B70F4: 409A008C  bne cr6, 0x821b7180
	if !ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B70F8: 7D7D58AE  lbzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B70FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7100: 409A0080  bne cr6, 0x821b7180
	if !ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B7104: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B7108: 57EA063E  clrlwi r10, r31, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821B710C: 6168EB03  ori r8, r11, 0xeb03
	ctx.r[8].u64 = ctx.r[11].u64 | 60163;
	// 821B7110: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7114: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7118: 392BCF90  addi r9, r11, -0x3070
	ctx.r[9].s64 = ctx.r[11].s64 + -12400;
	// 821B711C: 419A0064  beq cr6, 0x821b7180
	if ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B7120: 7D7D40AE  lbzx r11, r29, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B7124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7128: 419A0024  beq cr6, 0x821b714c
	if ctx.cr[6].eq {
	pc = 0x821B714C; continue 'dispatch;
	}
	// 821B712C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7130: 38E906D3  addi r7, r9, 0x6d3
	ctx.r[7].s64 = ctx.r[9].s64 + 1747;
	// 821B7134: 7CEB38AE  lbzx r7, r11, r7
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821B7138: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B713C: 409A0070  bne cr6, 0x821b71ac
	if !ctx.cr[6].eq {
	pc = 0x821B71AC; continue 'dispatch;
	}
	// 821B7140: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7144: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 821B7148: 4198FFE8  blt cr6, 0x821b7130
	if ctx.cr[6].lt {
	pc = 0x821B7130; continue 'dispatch;
	}
	// 821B714C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7150: 419A0030  beq cr6, 0x821b7180
	if ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B7154: 7D7E40AE  lbzx r11, r30, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B7158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B715C: 419A0024  beq cr6, 0x821b7180
	if ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B7160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7164: 394906A2  addi r10, r9, 0x6a2
	ctx.r[10].s64 = ctx.r[9].s64 + 1698;
	// 821B7168: 7D4B50AE  lbzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B716C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7170: 409A0068  bne cr6, 0x821b71d8
	if !ctx.cr[6].eq {
	pc = 0x821B71D8; continue 'dispatch;
	}
	// 821B7174: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7178: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 821B717C: 4198FFE8  blt cr6, 0x821b7164
	if ctx.cr[6].lt {
	pc = 0x821B7164; continue 'dispatch;
	}
	// 821B7180: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B7184: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B7188: 4BFFF6E9  bl 0x821b6870
	ctx.lr = 0x821B718C;
	sub_821B6870(ctx, base);
	// 821B718C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B7190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B7194: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B7198: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B719C: 4BFFF6D5  bl 0x821b6870
	ctx.lr = 0x821B71A0;
	sub_821B6870(ctx, base);
	// 821B71A0: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B71A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B71A8: 4837DF5C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 821B71AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B71B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B71B4: 4BFFF6BD  bl 0x821b6870
	ctx.lr = 0x821B71B8;
	sub_821B6870(ctx, base);
	// 821B71B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B71BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B71C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B71C4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B71C8: 4BFFF6A9  bl 0x821b6870
	ctx.lr = 0x821B71CC;
	sub_821B6870(ctx, base);
	// 821B71CC: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B71D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B71D4: 4837DF30  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 821B71D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B71DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B71E0: 4BFFF691  bl 0x821b6870
	ctx.lr = 0x821B71E4;
	sub_821B6870(ctx, base);
	// 821B71E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B71E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B71EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B71F0: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B71F4: 4BFFF67D  bl 0x821b6870
	ctx.lr = 0x821B71F8;
	sub_821B6870(ctx, base);
	// 821B71F8: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B71FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B7200: 4837DF04  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7208 size=176
    let mut pc: u32 = 0x821B7208;
    'dispatch: loop {
        match pc {
            0x821B7208 => {
    //   block [0x821B7208..0x821B72B8)
	// 821B7208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B720C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B7214: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7218: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B721C: 3FE00003  lis r31, 3
	ctx.r[31].s64 = 196608;
	// 821B7220: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B7224: 63FF9450  ori r31, r31, 0x9450
	ctx.r[31].u64 = ctx.r[31].u64 | 37968;
	// 821B7228: 7D6BFA2E  lhzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821B722C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B7230: 409A0074  bne cr6, 0x821b72a4
	if !ctx.cr[6].eq {
	pc = 0x821B72A4; continue 'dispatch;
	}
	// 821B7234: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821B7238: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B723C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821B7240: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821B7244: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 821B7248: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 821B724C: 409A0040  bne cr6, 0x821b728c
	if !ctx.cr[6].eq {
	pc = 0x821B728C; continue 'dispatch;
	}
	// 821B7250: E8A70000  ld r5, 0(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B7254: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821B7258: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 821B725C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821B7260: E8880000  ld r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821B7264: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821B7268: E9080008  ld r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821B726C: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821B7270: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821B7274: F8AB0000  std r5, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 821B7278: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821B727C: F88A0000  std r4, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 821B7280: F90A0008  std r8, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 821B7284: F8660000  std r3, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 821B7288: F9260008  std r9, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821B728C: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 821B7290: 38C00050  li r6, 0x50
	ctx.r[6].s64 = 80;
	// 821B7294: 386B45D8  addi r3, r11, 0x45d8
	ctx.r[3].s64 = ctx.r[11].s64 + 17880;
	// 821B7298: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B729C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 821B72A0: 4BFC5779  bl 0x8217ca18
	ctx.lr = 0x821B72A4;
	sub_8217CA18(ctx, base);
	// 821B72A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821B72A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B72AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B72B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B72B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B72B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B72B8 size=380
    let mut pc: u32 = 0x821B72B8;
    'dispatch: loop {
        match pc {
            0x821B72B8 => {
    //   block [0x821B72B8..0x821B7434)
	// 821B72B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B72BC: 4837DDFD  bl 0x825350b8
	ctx.lr = 0x821B72C0;
	sub_82535080(ctx, base);
	// 821B72C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B72C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B72C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B72CC: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B72D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B72D4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821B72D8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821B72DC: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B72E0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B72E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B72E8: 40990018  ble cr6, 0x821b7300
	if !ctx.cr[6].gt {
	pc = 0x821B7300; continue 'dispatch;
	}
	// 821B72EC: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B72F0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B72F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B72F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B72FC: 41990008  bgt cr6, 0x821b7304
	if ctx.cr[6].gt {
	pc = 0x821B7304; continue 'dispatch;
	}
	// 821B7300: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7304: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B730C: 409A0010  bne cr6, 0x821b731c
	if !ctx.cr[6].eq {
	pc = 0x821B731C; continue 'dispatch;
	}
	// 821B7310: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B7314: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821B7318: 4837DDF0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821B731C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7320: 3920003C  li r9, 0x3c
	ctx.r[9].s64 = 60;
	// 821B7324: 3900003A  li r8, 0x3a
	ctx.r[8].s64 = 58;
	// 821B7328: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B732C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B7330: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B7334: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7338: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B733C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B7340: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B7344: 4BFFDC85  bl 0x821b4fc8
	ctx.lr = 0x821B7348;
	sub_821B4FC8(ctx, base);
	// 821B7348: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B734C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7350: 419AFFC0  beq cr6, 0x821b7310
	if ctx.cr[6].eq {
	pc = 0x821B7310; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7438 size=140
    let mut pc: u32 = 0x821B7438;
    'dispatch: loop {
        match pc {
            0x821B7438 => {
    //   block [0x821B7438..0x821B74C4)
	// 821B7438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B743C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7440: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7444: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B7448: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821B744C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B7450: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B7458: 4E800421  bctrl
	ctx.lr = 0x821B745C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B745C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7460: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7464: C18B2194  lfs f12, 0x2194(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8596 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7468: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821B746C: 4098001C  bge cr6, 0x821b7488
	if !ctx.cr[6].lt {
	pc = 0x821B7488; continue 'dispatch;
	}
	// 821B7470: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7474: C02B2190  lfs f1, 0x2190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B7478: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B747C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7484: 4E800020  blr
	return;
	// 821B7488: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B748C: C1ABBA44  lfs f13, -0x45bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17852 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7490: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B7494: 4199FFDC  bgt cr6, 0x821b7470
	if ctx.cr[6].gt {
	pc = 0x821B7470; continue 'dispatch;
	}
	// 821B7498: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B749C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821B74A0: 4198FFD0  blt cr6, 0x821b7470
	if ctx.cr[6].lt {
	pc = 0x821B7470; continue 'dispatch;
	}
	// 821B74A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B74A8: 4199FFC8  bgt cr6, 0x821b7470
	if ctx.cr[6].gt {
	pc = 0x821B7470; continue 'dispatch;
	}
	// 821B74AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B74B0: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B74B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B74B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B74BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B74C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B74C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B74C8 size=92
    let mut pc: u32 = 0x821B74C8;
    'dispatch: loop {
        match pc {
            0x821B74C8 => {
    //   block [0x821B74C8..0x821B7524)
	// 821B74C8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B74CC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821B74D0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B74D4: 394BBA44  addi r10, r11, -0x45bc
	ctx.r[10].s64 = ctx.r[11].s64 + -17852;
	// 821B74D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B74DC: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B74E0: 419A0018  beq cr6, 0x821b74f8
	if ctx.cr[6].eq {
	pc = 0x821B74F8; continue 'dispatch;
	}
	// 821B74E4: C1AAFFF4  lfs f13, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B74E8: D0250000  stfs f1, 0(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B74EC: D1A50004  stfs f13, 4(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B74F0: D0250008  stfs f1, 8(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B74F4: D025000C  stfs f1, 0xc(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B74F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B74FC: C18B2194  lfs f12, 0x2194(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8596 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7500: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821B7504: 41980020  blt cr6, 0x821b7524
	if ctx.cr[6].lt {
		sub_821B7524(ctx, base);
		return;
	}
	// 821B7508: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B750C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B7510: 41990014  bgt cr6, 0x821b7524
	if ctx.cr[6].gt {
		sub_821B7524(ctx, base);
		return;
	}
	// 821B7514: FF026000  fcmpu cr6, f2, f12
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[12].f64);
	// 821B7518: 4198000C  blt cr6, 0x821b7524
	if ctx.cr[6].lt {
		sub_821B7524(ctx, base);
		return;
	}
	// 821B751C: FF026800  fcmpu cr6, f2, f13
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[13].f64);
	// 821B7520: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7524(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7524 size=12
    let mut pc: u32 = 0x821B7524;
    'dispatch: loop {
        match pc {
            0x821B7524 => {
    //   block [0x821B7524..0x821B7530)
	// 821B7524: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7528: C02B2190  lfs f1, 0x2190(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B752C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7530 size=100
    let mut pc: u32 = 0x821B7530;
    'dispatch: loop {
        match pc {
            0x821B7530 => {
    //   block [0x821B7530..0x821B7594)
	// 821B7530: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7534: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 821B7538: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B753C: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B7540: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B7544: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B7548: 40990018  ble cr6, 0x821b7560
	if !ctx.cr[6].gt {
	pc = 0x821B7560; continue 'dispatch;
	}
	// 821B754C: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B7550: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B7554: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7558: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B755C: 41990008  bgt cr6, 0x821b7564
	if ctx.cr[6].gt {
	pc = 0x821B7564; continue 'dispatch;
	}
	// 821B7560: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7564: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B756C: 409A0054  bne cr6, 0x821b75c0
	if !ctx.cr[6].eq {
		sub_821B75C0(ctx, base);
		return;
	}
	// 821B7570: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7574: C1AB2194  lfs f13, 0x2194(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8596 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B757C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 821B7580: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B7584: 40980010  bge cr6, 0x821b7594
	if !ctx.cr[6].lt {
		sub_821B7594(ctx, base);
		return;
	}
	// 821B7588: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B758C: C02B2190  lfs f1, 0x2190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B7590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7594(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7594 size=44
    let mut pc: u32 = 0x821B7594;
    'dispatch: loop {
        match pc {
            0x821B7594 => {
    //   block [0x821B7594..0x821B75C0)
	// 821B7594: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7598: C00BBA44  lfs f0, -0x45bc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B759C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821B75A0: 4199FFE8  bgt cr6, 0x821b7588
	if ctx.cr[6].gt {
		sub_821B7530(ctx, base);
		return;
	}
	// 821B75A4: FF026800  fcmpu cr6, f2, f13
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[13].f64);
	// 821B75A8: 4198FFE0  blt cr6, 0x821b7588
	if ctx.cr[6].lt {
		sub_821B7530(ctx, base);
		return;
	}
	// 821B75AC: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 821B75B0: 4199FFD8  bgt cr6, 0x821b7588
	if ctx.cr[6].gt {
		sub_821B7530(ctx, base);
		return;
	}
	// 821B75B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B75B8: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B75BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B75C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B75C0 size=16
    let mut pc: u32 = 0x821B75C0;
    'dispatch: loop {
        match pc {
            0x821B75C0 => {
    //   block [0x821B75C0..0x821B75D0)
	// 821B75C0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B75C4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821B75C8: 386BCD68  addi r3, r11, -0x3298
	ctx.r[3].s64 = ctx.r[11].s64 + -12952;
	// 821B75CC: 48001244  b 0x821b8810
	sub_821B8810(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B75D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B75D0 size=244
    let mut pc: u32 = 0x821B75D0;
    'dispatch: loop {
        match pc {
            0x821B75D0 => {
    //   block [0x821B75D0..0x821B76C4)
	// 821B75D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B75D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B75D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B75DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B75E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B75E4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B75E8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B75EC: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B75F0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821B75F4: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B75F8: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B75FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B7600: 40990018  ble cr6, 0x821b7618
	if !ctx.cr[6].gt {
	pc = 0x821B7618; continue 'dispatch;
	}
	// 821B7604: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B7608: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B760C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7610: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7614: 41990008  bgt cr6, 0x821b761c
	if ctx.cr[6].gt {
	pc = 0x821B761C; continue 'dispatch;
	}
	// 821B7618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B761C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7624: 409A0010  bne cr6, 0x821b7634
	if !ctx.cr[6].eq {
	pc = 0x821B7634; continue 'dispatch;
	}
	// 821B7628: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B762C: 4BFFFE9D  bl 0x821b74c8
	ctx.lr = 0x821B7630;
	sub_821B74C8(ctx, base);
	// 821B7630: 4800007C  b 0x821b76ac
	pc = 0x821B76AC; continue 'dispatch;
	// 821B7634: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7638: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 821B763C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B7640: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B7644: 4BFFFEED  bl 0x821b7530
	ctx.lr = 0x821B7648;
	sub_821B7530(ctx, base);
	// 821B7648: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B764C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7650: 419A005C  beq cr6, 0x821b76ac
	if ctx.cr[6].eq {
	pc = 0x821B76AC; continue 'dispatch;
	}
	// 821B7654: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B7658: 419A0018  beq cr6, 0x821b7670
	if ctx.cr[6].eq {
	pc = 0x821B7670; continue 'dispatch;
	}
	// 821B765C: 396A0030  addi r11, r10, 0x30
	ctx.r[11].s64 = ctx.r[10].s64 + 48;
	// 821B7660: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B7664: F93F0000  std r9, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B7668: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B766C: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B7670: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B7674: 419A0038  beq cr6, 0x821b76ac
	if ctx.cr[6].eq {
	pc = 0x821B76AC; continue 'dispatch;
	}
	// 821B7678: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B767C: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7680: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B7684: 419A0020  beq cr6, 0x821b76a4
	if ctx.cr[6].eq {
	pc = 0x821B76A4; continue 'dispatch;
	}
	// 821B7688: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B768C: 419A0010  beq cr6, 0x821b769c
	if ctx.cr[6].eq {
	pc = 0x821B769C; continue 'dispatch;
	}
	// 821B7690: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B7694: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B7698: 48000010  b 0x821b76a8
	pc = 0x821B76A8; continue 'dispatch;
	// 821B769C: 3960003C  li r11, 0x3c
	ctx.r[11].s64 = 60;
	// 821B76A0: 48000008  b 0x821b76a8
	pc = 0x821B76A8; continue 'dispatch;
	// 821B76A4: 3960003A  li r11, 0x3a
	ctx.r[11].s64 = 58;
	// 821B76A8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B76AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B76B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B76B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B76B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B76BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B76C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B76C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B76C8 size=148
    let mut pc: u32 = 0x821B76C8;
    'dispatch: loop {
        match pc {
            0x821B76C8 => {
    //   block [0x821B76C8..0x821B775C)
	// 821B76C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B76CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B76D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B76D4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B76D8: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B76DC: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B76E0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B76E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B76E8: 40990018  ble cr6, 0x821b7700
	if !ctx.cr[6].gt {
	pc = 0x821B7700; continue 'dispatch;
	}
	// 821B76EC: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B76F0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B76F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B76F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B76FC: 41990008  bgt cr6, 0x821b7704
	if ctx.cr[6].gt {
	pc = 0x821B7704; continue 'dispatch;
	}
	// 821B7700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7704: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B770C: 409A001C  bne cr6, 0x821b7728
	if !ctx.cr[6].eq {
	pc = 0x821B7728; continue 'dispatch;
	}
	// 821B7710: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B7714: 4BFFFD25  bl 0x821b7438
	ctx.lr = 0x821B7718;
	sub_821B7438(ctx, base);
	// 821B7718: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B771C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7724: 4E800020  blr
	return;
	// 821B7728: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B772C: 4800029D  bl 0x821b79c8
	ctx.lr = 0x821B7730;
	sub_821B79C8(ctx, base);
	// 821B7730: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7734: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B7738: C0410068  lfs f2, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B773C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B7740: C0210060  lfs f1, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B7744: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B7748: 4BFFFDE9  bl 0x821b7530
	ctx.lr = 0x821B774C;
	sub_821B7530(ctx, base);
	// 821B774C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B7750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7760 size=252
    let mut pc: u32 = 0x821B7760;
    'dispatch: loop {
        match pc {
            0x821B7760 => {
    //   block [0x821B7760..0x821B785C)
	// 821B7760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7768: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B776C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7770: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B7774: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B7778: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B777C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B7780: 40990018  ble cr6, 0x821b7798
	if !ctx.cr[6].gt {
	pc = 0x821B7798; continue 'dispatch;
	}
	// 821B7784: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B7788: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B778C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7790: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7794: 41990008  bgt cr6, 0x821b779c
	if ctx.cr[6].gt {
	pc = 0x821B779C; continue 'dispatch;
	}
	// 821B7798: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B779C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B77A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B77A4: 409A0018  bne cr6, 0x821b77bc
	if !ctx.cr[6].eq {
	pc = 0x821B77BC; continue 'dispatch;
	}
	// 821B77A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B77AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B77B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B77B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B77B8: 4E800020  blr
	return;
	// 821B77BC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B77C0: C0430008  lfs f2, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B77C4: C0230000  lfs f1, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B77C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B77CC: 396BCD68  addi r11, r11, -0x3298
	ctx.r[11].s64 = ctx.r[11].s64 + -12952;
	// 821B77D0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B77D4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821B77D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B77DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B77E0: 48001031  bl 0x821b8810
	ctx.lr = 0x821B77E4;
	sub_821B8810(ctx, base);
	// 821B77E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B77E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B77EC: 419A005C  beq cr6, 0x821b7848
	if ctx.cr[6].eq {
	pc = 0x821B7848; continue 'dispatch;
	}
	// 821B77F0: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B77F4: 554AC73E  rlwinm r10, r10, 0x18, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B77F8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821B77FC: 419A0038  beq cr6, 0x821b7834
	if ctx.cr[6].eq {
	pc = 0x821B7834; continue 'dispatch;
	}
	// 821B7800: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821B7804: 419A001C  beq cr6, 0x821b7820
	if ctx.cr[6].eq {
	pc = 0x821B7820; continue 'dispatch;
	}
	// 821B7808: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B780C: 5563E63E  rlwinm r3, r11, 0x1c, 0x18, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B7810: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B7814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B781C: 4E800020  blr
	return;
	// 821B7820: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 821B7824: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B7828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B782C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7830: 4E800020  blr
	return;
	// 821B7834: 3860003A  li r3, 0x3a
	ctx.r[3].s64 = 58;
	// 821B7838: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B783C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7840: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7844: 4E800020  blr
	return;
	// 821B7848: 3860003F  li r3, 0x3f
	ctx.r[3].s64 = 63;
	// 821B784C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B7850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7860 size=164
    let mut pc: u32 = 0x821B7860;
    'dispatch: loop {
        match pc {
            0x821B7860 => {
    //   block [0x821B7860..0x821B7904)
	// 821B7860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7868: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B786C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7870: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 821B7874: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B7878: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B787C: 4BFFFCB5  bl 0x821b7530
	ctx.lr = 0x821B7880;
	sub_821B7530(ctx, base);
	// 821B7880: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7884: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7888: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B788C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7890: 419A0038  beq cr6, 0x821b78c8
	if ctx.cr[6].eq {
	pc = 0x821B78C8; continue 'dispatch;
	}
	// 821B7894: A16B001C  lhz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B7898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B789C: 419A002C  beq cr6, 0x821b78c8
	if ctx.cr[6].eq {
	pc = 0x821B78C8; continue 'dispatch;
	}
	// 821B78A0: 556A181A  rlwinm r10, r11, 3, 0, 0xd
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821B78A4: 556905BE  clrlwi r9, r11, 0x16
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 821B78A8: 556BB6FE  rlwinm r11, r11, 0x16, 0x1b, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 821B78AC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821B78B0: 396B0070  addi r11, r11, 0x70
	ctx.r[11].s64 = ctx.r[11].s64 + 112;
	// 821B78B4: 554A6824  slwi r10, r10, 0xd
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(13);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B78B8: 556BB850  rlwinm r11, r11, 0x17, 1, 8
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	// 821B78BC: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821B78C0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B78C4: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B78C8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B78CC: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B78D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B78D4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B78D8: C9AB2008  lfd f13, 0x2008(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 821B78DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B78E0: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 821B78E4: C9AB2000  lfd f13, 0x2000(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 821B78E8: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 821B78EC: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 821B78F0: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B78F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B78F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B78FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7908 size=72
    let mut pc: u32 = 0x821B7908;
    'dispatch: loop {
        match pc {
            0x821B7908 => {
    //   block [0x821B7908..0x821B7950)
	// 821B7908: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B790C: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B7910: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B7914: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B7918: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B791C: 40990018  ble cr6, 0x821b7934
	if !ctx.cr[6].gt {
	pc = 0x821B7934; continue 'dispatch;
	}
	// 821B7920: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B7924: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B7928: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B792C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7930: 41990008  bgt cr6, 0x821b7938
	if ctx.cr[6].gt {
	pc = 0x821B7938; continue 'dispatch;
	}
	// 821B7934: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7938: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B793C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7940: 409A0010  bne cr6, 0x821b7950
	if !ctx.cr[6].eq {
		sub_821B7950(ctx, base);
		return;
	}
	// 821B7944: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7948: C02B2190  lfs f1, 0x2190(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B794C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7950 size=16
    let mut pc: u32 = 0x821B7950;
    'dispatch: loop {
        match pc {
            0x821B7950 => {
    //   block [0x821B7950..0x821B7960)
	// 821B7950: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7954: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B7958: C02B0C34  lfs f1, 0xc34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B795C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7960 size=48
    let mut pc: u32 = 0x821B7960;
    'dispatch: loop {
        match pc {
            0x821B7960 => {
    //   block [0x821B7960..0x821B7990)
	// 821B7960: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B7964: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B7968: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B796C: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B7970: 7D4350AE  lbzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B7974: 396B0798  addi r11, r11, 0x798
	ctx.r[11].s64 = ctx.r[11].s64 + 1944;
	// 821B7978: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821B797C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B7980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7984: 409A000C  bne cr6, 0x821b7990
	if !ctx.cr[6].eq {
		sub_821B7990(ctx, base);
		return;
	}
	// 821B7988: 3860003F  li r3, 0x3f
	ctx.r[3].s64 = 63;
	// 821B798C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7990 size=36
    let mut pc: u32 = 0x821B7990;
    'dispatch: loop {
        match pc {
            0x821B7990 => {
    //   block [0x821B7990..0x821B79B4)
	// 821B7990: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B7994: 554AC73E  rlwinm r10, r10, 0x18, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B7998: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821B799C: 419A0020  beq cr6, 0x821b79bc
	if ctx.cr[6].eq {
		sub_821B79BC(ctx, base);
		return;
	}
	// 821B79A0: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821B79A4: 419A0010  beq cr6, 0x821b79b4
	if ctx.cr[6].eq {
		sub_821B79B4(ctx, base);
		return;
	}
	// 821B79A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B79AC: 5563E63E  rlwinm r3, r11, 0x1c, 0x18, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B79B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B79B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B79B4 size=8
    let mut pc: u32 = 0x821B79B4;
    'dispatch: loop {
        match pc {
            0x821B79B4 => {
    //   block [0x821B79B4..0x821B79BC)
	// 821B79B4: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 821B79B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B79BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B79BC size=8
    let mut pc: u32 = 0x821B79BC;
    'dispatch: loop {
        match pc {
            0x821B79BC => {
    //   block [0x821B79BC..0x821B79C4)
	// 821B79BC: 3860003A  li r3, 0x3a
	ctx.r[3].s64 = 58;
	// 821B79C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B79C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B79C8 size=648
    let mut pc: u32 = 0x821B79C8;
    'dispatch: loop {
        match pc {
            0x821B79C8 => {
    //   block [0x821B79C8..0x821B7C50)
	// 821B79C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B79CC: 4837D6F1  bl 0x825350bc
	ctx.lr = 0x821B79D0;
	sub_82535080(ctx, base);
	// 821B79D0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 821B79D4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821B79D8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821B79DC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B79E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B79E4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B79E8: 2F0400A6  cmpwi cr6, r4, 0xa6
	ctx.cr[6].compare_i32(ctx.r[4].s32, 166, &mut ctx.xer);
	// 821B79EC: 409A0094  bne cr6, 0x821b7a80
	if !ctx.cr[6].eq {
	pc = 0x821B7A80; continue 'dispatch;
	}
	// 821B79F0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B79F4: 3BBE0030  addi r29, r30, 0x30
	ctx.r[29].s64 = ctx.r[30].s64 + 48;
	// 821B79F8: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 821B79FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B7A00: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7A04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B7A08: 4E800421  bctrl
	ctx.lr = 0x821B7A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7A0C: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B7A10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B7A14: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 821B7A18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B7A1C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7A20: C3EB0030  lfs f31, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B7A24: C3CB0034  lfs f30, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B7A28: C3AB0038  lfs f29, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B7A2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B7A30: 4E800421  bctrl
	ctx.lr = 0x821B7A34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7A34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7A38: C181005C  lfs f12, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7A3C: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7A40: C1630038  lfs f11, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B7A44: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7A48: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7A4C: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7A50: ED3E0032  fmuls f9, f30, f0
	ctx.f[9].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7A54: ED1D0032  fmuls f8, f29, f0
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7A58: ECED603A  fmadds f7, f13, f0, f12
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821B7A5C: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7A60: C1830034  lfs f12, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7A64: EDAD503A  fmadds f13, f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821B7A68: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B7A6C: EDAC483A  fmadds f13, f12, f0, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B7A70: D0FF000C  stfs f7, 0xc(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B7A74: EC0B403A  fmadds f0, f11, f0, f8
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821B7A78: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B7A7C: 48000040  b 0x821b7abc
	pc = 0x821B7ABC; continue 'dispatch;
	// 821B7A80: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821B7A84: 4198000C  blt cr6, 0x821b7a90
	if ctx.cr[6].lt {
	pc = 0x821B7A90; continue 'dispatch;
	}
	// 821B7A88: 2F040031  cmpwi cr6, r4, 0x31
	ctx.cr[6].compare_i32(ctx.r[4].s32, 49, &mut ctx.xer);
	// 821B7A8C: 40990048  ble cr6, 0x821b7ad4
	if !ctx.cr[6].gt {
	pc = 0x821B7AD4; continue 'dispatch;
	}
	// 821B7A90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B7A94: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B7A98: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B7A9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7AA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B7AA4: 4E800421  bctrl
	ctx.lr = 0x821B7AA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7AA8: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7AAC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B7AB0: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7AB4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B7AB8: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7ABC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B7AC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B7AC4: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B7AC8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B7ACC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B7AD0: 4837D63C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821B7AD4: 2F04002D  cmpwi cr6, r4, 0x2d
	ctx.cr[6].compare_i32(ctx.r[4].s32, 45, &mut ctx.xer);
	// 821B7AD8: 419800A8  blt cr6, 0x821b7b80
	if ctx.cr[6].lt {
	pc = 0x821B7B80; continue 'dispatch;
	}
	// 821B7ADC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B7AE0: 3964FFD3  addi r11, r4, -0x2d
	ctx.r[11].s64 = ctx.r[4].s64 + -45;
	// 821B7AE4: 6149BE64  ori r9, r10, 0xbe64
	ctx.r[9].u64 = ctx.r[10].u64 | 48740;
	// 821B7AE8: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B7AEC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821B7AF0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821B7AF4: 394AFA00  addi r10, r10, -0x600
	ctx.r[10].s64 = ctx.r[10].s64 + -1536;
	// 821B7AF8: 7D3E48AE  lbzx r9, r30, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B7AFC: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B7B00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B7B04: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821B7B08: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B7B0C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B7B10: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B7B14: F95F0000  std r10, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821B7B18: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B7B1C: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B7B20: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B7B24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7B28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B7B2C: 4E800421  bctrl
	ctx.lr = 0x821B7B30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7B30: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7C50 size=156
    let mut pc: u32 = 0x821B7C50;
    'dispatch: loop {
        match pc {
            0x821B7C50 => {
    //   block [0x821B7C50..0x821B7CEC)
	// 821B7C50: A1430004  lhz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7C54: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B7C58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7C5C: 419A0038  beq cr6, 0x821b7c94
	if ctx.cr[6].eq {
	pc = 0x821B7C94; continue 'dispatch;
	}
	// 821B7C60: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 821B7C64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B7C68: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B7C6C: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B7C70: 40990024  ble cr6, 0x821b7c94
	if !ctx.cr[6].gt {
	pc = 0x821B7C94; continue 'dispatch;
	}
	// 821B7C74: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821B7C78: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7C7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7C80: 7D2A412E  stwx r9, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 821B7C84: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B7C88: A1030004  lhz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7C8C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B7C90: 4198FFE8  blt cr6, 0x821b7c78
	if ctx.cr[6].lt {
	pc = 0x821B7C78; continue 'dispatch;
	}
	// 821B7C94: A0E3000C  lhz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B7C98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B7C9C: 419A0044  beq cr6, 0x821b7ce0
	if ctx.cr[6].eq {
	pc = 0x821B7CE0; continue 'dispatch;
	}
	// 821B7CA0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7CA4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821B7CA8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7CAC: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B7CB0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B7CB4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B7CB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821B7CBC: 40990024  ble cr6, 0x821b7ce0
	if !ctx.cr[6].gt {
	pc = 0x821B7CE0; continue 'dispatch;
	}
	// 821B7CC0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821B7CC4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7CC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7CCC: 7D2A412E  stwx r9, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 821B7CD0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B7CD4: A103000C  lhz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B7CD8: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B7CDC: 4198FFE8  blt cr6, 0x821b7cc4
	if ctx.cr[6].lt {
	pc = 0x821B7CC4; continue 'dispatch;
	}
	// 821B7CE0: A0E30014  lhz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B7CE4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B7CE8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7CEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7CEC size=32
    let mut pc: u32 = 0x821B7CEC;
    'dispatch: loop {
        match pc {
            0x821B7CEC => {
    //   block [0x821B7CEC..0x821B7D0C)
	// 821B7CEC: A163000C  lhz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B7CF0: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821B7CF4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7CF8: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B7CFC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B7D00: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B7D04: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821B7D08: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7D0C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7D0C size=36
    let mut pc: u32 = 0x821B7D0C;
    'dispatch: loop {
        match pc {
            0x821B7D0C => {
    //   block [0x821B7D0C..0x821B7D30)
	// 821B7D0C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821B7D10: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B7D14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7D18: 7D28512E  stwx r9, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 821B7D1C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B7D20: A1030014  lhz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B7D24: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B7D28: 4198FFE8  blt cr6, 0x821b7d10
	if ctx.cr[6].lt {
	pc = 0x821B7D10; continue 'dispatch;
	}
	// 821B7D2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7D30 size=24
    let mut pc: u32 = 0x821B7D30;
    'dispatch: loop {
        match pc {
            0x821B7D30 => {
    //   block [0x821B7D30..0x821B7D48)
	// 821B7D30: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7D34: 816BCD68  lwz r11, -0x3298(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12952 as u32) ) } as u64;
	// 821B7D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7D3C: 409A000C  bne cr6, 0x821b7d48
	if !ctx.cr[6].eq {
		sub_821B7D48(ctx, base);
		return;
	}
	// 821B7D40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B7D44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7D48 size=12
    let mut pc: u32 = 0x821B7D48;
    'dispatch: loop {
        match pc {
            0x821B7D48 => {
    //   block [0x821B7D48..0x821B7D54)
	// 821B7D48: A16B002C  lhz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B7D4C: 7D630734  extsh r3, r11
	ctx.r[3].s64 = ctx.r[11].s16 as i64;
	// 821B7D50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7D58 size=196
    let mut pc: u32 = 0x821B7D58;
    'dispatch: loop {
        match pc {
            0x821B7D58 => {
    //   block [0x821B7D58..0x821B7E1C)
	// 821B7D58: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7D5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7D60: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B7D64: C1050004  lfs f8, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B7D68: ECAB0032  fmuls f5, f11, f0
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7D6C: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7D70: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7D74: C1440000  lfs f10, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7D78: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B7D7C: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7D80: C1240008  lfs f9, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B7D84: C0C50008  lfs f6, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B7D88: ECAA2B7A  fmadds f5, f10, f13, f5
	ctx.f[5].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7D8C: EDA7037A  fmadds f13, f7, f13, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B7D90: EC092B3A  fmadds f0, f9, f12, f5
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7D94: EDA66B3A  fmadds f13, f6, f12, f13
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B7D98: C18B2238  lfs f12, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7D9C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B7DA0: FCA06A10  fabs f5, f13
	ctx.f[5].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 821B7DA4: FF056000  fcmpu cr6, f5, f12
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[12].f64);
	// 821B7DA8: 41980074  blt cr6, 0x821b7e1c
	if ctx.cr[6].lt {
		sub_821B7E1C(ctx, base);
		return;
	}
	// 821B7DAC: C183003C  lfs f12, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7DB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7DB4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B7DB8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821B7DBC: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7DC0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B7DC4: 41980058  blt cr6, 0x821b7e1c
	if ctx.cr[6].lt {
		sub_821B7E1C(ctx, base);
		return;
	}
	// 821B7DC8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7DCC: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7DD0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B7DD4: 41990048  bgt cr6, 0x821b7e1c
	if ctx.cr[6].gt {
		sub_821B7E1C(ctx, base);
		return;
	}
	// 821B7DD8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B7DDC: C184000C  lfs f12, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7DE0: C0A5000C  lfs f5, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821B7DE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B7DE8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B7DEC: EC8C0372  fmuls f4, f12, f13
	ctx.f[4].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B7DF0: ED290372  fmuls f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B7DF4: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B7DF8: EDA8583A  fmadds f13, f8, f0, f11
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821B7DFC: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B7E00: ED65203A  fmadds f11, f5, f0, f4
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64);
	// 821B7E04: D166000C  stfs f11, 0xc(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B7E08: ED86483A  fmadds f12, f6, f0, f9
	ctx.f[12].f64 = (((ctx.f[6].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B7E0C: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B7E10: EC07503A  fmadds f0, f7, f0, f10
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821B7E14: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B7E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7E1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7E1C size=8
    let mut pc: u32 = 0x821B7E1C;
    'dispatch: loop {
        match pc {
            0x821B7E1C => {
    //   block [0x821B7E1C..0x821B7E24)
	// 821B7E1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B7E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7E28 size=648
    let mut pc: u32 = 0x821B7E28;
    'dispatch: loop {
        match pc {
            0x821B7E28 => {
    //   block [0x821B7E28..0x821B80B0)
	// 821B7E28: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821B7E2C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821B7E30: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7E34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7E38: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7E3C: C1050004  lfs f8, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B7E40: ECAC0032  fmuls f5, f12, f0
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7E44: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7E48: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7E4C: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B7E50: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B7E54: C1430038  lfs f10, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7E58: C1240008  lfs f9, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B7E5C: C0C50008  lfs f6, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B7E60: ECAB2B7A  fmadds f5, f11, f13, f5
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7E64: EDA7037A  fmadds f13, f7, f13, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B7E68: EC092ABA  fmadds f0, f9, f10, f5
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7E6C: EDA66ABA  fmadds f13, f6, f10, f13
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B7E70: C14B2238  lfs f10, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7E74: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B7E78: FCA06A10  fabs f5, f13
	ctx.f[5].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 821B7E7C: FF055000  fcmpu cr6, f5, f10
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[10].f64);
	// 821B7E80: 41980220  blt cr6, 0x821b80a0
	if ctx.cr[6].lt {
	pc = 0x821B80A0; continue 'dispatch;
	}
	// 821B7E84: C143003C  lfs f10, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7E88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7E8C: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B7E90: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7E94: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821B7E98: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 821B7E9C: 41980204  blt cr6, 0x821b80a0
	if ctx.cr[6].lt {
	pc = 0x821B80A0; continue 'dispatch;
	}
	// 821B7EA0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7EA4: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7EA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B7EAC: 419901F4  bgt cr6, 0x821b80a0
	if ctx.cr[6].gt {
	pc = 0x821B80A0; continue 'dispatch;
	}
	// 821B7EB0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B7EB4: C0A4000C  lfs f5, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821B7EB8: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 821B7EBC: C085000C  lfs f4, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821B7EC0: 38A30020  addi r5, r3, 0x20
	ctx.r[5].s64 = ctx.r[3].s64 + 32;
	// 821B7EC4: 8121FFDC  lwz r9, -0x24(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-36 as u32) ) } as u64;
	// 821B7EC8: 3BC1FFD0  addi r30, r1, -0x30
	ctx.r[30].s64 = ctx.r[1].s64 + -48;
	// 821B7ECC: 8101FFEC  lwz r8, -0x14(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 821B7ED0: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B7ED4: 396B6230  addi r11, r11, 0x6230
	ctx.r[11].s64 = ctx.r[11].s64 + 25136;
	// 821B7ED8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7EDC: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7EE0: EC6B0032  fmuls f3, f11, f0
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7EE4: ECA50032  fmuls f5, f5, f0
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7EE8: EC08637A  fmadds f0, f8, f13, f12
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 821B7EEC: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B7EF0: ED864B7A  fmadds f12, f6, f13, f9
	ctx.f[12].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B7EF4: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B7EF8: ED271B7A  fmadds f9, f7, f13, f3
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[3].f64) as f32) as f64);
	// 821B7EFC: D1260000  stfs f9, 0(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B7F00: ED642B7A  fmadds f11, f4, f13, f5
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7F04: D166000C  stfs f11, 0xc(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B80B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B80B0 size=60
    let mut pc: u32 = 0x821B80B0;
    'dispatch: loop {
        match pc {
            0x821B80B0 => {
    //   block [0x821B80B0..0x821B80EC)
	// 821B80B0: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 821B80B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B80B8: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 821B80BC: 7C690194  addze r3, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[3].s64 = tmp.s64;
	// 821B80C0: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B80C4: 7D29282E  lwzx r9, r9, r5
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821B80C8: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B80CC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821B80D0: 4098001C  bge cr6, 0x821b80ec
	if !ctx.cr[6].lt {
		sub_821B80EC(ctx, base);
		return;
	}
	// 821B80D4: 7D235A14  add r9, r3, r11
	ctx.r[9].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 821B80D8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B80DC: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 821B80E0: 7C690194  addze r3, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[3].s64 = tmp.s64;
	// 821B80E4: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 821B80E8: 48000024  b 0x821b810c
	sub_821B80F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B80EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B80EC size=12
    let mut pc: u32 = 0x821B80EC;
    'dispatch: loop {
        match pc {
            0x821B80EC => {
    //   block [0x821B80EC..0x821B80F8)
	// 821B80EC: C0090004  lfs f0, 4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B80F0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821B80F4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B80F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B80F8 size=28
    let mut pc: u32 = 0x821B80F8;
    'dispatch: loop {
        match pc {
            0x821B80F8 => {
    //   block [0x821B80F8..0x821B8114)
	// 821B80F8: 7D235214  add r9, r3, r10
	ctx.r[9].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 821B80FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B8100: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 821B8104: 7C690194  addze r3, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[3].s64 = tmp.s64;
	// 821B8108: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 821B810C: 409AFFB4  bne cr6, 0x821b80c0
	if !ctx.cr[6].eq {
		sub_821B80B0(ctx, base);
		return;
	}
	// 821B8110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B8118 size=80
    let mut pc: u32 = 0x821B8118;
    'dispatch: loop {
        match pc {
            0x821B8118 => {
    //   block [0x821B8118..0x821B8168)
	// 821B8118: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B811C: 396BCD68  addi r11, r11, -0x3298
	ctx.r[11].s64 = ctx.r[11].s64 + -12952;
	// 821B8120: 894B0208  lbz r10, 0x208(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(520 as u32) ) } as u64;
	// 821B8124: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8128: 419A0040  beq cr6, 0x821b8168
	if ctx.cr[6].eq {
		sub_821B8168(ctx, base);
		return;
	}
	// 821B812C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8130: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B8134: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821B8138: 41980030  blt cr6, 0x821b8168
	if ctx.cr[6].lt {
		sub_821B8168(ctx, base);
		return;
	}
	// 821B813C: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B8140: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 821B8144: 41990024  bgt cr6, 0x821b8168
	if ctx.cr[6].gt {
		sub_821B8168(ctx, base);
		return;
	}
	// 821B8148: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B814C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B8150: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 821B8154: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821B8158: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821B815C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821B8160: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821B8164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B8168 size=8
    let mut pc: u32 = 0x821B8168;
    'dispatch: loop {
        match pc {
            0x821B8168 => {
    //   block [0x821B8168..0x821B8170)
	// 821B8168: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821B816C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B8170 size=820
    let mut pc: u32 = 0x821B8170;
    'dispatch: loop {
        match pc {
            0x821B8170 => {
    //   block [0x821B8170..0x821B84A4)
	// 821B8170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8174: 4837CF0D  bl 0x82535080
	ctx.lr = 0x821B8178;
	sub_82535080(ctx, base);
	// 821B8178: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821B817C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B8180: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B8184: 7CAF2B78  mr r15, r5
	ctx.r[15].u64 = ctx.r[5].u64;
	// 821B8188: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 821B818C: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 821B8190: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B8194: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B8198: 922F0000  stw r17, 0(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 821B819C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B81A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B81A4: 4E800421  bctrl
	ctx.lr = 0x821B81A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B81A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B81AC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B81B0: 92210050  stw r17, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[17].u32 ) };
	// 821B81B4: 7E2E8B78  mr r14, r17
	ctx.r[14].u64 = ctx.r[17].u64;
	// 821B81B8: C3EB2190  lfs f31, 0x2190(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B81BC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B81C0: C03A0030  lfs f1, 0x30(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B81C4: 3B8BCD68  addi r28, r11, -0x3298
	ctx.r[28].s64 = ctx.r[11].s64 + -12952;
	// 821B81C8: C19A0038  lfs f12, 0x38(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B81CC: 3D7D0002  addis r11, r29, 2
	ctx.r[11].s64 = ctx.r[29].s64 + 131072;
	// 821B81D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B81D4: 396BEB34  addi r11, r11, -0x14cc
	ctx.r[11].s64 = ctx.r[11].s64 + -5324;
	// 821B81D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B81DC: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B81E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B81E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B81E8: C00B2094  lfs f0, 0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B81EC: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B81F0: 3BEB6230  addi r31, r11, 0x6230
	ctx.r[31].s64 = ctx.r[11].s64 + 25136;
	// 821B81F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B81F8: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B81FC: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B8200: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B8204: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B8208: D03F0010  stfs f1, 0x10(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821B820C: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B8210: C1AB233C  lfs f13, 0x233c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9020 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B8214: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B8218: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B821C: D03F0000  stfs f1, 0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B8220: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B8224: 4BFFFEF5  bl 0x821b8118
	ctx.lr = 0x821B8228;
	sub_821B8118(ctx, base);
	// 821B8228: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B822C: 41980268  blt cr6, 0x821b8494
	if ctx.cr[6].lt {
	pc = 0x821B8494; continue 'dispatch;
	}
	// 821B8230: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8234: A16B0028  lhz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B8238: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B823C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B8240: 40980254  bge cr6, 0x821b8494
	if !ctx.cr[6].lt {
	pc = 0x821B8494; continue 'dispatch;
	}
	// 821B8244: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B8248: FC206090  fmr f1, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[12].f64;
	// 821B824C: 395C0004  addi r10, r28, 4
	ctx.r[10].s64 = ctx.r[28].s64 + 4;
	// 821B8250: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B8254: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B8258: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B825C: A0CB0004  lhz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8260: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B8264: 4BFFFE4D  bl 0x821b80b0
	ctx.lr = 0x821B8268;
	sub_821B80B0(ctx, base);
	// 821B8268: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B826C: 419801DC  blt cr6, 0x821b8448
	if ctx.cr[6].lt {
	pc = 0x821B8448; continue 'dispatch;
	}
	// 821B8270: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B8274: 7E0BF02E  lwzx r16, r11, r30
	ctx.r[16].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821B8278: A1700008  lhz r11, 8(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B827C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8280: 419A01C8  beq cr6, 0x821b8448
	if ctx.cr[6].eq {
	pc = 0x821B8448; continue 'dispatch;
	}
	// 821B8284: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B8288: 3AD00010  addi r22, r16, 0x10
	ctx.r[22].s64 = ctx.r[16].s64 + 16;
	// 821B828C: 3B2B0C40  addi r25, r11, 0xc40
	ctx.r[25].s64 = ctx.r[11].s64 + 3136;
	// 821B8290: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B8294: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 821B8298: 3B6B1090  addi r27, r11, 0x1090
	ctx.r[27].s64 = ctx.r[11].s64 + 4240;
	// 821B829C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B82A0: 6177BE64  ori r23, r11, 0xbe64
	ctx.r[23].u64 = ctx.r[11].u64 | 48740;
	// 821B82A4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B82A8: 6174EB29  ori r20, r11, 0xeb29
	ctx.r[20].u64 = ctx.r[11].u64 | 60201;
	// 821B82AC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B82B0: 6175EB33  ori r21, r11, 0xeb33
	ctx.r[21].u64 = ctx.r[11].u64 | 60211;
	// 821B82B4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B82B8: 6172F328  ori r18, r11, 0xf328
	ctx.r[18].u64 = ctx.r[11].u64 | 62248;
	// 821B82BC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B82C0: 6173D330  ori r19, r11, 0xd330
	ctx.r[19].u64 = ctx.r[11].u64 | 54064;
	// 821B82C4: 81160000  lwz r8, 0(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B82C8: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 821B82CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B82D0: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 821B82D4: 480001D5  bl 0x821b84a8
	ctx.lr = 0x821B82D8;
	sub_821B84A8(ctx, base);
	// 821B82D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B82DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B82E0: 419A0148  beq cr6, 0x821b8428
	if ctx.cr[6].eq {
	pc = 0x821B8428; continue 'dispatch;
	}
	// 821B82E4: 7FDDBA14  add r30, r29, r23
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[23].u64;
	// 821B82E8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B82EC: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B82F0: 419A0038  beq cr6, 0x821b8328
	if ctx.cr[6].eq {
	pc = 0x821B8328; continue 'dispatch;
	}
	// 821B82F4: 8928000C  lbz r9, 0xc(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B82F8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B82FC: 81590688  lwz r10, 0x688(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B8300: 5527073E  clrlwi r7, r9, 0x1c
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 821B8304: 393B00D8  addi r9, r27, 0xd8
	ctx.r[9].s64 = ctx.r[27].s64 + 216;
	// 821B8308: 7CCB482E  lwzx r6, r11, r9
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B830C: 7F065040  cmplw cr6, r6, r10
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B8310: 419A0018  beq cr6, 0x821b8328
	if ctx.cr[6].eq {
	pc = 0x821B8328; continue 'dispatch;
	}
	// 821B8314: 2F07000F  cmpwi cr6, r7, 0xf
	ctx.cr[6].compare_i32(ctx.r[7].s32, 15, &mut ctx.xer);
	// 821B8318: 419A0010  beq cr6, 0x821b8328
	if ctx.cr[6].eq {
	pc = 0x821B8328; continue 'dispatch;
	}
	// 821B831C: 38DB00C8  addi r6, r27, 0xc8
	ctx.r[6].s64 = ctx.r[27].s64 + 200;
	// 821B8320: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 821B8324: 7CEB312E  stwx r7, r11, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), ctx.r[7].u32) };
	// 821B8328: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B832C: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B8330: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B8334: 419A00F4  beq cr6, 0x821b8428
	if ctx.cr[6].eq {
	pc = 0x821B8428; continue 'dispatch;
	}
	// 821B8338: 8168001C  lwz r11, 0x1c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B833C: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B8340: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8344: 419A0010  beq cr6, 0x821b8354
	if ctx.cr[6].eq {
	pc = 0x821B8354; continue 'dispatch;
	}
	// 821B8348: C0080004  lfs f0, 4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B834C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B8350: 48000020  b 0x821b8370
	pc = 0x821B8370; continue 'dispatch;
	// 821B8354: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 821B8358: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B835C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821B8360: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B8364: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 821B8368: 4BFFF9F1  bl 0x821b7d58
	ctx.lr = 0x821B836C;
	sub_821B7D58(ctx, base);
	// 821B836C: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B8370: 8168001C  lwz r11, 0x1c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8374: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8378: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B837C: 419A001C  beq cr6, 0x821b8398
	if ctx.cr[6].eq {
	pc = 0x821B8398; continue 'dispatch;
	}
	// 821B8380: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B8384: 419A0040  beq cr6, 0x821b83c4
	if ctx.cr[6].eq {
	pc = 0x821B83C4; continue 'dispatch;
	}
	// 821B8388: 8148000C  lwz r10, 0xc(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B838C: 554AE63E  rlwinm r10, r10, 0x1c, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821B8390: 2F0A003A  cmpwi cr6, r10, 0x3a
	ctx.cr[6].compare_i32(ctx.r[10].s32, 58, &mut ctx.xer);
	// 821B8394: 409A0030  bne cr6, 0x821b83c4
	if !ctx.cr[6].eq {
	pc = 0x821B83C4; continue 'dispatch;
	}
	// 821B8398: C1BA0034  lfs f13, 0x34(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B839C: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 821B83A0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B83A4: 40980084  bge cr6, 0x821b8428
	if !ctx.cr[6].lt {
	pc = 0x821B8428; continue 'dispatch;
	}
	// 821B83A8: 7D7DA0AE  lbzx r11, r29, r20
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[20].u32)) } as u64;
	// 821B83AC: 7F1DA9AE  stbx r24, r29, r21
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[21].u32), ctx.r[24].u8) };
	// 821B83B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B83B4: 409A0074  bne cr6, 0x821b8428
	if !ctx.cr[6].eq {
	pc = 0x821B8428; continue 'dispatch;
	}
	// 821B83B8: 7C1D942E  lfsx f0, r29, r18
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[18].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B83BC: 7C1D9D2E  stfsx f0, r29, r19
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[19].u32), tmp.u32) };
	// 821B83C0: 48000068  b 0x821b8428
	pc = 0x821B8428; continue 'dispatch;
	// 821B83C4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B83C8: 419A0078  beq cr6, 0x821b8440
	if ctx.cr[6].eq {
	pc = 0x821B8440; continue 'dispatch;
	}
	// 821B83CC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B83D0: 419A0070  beq cr6, 0x821b8440
	if ctx.cr[6].eq {
	pc = 0x821B8440; continue 'dispatch;
	}
	// 821B83D4: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B83D8: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B83DC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B83E0: 409A0060  bne cr6, 0x821b8440
	if !ctx.cr[6].eq {
	pc = 0x821B8440; continue 'dispatch;
	}
	// 821B83E4: C1BA0034  lfs f13, 0x34(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B83E8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B83EC: 4098003C  bge cr6, 0x821b8428
	if !ctx.cr[6].lt {
	pc = 0x821B8428; continue 'dispatch;
	}
	// 821B83F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B83F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B83F8: 409A002C  bne cr6, 0x821b8424
	if !ctx.cr[6].eq {
	pc = 0x821B8424; continue 'dispatch;
	}
	// 821B83FC: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8400: 395C020C  addi r10, r28, 0x20c
	ctx.r[10].s64 = ctx.r[28].s64 + 524;
	// 821B8404: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B8408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B840C: 409A0018  bne cr6, 0x821b8424
	if !ctx.cr[6].eq {
	pc = 0x821B8424; continue 'dispatch;
	}
	// 821B8410: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B8414: 48168585  bl 0x82320998
	ctx.lr = 0x821B8418;
	sub_82320998(ctx, base);
	// 821B8418: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B841C: 395C020C  addi r10, r28, 0x20c
	ctx.r[10].s64 = ctx.r[28].s64 + 524;
	// 821B8420: 7F0B51AE  stbx r24, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[24].u8) };
	// 821B8424: 7F0EC378  mr r14, r24
	ctx.r[14].u64 = ctx.r[24].u64;
	// 821B8428: A1700008  lhz r11, 8(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B842C: 3A310001  addi r17, r17, 1
	ctx.r[17].s64 = ctx.r[17].s64 + 1;
	// 821B8430: 3AD60004  addi r22, r22, 4
	ctx.r[22].s64 = ctx.r[22].s64 + 4;
	// 821B8434: 7F115800  cmpw cr6, r17, r11
	ctx.cr[6].compare_i32(ctx.r[17].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B8438: 4198FE8C  blt cr6, 0x821b82c4
	if ctx.cr[6].lt {
	pc = 0x821B82C4; continue 'dispatch;
	}
	// 821B843C: 4800000C  b 0x821b8448
	pc = 0x821B8448; continue 'dispatch;
	// 821B8440: FFE00090  fmr f31, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[0].f64;
	// 821B8444: 910F0000  stw r8, 0(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B8448: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B844C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B8450: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8454: 614AEB32  ori r10, r10, 0xeb32
	ctx.r[10].u64 = ctx.r[10].u64 | 60210;
	// 821B8458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B845C: 7D7D51AE  stbx r11, r29, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u8) };
	// 821B8460: 409A002C  bne cr6, 0x821b848c
	if !ctx.cr[6].eq {
	pc = 0x821B848C; continue 'dispatch;
	}
	// 821B8464: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821B8468: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B846C: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 821B8470: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B8474: 4BF6E1A5  bl 0x82126618
	ctx.lr = 0x821B8478;
	sub_82126618(ctx, base);
	// 821B8478: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821B847C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B8480: 3880003B  li r4, 0x3b
	ctx.r[4].s64 = 59;
	// 821B8484: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B8488: 4BF6E191  bl 0x82126618
	ctx.lr = 0x821B848C;
	sub_82126618(ctx, base);
	// 821B848C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B8490: 99CA0000  stb r14, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[14].u8 ) };
	// 821B8494: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B8498: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821B849C: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 821B84A0: 4837CC30  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B84A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B84A8 size=144
    let mut pc: u32 = 0x821B84A8;
    'dispatch: loop {
        match pc {
            0x821B84A8 => {
    //   block [0x821B84A8..0x821B8538)
	// 821B84A8: C1850008  lfs f12, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B84AC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B84B0: C1650018  lfs f11, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B84B4: C1450000  lfs f10, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B84B8: ED6B6028  fsubs f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B84BC: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B84C0: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B84C4: ED005028  fsubs f8, f0, f10
	ctx.f[8].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 821B84C8: C1250010  lfs f9, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B84CC: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B84D0: ED295028  fsubs f9, f9, f10
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 821B84D4: ED6802F2  fmuls f11, f8, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B84D8: ED8C0272  fmuls f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 821B84DC: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 821B84E0: 41980008  blt cr6, 0x821b84e8
	if ctx.cr[6].lt {
	pc = 0x821B84E8; continue 'dispatch;
	}
	// 821B84E4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B84E8: C1850018  lfs f12, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B84EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B84F0: C1650010  lfs f11, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B84F4: C1250028  lfs f9, 0x28(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B84F8: ECE05828  fsubs f7, f0, f11
	ctx.f[7].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 821B84FC: C1050020  lfs f8, 0x20(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B8500: ED296028  fsubs f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B8504: ED685828  fsubs f11, f8, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 821B8508: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B850C: ED270272  fmuls f9, f7, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[9].f64) as f32) as f64);
	// 821B8510: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B8514: FF096000  fcmpu cr6, f9, f12
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[12].f64);
	// 821B8518: 41980008  blt cr6, 0x821b8520
	if ctx.cr[6].lt {
	pc = 0x821B8520; continue 'dispatch;
	}
	// 821B851C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B8520: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8524: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 821B8528: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B852C: 419A000C  beq cr6, 0x821b8538
	if ctx.cr[6].eq {
		sub_821B8538(ctx, base);
		return;
	}
	// 821B8530: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B8534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B8538 size=72
    let mut pc: u32 = 0x821B8538;
    'dispatch: loop {
        match pc {
            0x821B8538 => {
    //   block [0x821B8538..0x821B8580)
	// 821B8538: C1650020  lfs f11, 0x20(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B853C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B8540: C1850028  lfs f12, 0x28(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B8544: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 821B8548: C1250008  lfs f9, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B854C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821B8550: ED296028  fsubs f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B8554: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B8558: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 821B855C: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B8560: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B8564: 41980008  blt cr6, 0x821b856c
	if ctx.cr[6].lt {
	pc = 0x821B856C; continue 'dispatch;
	}
	// 821B8568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B856C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8570: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B8574: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B8578: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B857C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B8580 size=652
    let mut pc: u32 = 0x821B8580;
    'dispatch: loop {
        match pc {
            0x821B8580 => {
    //   block [0x821B8580..0x821B880C)
	// 821B8580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8584: 4837CB21  bl 0x825350a4
	ctx.lr = 0x821B8588;
	sub_82535080(ctx, base);
	// 821B8588: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B858C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821B8590: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 821B8594: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 821B8598: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 821B859C: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 821B85A0: 40980008  bge cr6, 0x821b85a8
	if !ctx.cr[6].lt {
	pc = 0x821B85A8; continue 'dispatch;
	}
	// 821B85A4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821B85A8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B85AC: 3BCB6230  addi r30, r11, 0x6230
	ctx.r[30].s64 = ctx.r[11].s64 + 25136;
	// 821B85B0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B85B4: 3BABCD68  addi r29, r11, -0x3298
	ctx.r[29].s64 = ctx.r[11].s64 + -12952;
	// 821B85B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B85BC: D03E0010  stfs f1, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821B85C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B85C4: D03E0000  stfs f1, 0(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B85C8: C00B2094  lfs f0, 0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B85CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B85D0: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B85D4: D05E0018  stfs f2, 0x18(r30)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B85D8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B85DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B85E0: D01E001C  stfs f0, 0x1c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B85E4: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B85E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B85EC: C1AB233C  lfs f13, 0x233c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9020 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B85F0: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B85F4: D05E0008  stfs f2, 8(r30)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B85F8: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B85FC: 4BFFFB1D  bl 0x821b8118
	ctx.lr = 0x821B8600;
	sub_821B8118(ctx, base);
	// 821B8600: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B8604: 419801B0  blt cr6, 0x821b87b4
	if ctx.cr[6].lt {
	pc = 0x821B87B4; continue 'dispatch;
	}
	// 821B8608: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B860C: A16B0028  lhz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B8610: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B8614: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B8618: 4098019C  bge cr6, 0x821b87b4
	if !ctx.cr[6].lt {
	pc = 0x821B87B4; continue 'dispatch;
	}
	// 821B861C: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B8620: FC201090  fmr f1, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821B8624: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 821B8628: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B862C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B8630: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8634: A0CB0004  lhz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8638: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B863C: 4BFFFA75  bl 0x821b80b0
	ctx.lr = 0x821B8640;
	sub_821B80B0(ctx, base);
	// 821B8640: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B8644: 41980170  blt cr6, 0x821b87b4
	if ctx.cr[6].lt {
	pc = 0x821B87B4; continue 'dispatch;
	}
	// 821B8648: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B864C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B8650: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821B8654: A3EB0008  lhz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8658: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B865C: 40990158  ble cr6, 0x821b87b4
	if !ctx.cr[6].gt {
	pc = 0x821B87B4; continue 'dispatch;
	}
	// 821B8660: 38EB0010  addi r7, r11, 0x10
	ctx.r[7].s64 = ctx.r[11].s64 + 16;
	// 821B8664: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B8668: 3F80F000  lis r28, -0x1000
	ctx.r[28].s64 = -268435456;
	// 821B866C: 3F600F00  lis r27, 0xf00
	ctx.r[27].s64 = 251658240;
	// 821B8670: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B8674: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8678: 8168001C  lwz r11, 0x1c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B867C: 556AA73E  rlwinm r10, r11, 0x14, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 821B8680: 7F0AC000  cmpw cr6, r10, r24
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[24].s32, &mut ctx.xer);
	// 821B8684: 409A0120  bne cr6, 0x821b87a4
	if !ctx.cr[6].eq {
	pc = 0x821B87A4; continue 'dispatch;
	}
	// 821B8688: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B868C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B8690: 419A0020  beq cr6, 0x821b86b0
	if ctx.cr[6].eq {
	pc = 0x821B86B0; continue 'dispatch;
	}
	// 821B8694: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B8698: 419A0010  beq cr6, 0x821b86a8
	if ctx.cr[6].eq {
	pc = 0x821B86A8; continue 'dispatch;
	}
	// 821B869C: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B86A0: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B86A4: 48000010  b 0x821b86b4
	pc = 0x821B86B4; continue 'dispatch;
	// 821B86A8: 3960003C  li r11, 0x3c
	ctx.r[11].s64 = 60;
	// 821B86AC: 48000008  b 0x821b86b4
	pc = 0x821B86B4; continue 'dispatch;
	// 821B86B0: 3960003A  li r11, 0x3a
	ctx.r[11].s64 = 58;
	// 821B86B4: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 821B86B8: 409A0010  bne cr6, 0x821b86c8
	if !ctx.cr[6].eq {
	pc = 0x821B86C8; continue 'dispatch;
	}
	// 821B86BC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B86C0: 409A00E4  bne cr6, 0x821b87a4
	if !ctx.cr[6].eq {
	pc = 0x821B87A4; continue 'dispatch;
	}
	// 821B86C4: 48000024  b 0x821b86e8
	pc = 0x821B86E8; continue 'dispatch;
	// 821B86C8: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 821B86CC: 419A000C  beq cr6, 0x821b86d8
	if ctx.cr[6].eq {
	pc = 0x821B86D8; continue 'dispatch;
	}
	// 821B86D0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B86D4: 419A00D0  beq cr6, 0x821b87a4
	if ctx.cr[6].eq {
	pc = 0x821B87A4; continue 'dispatch;
	}
	// 821B86D8: 2F1A0003  cmpwi cr6, r26, 3
	ctx.cr[6].compare_i32(ctx.r[26].s32, 3, &mut ctx.xer);
	// 821B86DC: 419A000C  beq cr6, 0x821b86e8
	if ctx.cr[6].eq {
	pc = 0x821B86E8; continue 'dispatch;
	}
	// 821B86E0: 2F0B003A  cmpwi cr6, r11, 0x3a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 58, &mut ctx.xer);
	// 821B86E4: 419A00C0  beq cr6, 0x821b87a4
	if ctx.cr[6].eq {
	pc = 0x821B87A4; continue 'dispatch;
	}
	// 821B86E8: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 821B86EC: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 821B86F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B86F4: 4BFFFDB5  bl 0x821b84a8
	ctx.lr = 0x821B86F8;
	sub_821B84A8(ctx, base);
	// 821B86F8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B86FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8700: 419A00A4  beq cr6, 0x821b87a4
	if ctx.cr[6].eq {
	pc = 0x821B87A4; continue 'dispatch;
	}
	// 821B8704: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B8708: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B870C: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821B8710: 409A0088  bne cr6, 0x821b8798
	if !ctx.cr[6].eq {
	pc = 0x821B8798; continue 'dispatch;
	}
	// 821B8714: 56EA063E  clrlwi r10, r23, 0x18
	ctx.r[10].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 821B8718: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B871C: 419A0088  beq cr6, 0x821b87a4
	if ctx.cr[6].eq {
	pc = 0x821B87A4; continue 'dispatch;
	}
	// 821B8720: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 821B8724: 419A0064  beq cr6, 0x821b8788
	if ctx.cr[6].eq {
	pc = 0x821B8788; continue 'dispatch;
	}
	// 821B8728: 2F1A0005  cmpwi cr6, r26, 5
	ctx.cr[6].compare_i32(ctx.r[26].s32, 5, &mut ctx.xer);
	// 821B872C: 419A004C  beq cr6, 0x821b8778
	if ctx.cr[6].eq {
	pc = 0x821B8778; continue 'dispatch;
	}
	// 821B8730: 2F1A0006  cmpwi cr6, r26, 6
	ctx.cr[6].compare_i32(ctx.r[26].s32, 6, &mut ctx.xer);
	// 821B8734: 409A0070  bne cr6, 0x821b87a4
	if !ctx.cr[6].eq {
	pc = 0x821B87A4; continue 'dispatch;
	}
	// 821B8738: A168001C  lhz r11, 0x1c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B873C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8740: 419A0064  beq cr6, 0x821b87a4
	if ctx.cr[6].eq {
	pc = 0x821B87A4; continue 'dispatch;
	}
	// 821B8744: 556A181A  rlwinm r10, r11, 3, 0, 0xd
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821B8748: 556905BE  clrlwi r9, r11, 0x16
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 821B874C: 556BB6FE  rlwinm r11, r11, 0x16, 0x1b, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 821B8750: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821B8754: 396B0070  addi r11, r11, 0x70
	ctx.r[11].s64 = ctx.r[11].s64 + 112;
	// 821B8758: 554A6824  slwi r10, r10, 0xd
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(13);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B875C: 556BB850  rlwinm r11, r11, 0x17, 1, 8
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	// 821B8760: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821B8764: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B8768: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B876C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 821B8770: 41990090  bgt cr6, 0x821b8800
	if ctx.cr[6].gt {
	pc = 0x821B8800; continue 'dispatch;
	}
	// 821B8774: 48000030  b 0x821b87a4
	pc = 0x821B87A4; continue 'dispatch;
	// 821B8778: 556B0006  rlwinm r11, r11, 0, 0, 3
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B877C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B8780: 409A0080  bne cr6, 0x821b8800
	if !ctx.cr[6].eq {
	pc = 0x821B8800; continue 'dispatch;
	}
	// 821B8784: 48000020  b 0x821b87a4
	pc = 0x821B87A4; continue 'dispatch;
	// 821B8788: 556B010E  rlwinm r11, r11, 0, 4, 7
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B878C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821B8790: 409A0070  bne cr6, 0x821b8800
	if !ctx.cr[6].eq {
	pc = 0x821B8800; continue 'dispatch;
	}
	// 821B8794: 48000010  b 0x821b87a4
	pc = 0x821B87A4; continue 'dispatch;
	// 821B8798: 56EB063E  clrlwi r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 821B879C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B87A0: 419A0024  beq cr6, 0x821b87c4
	if ctx.cr[6].eq {
	pc = 0x821B87C4; continue 'dispatch;
	}
	// 821B87A4: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821B87A8: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 821B87AC: 7F06F800  cmpw cr6, r6, r31
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[31].s32, &mut ctx.xer);
	// 821B87B0: 4198FEC4  blt cr6, 0x821b8674
	if ctx.cr[6].lt {
	pc = 0x821B8674; continue 'dispatch;
	}
	// 821B87B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B87B8: C02B2190  lfs f1, 0x2190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B87BC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B87C0: 4837C934  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
	// 821B87C4: 8168001C  lwz r11, 0x1c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B87C8: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B87CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B87D0: 419A0014  beq cr6, 0x821b87e4
	if ctx.cr[6].eq {
	pc = 0x821B87E4; continue 'dispatch;
	}
	// 821B87D4: C0280004  lfs f1, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B87D8: 91190000  stw r8, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B87DC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B87E0: 4837C914  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
	// 821B87E4: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 821B87E8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B87EC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821B87F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B87F4: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 821B87F8: 4BFFF561  bl 0x821b7d58
	ctx.lr = 0x821B87FC;
	sub_821B7D58(ctx, base);
	// 821B87FC: C0210064  lfs f1, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B8800: 91190000  stw r8, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B8804: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B8808: 4837C8EC  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B8810 size=296
    let mut pc: u32 = 0x821B8810;
    'dispatch: loop {
        match pc {
            0x821B8810 => {
    //   block [0x821B8810..0x821B8938)
	// 821B8810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8814: 4837C895  bl 0x825350a8
	ctx.lr = 0x821B8818;
	sub_82535080(ctx, base);
	// 821B8818: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 821B881C: 4837D7CD  bl 0x82535fe8
	ctx.lr = 0x821B8820;
	sub_82535FB0(ctx, base);
	// 821B8820: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B8824: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B8828: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821B882C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821B8830: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821B8834: 3B4BCF90  addi r26, r11, -0x3070
	ctx.r[26].s64 = ctx.r[11].s64 + -12400;
	// 821B8838: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821B883C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B8840: 3B8B4170  addi r28, r11, 0x4170
	ctx.r[28].s64 = ctx.r[11].s64 + 16752;
	// 821B8844: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B8848: C389BA38  lfs f28, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B884C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 821B8850: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 821B8854: C3AA1FF8  lfs f29, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B8858: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821B885C: 3BBA0800  addi r29, r26, 0x800
	ctx.r[29].s64 = ctx.r[26].s64 + 2048;
	// 821B8860: 3BCBCD68  addi r30, r11, -0x3298
	ctx.r[30].s64 = ctx.r[11].s64 + -12952;
	// 821B8864: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821B8868: 397E0209  addi r11, r30, 0x209
	ctx.r[11].s64 = ctx.r[30].s64 + 521;
	// 821B886C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821B8870: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B8874: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821B8878: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821B887C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821B8880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8884: 419A0060  beq cr6, 0x821b88e4
	if ctx.cr[6].eq {
	pc = 0x821B88E4; continue 'dispatch;
	}
	// 821B8888: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 821B888C: 41980014  blt cr6, 0x821b88a0
	if ctx.cr[6].lt {
	pc = 0x821B88A0; continue 'dispatch;
	}
	// 821B8890: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 821B8894: 4199000C  bgt cr6, 0x821b88a0
	if ctx.cr[6].gt {
	pc = 0x821B88A0; continue 'dispatch;
	}
	// 821B8898: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B889C: 48000018  b 0x821b88b4
	pc = 0x821B88B4; continue 'dispatch;
	// 821B88A0: D3BC0000  stfs f29, 0(r28)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B88A4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B88A8: D3BC0004  stfs f29, 4(r28)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B88AC: D3BC0008  stfs f29, 8(r28)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B88B0: D39C000C  stfs f28, 0xc(r28)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B88B4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B88B8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 821B88BC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B88C0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B88C4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B88C8: EC3F0028  fsubs f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B88CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B88D0: EC5E6828  fsubs f2, f30, f13
	ctx.f[2].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B88D4: 4BFFFCAD  bl 0x821b8580
	ctx.lr = 0x821B88D8;
	sub_821B8580(ctx, base);
	// 821B88D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B88DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B88E0: 409A0044  bne cr6, 0x821b8924
	if !ctx.cr[6].eq {
	pc = 0x821B8924; continue 'dispatch;
	}
	// 821B88E4: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 821B88E8: 397A0810  addi r11, r26, 0x810
	ctx.r[11].s64 = ctx.r[26].s64 + 2064;
	// 821B88EC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B88F0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B88F4: 4099FF74  ble cr6, 0x821b8868
	if !ctx.cr[6].gt {
	pc = 0x821B8868; continue 'dispatch;
	}
	// 821B88F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B88FC: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821B8900: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B8904: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B8908: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 821B890C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B8910: 4BFFFC71  bl 0x821b8580
	ctx.lr = 0x821B8914;
	sub_821B8580(ctx, base);
	// 821B8914: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B8918: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 821B891C: 4837D719  bl 0x82536034
	ctx.lr = 0x821B8920;
	sub_82535FFC(ctx, base);
	// 821B8920: 4837C7D8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
	// 821B8924: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B8928: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B892C: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 821B8930: 4837D705  bl 0x82536034
	ctx.lr = 0x821B8934;
	sub_82535FFC(ctx, base);
	// 821B8934: 4837C7C4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B8938 size=756
    let mut pc: u32 = 0x821B8938;
    'dispatch: loop {
        match pc {
            0x821B8938 => {
    //   block [0x821B8938..0x821B8C2C)
	// 821B8938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B893C: 4837C745  bl 0x82535080
	ctx.lr = 0x821B8940;
	sub_82535080(ctx, base);
	// 821B8940: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821B8944: 4837D6A5  bl 0x82535fe8
	ctx.lr = 0x821B8948;
	sub_82535FB0(ctx, base);
	// 821B8948: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B894C: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 821B8950: 9101015C  stw r8, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[8].u32 ) };
	// 821B8954: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 821B8958: 7CF33B78  mr r19, r7
	ctx.r[19].u64 = ctx.r[7].u64;
	// 821B895C: 7D515378  mr r17, r10
	ctx.r[17].u64 = ctx.r[10].u64;
	// 821B8960: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821B8964: 4198023C  blt cr6, 0x821b8ba0
	if ctx.cr[6].lt {
	pc = 0x821B8BA0; continue 'dispatch;
	}
	// 821B8968: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B896C: 3B8BCD68  addi r28, r11, -0x3298
	ctx.r[28].s64 = ctx.r[11].s64 + -12952;
	// 821B8970: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8974: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 821B8978: A16B0028  lhz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B897C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B8980: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B8984: 4098021C  bge cr6, 0x821b8ba0
	if !ctx.cr[6].lt {
	pc = 0x821B8BA0; continue 'dispatch;
	}
	// 821B8988: C0150008  lfs f0, 8(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B898C: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 821B8990: C1B40008  lfs f13, 8(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B8994: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B8998: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B899C: FFCC036E  fsel f30, f12, f13, f0
	ctx.f[30].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 821B89A0: FFAC682E  fsel f29, f12, f0, f13
	ctx.f[29].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 821B89A4: 41980008  blt cr6, 0x821b89ac
	if ctx.cr[6].lt {
	pc = 0x821B89AC; continue 'dispatch;
	}
	// 821B89A8: 3AE0FFFF  li r23, -1
	ctx.r[23].s64 = -1;
	// 821B89AC: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 821B89B0: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B89B4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B89B8: 391C0004  addi r8, r28, 4
	ctx.r[8].s64 = ctx.r[28].s64 + 4;
	// 821B89BC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B89C0: 696A0001  xori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 ^ 1;
	// 821B89C4: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B89C8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821B89CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B89D0: A36B000C  lhz r27, 0xc(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B89D4: 820B0008  lwz r16, 8(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B89D8: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 821B89DC: 409A0010  bne cr6, 0x821b89ec
	if !ctx.cr[6].eq {
	pc = 0x821B89EC; continue 'dispatch;
	}
	// 821B89E0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B89E4: A3AB0004  lhz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B89E8: 4800000C  b 0x821b89f4
	pc = 0x821B89F4; continue 'dispatch;
	// 821B89EC: 7E1E8378  mr r30, r16
	ctx.r[30].u64 = ctx.r[16].u64;
	// 821B89F0: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 821B89F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B89F8: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 821B89FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B8A00: C38BBA38  lfs f28, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B8A04: FFE0E090  fmr f31, f28
	ctx.f[31].f64 = ctx.f[28].f64;
	// 821B8A08: 419A0198  beq cr6, 0x821b8ba0
	if ctx.cr[6].eq {
	pc = 0x821B8BA0; continue 'dispatch;
	}
	// 821B8A0C: 81E1017C  lwz r15, 0x17c(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 821B8A10: 81C10174  lwz r14, 0x174(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 821B8A14: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B8A18: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821B8A1C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B8A20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B8A24: 4BFFF68D  bl 0x821b80b0
	ctx.lr = 0x821B8A28;
	sub_821B80B0(ctx, base);
	// 821B8A28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B8A2C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B8A30: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821B8A34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B8A38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B8A3C: 4BFFF675  bl 0x821b80b0
	ctx.lr = 0x821B8A40;
	sub_821B80B0(ctx, base);
	// 821B8A40: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 821B8A44: 40980010  bge cr6, 0x821b8a54
	if !ctx.cr[6].lt {
	pc = 0x821B8A54; continue 'dispatch;
	}
	// 821B8A48: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821B8A4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B8A50: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821B8A54: 7EC3B9D6  mullw r22, r3, r23
	ctx.r[22].s64 = (ctx.r[3].s32 as i64) * (ctx.r[23].s32 as i64);
	// 821B8A58: 7D7FB9D6  mullw r11, r31, r23
	ctx.r[11].s64 = (ctx.r[31].s32 as i64) * (ctx.r[23].s32 as i64);
	// 821B8A5C: 7F0BB000  cmpw cr6, r11, r22
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[22].s32, &mut ctx.xer);
	// 821B8A60: 4199011C  bgt cr6, 0x821b8b7c
	if ctx.cr[6].gt {
	pc = 0x821B8B7C; continue 'dispatch;
	}
	// 821B8A64: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B8A68: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 821B8A6C: 7F37B9D6  mullw r25, r23, r23
	ctx.r[25].s64 = (ctx.r[23].s32 as i64) * (ctx.r[23].s32 as i64);
	// 821B8A70: 56F8103A  slwi r24, r23, 2
	ctx.r[24].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 821B8A74: 7F6AF214  add r27, r10, r30
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821B8A78: 839B0000  lwz r28, 0(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8A7C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B8A80: A17C0008  lhz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8A88: 419A00DC  beq cr6, 0x821b8b64
	if ctx.cr[6].eq {
	pc = 0x821B8B64; continue 'dispatch;
	}
	// 821B8A8C: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 821B8A90: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8A94: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8A98: 556AA73E  rlwinm r10, r11, 0x14, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 821B8A9C: 7F0A8800  cmpw cr6, r10, r17
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[17].s32, &mut ctx.xer);
	// 821B8AA0: 409A00A8  bne cr6, 0x821b8b48
	if !ctx.cr[6].eq {
	pc = 0x821B8B48; continue 'dispatch;
	}
	// 821B8AA4: 556AC73E  rlwinm r10, r11, 0x18, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8AA8: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 821B8AAC: 419A009C  beq cr6, 0x821b8b48
	if ctx.cr[6].eq {
	pc = 0x821B8B48; continue 'dispatch;
	}
	// 821B8AB0: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821B8AB4: 419A0020  beq cr6, 0x821b8ad4
	if ctx.cr[6].eq {
	pc = 0x821B8AD4; continue 'dispatch;
	}
	// 821B8AB8: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821B8ABC: 419A0010  beq cr6, 0x821b8acc
	if ctx.cr[6].eq {
	pc = 0x821B8ACC; continue 'dispatch;
	}
	// 821B8AC0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B8AC4: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B8AC8: 48000010  b 0x821b8ad8
	pc = 0x821B8AD8; continue 'dispatch;
	// 821B8ACC: 3960003C  li r11, 0x3c
	ctx.r[11].s64 = 60;
	// 821B8AD0: 48000008  b 0x821b8ad8
	pc = 0x821B8AD8; continue 'dispatch;
	// 821B8AD4: 3960003A  li r11, 0x3a
	ctx.r[11].s64 = 58;
	// 821B8AD8: 7F0B7000  cmpw cr6, r11, r14
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[14].s32, &mut ctx.xer);
	// 821B8ADC: 419A006C  beq cr6, 0x821b8b48
	if ctx.cr[6].eq {
	pc = 0x821B8B48; continue 'dispatch;
	}
	// 821B8AE0: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821B8AE4: 419A0020  beq cr6, 0x821b8b04
	if ctx.cr[6].eq {
	pc = 0x821B8B04; continue 'dispatch;
	}
	// 821B8AE8: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821B8AEC: 419A0010  beq cr6, 0x821b8afc
	if ctx.cr[6].eq {
	pc = 0x821B8AFC; continue 'dispatch;
	}
	// 821B8AF0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B8AF4: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B8AF8: 48000010  b 0x821b8b08
	pc = 0x821B8B08; continue 'dispatch;
	// 821B8AFC: 3960003C  li r11, 0x3c
	ctx.r[11].s64 = 60;
	// 821B8B00: 48000008  b 0x821b8b08
	pc = 0x821B8B08; continue 'dispatch;
	// 821B8B04: 3960003A  li r11, 0x3a
	ctx.r[11].s64 = 58;
	// 821B8B08: 7F0B7800  cmpw cr6, r11, r15
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[15].s32, &mut ctx.xer);
	// 821B8B0C: 419A003C  beq cr6, 0x821b8b48
	if ctx.cr[6].eq {
	pc = 0x821B8B48; continue 'dispatch;
	}
	// 821B8B10: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 821B8B14: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 821B8B18: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 821B8B1C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 821B8B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B8B24: 4BFFF305  bl 0x821b7e28
	ctx.lr = 0x821B8B28;
	sub_821B7E28(ctx, base);
	// 821B8B28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B8B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8B30: 419A0018  beq cr6, 0x821b8b48
	if ctx.cr[6].eq {
	pc = 0x821B8B48; continue 'dispatch;
	}
	// 821B8B34: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B8B38: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B8B3C: 4098000C  bge cr6, 0x821b8b48
	if !ctx.cr[6].lt {
	pc = 0x821B8B48; continue 'dispatch;
	}
	// 821B8B40: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 821B8B44: 7FF2FB78  mr r18, r31
	ctx.r[18].u64 = ctx.r[31].u64;
	// 821B8B48: A17C0008  lhz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8B4C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821B8B50: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B8B54: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B8B58: 4198FF38  blt cr6, 0x821b8a90
	if ctx.cr[6].lt {
	pc = 0x821B8A90; continue 'dispatch;
	}
	// 821B8B5C: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 821B8B60: 409A0054  bne cr6, 0x821b8bb4
	if !ctx.cr[6].eq {
	pc = 0x821B8BB4; continue 'dispatch;
	}
	// 821B8B64: 7F59D214  add r26, r25, r26
	ctx.r[26].u64 = ctx.r[25].u64 + ctx.r[26].u64;
	// 821B8B68: 7F78DA14  add r27, r24, r27
	ctx.r[27].u64 = ctx.r[24].u64 + ctx.r[27].u64;
	// 821B8B6C: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 821B8B70: 4099FF08  ble cr6, 0x821b8a78
	if !ctx.cr[6].gt {
	pc = 0x821B8A78; continue 'dispatch;
	}
	// 821B8B74: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B8B78: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B8B7C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B8B80: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B8B84: 409A001C  bne cr6, 0x821b8ba0
	if !ctx.cr[6].eq {
	pc = 0x821B8BA0; continue 'dispatch;
	}
	// 821B8B88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B8B8C: 7E1E8378  mr r30, r16
	ctx.r[30].u64 = ctx.r[16].u64;
	// 821B8B90: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 821B8B94: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 821B8B98: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B8B9C: 409AFE78  bne cr6, 0x821b8a14
	if !ctx.cr[6].eq {
	pc = 0x821B8A14; continue 'dispatch;
	}
	// 821B8BA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B8BA4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821B8BA8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821B8BAC: 4837D489  bl 0x82536034
	ctx.lr = 0x821B8BB0;
	sub_82535FFC(ctx, base);
	// 821B8BB0: 4837C520  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
	// 821B8BB4: 8161015C  lwz r11, 0x15c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 821B8BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8BBC: 419A0008  beq cr6, 0x821b8bc4
	if ctx.cr[6].eq {
	pc = 0x821B8BC4; continue 'dispatch;
	}
	// 821B8BC0: D3EB0000  stfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B8BC4: EC1CF828  fsubs f0, f28, f31
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B8BC8: C1B50004  lfs f13, 4(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B8BCC: C1950008  lfs f12, 8(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B8BD0: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 821B8BD4: C175000C  lfs f11, 0xc(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B8BD8: C0F50000  lfs f7, 0(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B8BDC: C1540004  lfs f10, 4(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B8BE0: C1340008  lfs f9, 8(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B8BE4: C114000C  lfs f8, 0xc(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B8BE8: C0D40000  lfs f6, 0(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B8BEC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B8BF0: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B8BF4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B8BF8: ECE70032  fmuls f7, f7, f0
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B8BFC: EC0A6FFA  fmadds f0, f10, f31, f13
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B8C00: D0130004  stfs f0, 4(r19)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B8C04: EDA967FA  fmadds f13, f9, f31, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 821B8C08: D1B30008  stfs f13, 8(r19)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B8C0C: ED885FFA  fmadds f12, f8, f31, f11
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 821B8C10: D193000C  stfs f12, 0xc(r19)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B8C14: ED7F39BA  fmadds f11, f31, f6, f7
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[6].f64 + ctx.f[7].f64) as f32) as f64);
	// 821B8C18: D1730000  stfs f11, 0(r19)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B8C1C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821B8C20: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821B8C24: 4837D411  bl 0x82536034
	ctx.lr = 0x821B8C28;
	sub_82535FFC(ctx, base);
	// 821B8C28: 4837C4A8  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B8C30 size=20
    let mut pc: u32 = 0x821B8C30;
    'dispatch: loop {
        match pc {
            0x821B8C30 => {
    //   block [0x821B8C30..0x821B8C44)
	// 821B8C30: 8964000A  lbz r11, 0xa(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(10 as u32) ) } as u64;
	// 821B8C34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C38: 419A000C  beq cr6, 0x821b8c44
	if ctx.cr[6].eq {
		sub_821B8C44(ctx, base);
		return;
	}
	// 821B8C3C: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 821B8C40: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8C44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B8C44 size=80
    let mut pc: u32 = 0x821B8C44;
    'dispatch: loop {
        match pc {
            0x821B8C44 => {
    //   block [0x821B8C44..0x821B8C94)
	// 821B8C44: A1640008  lhz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8C48: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B8C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C50: 419A0038  beq cr6, 0x821b8c88
	if ctx.cr[6].eq {
	pc = 0x821B8C88; continue 'dispatch;
	}
	// 821B8C54: 3D2082CF  lis r9, -0x7d31
	ctx.r[9].s64 = -2100363264;
	// 821B8C58: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 821B8C5C: 38E9CD68  addi r7, r9, -0x3298
	ctx.r[7].s64 = ctx.r[9].s64 + -12952;
	// 821B8C60: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8C64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B8C68: 5528303E  rotlwi r8, r9, 6
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(6)) as u64;
	// 821B8C6C: 81270204  lwz r9, 0x204(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(516 as u32) ) } as u64;
	// 821B8C70: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821B8C74: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B8C78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B8C7C: A1240008  lhz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8C80: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B8C84: 4198FFDC  blt cr6, 0x821b8c60
	if ctx.cr[6].lt {
	pc = 0x821B8C60; continue 'dispatch;
	}
	// 821B8C88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B8C8C: 9964000A  stb r11, 0xa(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(10 as u32), ctx.r[11].u8 ) };
	// 821B8C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B8C98 size=1244
    let mut pc: u32 = 0x821B8C98;
    'dispatch: loop {
        match pc {
            0x821B8C98 => {
    //   block [0x821B8C98..0x821B9174)
	// 821B8C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8C9C: 4837C419  bl 0x825350b4
	ctx.lr = 0x821B8CA0;
	sub_82535080(ctx, base);
	// 821B8CA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B8CA4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B8CA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B8CAC: 3BCBCD68  addi r30, r11, -0x3298
	ctx.r[30].s64 = ctx.r[11].s64 + -12952;
	// 821B8CB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B8CB4: 480004C5  bl 0x821b9178
	ctx.lr = 0x821B8CB8;
	sub_821B9178(ctx, base);
	// 821B8CB8: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 821B8CBC: A15F0028  lhz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B8CC0: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	// 821B8CC4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821B8CC8: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821B8CCC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B8CD0: 55492036  slwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B8CD4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821B8CD8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B8CDC: 7F895A14  add r28, r9, r11
	ctx.r[28].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821B8CE0: 40990044  ble cr6, 0x821b8d24
	if !ctx.cr[6].gt {
	pc = 0x821B8D24; continue 'dispatch;
	}
	// 821B8CE4: 397D0006  addi r11, r29, 6
	ctx.r[11].s64 = ctx.r[29].s64 + 6;
	// 821B8CE8: A12BFFFC  lhz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821B8CEC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B8CF0: A0EB0004  lhz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8CF4: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8CF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8CFC: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 821B8D00: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821B8D04: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821B8D08: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B8D0C: 39290027  addi r9, r9, 0x27
	ctx.r[9].s64 = ctx.r[9].s64 + 39;
	// 821B8D10: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821B8D14: 7D290194  addze r9, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[9].s64 = tmp.s64;
	// 821B8D18: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B8D1C: 7C892214  add r4, r9, r4
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 821B8D20: 409AFFC8  bne cr6, 0x821b8ce8
	if !ctx.cr[6].eq {
	pc = 0x821B8CE8; continue 'dispatch;
	}
	// 821B8D24: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B8D28: 387E0210  addi r3, r30, 0x210
	ctx.r[3].s64 = ctx.r[30].s64 + 528;
	// 821B8D2C: 3BEB0FDC  addi r31, r11, 0xfdc
	ctx.r[31].s64 = ctx.r[11].s64 + 4060;
	// 821B8D30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B8D34: 4BFC493D  bl 0x8217d670
	ctx.lr = 0x821B8D38;
	sub_8217D670(ctx, base);
	// 821B8D38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8D3C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B8D40: A14B0028  lhz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B8D44: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821B8D48: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B8D4C: 409900AC  ble cr6, 0x821b8df8
	if !ctx.cr[6].gt {
	pc = 0x821B8DF8; continue 'dispatch;
	}
	// 821B8D50: 38DD0006  addi r6, r29, 6
	ctx.r[6].s64 = ctx.r[29].s64 + 6;
	// 821B8D54: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 821B8D58: A1460000  lhz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8D5C: A106FFFC  lhz r8, -4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821B8D60: A1260004  lhz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8D64: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B8D68: 817E0218  lwz r11, 0x218(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(536 as u32) ) } as u64;
	// 821B8D6C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B8D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8D74: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B8D78: 394A0027  addi r10, r10, 0x27
	ctx.r[10].s64 = ctx.r[10].s64 + 39;
	// 821B8D7C: 7D4A2670  srawi r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 821B8D80: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821B8D84: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B8D88: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B8D8C: 915E0218  stw r10, 0x218(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(536 as u32), ctx.r[10].u32 ) };
	// 821B8D90: 419A0024  beq cr6, 0x821b8db4
	if ctx.cr[6].eq {
	pc = 0x821B8DB4; continue 'dispatch;
	}
	// 821B8D94: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821B8D98: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821B8D9C: B36B0004  sth r27, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 821B8DA0: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 821B8DA4: B36B000C  sth r27, 0xc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[27].u16 ) };
	// 821B8DA8: 936B0010  stw r27, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	// 821B8DAC: B36B0014  sth r27, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[27].u16 ) };
	// 821B8DB0: 48000008  b 0x821b8db8
	pc = 0x821B8DB8; continue 'dispatch;
	// 821B8DB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8DB8: A166FFFC  lhz r11, -4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821B8DBC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 821B8DC0: A1660000  lhz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8DC4: B163000C  sth r11, 0xc(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u16 ) };
	// 821B8DC8: A1660004  lhz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8DCC: B1630014  sth r11, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 821B8DD0: 4BFFEE81  bl 0x821b7c50
	ctx.lr = 0x821B8DD4;
	sub_821B7C50(ctx, base);
	// 821B8DD4: 90650000  stw r3, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B8DD8: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821B8DDC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8DE0: 38C60010  addi r6, r6, 0x10
	ctx.r[6].s64 = ctx.r[6].s64 + 16;
	// 821B8DE4: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B8DE8: A14B0028  lhz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B8DEC: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821B8DF0: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B8DF4: 4198FF64  blt cr6, 0x821b8d58
	if ctx.cr[6].lt {
	pc = 0x821B8D58; continue 'dispatch;
	}
	// 821B8DF8: A14B002A  lhz r10, 0x2a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(42 as u32) ) } as u64;
	// 821B8DFC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B8E00: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821B8E04: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821B8E08: 386B5508  addi r3, r11, 0x5508
	ctx.r[3].s64 = ctx.r[11].s64 + 21768;
	// 821B8E0C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 821B8E10: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 821B8E14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B8E18: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821B8E1C: 4807471D  bl 0x8222d538
	ctx.lr = 0x821B8E20;
	sub_8222D538(ctx, base);
	// 821B8E20: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B8E24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8E28: 409A000C  bne cr6, 0x821b8e34
	if !ctx.cr[6].eq {
	pc = 0x821B8E34; continue 'dispatch;
	}
	// 821B8E2C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B8E30: 4800002C  b 0x821b8e5c
	pc = 0x821B8E5C; continue 'dispatch;
	// 821B8E34: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8E38: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B8E3C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B8E40: 419A000C  beq cr6, 0x821b8e4c
	if ctx.cr[6].eq {
	pc = 0x821B8E4C; continue 'dispatch;
	}
	// 821B8E44: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B8E48: 48000014  b 0x821b8e5c
	pc = 0x821B8E5C; continue 'dispatch;
	// 821B8E4C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8E50: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B8E54: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B8E58: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 821B8E5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8E60: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821B8E64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8E68: 419A0008  beq cr6, 0x821b8e70
	if ctx.cr[6].eq {
	pc = 0x821B8E70; continue 'dispatch;
	}
	// 821B8E6C: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8E70: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8E74: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821B8E78: A16B002A  lhz r11, 0x2a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(42 as u32) ) } as u64;
	// 821B8E7C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B8E80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8E84: 40990058  ble cr6, 0x821b8edc
	if !ctx.cr[6].gt {
	pc = 0x821B8EDC; continue 'dispatch;
	}
	// 821B8E88: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821B8E8C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821B8E90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B8E94: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8E98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B8E9C: A13C0008  lhz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8EA0: A108002A  lhz r8, 0x2a(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(42 as u32) ) } as u64;
	// 821B8EA4: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 821B8EA8: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B8EAC: 39090004  addi r8, r9, 4
	ctx.r[8].s64 = ctx.r[9].s64 + 4;
	// 821B8EB0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B8EB4: 38E8000F  addi r7, r8, 0xf
	ctx.r[7].s64 = ctx.r[8].s64 + 15;
	// 821B8EB8: 7CE72670  srawi r7, r7, 4
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[7].s32 >> 4) as i64;
	// 821B8EBC: 7CE70194  addze r7, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[7].s64 = tmp.s64;
	// 821B8EC0: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821B8EC4: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B8EC8: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821B8ECC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B8ED0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821B8ED4: 7F89E214  add r28, r9, r28
	ctx.r[28].u64 = ctx.r[9].u64 + ctx.r[28].u64;
	// 821B8ED8: 4198FFB4  blt cr6, 0x821b8e8c
	if ctx.cr[6].lt {
	pc = 0x821B8E8C; continue 'dispatch;
	}
	// 821B8EDC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8EE0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B8EE4: A16B0028  lhz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B8EE8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B8EEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8EF0: 40990104  ble cr6, 0x821b8ff4
	if !ctx.cr[6].gt {
	pc = 0x821B8FF4; continue 'dispatch;
	}
	// 821B8EF4: 38FD0008  addi r7, r29, 8
	ctx.r[7].s64 = ctx.r[29].s64 + 8;
	// 821B8EF8: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 821B8EFC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F00: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B8F04: A1280004  lhz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8F08: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B8F0C: 419A0038  beq cr6, 0x821b8f44
	if ctx.cr[6].eq {
	pc = 0x821B8F44; continue 'dispatch;
	}
	// 821B8F10: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 821B8F14: A0C7FFF8  lhz r6, -8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B8F18: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F1C: 7CC65A14  add r6, r6, r11
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821B8F20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B8F24: 54C6103A  slwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821B8F28: 7CC6282E  lwzx r6, r6, r5
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821B8F2C: 7CC9412E  stwx r6, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[6].u32) };
	// 821B8F30: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821B8F34: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F38: A0C80004  lhz r6, 4(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8F3C: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821B8F40: 4198FFD4  blt cr6, 0x821b8f14
	if ctx.cr[6].lt {
	pc = 0x821B8F14; continue 'dispatch;
	}
	// 821B8F44: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F48: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B8F4C: A128000C  lhz r9, 0xc(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B8F50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B8F54: 419A0038  beq cr6, 0x821b8f8c
	if ctx.cr[6].eq {
	pc = 0x821B8F8C; continue 'dispatch;
	}
	// 821B8F58: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 821B8F5C: A0C7FFFC  lhz r6, -4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821B8F60: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8F64: 7CC65A14  add r6, r6, r11
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821B8F68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B8F6C: 54C6103A  slwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821B8F70: 7CC6282E  lwzx r6, r6, r5
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821B8F74: 7CC8492E  stwx r6, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[6].u32) };
	// 821B8F78: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821B8F7C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F80: A0C8000C  lhz r6, 0xc(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B8F84: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821B8F88: 4198FFD4  blt cr6, 0x821b8f5c
	if ctx.cr[6].lt {
	pc = 0x821B8F5C; continue 'dispatch;
	}
	// 821B8F8C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F90: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B8F94: A1280014  lhz r9, 0x14(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B8F98: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B8F9C: 419A0038  beq cr6, 0x821b8fd4
	if ctx.cr[6].eq {
	pc = 0x821B8FD4; continue 'dispatch;
	}
	// 821B8FA0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 821B8FA4: A0C70000  lhz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8FA8: 81080010  lwz r8, 0x10(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B8FAC: 7CC65A14  add r6, r6, r11
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821B8FB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B8FB4: 54C6103A  slwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821B8FB8: 7CC6282E  lwzx r6, r6, r5
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821B8FBC: 7CC8492E  stwx r6, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[6].u32) };
	// 821B8FC0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821B8FC4: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8FC8: A0C80014  lhz r6, 0x14(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B8FCC: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821B8FD0: 4198FFD4  blt cr6, 0x821b8fa4
	if ctx.cr[6].lt {
	pc = 0x821B8FA4; continue 'dispatch;
	}
	// 821B8FD4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8FD8: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821B8FDC: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 821B8FE0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B8FE4: A16B0028  lhz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B8FE8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B8FEC: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B8FF0: 4198FF0C  blt cr6, 0x821b8efc
	if ctx.cr[6].lt {
	pc = 0x821B8EFC; continue 'dispatch;
	}
	// 821B8FF4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B8FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8FFC: 419A0008  beq cr6, 0x821b9004
	if ctx.cr[6].eq {
	pc = 0x821B9004; continue 'dispatch;
	}
	// 821B9000: 4BF64059  bl 0x8211d058
	ctx.lr = 0x821B9004;
	sub_8211D058(ctx, base);
	// 821B9004: 939E0204  stw r28, 0x204(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(516 as u32), ctx.r[28].u32 ) };
	// 821B9008: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B900C: 9B7E0209  stb r27, 0x209(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(521 as u32), ctx.r[27].u8 ) };
	// 821B9010: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821B9014: 9B7E020A  stb r27, 0x20a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(522 as u32), ctx.r[27].u8 ) };
	// 821B9018: 9B7E020B  stb r27, 0x20b(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(523 as u32), ctx.r[27].u8 ) };
	// 821B901C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9020: A14A002C  lhz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B9024: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821B9028: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B902C: 4099003C  ble cr6, 0x821b9068
	if !ctx.cr[6].gt {
	pc = 0x821B9068; continue 'dispatch;
	}
	// 821B9030: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821B9034: 813E0204  lwz r9, 0x204(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 821B9038: 391E0209  addi r8, r30, 0x209
	ctx.r[8].s64 = ctx.r[30].s64 + 521;
	// 821B903C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B9040: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B9044: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 821B9048: 8129001C  lwz r9, 0x1c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B904C: 5529A73E  rlwinm r9, r9, 0x14, 0x1c, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 821B9050: 7F8941AE  stbx r28, r9, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[28].u8) };
	// 821B9054: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9058: A129002C  lhz r9, 0x2c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B905C: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 821B9060: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B9064: 4198FFD0  blt cr6, 0x821b9034
	if ctx.cr[6].lt {
	pc = 0x821B9034; continue 'dispatch;
	}
	// 821B9068: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B906C: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 821B9070: A16B0028  lhz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B9074: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B9078: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B907C: 409900E4  ble cr6, 0x821b9160
	if !ctx.cr[6].gt {
	pc = 0x821B9160; continue 'dispatch;
	}
	// 821B9080: 38DE0004  addi r6, r30, 4
	ctx.r[6].s64 = ctx.r[30].s64 + 4;
	// 821B9084: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9088: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821B908C: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9090: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9094: 419A0030  beq cr6, 0x821b90c4
	if ctx.cr[6].eq {
	pc = 0x821B90C4; continue 'dispatch;
	}
	// 821B9098: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821B909C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B90A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B90A4: 7C85582E  lwzx r4, r5, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B90A8: 4BFFFB89  bl 0x821b8c30
	ctx.lr = 0x821B90AC;
	sub_821B8C30(ctx, base);
	// 821B90AC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B90B0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B90B4: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B90B8: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B90BC: 7F1F5000  cmpw cr6, r31, r10
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B90C0: 4198FFDC  blt cr6, 0x821b909c
	if ctx.cr[6].lt {
	pc = 0x821B909C; continue 'dispatch;
	}
	// 821B90C4: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B90C8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821B90CC: A14B000C  lhz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B90D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B90D4: 419A0030  beq cr6, 0x821b9104
	if ctx.cr[6].eq {
	pc = 0x821B9104; continue 'dispatch;
	}
	// 821B90D8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821B90DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B90E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B90E4: 7C8B282E  lwzx r4, r11, r5
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821B90E8: 4BFFFB49  bl 0x821b8c30
	ctx.lr = 0x821B90EC;
	sub_821B8C30(ctx, base);
	// 821B90EC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B90F0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B90F4: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B90F8: A14B000C  lhz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B90FC: 7F1F5000  cmpw cr6, r31, r10
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B9100: 4198FFDC  blt cr6, 0x821b90dc
	if ctx.cr[6].lt {
	pc = 0x821B90DC; continue 'dispatch;
	}
	// 821B9104: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9108: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821B910C: A14B0014  lhz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B9110: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9114: 419A0030  beq cr6, 0x821b9144
	if ctx.cr[6].eq {
	pc = 0x821B9144; continue 'dispatch;
	}
	// 821B9118: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821B911C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B9120: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B9124: 7C8B282E  lwzx r4, r11, r5
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821B9128: 4BFFFB09  bl 0x821b8c30
	ctx.lr = 0x821B912C;
	sub_821B8C30(ctx, base);
	// 821B912C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9130: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B9134: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821B9138: A14B0014  lhz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B913C: 7F1F5000  cmpw cr6, r31, r10
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B9140: 4198FFDC  blt cr6, 0x821b911c
	if ctx.cr[6].lt {
	pc = 0x821B911C; continue 'dispatch;
	}
	// 821B9144: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9148: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821B914C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 821B9150: A16B0028  lhz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B9154: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B9158: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B915C: 4198FF28  blt cr6, 0x821b9084
	if ctx.cr[6].lt {
	pc = 0x821B9084; continue 'dispatch;
	}
	// 821B9160: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821B9164: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B9168: 997E0208  stb r11, 0x208(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(520 as u32), ctx.r[11].u8 ) };
	// 821B916C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B9170: 4837BF94  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9178 size=84
    let mut pc: u32 = 0x821B9178;
    'dispatch: loop {
        match pc {
            0x821B9178 => {
    //   block [0x821B9178..0x821B91CC)
	// 821B9178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B917C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9180: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9184: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9188: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B918C: 3BEBCD68  addi r31, r11, -0x3298
	ctx.r[31].s64 = ctx.r[11].s64 + -12952;
	// 821B9190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B9194: 807F0220  lwz r3, 0x220(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 821B9198: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 821B919C: 917F0220  stw r11, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 821B91A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B91A4: 419A0008  beq cr6, 0x821b91ac
	if ctx.cr[6].eq {
	pc = 0x821B91AC; continue 'dispatch;
	}
	// 821B91A8: 4BF63EB1  bl 0x8211d058
	ctx.lr = 0x821B91AC;
	sub_8211D058(ctx, base);
	// 821B91AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B91B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B91B4: 997F0208  stb r11, 0x208(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u8 ) };
	// 821B91B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B91BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B91C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B91C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B91C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B91D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B91D0 size=236
    let mut pc: u32 = 0x821B91D0;
    'dispatch: loop {
        match pc {
            0x821B91D0 => {
    //   block [0x821B91D0..0x821B9260)
	// 821B91D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B91D4: 4837BEE1  bl 0x825350b4
	ctx.lr = 0x821B91D8;
	sub_82535080(ctx, base);
	// 821B91D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B91DC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821B91E0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821B91E4: 2B1CFFFF  cmplwi cr6, r28, 0xffff
	ctx.cr[6].compare_u32(ctx.r[28].u32, 65535 as u32, &mut ctx.xer);
	// 821B91E8: 419A00CC  beq cr6, 0x821b92b4
	if ctx.cr[6].eq {
	pc = 0x821B92B4; continue 'dispatch;
	}
	// 821B91EC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B91F0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B91F4: 3BCBCD68  addi r30, r11, -0x3298
	ctx.r[30].s64 = ctx.r[11].s64 + -12952;
	// 821B91F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B91FC: 4BFFEB35  bl 0x821b7d30
	ctx.lr = 0x821B9200;
	sub_821B7D30(ctx, base);
	// 821B9200: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B9204: 409900B0  ble cr6, 0x821b92b4
	if !ctx.cr[6].gt {
	pc = 0x821B92B4; continue 'dispatch;
	}
	// 821B9208: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B920C: 817E0204  lwz r11, 0x204(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 821B9210: 7D5F5A14  add r10, r31, r11
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821B9214: A16A002E  lhz r11, 0x2e(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B9218: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821B921C: 409A0080  bne cr6, 0x821b929c
	if !ctx.cr[6].eq {
	pc = 0x821B929C; continue 'dispatch;
	}
	// 821B9220: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B9224: 556BE73E  rlwinm r11, r11, 0x1c, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B9228: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B922C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 821B9230: 4199006C  bgt cr6, 0x821b929c
	if ctx.cr[6].gt {
	pc = 0x821B929C; continue 'dispatch;
	}
	// 821B9234: 3D80821C  lis r12, -0x7de4
	ctx.r[12].s64 = -2112094208;
	// 821B9238: 398C924C  addi r12, r12, -0x6db4
	ctx.r[12].s64 = ctx.r[12].s64 + -28084;
	// 821B923C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B9240: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B9244: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B9248: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821B9260; continue 'dispatch;
		},
		1 => {
	pc = 0x821B9270; continue 'dispatch;
		},
		2 => {
	pc = 0x821B929C; continue 'dispatch;
		},
		3 => {
	pc = 0x821B9278; continue 'dispatch;
		},
		4 => {
	pc = 0x821B9268; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B924C: 821B9260  lwz r16, -0x6da0(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-28064 as u32) ) } as u64;
	// 821B9250: 821B9270  lwz r16, -0x6d90(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-28048 as u32) ) } as u64;
	// 821B9254: 821B929C  lwz r16, -0x6d64(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-28004 as u32) ) } as u64;
	// 821B9258: 821B9278  lwz r16, -0x6d88(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-28040 as u32) ) } as u64;
	// 821B925C: 821B9268  lwz r16, -0x6d98(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-28056 as u32) ) } as u64;
            }
            0x821B9260 => {
    //   block [0x821B9260..0x821B9268)
	// 821B9260: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9264: 48000024  b 0x821b9288
	pc = 0x821B9288; continue 'dispatch;
            }
            0x821B9268 => {
    //   block [0x821B9268..0x821B9270)
	// 821B9268: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 821B926C: 4800001C  b 0x821b9288
	pc = 0x821B9288; continue 'dispatch;
            }
            0x821B9270 => {
    //   block [0x821B9270..0x821B9278)
	// 821B9270: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821B9274: 48000014  b 0x821b9288
	pc = 0x821B9288; continue 'dispatch;
            }
            0x821B9278 => {
    //   block [0x821B9278..0x821B929C)
	// 821B9278: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 821B927C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B9280: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B9284: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 821B9288: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B928C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B9290: 55290626  rlwinm r9, r9, 0, 0x18, 0x13
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821B9294: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 821B9298: 916A001C  stw r11, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x821B929C; continue 'dispatch;
            }
            0x821B929C => {
    //   block [0x821B929C..0x821B92BC)
	// 821B929C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B92A0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821B92A4: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 821B92A8: 4BFFEA89  bl 0x821b7d30
	ctx.lr = 0x821B92AC;
	sub_821B7D30(ctx, base);
	// 821B92AC: 7F1D1800  cmpw cr6, r29, r3
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[3].s32, &mut ctx.xer);
	// 821B92B0: 4198FF5C  blt cr6, 0x821b920c
	if ctx.cr[6].lt {
	pc = 0x821B920C; continue 'dispatch;
	}
	// 821B92B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B92B8: 4837BE4C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B92C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B92C0 size=92
    let mut pc: u32 = 0x821B92C0;
    'dispatch: loop {
        match pc {
            0x821B92C0 => {
    //   block [0x821B92C0..0x821B931C)
	// 821B92C0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B92C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B92C8: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B92CC: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B92D0: ECAC0032  fmuls f5, f12, f0
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B92D4: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B92D8: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B92DC: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B92E0: C1050000  lfs f8, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B92E4: C0C30008  lfs f6, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B92E8: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B92EC: C0E50008  lfs f7, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B92F0: ECAB2B7A  fmadds f5, f11, f13, f5
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B92F4: EDA8037A  fmadds f13, f8, f13, f0
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B92F8: EC0A29BA  fmadds f0, f10, f6, f5
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[6].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B92FC: EDA769BA  fmadds f13, f7, f6, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[6].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B9300: C0CB2238  lfs f6, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B9304: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B9308: FCA06A10  fabs f5, f13
	ctx.f[5].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 821B930C: FF053000  fcmpu cr6, f5, f6
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[6].f64);
	// 821B9310: 4098000C  bge cr6, 0x821b931c
	if !ctx.cr[6].lt {
		sub_821B931C(ctx, base);
		return;
	}
	// 821B9314: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B9318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B931C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B931C size=88
    let mut pc: u32 = 0x821B931C;
    'dispatch: loop {
        match pc {
            0x821B931C => {
    //   block [0x821B931C..0x821B9374)
	// 821B931C: C0C3000C  lfs f6, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B9320: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B9324: EC06002A  fadds f0, f6, f0
	ctx.f[0].f64 = ((ctx.f[6].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B9328: C0C4000C  lfs f6, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B932C: C0A5000C  lfs f5, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821B9330: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B9334: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821B9338: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B933C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B9340: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B9344: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B9348: ECC60372  fmuls f6, f6, f13
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B934C: EC8B0372  fmuls f4, f11, f13
	ctx.f[4].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B9350: EDA9603A  fmadds f13, f9, f0, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821B9354: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B9358: ED87503A  fmadds f12, f7, f0, f10
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821B935C: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B9360: ED65303A  fmadds f11, f5, f0, f6
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 821B9364: D166000C  stfs f11, 0xc(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B9368: EC08203A  fmadds f0, f8, f0, f4
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64);
	// 821B936C: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B9370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B9378 size=288
    let mut pc: u32 = 0x821B9378;
    'dispatch: loop {
        match pc {
            0x821B9378 => {
    //   block [0x821B9378..0x821B9498)
	// 821B9378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B937C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B9384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B938C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B9390: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B9394: 3BEBDBD8  addi r31, r11, -0x2428
	ctx.r[31].s64 = ctx.r[11].s64 + -9256;
	// 821B9398: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B939C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B93A0: 419A0014  beq cr6, 0x821b93b4
	if ctx.cr[6].eq {
	pc = 0x821B93B4; continue 'dispatch;
	}
	// 821B93A4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B93A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B93AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B93B0: 419A00CC  beq cr6, 0x821b947c
	if ctx.cr[6].eq {
	pc = 0x821B947C; continue 'dispatch;
	}
	// 821B93B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B93B8: 419A00C4  beq cr6, 0x821b947c
	if ctx.cr[6].eq {
	pc = 0x821B947C; continue 'dispatch;
	}
	// 821B93BC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B93C0: 38C071C0  li r6, 0x71c0
	ctx.r[6].s64 = 29120;
	// 821B93C4: 38EB1160  addi r7, r11, 0x1160
	ctx.r[7].s64 = ctx.r[11].s64 + 4448;
	// 821B93C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B93CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B93D0: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 821B93D4: 481B10BD  bl 0x8236a490
	ctx.lr = 0x821B93D8;
	sub_8236A490(ctx, base);
	// 821B93D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B93DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B93E0: 419A000C  beq cr6, 0x821b93ec
	if ctx.cr[6].eq {
	pc = 0x821B93EC; continue 'dispatch;
	}
	// 821B93E4: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B93E8: 48000008  b 0x821b93f0
	pc = 0x821B93F0; continue 'dispatch;
	// 821B93EC: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821B93F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B93F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B93F8: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821B93FC: 419A0080  beq cr6, 0x821b947c
	if ctx.cr[6].eq {
	pc = 0x821B947C; continue 'dispatch;
	}
	// 821B9400: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B9404: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B9408: 396B0FF4  addi r11, r11, 0xff4
	ctx.r[11].s64 = ctx.r[11].s64 + 4084;
	// 821B940C: 3CE0DEAD  lis r7, -0x2153
	ctx.r[7].s64 = -559087616;
	// 821B9410: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B9414: 38C03000  li r6, 0x3000
	ctx.r[6].s64 = 12288;
	// 821B9418: C00ABA38  lfs f0, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B941C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B9420: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B9424: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821B9428: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821B942C: 910300A0  stw r8, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[8].u32 ) };
	// 821B9430: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821B9434: 90E300A4  stw r7, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821B9438: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821B943C: 91030080  stw r8, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 821B9440: 93C30084  stw r30, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 821B9444: 90C30088  stw r6, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[6].u32 ) };
	// 821B9448: 90A30090  stw r5, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[5].u32 ) };
	// 821B944C: 916A14AC  stw r11, 0x14ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5292 as u32), ctx.r[11].u32 ) };
	// 821B9450: 90830098  stw r4, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[4].u32 ) };
	// 821B9454: 9923001E  stb r9, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821B9458: 9923001C  stb r9, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 821B945C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9464: 419A0018  beq cr6, 0x821b947c
	if ctx.cr[6].eq {
	pc = 0x821B947C; continue 'dispatch;
	}
	// 821B9468: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B946C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B9470: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9474: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9478: 419A0008  beq cr6, 0x821b9480
	if ctx.cr[6].eq {
	pc = 0x821B9480; continue 'dispatch;
	}
	// 821B947C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B9480: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B9484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B948C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B9490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B9498 size=368
    let mut pc: u32 = 0x821B9498;
    'dispatch: loop {
        match pc {
            0x821B9498 => {
    //   block [0x821B9498..0x821B9608)
	// 821B9498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B949C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B94A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B94A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B94A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B94AC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821B94B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B94B4: 388B3100  addi r4, r11, 0x3100
	ctx.r[4].s64 = ctx.r[11].s64 + 12544;
	// 821B94B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B94BC: 38A07A00  li r5, 0x7a00
	ctx.r[5].s64 = 31232;
	// 821B94C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B94C4: C02B2944  lfs f1, 0x2944(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10564 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B94C8: 481C4319  bl 0x8237d7e0
	ctx.lr = 0x821B94CC;
	sub_8237D7E0(ctx, base);
	// 821B94CC: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B94D0: F97E00A0  std r11, 0xa0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 821B94D4: 83FE00A0  lwz r31, 0xa0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B94D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B94DC: 419A0068  beq cr6, 0x821b9544
	if ctx.cr[6].eq {
	pc = 0x821B9544; continue 'dispatch;
	}
	// 821B94E0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B94E4: 815E00A4  lwz r10, 0xa4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 821B94E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B94EC: 409A0058  bne cr6, 0x821b9544
	if !ctx.cr[6].eq {
	pc = 0x821B9544; continue 'dispatch;
	}
	// 821B94F0: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821B94F4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B94F8: 61630006  ori r3, r11, 6
	ctx.r[3].u64 = ctx.r[11].u64 | 6;
	// 821B94FC: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 821B9500: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B9504: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B9508: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 821B950C: 915F0044  stw r10, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 821B9510: 481E14D9  bl 0x8239a9e8
	ctx.lr = 0x821B9514;
	sub_8239A9E8(ctx, base);
	// 821B9514: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B9518: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821B951C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821B9520: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B9524: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821B9528: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B952C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821B9530: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B9534: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B9538: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821B953C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B9540: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821B9544: 815E00A0  lwz r10, 0xa0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B9548: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B954C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9550: 419A0040  beq cr6, 0x821b9590
	if ctx.cr[6].eq {
	pc = 0x821B9590; continue 'dispatch;
	}
	// 821B9554: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B9558: 813E00A4  lwz r9, 0xa4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 821B955C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9560: 409A0030  bne cr6, 0x821b9590
	if !ctx.cr[6].eq {
	pc = 0x821B9590; continue 'dispatch;
	}
	// 821B9564: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821B9568: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B956C: 396B1E40  addi r11, r11, 0x1e40
	ctx.r[11].s64 = ctx.r[11].s64 + 7744;
	// 821B9570: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B9574: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821B9578: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821B957C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821B9580: 409A000C  bne cr6, 0x821b958c
	if !ctx.cr[6].eq {
	pc = 0x821B958C; continue 'dispatch;
	}
	// 821B9584: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821B9588: 48000008  b 0x821b9590
	pc = 0x821B9590; continue 'dispatch;
	// 821B958C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821B9590: 817E00A0  lwz r11, 0xa0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B9594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9598: 419A0058  beq cr6, 0x821b95f0
	if ctx.cr[6].eq {
	pc = 0x821B95F0; continue 'dispatch;
	}
	// 821B959C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B95A0: 813E00A4  lwz r9, 0xa4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 821B95A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B95A8: 409A0048  bne cr6, 0x821b95f0
	if !ctx.cr[6].eq {
	pc = 0x821B95F0; continue 'dispatch;
	}
	// 821B95AC: 910B0024  stw r8, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 821B95B0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B95B4: F90B0050  std r8, 0x50(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821B95B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B95BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B95C0: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821B95C4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821B95C8: 419A0028  beq cr6, 0x821b95f0
	if ctx.cr[6].eq {
	pc = 0x821B95F0; continue 'dispatch;
	}
	// 821B95CC: 7C0057EC  dcbz 0, r10
	ea.u32 = ctx.r[10].u32;
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821B95D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B95D4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B95D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B95DC: 394A0080  addi r10, r10, 0x80
	ctx.r[10].s64 = ctx.r[10].s64 + 128;
	// 821B95E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B95E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B95E8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821B95EC: 409AFFE0  bne cr6, 0x821b95cc
	if !ctx.cr[6].eq {
	pc = 0x821B95CC; continue 'dispatch;
	}
	// 821B95F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B95F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B95F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B95FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B9600: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9608 size=392
    let mut pc: u32 = 0x821B9608;
    'dispatch: loop {
        match pc {
            0x821B9608 => {
    //   block [0x821B9608..0x821B965C)
	// 821B9608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B960C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9614: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B961C: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B9620: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B9624: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 821B9628: 41990154  bgt cr6, 0x821b977c
	if ctx.cr[6].gt {
	pc = 0x821B977C; continue 'dispatch;
	}
	// 821B962C: 3D80821C  lis r12, -0x7de4
	ctx.r[12].s64 = -2112094208;
	// 821B9630: 398C9644  addi r12, r12, -0x69bc
	ctx.r[12].s64 = ctx.r[12].s64 + -27068;
	// 821B9634: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B9638: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B963C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B9640: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821B965C; continue 'dispatch;
		},
		1 => {
	pc = 0x821B9680; continue 'dispatch;
		},
		2 => {
	pc = 0x821B96C0; continue 'dispatch;
		},
		3 => {
	pc = 0x821B972C; continue 'dispatch;
		},
		4 => {
	pc = 0x821B977C; continue 'dispatch;
		},
		5 => {
	pc = 0x821B9760; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B9644: 821B965C  lwz r16, -0x69a4(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27044 as u32) ) } as u64;
	// 821B9648: 821B9680  lwz r16, -0x6980(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27008 as u32) ) } as u64;
	// 821B964C: 821B96C0  lwz r16, -0x6940(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-26944 as u32) ) } as u64;
	// 821B9650: 821B972C  lwz r16, -0x68d4(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-26836 as u32) ) } as u64;
	// 821B9654: 821B977C  lwz r16, -0x6884(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-26756 as u32) ) } as u64;
	// 821B9658: 821B9760  lwz r16, -0x68a0(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-26784 as u32) ) } as u64;
            }
            0x821B965C => {
    //   block [0x821B965C..0x821B9680)
	// 821B965C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B9660: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B9664: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 821B9668: 816B0684  lwz r11, 0x684(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1668 as u32) ) } as u64;
	// 821B966C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B9670: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 821B9674: 41980108  blt cr6, 0x821b977c
	if ctx.cr[6].lt {
	pc = 0x821B977C; continue 'dispatch;
	}
	// 821B9678: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821B967C: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	pc = 0x821B9680; continue 'dispatch;
            }
            0x821B9680 => {
    //   block [0x821B9680..0x821B96C0)
	// 821B9680: 3C60C000  lis r3, -0x4000
	ctx.r[3].s64 = -1073741824;
	// 821B9684: 80BF0088  lwz r5, 0x88(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B9688: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B968C: 809F0084  lwz r4, 0x84(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B9690: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B9694: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 821B9698: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B969C: 60630006  ori r3, r3, 6
	ctx.r[3].u64 = ctx.r[3].u64 | 6;
	// 821B96A0: 481E1B21  bl 0x8239b1c0
	ctx.lr = 0x821B96A4;
	sub_8239B1C0(ctx, base);
	// 821B96A4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B96A8: 907F0090  stw r3, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 821B96AC: 4098000C  bge cr6, 0x821b96b8
	if !ctx.cr[6].lt {
	pc = 0x821B96B8; continue 'dispatch;
	}
	// 821B96B0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821B96B4: 480000C4  b 0x821b9778
	pc = 0x821B9778; continue 'dispatch;
	// 821B96B8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821B96BC: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
            }
            0x821B96C0 => {
    //   block [0x821B96C0..0x821B972C)
	// 821B96C0: 813F0090  lwz r9, 0x90(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B96C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B96C8: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821B96CC: 481E1A8D  bl 0x8239b158
	ctx.lr = 0x821B96D0;
	sub_8239B158(ctx, base);
	// 821B96D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B96D4: 419A00A8  beq cr6, 0x821b977c
	if ctx.cr[6].eq {
	pc = 0x821B977C; continue 'dispatch;
	}
	// 821B96D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B96DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B96E0: 409AFFD0  bne cr6, 0x821b96b0
	if !ctx.cr[6].eq {
	pc = 0x821B96B0; continue 'dispatch;
	}
	// 821B96E4: 2B090007  cmplwi cr6, r9, 7
	ctx.cr[6].compare_u32(ctx.r[9].u32, 7 as u32, &mut ctx.xer);
	// 821B96E8: 41990030  bgt cr6, 0x821b9718
	if ctx.cr[6].gt {
	pc = 0x821B9718; continue 'dispatch;
	}
	// 821B96EC: 3D608310  lis r11, -0x7cf0
	ctx.r[11].s64 = -2096103424;
	// 821B96F0: 1D490078  mulli r10, r9, 0x78
	ctx.r[10].s64 = ctx.r[9].s64 * 120;
	// 821B96F4: 396BC630  addi r11, r11, -0x39d0
	ctx.r[11].s64 = ctx.r[11].s64 + -14800;
	// 821B96F8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B96FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9700: 419A0018  beq cr6, 0x821b9718
	if ctx.cr[6].eq {
	pc = 0x821B9718; continue 'dispatch;
	}
	// 821B9704: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B9708: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B970C: 409A000C  bne cr6, 0x821b9718
	if !ctx.cr[6].eq {
	pc = 0x821B9718; continue 'dispatch;
	}
	// 821B9710: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B9714: 48000008  b 0x821b971c
	pc = 0x821B971C; continue 'dispatch;
	// 821B9718: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B971C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 821B9720: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821B9724: 913F0080  stw r9, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821B9728: 916A14AC  stw r11, 0x14ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5292 as u32), ctx.r[11].u32 ) };
            }
            0x821B972C => {
    //   block [0x821B972C..0x821B9760)
	// 821B972C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821B9730: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821B9734: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B9738: 409A0044  bne cr6, 0x821b977c
	if !ctx.cr[6].eq {
	pc = 0x821B977C; continue 'dispatch;
	}
	// 821B973C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821B9740: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B9744: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821B9748: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821B974C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B9750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9758: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B975C: 4E800020  blr
	return;
            }
            0x821B9760 => {
    //   block [0x821B9760..0x821B977C)
	// 821B9760: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B9764: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B9768: 481E19F1  bl 0x8239b158
	ctx.lr = 0x821B976C;
	sub_8239B158(ctx, base);
	// 821B976C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B9770: 419A000C  beq cr6, 0x821b977c
	if ctx.cr[6].eq {
	pc = 0x821B977C; continue 'dispatch;
	}
	// 821B9774: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 821B9778: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	pc = 0x821B977C; continue 'dispatch;
            }
            0x821B977C => {
    //   block [0x821B977C..0x821B9790)
	// 821B977C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B9780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9788: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B978C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B9790 size=752
    let mut pc: u32 = 0x821B9790;
    'dispatch: loop {
        match pc {
            0x821B9790 => {
    //   block [0x821B9790..0x821B9A80)
	// 821B9790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9794: 4837B929  bl 0x825350bc
	ctx.lr = 0x821B9798;
	sub_82535080(ctx, base);
	// 821B9798: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 821B979C: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821B97A0: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821B97A4: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B97A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B97AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B97B0: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B97B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B97B8: 409A0250  bne cr6, 0x821b9a08
	if !ctx.cr[6].eq {
	pc = 0x821B9A08; continue 'dispatch;
	}
	// 821B97BC: 3BFD00A0  addi r31, r29, 0xa0
	ctx.r[31].s64 = ctx.r[29].s64 + 160;
	// 821B97C0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821B97C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B97C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B97CC: 419A0058  beq cr6, 0x821b9824
	if ctx.cr[6].eq {
	pc = 0x821B9824; continue 'dispatch;
	}
	// 821B97D0: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B97D4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B97D8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B97DC: 409A0048  bne cr6, 0x821b9824
	if !ctx.cr[6].eq {
	pc = 0x821B9824; continue 'dispatch;
	}
	// 821B97E0: 93CB0024  stw r30, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 821B97E4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B97E8: F92B0050  std r9, 0x50(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821B97EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B97F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B97F4: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821B97F8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B97FC: 419A0028  beq cr6, 0x821b9824
	if ctx.cr[6].eq {
	pc = 0x821B9824; continue 'dispatch;
	}
	// 821B9800: 7C0057EC  dcbz 0, r10
	ea.u32 = ctx.r[10].u32;
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821B9804: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B9808: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B980C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B9810: 394A0080  addi r10, r10, 0x80
	ctx.r[10].s64 = ctx.r[10].s64 + 128;
	// 821B9814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9818: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B981C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B9820: 409AFFE0  bne cr6, 0x821b9800
	if !ctx.cr[6].eq {
	pc = 0x821B9800; continue 'dispatch;
	}
	// 821B9824: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B9828: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B982C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9830: C3AA1FF8  lfs f29, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B9834: 419A0014  beq cr6, 0x821b9848
	if ctx.cr[6].eq {
	pc = 0x821B9848; continue 'dispatch;
	}
	// 821B9838: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B983C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9840: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B9844: 419A000C  beq cr6, 0x821b9850
	if ctx.cr[6].eq {
	pc = 0x821B9850; continue 'dispatch;
	}
	// 821B9848: FDA0E890  fmr f13, f29
	ctx.f[13].f64 = ctx.f[29].f64;
	// 821B984C: 48000008  b 0x821b9854
	pc = 0x821B9854; continue 'dispatch;
	// 821B9850: C1AB0048  lfs f13, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B9854: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B985C: 419A0014  beq cr6, 0x821b9870
	if ctx.cr[6].eq {
	pc = 0x821B9870; continue 'dispatch;
	}
	// 821B9860: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B9864: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9868: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B986C: 419A000C  beq cr6, 0x821b9878
	if ctx.cr[6].eq {
	pc = 0x821B9878; continue 'dispatch;
	}
	// 821B9870: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821B9874: 48000008  b 0x821b987c
	pc = 0x821B987C; continue 'dispatch;
	// 821B9878: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B987C: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B9880: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B9884: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821B9888: 556A072E  rlwinm r10, r11, 0, 0x1c, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B988C: B1210064  sth r9, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u16 ) };
	// 821B9890: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B9894: B1210066  sth r9, 0x66(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[9].u16 ) };
	// 821B9898: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821B989C: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 821B98A0: C00BD5B8  lfs f0, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B98A4: 614B0001  ori r11, r10, 1
	ctx.r[11].u64 = ctx.r[10].u64 | 1;
	// 821B98A8: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 821B98AC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821B98B0: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821B98B4: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821B98B8: 3D40D000  lis r10, -0x3000
	ctx.r[10].s64 = -805306368;
	// 821B98BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B98C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B98C4: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 821B98C8: C1AB20E8  lfs f13, 0x20e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8424 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B98CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B98D0: EDAC683C  fnmsubs f13, f12, f0, f13
	ctx.f[13].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B98D4: C00B2940  lfs f0, 0x2940(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B98D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B98DC: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B98E0: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B98E4: 409A0018  bne cr6, 0x821b98fc
	if !ctx.cr[6].eq {
	pc = 0x821B98FC; continue 'dispatch;
	}
	// 821B98E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B98EC: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821B98F0: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B98F4: EC1EF83C  fnmsubs f0, f30, f0, f31
	ctx.f[0].f64 = -(((ctx.f[30].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B98F8: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821B98FC: 3D600400  lis r11, 0x400
	ctx.r[11].s64 = 67108864;
	// 821B9900: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821B9904: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 821B9908: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821B990C: 4BF9A7B5  bl 0x821540c0
	ctx.lr = 0x821B9910;
	sub_821540C0(ctx, base);
	// 821B9910: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 821B9914: D3A100B0  stfs f29, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821B9918: D3A100B4  stfs f29, 0xb4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821B991C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821B9920: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821B9924: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 821B9928: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 821B992C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9934: 419A0014  beq cr6, 0x821b9948
	if ctx.cr[6].eq {
	pc = 0x821B9948; continue 'dispatch;
	}
	// 821B9938: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B993C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9940: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9944: 419A000C  beq cr6, 0x821b9950
	if ctx.cr[6].eq {
	pc = 0x821B9950; continue 'dispatch;
	}
	// 821B9948: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821B994C: 48000008  b 0x821b9954
	pc = 0x821B9954; continue 'dispatch;
	// 821B9950: C00B0048  lfs f0, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B9954: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9958: D00100E0  stfs f0, 0xe0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 821B995C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9960: 419A0014  beq cr6, 0x821b9974
	if ctx.cr[6].eq {
	pc = 0x821B9974; continue 'dispatch;
	}
	// 821B9964: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B9968: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B996C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9970: 419A000C  beq cr6, 0x821b997c
	if ctx.cr[6].eq {
	pc = 0x821B997C; continue 'dispatch;
	}
	// 821B9974: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821B9978: 48000008  b 0x821b9980
	pc = 0x821B9980; continue 'dispatch;
	// 821B997C: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B9980: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 821B9984: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 821B9988: D3C100F0  stfs f30, 0xf0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 821B998C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 821B9990: 394BE550  addi r10, r11, -0x1ab0
	ctx.r[10].s64 = ctx.r[11].s64 + -6832;
	// 821B9994: D3A100F4  stfs f29, 0xf4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 821B9998: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B999C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B99A0: 419A0018  beq cr6, 0x821b99b8
	if ctx.cr[6].eq {
	pc = 0x821B99B8; continue 'dispatch;
	}
	// 821B99A4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B99A8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B99AC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B99B0: 409A0008  bne cr6, 0x821b99b8
	if !ctx.cr[6].eq {
	pc = 0x821B99B8; continue 'dispatch;
	}
	// 821B99B4: C00B008C  lfs f0, 0x8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B99B8: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 821B99BC: D00100D0  stfs f0, 0xd0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821B99C0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821B99C4: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 821B99C8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B99CC: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 821B99D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B99D4: D3E100DC  stfs f31, 0xdc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 821B99D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B99DC: 481B272D  bl 0x8236c108
	ctx.lr = 0x821B99E0;
	sub_8236C108(ctx, base);
	// 821B99E0: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B99E4: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 821B99E8: 816B0684  lwz r11, 0x684(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1668 as u32) ) } as u64;
	// 821B99EC: 93DD0080  stw r30, 0x80(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 821B99F0: 917D008C  stw r11, 0x8c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821B99F4: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 821B99F8: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B99FC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B9A00: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B9A04: 4837B708  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821B9A08: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821B9A0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9A10: 419A0058  beq cr6, 0x821b9a68
	if ctx.cr[6].eq {
	pc = 0x821B9A68; continue 'dispatch;
	}
	// 821B9A14: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B9A18: 811D00A4  lwz r8, 0xa4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(164 as u32) ) } as u64;
	// 821B9A1C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B9A20: 409A0048  bne cr6, 0x821b9a68
	if !ctx.cr[6].eq {
	pc = 0x821B9A68; continue 'dispatch;
	}
	// 821B9A24: 912B0024  stw r9, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 821B9A28: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B9A2C: F92B0050  std r9, 0x50(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821B9A30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9A34: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821B9A38: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821B9A3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B9A40: 419A0028  beq cr6, 0x821b9a68
	if ctx.cr[6].eq {
	pc = 0x821B9A68; continue 'dispatch;
	}
	// 821B9A44: 7C0057EC  dcbz 0, r10
	ea.u32 = ctx.r[10].u32;
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821B9A48: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B9A4C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B9A50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B9A54: 394A0080  addi r10, r10, 0x80
	ctx.r[10].s64 = ctx.r[10].s64 + 128;
	// 821B9A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9A5C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B9A60: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821B9A64: 409AFFE0  bne cr6, 0x821b9a44
	if !ctx.cr[6].eq {
	pc = 0x821B9A44; continue 'dispatch;
	}
	// 821B9A68: 993D001E  stb r9, 0x1e(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821B9A6C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 821B9A70: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B9A74: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B9A78: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B9A7C: 4837B690  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9A80 size=180
    let mut pc: u32 = 0x821B9A80;
    'dispatch: loop {
        match pc {
            0x821B9A80 => {
    //   block [0x821B9A80..0x821B9B34)
	// 821B9A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9A88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B9A8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9A90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9A94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B9A98: 3BFE00A0  addi r31, r30, 0xa0
	ctx.r[31].s64 = ctx.r[30].s64 + 160;
	// 821B9A9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9AA4: 419A0044  beq cr6, 0x821b9ae8
	if ctx.cr[6].eq {
	pc = 0x821B9AE8; continue 'dispatch;
	}
	// 821B9AA8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B9AAC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9AB0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B9AB4: 409A0034  bne cr6, 0x821b9ae8
	if !ctx.cr[6].eq {
	pc = 0x821B9AE8; continue 'dispatch;
	}
	// 821B9AB8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9ABC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B9AC0: 419A0028  beq cr6, 0x821b9ae8
	if ctx.cr[6].eq {
	pc = 0x821B9AE8; continue 'dispatch;
	}
	// 821B9AC4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B9AC8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B9ACC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B9AD0: 409A0018  bne cr6, 0x821b9ae8
	if !ctx.cr[6].eq {
	pc = 0x821B9AE8; continue 'dispatch;
	}
	// 821B9AD4: 481C37ED  bl 0x8237d2c0
	ctx.lr = 0x821B9AD8;
	sub_8237D2C0(ctx, base);
	// 821B9AD8: 3D60DEAD  lis r11, -0x2153
	ctx.r[11].s64 = -559087616;
	// 821B9ADC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B9AE0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821B9AE4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B9AE8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B9AEC: 394BDBD8  addi r10, r11, -0x2428
	ctx.r[10].s64 = ctx.r[11].s64 + -9256;
	// 821B9AF0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9AF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9AF8: 419A0024  beq cr6, 0x821b9b1c
	if ctx.cr[6].eq {
	pc = 0x821B9B1C; continue 'dispatch;
	}
	// 821B9AFC: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B9B00: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9B04: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9B08: 409A0014  bne cr6, 0x821b9b1c
	if !ctx.cr[6].eq {
	pc = 0x821B9B1C; continue 'dispatch;
	}
	// 821B9B0C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821B9B10: 409A000C  bne cr6, 0x821b9b1c
	if !ctx.cr[6].eq {
	pc = 0x821B9B1C; continue 'dispatch;
	}
	// 821B9B14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B9B18: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B9B1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B9B20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9B24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9B28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B9B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9B38 size=96
    let mut pc: u32 = 0x821B9B38;
    'dispatch: loop {
        match pc {
            0x821B9B38 => {
    //   block [0x821B9B38..0x821B9B98)
	// 821B9B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9B40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9B44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9B48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B9B4C: 80640000  lwz r3, 0(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9B50: 4811CF69  bl 0x822d6ab8
	ctx.lr = 0x821B9B54;
	sub_822D6AB8(ctx, base);
	// 821B9B54: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9B58: 2F050023  cmpwi cr6, r5, 0x23
	ctx.cr[6].compare_i32(ctx.r[5].s32, 35, &mut ctx.xer);
	// 821B9B5C: 419A0020  beq cr6, 0x821b9b7c
	if ctx.cr[6].eq {
	pc = 0x821B9B7C; continue 'dispatch;
	}
	// 821B9B60: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821B9B64: 4811D18D  bl 0x822d6cf0
	ctx.lr = 0x821B9B68;
	sub_822D6CF0(ctx, base);
	// 821B9B68: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 821B9B6C: 396B663C  addi r11, r11, 0x663c
	ctx.r[11].s64 = ctx.r[11].s64 + 26172;
	// 821B9B70: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9B74: 409A0008  bne cr6, 0x821b9b7c
	if !ctx.cr[6].eq {
	pc = 0x821B9B7C; continue 'dispatch;
	}
	// 821B9B78: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821B9B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9B80: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821B9B84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9B88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9B8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9B90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9B94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9B98 size=116
    let mut pc: u32 = 0x821B9B98;
    'dispatch: loop {
        match pc {
            0x821B9B98 => {
    //   block [0x821B9B98..0x821B9C0C)
	// 821B9B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9B9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9BA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9BA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9BA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B9BAC: 80640000  lwz r3, 0(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9BB0: 2F030021  cmpwi cr6, r3, 0x21
	ctx.cr[6].compare_i32(ctx.r[3].s32, 33, &mut ctx.xer);
	// 821B9BB4: 409A0010  bne cr6, 0x821b9bc4
	if !ctx.cr[6].eq {
	pc = 0x821B9BC4; continue 'dispatch;
	}
	// 821B9BB8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B9BBC: 386BF9C0  addi r3, r11, -0x640
	ctx.r[3].s64 = ctx.r[11].s64 + -1600;
	// 821B9BC0: 48000008  b 0x821b9bc8
	pc = 0x821B9BC8; continue 'dispatch;
	// 821B9BC4: 480021F5  bl 0x821bbdb8
	ctx.lr = 0x821B9BC8;
	sub_821BBDB8(ctx, base);
	// 821B9BC8: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9BCC: 2F050023  cmpwi cr6, r5, 0x23
	ctx.cr[6].compare_i32(ctx.r[5].s32, 35, &mut ctx.xer);
	// 821B9BD0: 419A0020  beq cr6, 0x821b9bf0
	if ctx.cr[6].eq {
	pc = 0x821B9BF0; continue 'dispatch;
	}
	// 821B9BD4: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821B9BD8: 4811CEE1  bl 0x822d6ab8
	ctx.lr = 0x821B9BDC;
	sub_822D6AB8(ctx, base);
	// 821B9BDC: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 821B9BE0: 396B66EC  addi r11, r11, 0x66ec
	ctx.r[11].s64 = ctx.r[11].s64 + 26348;
	// 821B9BE4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9BE8: 409A0008  bne cr6, 0x821b9bf0
	if !ctx.cr[6].eq {
	pc = 0x821B9BF0; continue 'dispatch;
	}
	// 821B9BEC: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821B9BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9BF4: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821B9BF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9BFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9C00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9C04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9C08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9C10 size=196
    let mut pc: u32 = 0x821B9C10;
    'dispatch: loop {
        match pc {
            0x821B9C10 => {
    //   block [0x821B9C10..0x821B9CD4)
	// 821B9C10: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9C14: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9C18: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B9C1C: 409A00B0  bne cr6, 0x821b9ccc
	if !ctx.cr[6].eq {
	pc = 0x821B9CCC; continue 'dispatch;
	}
	// 821B9C20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9C24: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9C28: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B9C2C: 409A00A0  bne cr6, 0x821b9ccc
	if !ctx.cr[6].eq {
	pc = 0x821B9CCC; continue 'dispatch;
	}
	// 821B9C30: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9C34: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9C38: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9C3C: 409A0068  bne cr6, 0x821b9ca4
	if !ctx.cr[6].eq {
	pc = 0x821B9CA4; continue 'dispatch;
	}
	// 821B9C40: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B9C44: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B9C48: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9C4C: 409A0058  bne cr6, 0x821b9ca4
	if !ctx.cr[6].eq {
	pc = 0x821B9CA4; continue 'dispatch;
	}
	// 821B9C50: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B9C54: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B9C58: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9C5C: 409A0048  bne cr6, 0x821b9ca4
	if !ctx.cr[6].eq {
	pc = 0x821B9CA4; continue 'dispatch;
	}
	// 821B9C60: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B9C64: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B9C68: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9C6C: 409A0038  bne cr6, 0x821b9ca4
	if !ctx.cr[6].eq {
	pc = 0x821B9CA4; continue 'dispatch;
	}
	// 821B9C70: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B9C74: 81240018  lwz r9, 0x18(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B9C78: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9C7C: 409A0028  bne cr6, 0x821b9ca4
	if !ctx.cr[6].eq {
	pc = 0x821B9CA4; continue 'dispatch;
	}
	// 821B9C80: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B9C84: 8124001C  lwz r9, 0x1c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B9C88: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9C8C: 409A0018  bne cr6, 0x821b9ca4
	if !ctx.cr[6].eq {
	pc = 0x821B9CA4; continue 'dispatch;
	}
	// 821B9C90: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B9C94: 81240020  lwz r9, 0x20(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B9C98: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9C9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B9CA0: 419A0008  beq cr6, 0x821b9ca8
	if ctx.cr[6].eq {
	pc = 0x821B9CA8; continue 'dispatch;
	}
	// 821B9CA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9CA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B9CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9CB0: 409A001C  bne cr6, 0x821b9ccc
	if !ctx.cr[6].eq {
	pc = 0x821B9CCC; continue 'dispatch;
	}
	// 821B9CB4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B9CB8: 419A001C  beq cr6, 0x821b9cd4
	if ctx.cr[6].eq {
		sub_821B9CD4(ctx, base);
		return;
	}
	// 821B9CBC: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B9CC0: 81240024  lwz r9, 0x24(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B9CC4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9CC8: 419A0024  beq cr6, 0x821b9cec
	if ctx.cr[6].eq {
		sub_821B9CEC(ctx, base);
		return;
	}
	// 821B9CCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B9CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9CD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9CD4 size=24
    let mut pc: u32 = 0x821B9CD4;
    'dispatch: loop {
        match pc {
            0x821B9CD4 => {
    //   block [0x821B9CD4..0x821B9CEC)
	// 821B9CD4: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B9CD8: 81240028  lwz r9, 0x28(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B9CDC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B9CE0: 419A000C  beq cr6, 0x821b9cec
	if ctx.cr[6].eq {
		sub_821B9CEC(ctx, base);
		return;
	}
	// 821B9CE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B9CE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9CEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9CEC size=132
    let mut pc: u32 = 0x821B9CEC;
    'dispatch: loop {
        match pc {
            0x821B9CEC => {
    //   block [0x821B9CEC..0x821B9D70)
	// 821B9CEC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B9CF0: 419A0048  beq cr6, 0x821b9d38
	if ctx.cr[6].eq {
	pc = 0x821B9D38; continue 'dispatch;
	}
	// 821B9CF4: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821B9CF8: 419A0040  beq cr6, 0x821b9d38
	if ctx.cr[6].eq {
	pc = 0x821B9D38; continue 'dispatch;
	}
	// 821B9CFC: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821B9D00: 419A0038  beq cr6, 0x821b9d38
	if ctx.cr[6].eq {
	pc = 0x821B9D38; continue 'dispatch;
	}
	// 821B9D04: 39440034  addi r10, r4, 0x34
	ctx.r[10].s64 = ctx.r[4].s64 + 52;
	// 821B9D08: 39630034  addi r11, r3, 0x34
	ctx.r[11].s64 = ctx.r[3].s64 + 52;
	// 821B9D0C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9D10: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9D14: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B9D18: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821B9D1C: 419A0014  beq cr6, 0x821b9d30
	if ctx.cr[6].eq {
	pc = 0x821B9D30; continue 'dispatch;
	}
	// 821B9D20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B9D24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B9D28: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821B9D2C: 419AFFE0  beq cr6, 0x821b9d0c
	if ctx.cr[6].eq {
	pc = 0x821B9D0C; continue 'dispatch;
	}
	// 821B9D30: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821B9D34: 409AFF98  bne cr6, 0x821b9ccc
	if !ctx.cr[6].eq {
		sub_821B9C10(ctx, base);
		return;
	}
	// 821B9D38: 39630062  addi r11, r3, 0x62
	ctx.r[11].s64 = ctx.r[3].s64 + 98;
	// 821B9D3C: 39440062  addi r10, r4, 0x62
	ctx.r[10].s64 = ctx.r[4].s64 + 98;
	// 821B9D40: 390B0014  addi r8, r11, 0x14
	ctx.r[8].s64 = ctx.r[11].s64 + 20;
	// 821B9D44: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9D48: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9D4C: 7D274851  subf. r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B9D50: 40820014  bne 0x821b9d64
	if !ctx.cr[0].eq {
	pc = 0x821B9D64; continue 'dispatch;
	}
	// 821B9D54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B9D58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B9D5C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B9D60: 409AFFE4  bne cr6, 0x821b9d44
	if !ctx.cr[6].eq {
	pc = 0x821B9D44; continue 'dispatch;
	}
	// 821B9D64: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821B9D68: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B9D6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9D70 size=348
    let mut pc: u32 = 0x821B9D70;
    'dispatch: loop {
        match pc {
            0x821B9D70 => {
    //   block [0x821B9D70..0x821B9ECC)
	// 821B9D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9D74: 4837B345  bl 0x825350b8
	ctx.lr = 0x821B9D78;
	sub_82535080(ctx, base);
	// 821B9D78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9D7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B9D80: 39000021  li r8, 0x21
	ctx.r[8].s64 = 33;
	// 821B9D84: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B9D88: 3BFD0062  addi r31, r29, 0x62
	ctx.r[31].s64 = ctx.r[29].s64 + 98;
	// 821B9D8C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 821B9D90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B9D94: 911D0000  stw r8, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B9D98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B9D9C: 915D0004  stw r10, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821B9DA0: 993F000E  stb r9, 0xe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(14 as u32), ctx.r[9].u8 ) };
	// 821B9DA4: 997F000A  stb r11, 0xa(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10 as u32), ctx.r[11].u8 ) };
	// 821B9DA8: 997F000B  stb r11, 0xb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	// 821B9DAC: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 821B9DB0: 997F000D  stb r11, 0xd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(13 as u32), ctx.r[11].u8 ) };
	// 821B9DB4: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 821B9DB8: B17F0002  sth r11, 2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 821B9DBC: B17F0004  sth r11, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 821B9DC0: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 821B9DC4: B17F0008  sth r11, 8(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	// 821B9DC8: 997F000F  stb r11, 0xf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(15 as u32), ctx.r[11].u8 ) };
	// 821B9DCC: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 821B9DD0: 997F0011  stb r11, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[11].u8 ) };
	// 821B9DD4: 88FE0004  lbz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9DD8: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821B9DDC: 419A0020  beq cr6, 0x821b9dfc
	if ctx.cr[6].eq {
	pc = 0x821B9DFC; continue 'dispatch;
	}
	// 821B9DE0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821B9DE4: 48001FD5  bl 0x821bbdb8
	ctx.lr = 0x821B9DE8;
	sub_821BBDB8(ctx, base);
	// 821B9DE8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B9DEC: 396BF9C0  addi r11, r11, -0x640
	ctx.r[11].s64 = ctx.r[11].s64 + -1600;
	// 821B9DF0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9DF4: 409A0008  bne cr6, 0x821b9dfc
	if !ctx.cr[6].eq {
	pc = 0x821B9DFC; continue 'dispatch;
	}
	// 821B9DF8: 38E00021  li r7, 0x21
	ctx.r[7].s64 = 33;
	// 821B9DFC: 90FD0000  stw r7, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821B9E00: 397E0CCC  addi r11, r30, 0xccc
	ctx.r[11].s64 = ctx.r[30].s64 + 3276;
	// 821B9E04: 811E0FEC  lwz r8, 0xfec(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4076 as u32) ) } as u64;
	// 821B9E08: 395D0008  addi r10, r29, 8
	ctx.r[10].s64 = ctx.r[29].s64 + 8;
	// 821B9E0C: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 821B9E10: 911D0004  stw r8, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821B9E14: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821B9E18: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9E1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B9E20: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B9E24: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B9E28: 4200FFF0  bdnz 0x821b9e18
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B9E18; continue 'dispatch;
	}
	// 821B9E2C: 817E0F58  lwz r11, 0xf58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3928 as u32) ) } as u64;
	// 821B9E30: 3B9D0034  addi r28, r29, 0x34
	ctx.r[28].s64 = ctx.r[29].s64 + 52;
	// 821B9E34: 917D0024  stw r11, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821B9E38: 817E1014  lwz r11, 0x1014(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4116 as u32) ) } as u64;
	// 821B9E3C: 917D0028  stw r11, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 821B9E40: 817E100C  lwz r11, 0x100c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4108 as u32) ) } as u64;
	// 821B9E44: 917D002C  stw r11, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 821B9E48: 817E1010  lwz r11, 0x1010(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4112 as u32) ) } as u64;
	// 821B9E4C: 917D0030  stw r11, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821B9E50: 817E1004  lwz r11, 0x1004(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4100 as u32) ) } as u64;
	// 821B9E54: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B9E58: 409A0018  bne cr6, 0x821b9e70
	if !ctx.cr[6].eq {
	pc = 0x821B9E70; continue 'dispatch;
	}
	// 821B9E5C: 817E1008  lwz r11, 0x1008(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4104 as u32) ) } as u64;
	// 821B9E60: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B9E64: 409A000C  bne cr6, 0x821b9e70
	if !ctx.cr[6].eq {
	pc = 0x821B9E70; continue 'dispatch;
	}
	// 821B9E68: 389E0F28  addi r4, r30, 0xf28
	ctx.r[4].s64 = ctx.r[30].s64 + 3880;
	// 821B9E6C: 48000028  b 0x821b9e94
	pc = 0x821B9E94; continue 'dispatch;
	// 821B9E70: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B9E74: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821B9E78: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B9E7C: 614A94F8  ori r10, r10, 0x94f8
	ctx.r[10].u64 = ctx.r[10].u64 | 38136;
	// 821B9E80: 3C600500  lis r3, 0x500
	ctx.r[3].s64 = 83886080;
	// 821B9E84: 60630119  ori r3, r3, 0x119
	ctx.r[3].u64 = ctx.r[3].u64 | 281;
	// 821B9E88: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B9E8C: 4810D2A5  bl 0x822c7130
	ctx.lr = 0x821B9E90;
	sub_822C7130(ctx, base);
	// 821B9E90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B9E94: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 821B9E98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B9E9C: 4837ACB5  bl 0x82534b50
	ctx.lr = 0x821B9EA0;
	sub_82534B50(ctx, base);
	// 821B9EA0: 397E044C  addi r11, r30, 0x44c
	ctx.r[11].s64 = ctx.r[30].s64 + 1100;
	// 821B9EA4: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 821B9EA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B9EAC: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9EB0: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821B9EB4: B15F0000  sth r10, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 821B9EB8: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 821B9EBC: 4200FFF0  bdnz 0x821b9eac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B9EAC; continue 'dispatch;
	}
	// 821B9EC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B9EC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B9EC8: 4837B240  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9ED0 size=92
    let mut pc: u32 = 0x821B9ED0;
    'dispatch: loop {
        match pc {
            0x821B9ED0 => {
    //   block [0x821B9ED0..0x821B9F2C)
	// 821B9ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9ED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B9EDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9EE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9EE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9EE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B9EEC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B9EF0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9EF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B9EF8: 4E800421  bctrl
	ctx.lr = 0x821B9EFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B9EFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9F00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B9F04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B9F08: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B9F0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B9F10: 4E800421  bctrl
	ctx.lr = 0x821B9F14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B9F14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B9F18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9F1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9F20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B9F24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9F28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9F30 size=136
    let mut pc: u32 = 0x821B9F30;
    'dispatch: loop {
        match pc {
            0x821B9F30 => {
    //   block [0x821B9F30..0x821B9FB8)
	// 821B9F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9F38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B9F3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9F44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B9F48: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9F4C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9F50: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B9F54: 419A000C  beq cr6, 0x821b9f60
	if ctx.cr[6].eq {
	pc = 0x821B9F60; continue 'dispatch;
	}
	// 821B9F58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B9F5C: 48000044  b 0x821b9fa0
	pc = 0x821B9FA0; continue 'dispatch;
	// 821B9F60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9F64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9F68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B9F6C: 4E800421  bctrl
	ctx.lr = 0x821B9F70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B9F70: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9F74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B9F78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B9F7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9F80: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9F84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B9F88: 4E800421  bctrl
	ctx.lr = 0x821B9F8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B9F8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B9F90: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B9F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9F98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B9F9C: 4E800421  bctrl
	ctx.lr = 0x821B9FA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B9FA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B9FA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9FA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9FAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B9FB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9FB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9FB8 size=8
    let mut pc: u32 = 0x821B9FB8;
    'dispatch: loop {
        match pc {
            0x821B9FB8 => {
    //   block [0x821B9FB8..0x821B9FC0)
	// 821B9FB8: 38600032  li r3, 0x32
	ctx.r[3].s64 = 50;
	// 821B9FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9FC0 size=8
    let mut pc: u32 = 0x821B9FC0;
    'dispatch: loop {
        match pc {
            0x821B9FC0 => {
    //   block [0x821B9FC0..0x821B9FC8)
	// 821B9FC0: 3860004A  li r3, 0x4a
	ctx.r[3].s64 = 74;
	// 821B9FC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9FC8 size=16
    let mut pc: u32 = 0x821B9FC8;
    'dispatch: loop {
        match pc {
            0x821B9FC8 => {
    //   block [0x821B9FC8..0x821B9FD8)
	// 821B9FC8: 1D641018  mulli r11, r4, 0x1018
	ctx.r[11].s64 = ctx.r[4].s64 * 4120;
	// 821B9FCC: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821B9FD0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 821B9FD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9FD8 size=8
    let mut pc: u32 = 0x821B9FD8;
    'dispatch: loop {
        match pc {
            0x821B9FD8 => {
    //   block [0x821B9FD8..0x821B9FE0)
	// 821B9FD8: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 821B9FDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B9FE0 size=656
    let mut pc: u32 = 0x821B9FE0;
    'dispatch: loop {
        match pc {
            0x821B9FE0 => {
    //   block [0x821B9FE0..0x821BA030)
	// 821B9FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9FE4: 4837B0D5  bl 0x825350b8
	ctx.lr = 0x821B9FE8;
	sub_82535080(ctx, base);
	// 821B9FE8: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9FEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B9FF0: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B9FF4: 83DF0084  lwz r30, 0x84(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B9FF8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821B9FFC: 4199026C  bgt cr6, 0x821ba268
	if ctx.cr[6].gt {
	pc = 0x821BA268; continue 'dispatch;
	}
	// 821BA000: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821BA004: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821BA008: 3D80821C  lis r12, -0x7de4
	ctx.r[12].s64 = -2112094208;
	// 821BA00C: 398CA020  addi r12, r12, -0x5fe0
	ctx.r[12].s64 = ctx.r[12].s64 + -24544;
	// 821BA010: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821BA014: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821BA018: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821BA01C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821BA030; continue 'dispatch;
		},
		1 => {
	pc = 0x821BA1B4; continue 'dispatch;
		},
		2 => {
	pc = 0x821BA1E8; continue 'dispatch;
		},
		3 => {
	pc = 0x821BA240; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821BA020: 821BA030  lwz r16, -0x5fd0(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24528 as u32) ) } as u64;
	// 821BA024: 821BA1B4  lwz r16, -0x5e4c(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24140 as u32) ) } as u64;
	// 821BA028: 821BA1E8  lwz r16, -0x5e18(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24088 as u32) ) } as u64;
	// 821BA02C: 821BA240  lwz r16, -0x5dc0(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24000 as u32) ) } as u64;
            }
            0x821BA030 => {
    //   block [0x821BA030..0x821BA1B4)
	// 821BA030: 817E0FE4  lwz r11, 0xfe4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4068 as u32) ) } as u64;
	// 821BA034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA038: 409A0014  bne cr6, 0x821ba04c
	if !ctx.cr[6].eq {
	pc = 0x821BA04C; continue 'dispatch;
	}
	// 821BA03C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821BA040: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821BA044: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 821BA048: 4837B0C0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821BA04C: 817E0FE8  lwz r11, 0xfe8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BA050: 2F0B0023  cmpwi cr6, r11, 0x23
	ctx.cr[6].compare_i32(ctx.r[11].s32, 35, &mut ctx.xer);
	// 821BA054: 419A001C  beq cr6, 0x821ba070
	if ctx.cr[6].eq {
	pc = 0x821BA070; continue 'dispatch;
	}
	// 821BA058: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BA05C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821BA060: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821BA064: 915F0080  stw r10, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821BA068: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 821BA06C: 4837B09C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
	// 821BA070: 817E1004  lwz r11, 0x1004(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4100 as u32) ) } as u64;
	// 821BA074: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821BA078: 409A0018  bne cr6, 0x821ba090
	if !ctx.cr[6].eq {
	pc = 0x821BA090; continue 'dispatch;
	}
	// 821BA07C: 817E1008  lwz r11, 0x1008(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4104 as u32) ) } as u64;
	// 821BA080: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821BA084: 409A000C  bne cr6, 0x821ba090
	if !ctx.cr[6].eq {
	pc = 0x821BA090; continue 'dispatch;
	}
	// 821BA088: 387E0F28  addi r3, r30, 0xf28
	ctx.r[3].s64 = ctx.r[30].s64 + 3880;
	// 821BA08C: 48000024  b 0x821ba0b0
	pc = 0x821BA0B0; continue 'dispatch;
	// 821BA090: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821BA094: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821BA098: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821BA09C: 614A94F8  ori r10, r10, 0x94f8
	ctx.r[10].u64 = ctx.r[10].u64 | 38136;
	// 821BA0A0: 3C600500  lis r3, 0x500
	ctx.r[3].s64 = 83886080;
	// 821BA0A4: 60630119  ori r3, r3, 0x119
	ctx.r[3].u64 = ctx.r[3].u64 | 281;
	// 821BA0A8: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821BA0AC: 4810D085  bl 0x822c7130
	ctx.lr = 0x821BA0B0;
	sub_822C7130(ctx, base);
	// 821BA0B0: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821BA0B4: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 821BA0B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821BA0BC: 481BD2FD  bl 0x823773b8
	ctx.lr = 0x821BA0C0;
	sub_823773B8(ctx, base);
	// 821BA0C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA0C4: 419AFF78  beq cr6, 0x821ba03c
	if ctx.cr[6].eq {
	pc = 0x821BA03C; continue 'dispatch;
	}
	// 821BA0C8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA0CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA0D0: 419A000C  beq cr6, 0x821ba0dc
	if ctx.cr[6].eq {
	pc = 0x821BA0DC; continue 'dispatch;
	}
	// 821BA0D4: 93BE1004  stw r29, 0x1004(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4100 as u32), ctx.r[29].u32 ) };
	// 821BA0D8: 93BE1008  stw r29, 0x1008(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4104 as u32), ctx.r[29].u32 ) };
	// 821BA0DC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821BA0E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821BA0E4: 38EB1014  addi r7, r11, 0x1014
	ctx.r[7].s64 = ctx.r[11].s64 + 4116;
	// 821BA0E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821BA0EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BA0F0: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 821BA0F4: 481B039D  bl 0x8236a490
	ctx.lr = 0x821BA0F8;
	sub_8236A490(ctx, base);
	// 821BA0F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA0FC: 419A000C  beq cr6, 0x821ba108
	if ctx.cr[6].eq {
	pc = 0x821BA108; continue 'dispatch;
	}
	// 821BA100: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BA104: 48000008  b 0x821ba10c
	pc = 0x821BA10C; continue 'dispatch;
	// 821BA108: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821BA10C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA110: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821BA114: 907F009C  stw r3, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[3].u32 ) };
	// 821BA118: 419A0008  beq cr6, 0x821ba120
	if ctx.cr[6].eq {
	pc = 0x821BA120; continue 'dispatch;
	}
	// 821BA11C: 4814D56D  bl 0x82307688
	ctx.lr = 0x821BA120;
	sub_82307688(ctx, base);
	// 821BA120: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821BA124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA128: 419A0014  beq cr6, 0x821ba13c
	if ctx.cr[6].eq {
	pc = 0x821BA13C; continue 'dispatch;
	}
	// 821BA12C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BA130: 813F0098  lwz r9, 0x98(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821BA134: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BA138: 419A0008  beq cr6, 0x821ba140
	if ctx.cr[6].eq {
	pc = 0x821BA140; continue 'dispatch;
	}
	// 821BA13C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821BA140: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821BA144: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821BA148: 4814D801  bl 0x82307948
	ctx.lr = 0x821BA14C;
	sub_82307948(ctx, base);
	// 821BA14C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821BA150: 4198FEEC  blt cr6, 0x821ba03c
	if ctx.cr[6].lt {
	pc = 0x821BA03C; continue 'dispatch;
	}
	// 821BA154: 907F0090  stw r3, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 821BA158: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821BA15C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA160: 419A0014  beq cr6, 0x821ba174
	if ctx.cr[6].eq {
	pc = 0x821BA174; continue 'dispatch;
	}
	// 821BA164: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BA168: 813F0098  lwz r9, 0x98(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821BA16C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BA170: 419A0008  beq cr6, 0x821ba178
	if ctx.cr[6].eq {
	pc = 0x821BA178; continue 'dispatch;
	}
	// 821BA174: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821BA178: 3D4082B5  lis r10, -0x7d4b
	ctx.r[10].s64 = -2102067200;
	// 821BA17C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821BA180: 394A0C40  addi r10, r10, 0xc40
	ctx.r[10].s64 = ctx.r[10].s64 + 3136;
	// 821BA184: C00A06B0  lfs f0, 0x6b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BA188: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821BA18C: C1AAD5B0  lfs f13, -0x2a50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821BA190: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821BA194: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821BA198: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821BA19C: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821BA1A0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BA1A4: 4814D8A5  bl 0x82307a48
	ctx.lr = 0x821BA1A8;
	sub_82307A48(ctx, base);
	// 821BA1A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA1AC: 419AFE90  beq cr6, 0x821ba03c
	if ctx.cr[6].eq {
	pc = 0x821BA03C; continue 'dispatch;
	}
	// 821BA1B0: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
            }
            0x821BA1B4 => {
    //   block [0x821BA1B4..0x821BA1E8)
	// 821BA1B4: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821BA1B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA1BC: 419A0014  beq cr6, 0x821ba1d0
	if ctx.cr[6].eq {
	pc = 0x821BA1D0; continue 'dispatch;
	}
	// 821BA1C0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BA1C4: 813F0098  lwz r9, 0x98(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821BA1C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BA1CC: 419A0008  beq cr6, 0x821ba1d4
	if ctx.cr[6].eq {
	pc = 0x821BA1D4; continue 'dispatch;
	}
	// 821BA1D0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821BA1D4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821BA1D8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821BA1DC: 419A008C  beq cr6, 0x821ba268
	if ctx.cr[6].eq {
	pc = 0x821BA268; continue 'dispatch;
	}
	// 821BA1E0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821BA1E4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	pc = 0x821BA1E8; continue 'dispatch;
            }
            0x821BA1E8 => {
    //   block [0x821BA1E8..0x821BA240)
	// 821BA1E8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA1EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA1F0: 419A0048  beq cr6, 0x821ba238
	if ctx.cr[6].eq {
	pc = 0x821BA238; continue 'dispatch;
	}
	// 821BA1F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA1F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA1FC: 83DF0084  lwz r30, 0x84(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 821BA200: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BA204: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BA208: 4E800421  bctrl
	ctx.lr = 0x821BA20C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BA20C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821BA210: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA218: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821BA21C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BA220: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BA224: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 821BA228: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BA22C: 4E800421  bctrl
	ctx.lr = 0x821BA230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BA230: 907E1004  stw r3, 0x1004(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4100 as u32), ctx.r[3].u32 ) };
	// 821BA234: 93BE1008  stw r29, 0x1008(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4104 as u32), ctx.r[29].u32 ) };
	// 821BA238: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821BA23C: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
            }
            0x821BA240 => {
    //   block [0x821BA240..0x821BA270)
	// 821BA240: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA248: 419A0020  beq cr6, 0x821ba268
	if ctx.cr[6].eq {
	pc = 0x821BA268; continue 'dispatch;
	}
	// 821BA24C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821BA250: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821BA254: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821BA258: 409A0010  bne cr6, 0x821ba268
	if !ctx.cr[6].eq {
	pc = 0x821BA268; continue 'dispatch;
	}
	// 821BA25C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821BA260: 9B9F0025  stb r28, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[28].u8 ) };
	// 821BA264: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821BA268: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 821BA26C: 4837AE9C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA270 size=20
    let mut pc: u32 = 0x821BA270;
    'dispatch: loop {
        match pc {
            0x821BA270 => {
    //   block [0x821BA270..0x821BA284)
	// 821BA270: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821BA274: 396BFFFD  addi r11, r11, -3
	ctx.r[11].s64 = ctx.r[11].s64 + -3;
	// 821BA278: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821BA27C: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BA280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA288 size=96
    let mut pc: u32 = 0x821BA288;
    'dispatch: loop {
        match pc {
            0x821BA288 => {
    //   block [0x821BA288..0x821BA2E8)
	// 821BA288: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 821BA28C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA290: 419A0070  beq cr6, 0x821ba300
	if ctx.cr[6].eq {
		sub_821BA300(ctx, base);
		return;
	}
	// 821BA294: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BA298: 81430098  lwz r10, 0x98(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 821BA29C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BA2A0: 409A0060  bne cr6, 0x821ba300
	if !ctx.cr[6].eq {
		sub_821BA300(ctx, base);
		return;
	}
	// 821BA2A4: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 821BA2A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA2AC: 419A0014  beq cr6, 0x821ba2c0
	if ctx.cr[6].eq {
	pc = 0x821BA2C0; continue 'dispatch;
	}
	// 821BA2B0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BA2B4: 81230098  lwz r9, 0x98(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 821BA2B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BA2BC: 419A0008  beq cr6, 0x821ba2c4
	if ctx.cr[6].eq {
	pc = 0x821BA2C4; continue 'dispatch;
	}
	// 821BA2C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BA2C4: 81430090  lwz r10, 0x90(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821BA2C8: 812B008C  lwz r9, 0x8c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BA2CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BA2D0: 41980018  blt cr6, 0x821ba2e8
	if ctx.cr[6].lt {
		sub_821BA2E8(ctx, base);
		return;
	}
	// 821BA2D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BA2D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BA2DC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821BA2E0: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BA2E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA2E8 size=24
    let mut pc: u32 = 0x821BA2E8;
    'dispatch: loop {
        match pc {
            0x821BA2E8 => {
    //   block [0x821BA2E8..0x821BA300)
	// 821BA2E8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BA2EC: 896B012C  lbz r11, 0x12c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(300 as u32) ) } as u64;
	// 821BA2F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BA2F4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821BA2F8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BA2FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA300 size=8
    let mut pc: u32 = 0x821BA300;
    'dispatch: loop {
        match pc {
            0x821BA300 => {
    //   block [0x821BA300..0x821BA308)
	// 821BA300: 8063008C  lwz r3, 0x8c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BA304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA308 size=16
    let mut pc: u32 = 0x821BA308;
    'dispatch: loop {
        match pc {
            0x821BA308 => {
    //   block [0x821BA308..0x821BA318)
	// 821BA308: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821BA30C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BA310: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BA314: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA318 size=8
    let mut pc: u32 = 0x821BA318;
    'dispatch: loop {
        match pc {
            0x821BA318 => {
    //   block [0x821BA318..0x821BA320)
	// 821BA318: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BA31C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA320 size=56
    let mut pc: u32 = 0x821BA320;
    'dispatch: loop {
        match pc {
            0x821BA320 => {
    //   block [0x821BA320..0x821BA358)
	// 821BA320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA328: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA32C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA330: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BA334: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BA338: 4E800421  bctrl
	ctx.lr = 0x821BA33C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BA33C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821BA340: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BA344: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 821BA348: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BA34C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA350: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA354: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA358 size=120
    let mut pc: u32 = 0x821BA358;
    'dispatch: loop {
        match pc {
            0x821BA358 => {
    //   block [0x821BA358..0x821BA3D0)
	// 821BA358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA35C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA360: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA364: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA368: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BA36C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA370: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BA374: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BA378: 4E800421  bctrl
	ctx.lr = 0x821BA37C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BA37C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA380: 419A0038  beq cr6, 0x821ba3b8
	if ctx.cr[6].eq {
	pc = 0x821BA3B8; continue 'dispatch;
	}
	// 821BA384: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA38C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BA390: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BA394: 4E800421  bctrl
	ctx.lr = 0x821BA398;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BA398: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821BA39C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BA3A0: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 821BA3A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BA3A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA3AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA3B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BA3B4: 4E800020  blr
	return;
	// 821BA3B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BA3BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BA3C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA3C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA3C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BA3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA3D0 size=56
    let mut pc: u32 = 0x821BA3D0;
    'dispatch: loop {
        match pc {
            0x821BA3D0 => {
    //   block [0x821BA3D0..0x821BA408)
	// 821BA3D0: A163003A  lhz r11, 0x3a(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(58 as u32) ) } as u64;
	// 821BA3D4: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 821BA3D8: 419A0028  beq cr6, 0x821ba400
	if ctx.cr[6].eq {
	pc = 0x821BA400; continue 'dispatch;
	}
	// 821BA3DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821BA3E0: 3963032C  addi r11, r3, 0x32c
	ctx.r[11].s64 = ctx.r[3].s64 + 812;
	// 821BA3E4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA3E8: 2B090080  cmplwi cr6, r9, 0x80
	ctx.cr[6].compare_u32(ctx.r[9].u32, 128 as u32, &mut ctx.xer);
	// 821BA3EC: 4198001C  blt cr6, 0x821ba408
	if ctx.cr[6].lt {
		sub_821BA408(ctx, base);
		return;
	}
	// 821BA3F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BA3F4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821BA3F8: 2F0A0022  cmpwi cr6, r10, 0x22
	ctx.cr[6].compare_i32(ctx.r[10].s32, 34, &mut ctx.xer);
	// 821BA3FC: 4198FFE8  blt cr6, 0x821ba3e4
	if ctx.cr[6].lt {
	pc = 0x821BA3E4; continue 'dispatch;
	}
	// 821BA400: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BA404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA408 size=36
    let mut pc: u32 = 0x821BA408;
    'dispatch: loop {
        match pc {
            0x821BA408 => {
    //   block [0x821BA408..0x821BA42C)
	// 821BA408: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA40C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BA410: 409AFFF0  bne cr6, 0x821ba400
	if !ctx.cr[6].eq {
		sub_821BA3D0(ctx, base);
		return;
	}
	// 821BA414: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821BA418: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BA41C: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821BA420: 99440000  stb r10, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821BA424: 99640001  stb r11, 1(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 821BA428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA430 size=972
    let mut pc: u32 = 0x821BA430;
    'dispatch: loop {
        match pc {
            0x821BA430 => {
    //   block [0x821BA430..0x821BA728)
	// 821BA430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA434: 4837AC81  bl 0x825350b4
	ctx.lr = 0x821BA438;
	sub_82535080(ctx, base);
	// 821BA438: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA43C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BA440: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821BA444: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA44C: 48003F95  bl 0x821be3e0
	ctx.lr = 0x821BA450;
	sub_821BE3E0(ctx, base);
	// 821BA450: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821BA454: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821BA458: 38A00F5C  li r5, 0xf5c
	ctx.r[5].s64 = 3932;
	// 821BA45C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BA460: 937F0FE4  stw r27, 0xfe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4068 as u32), ctx.r[27].u32 ) };
	// 821BA464: 939F1004  stw r28, 0x1004(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4100 as u32), ctx.r[28].u32 ) };
	// 821BA468: 939F1008  stw r28, 0x1008(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4104 as u32), ctx.r[28].u32 ) };
	// 821BA46C: 937F1014  stw r27, 0x1014(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4116 as u32), ctx.r[27].u32 ) };
	// 821BA470: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA474: 4837A6DD  bl 0x82534b50
	ctx.lr = 0x821BA478;
	sub_82534B50(ctx, base);
	// 821BA478: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 821BA47C: A17D003A  lhz r11, 0x3a(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(58 as u32) ) } as u64;
	// 821BA480: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 821BA484: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 821BA488: 395D032D  addi r10, r29, 0x32d
	ctx.r[10].s64 = ctx.r[29].s64 + 813;
	// 821BA48C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821BA490: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821BA494: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821BA498: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BA49C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 821BA4A0: 88CAFFFF  lbz r6, -1(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-1 as u32) ) } as u64;
	// 821BA4A4: 7CCB0774  extsb r11, r6
	ctx.r[11].s64 = ctx.r[6].s8 as i64;
	// 821BA4A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BA4AC: 419800B4  blt cr6, 0x821ba560
	if ctx.cr[6].lt {
	pc = 0x821BA560; continue 'dispatch;
	}
	// 821BA4B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA4B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA4B8: 419A0064  beq cr6, 0x821ba51c
	if ctx.cr[6].eq {
	pc = 0x821BA51C; continue 'dispatch;
	}
	// 821BA4BC: 396B0F5C  addi r11, r11, 0xf5c
	ctx.r[11].s64 = ctx.r[11].s64 + 3932;
	// 821BA4C0: 890A0001  lbz r8, 1(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 821BA4C4: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA4C8: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA4CC: 2B090022  cmplwi cr6, r9, 0x22
	ctx.cr[6].compare_u32(ctx.r[9].u32, 34 as u32, &mut ctx.xer);
	// 821BA4D0: 40980090  bge cr6, 0x821ba560
	if !ctx.cr[6].lt {
	pc = 0x821BA560; continue 'dispatch;
	}
	// 821BA4D4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BA4D8: 7CC959AE  stbx r6, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u8) };
	// 821BA4DC: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA4E0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BA4E4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821BA4E8: 98E90001  stb r7, 1(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(1 as u32), ctx.r[7].u8 ) };
	// 821BA4EC: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA4F0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BA4F4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821BA4F8: 99090002  stb r8, 2(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 821BA4FC: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA500: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BA504: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821BA508: 98A90003  stb r5, 3(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(3 as u32), ctx.r[5].u8 ) };
	// 821BA50C: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA510: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821BA514: 912B0088  stw r9, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 821BA518: 48000048  b 0x821ba560
	pc = 0x821BA560; continue 'dispatch;
	// 821BA51C: 392B0F5C  addi r9, r11, 0xf5c
	ctx.r[9].s64 = ctx.r[11].s64 + 3932;
	// 821BA520: 81690088  lwz r11, 0x88(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA524: 2B0B0022  cmplwi cr6, r11, 0x22
	ctx.cr[6].compare_u32(ctx.r[11].u32, 34 as u32, &mut ctx.xer);
	// 821BA528: 40980038  bge cr6, 0x821ba560
	if !ctx.cr[6].lt {
	pc = 0x821BA560; continue 'dispatch;
	}
	// 821BA52C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA530: 890AFFFF  lbz r8, -1(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-1 as u32) ) } as u64;
	// 821BA534: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821BA538: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 821BA53C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA540: 990B0001  stb r8, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[8].u8 ) };
	// 821BA544: 890A0001  lbz r8, 1(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 821BA548: 990B0002  stb r8, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 821BA54C: 890A0002  lbz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 821BA550: 990B0003  stb r8, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[8].u8 ) };
	// 821BA554: 81690088  lwz r11, 0x88(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA558: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BA55C: 91690088  stw r11, 0x88(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 821BA560: 88CA0007  lbz r6, 7(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(7 as u32) ) } as u64;
	// 821BA564: 7CCB0774  extsb r11, r6
	ctx.r[11].s64 = ctx.r[6].s8 as i64;
	// 821BA568: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BA56C: 419800B4  blt cr6, 0x821ba620
	if ctx.cr[6].lt {
	pc = 0x821BA620; continue 'dispatch;
	}
	// 821BA570: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA574: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA578: 419A0064  beq cr6, 0x821ba5dc
	if ctx.cr[6].eq {
	pc = 0x821BA5DC; continue 'dispatch;
	}
	// 821BA57C: 396B0F5C  addi r11, r11, 0xf5c
	ctx.r[11].s64 = ctx.r[11].s64 + 3932;
	// 821BA580: 890A0009  lbz r8, 9(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(9 as u32) ) } as u64;
	// 821BA584: 88EA0008  lbz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA588: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA58C: 2B090022  cmplwi cr6, r9, 0x22
	ctx.cr[6].compare_u32(ctx.r[9].u32, 34 as u32, &mut ctx.xer);
	// 821BA590: 40980090  bge cr6, 0x821ba620
	if !ctx.cr[6].lt {
	pc = 0x821BA620; continue 'dispatch;
	}
	// 821BA594: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BA598: 7CC959AE  stbx r6, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u8) };
	// 821BA59C: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA5A0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BA5A4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821BA5A8: 98E90001  stb r7, 1(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(1 as u32), ctx.r[7].u8 ) };
	// 821BA5AC: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA5B0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BA5B4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821BA5B8: 99090002  stb r8, 2(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 821BA5BC: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA5C0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BA5C4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821BA5C8: 98A90003  stb r5, 3(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(3 as u32), ctx.r[5].u8 ) };
	// 821BA5CC: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA5D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821BA5D4: 912B0088  stw r9, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 821BA5D8: 48000048  b 0x821ba620
	pc = 0x821BA620; continue 'dispatch;
	// 821BA5DC: 392B0F5C  addi r9, r11, 0xf5c
	ctx.r[9].s64 = ctx.r[11].s64 + 3932;
	// 821BA5E0: 81690088  lwz r11, 0x88(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA5E4: 2B0B0022  cmplwi cr6, r11, 0x22
	ctx.cr[6].compare_u32(ctx.r[11].u32, 34 as u32, &mut ctx.xer);
	// 821BA5E8: 40980038  bge cr6, 0x821ba620
	if !ctx.cr[6].lt {
	pc = 0x821BA620; continue 'dispatch;
	}
	// 821BA5EC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA5F0: 890A0007  lbz r8, 7(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(7 as u32) ) } as u64;
	// 821BA5F4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821BA5F8: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 821BA5FC: 890A0008  lbz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA600: 990B0001  stb r8, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[8].u8 ) };
	// 821BA604: 890A0009  lbz r8, 9(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(9 as u32) ) } as u64;
	// 821BA608: 990B0002  stb r8, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 821BA60C: 890A000A  lbz r8, 0xa(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(10 as u32) ) } as u64;
	// 821BA610: 990B0003  stb r8, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[8].u8 ) };
	// 821BA614: 81690088  lwz r11, 0x88(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(136 as u32) ) } as u64;
	// 821BA618: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BA61C: 91690088  stw r11, 0x88(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 821BA620: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 821BA624: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821BA628: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821BA62C: 409AFE74  bne cr6, 0x821ba4a0
	if !ctx.cr[6].eq {
	pc = 0x821BA4A0; continue 'dispatch;
	}
	// 821BA630: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA634: 817F0FE4  lwz r11, 0xfe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4068 as u32) ) } as u64;
	// 821BA638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA63C: 419A01B8  beq cr6, 0x821ba7f4
	if ctx.cr[6].eq {
	pc = 0x821BA7F4; continue 'dispatch;
	}
	// 821BA640: 897D0008  lbz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BA648: 889D0004  lbz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA64C: 7D650774  extsb r5, r11
	ctx.r[5].s64 = ctx.r[11].s8 as i64;
	// 821BA650: 48004419  bl 0x821bea68
	ctx.lr = 0x821BA654;
	sub_821BEA68(ctx, base);
	// 821BA654: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA658: 917F0FE8  stw r11, 0xfe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4072 as u32), ctx.r[11].u32 ) };
	// 821BA65C: 897D0008  lbz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA660: 7D650774  extsb r5, r11
	ctx.r[5].s64 = ctx.r[11].s8 as i64;
	// 821BA664: 2F050023  cmpwi cr6, r5, 0x23
	ctx.cr[6].compare_i32(ctx.r[5].s32, 35, &mut ctx.xer);
	// 821BA668: 419A0020  beq cr6, 0x821ba688
	if ctx.cr[6].eq {
	pc = 0x821BA688; continue 'dispatch;
	}
	// 821BA66C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821BA670: 4811C681  bl 0x822d6cf0
	ctx.lr = 0x821BA674;
	sub_822D6CF0(ctx, base);
	// 821BA674: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 821BA678: 396B663C  addi r11, r11, 0x663c
	ctx.r[11].s64 = ctx.r[11].s64 + 26172;
	// 821BA67C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BA680: 409A0008  bne cr6, 0x821ba688
	if !ctx.cr[6].eq {
	pc = 0x821BA688; continue 'dispatch;
	}
	// 821BA684: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BA688: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA68C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BA690: 90AB0FEC  stw r5, 0xfec(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4076 as u32), ctx.r[5].u32 ) };
	// 821BA694: 895D0009  lbz r10, 9(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(9 as u32) ) } as u64;
	// 821BA698: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA69C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821BA6A0: 814B0FEC  lwz r10, 0xfec(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4076 as u32) ) } as u64;
	// 821BA6A4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821BA6A8: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821BA6AC: F94B0FF0  std r10, 0xff0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(4080 as u32), ctx.r[10].u64 ) };
	// 821BA6B0: 889D0010  lbz r4, 0x10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BA6B4: 4811C8A5  bl 0x822d6f58
	ctx.lr = 0x821BA6B8;
	sub_822D6F58(ctx, base);
	// 821BA6B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821BA6BC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA6C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821BA6C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BA6C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA6CC: 916A0FF8  stw r11, 0xff8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4088 as u32), ctx.r[11].u32 ) };
	// 821BA6D0: 897D000A  lbz r11, 0xa(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(10 as u32) ) } as u64;
	// 821BA6D4: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 821BA6D8: 4811C461  bl 0x822d6b38
	ctx.lr = 0x821BA6DC;
	sub_822D6B38(ctx, base);
	// 821BA6DC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA6E0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BA6E4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 821BA6E8: 912A0FFC  stw r9, 0xffc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4092 as u32), ctx.r[9].u32 ) };
	// 821BA6EC: 895D0007  lbz r10, 7(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(7 as u32) ) } as u64;
	// 821BA6F0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821BA6F4: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 821BA6F8: 4199003C  bgt cr6, 0x821ba734
	if ctx.cr[6].gt {
	pc = 0x821BA734; continue 'dispatch;
	}
	// 821BA6FC: 3D80821C  lis r12, -0x7de4
	ctx.r[12].s64 = -2112094208;
	// 821BA700: 398CA714  addi r12, r12, -0x58ec
	ctx.r[12].s64 = ctx.r[12].s64 + -22764;
	// 821BA704: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821BA708: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821BA70C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821BA710: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x821BA728; continue 'dispatch;
		},
		1 => {
	pc = 0x821BA730; continue 'dispatch;
		},
		2 => {
	pc = 0x821BA728; continue 'dispatch;
		},
		3 => {
	pc = 0x821BA728; continue 'dispatch;
		},
		4 => {
	pc = 0x821BA728; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821BA714: 821BA728  lwz r16, -0x58d8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22744 as u32) ) } as u64;
	// 821BA718: 821BA730  lwz r16, -0x58d0(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22736 as u32) ) } as u64;
	// 821BA71C: 821BA728  lwz r16, -0x58d8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22744 as u32) ) } as u64;
	// 821BA720: 821BA728  lwz r16, -0x58d8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22744 as u32) ) } as u64;
	// 821BA724: 821BA728  lwz r16, -0x58d8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22744 as u32) ) } as u64;
            }
            0x821BA728 => {
    //   block [0x821BA728..0x821BA730)
	// 821BA728: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821BA72C: 48000008  b 0x821ba734
	pc = 0x821BA734; continue 'dispatch;
            }
            0x821BA730 => {
    //   block [0x821BA730..0x821BA7FC)
	// 821BA730: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821BA734: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA738: 916A1000  stw r11, 0x1000(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4096 as u32), ctx.r[11].u32 ) };
	// 821BA73C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA740: 88EB0004  lbz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA744: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821BA748: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821BA74C: 38CBF9C0  addi r6, r11, -0x640
	ctx.r[6].s64 = ctx.r[11].s64 + -1600;
	// 821BA750: 419A0014  beq cr6, 0x821ba764
	if ctx.cr[6].eq {
	pc = 0x821BA764; continue 'dispatch;
	}
	// 821BA754: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821BA758: 48001661  bl 0x821bbdb8
	ctx.lr = 0x821BA75C;
	sub_821BBDB8(ctx, base);
	// 821BA75C: 7F033040  cmplw cr6, r3, r6
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BA760: 419A0094  beq cr6, 0x821ba7f4
	if ctx.cr[6].eq {
	pc = 0x821BA7F4; continue 'dispatch;
	}
	// 821BA764: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821BA768: 419A0014  beq cr6, 0x821ba77c
	if ctx.cr[6].eq {
	pc = 0x821BA77C; continue 'dispatch;
	}
	// 821BA76C: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 821BA770: 419A000C  beq cr6, 0x821ba77c
	if ctx.cr[6].eq {
	pc = 0x821BA77C; continue 'dispatch;
	}
	// 821BA774: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821BA778: 409A007C  bne cr6, 0x821ba7f4
	if !ctx.cr[6].eq {
	pc = 0x821BA7F4; continue 'dispatch;
	}
	// 821BA77C: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821BA780: 419A0018  beq cr6, 0x821ba798
	if ctx.cr[6].eq {
	pc = 0x821BA798; continue 'dispatch;
	}
	// 821BA784: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821BA788: 48001631  bl 0x821bbdb8
	ctx.lr = 0x821BA78C;
	sub_821BBDB8(ctx, base);
	// 821BA78C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821BA790: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BA794: 409A0008  bne cr6, 0x821ba79c
	if !ctx.cr[6].eq {
	pc = 0x821BA79C; continue 'dispatch;
	}
	// 821BA798: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 821BA79C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821BA7A0: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BA7A4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821BA7A8: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821BA7AC: 612994F8  ori r9, r9, 0x94f8
	ctx.r[9].u64 = ctx.r[9].u64 | 38136;
	// 821BA7B0: 7C8B482E  lwzx r4, r11, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821BA7B4: 4810C97D  bl 0x822c7130
	ctx.lr = 0x821BA7B8;
	sub_822C7130(ctx, base);
	// 821BA7B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA7BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BA7C0: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 821BA7C4: 386B0F28  addi r3, r11, 0xf28
	ctx.r[3].s64 = ctx.r[11].s64 + 3880;
	// 821BA7C8: 483783F9  bl 0x82532bc0
	ctx.lr = 0x821BA7CC;
	sub_82532BC0(ctx, base);
	// 821BA7CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA7D0: 9B6B0F54  stb r27, 0xf54(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3924 as u32), ctx.r[27].u8 ) };
	// 821BA7D4: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA7DC: 480040DD  bl 0x821be8b8
	ctx.lr = 0x821BA7E0;
	sub_821BE8B8(ctx, base);
	// 821BA7E0: 907F0F58  stw r3, 0xf58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3928 as u32), ctx.r[3].u32 ) };
	// 821BA7E4: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA7EC: 480041A5  bl 0x821be990
	ctx.lr = 0x821BA7F0;
	sub_821BE990(ctx, base);
	// 821BA7F0: 907F1014  stw r3, 0x1014(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4116 as u32), ctx.r[3].u32 ) };
	// 821BA7F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BA7F8: 4837A90C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA800 size=316
    let mut pc: u32 = 0x821BA800;
    'dispatch: loop {
        match pc {
            0x821BA800 => {
    //   block [0x821BA800..0x821BA93C)
	// 821BA800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BA80C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA814: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BA818: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BA81C: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 821BA820: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 821BA824: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA828: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA82C: 98E80004  stb r7, 4(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u8 ) };
	// 821BA830: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA834: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA838: 910A0FEC  stw r8, 0xfec(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4076 as u32), ctx.r[8].u32 ) };
	// 821BA83C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA840: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BA844: 910A0F58  stw r8, 0xf58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3928 as u32), ctx.r[8].u32 ) };
	// 821BA848: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA84C: 394A0CCC  addi r10, r10, 0xccc
	ctx.r[10].s64 = ctx.r[10].s64 + 3276;
	// 821BA850: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BA854: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA858: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821BA85C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821BA860: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BA864: 4200FFF0  bdnz 0x821ba854
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA854; continue 'dispatch;
	}
	// 821BA868: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA86C: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 821BA870: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BA874: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 821BA878: 914B1014  stw r10, 0x1014(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4116 as u32), ctx.r[10].u32 ) };
	// 821BA87C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA880: 386B0F28  addi r3, r11, 0xf28
	ctx.r[3].s64 = ctx.r[11].s64 + 3880;
	// 821BA884: 4837A2CD  bl 0x82534b50
	ctx.lr = 0x821BA888;
	sub_82534B50(ctx, base);
	// 821BA888: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA88C: 393F0062  addi r9, r31, 0x62
	ctx.r[9].s64 = ctx.r[31].s64 + 98;
	// 821BA890: 394B044C  addi r10, r11, 0x44c
	ctx.r[10].s64 = ctx.r[11].s64 + 1100;
	// 821BA894: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821BA898: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821BA89C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BA8A0: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA8A4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821BA8A8: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 821BA8AC: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 821BA8B0: 4200FFF0  bdnz 0x821ba8a0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA8A0; continue 'dispatch;
	}
	// 821BA8B4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA8B8: 88E40004  lbz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA8BC: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821BA8C0: 419A001C  beq cr6, 0x821ba8dc
	if ctx.cr[6].eq {
	pc = 0x821BA8DC; continue 'dispatch;
	}
	// 821BA8C4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821BA8C8: 480014F1  bl 0x821bbdb8
	ctx.lr = 0x821BA8CC;
	sub_821BBDB8(ctx, base);
	// 821BA8CC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821BA8D0: 396BF9C0  addi r11, r11, -0x640
	ctx.r[11].s64 = ctx.r[11].s64 + -1600;
	// 821BA8D4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BA8D8: 419A004C  beq cr6, 0x821ba924
	if ctx.cr[6].eq {
	pc = 0x821BA924; continue 'dispatch;
	}
	// 821BA8DC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821BA8E0: 419A0014  beq cr6, 0x821ba8f4
	if ctx.cr[6].eq {
	pc = 0x821BA8F4; continue 'dispatch;
	}
	// 821BA8E4: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 821BA8E8: 419A000C  beq cr6, 0x821ba8f4
	if ctx.cr[6].eq {
	pc = 0x821BA8F4; continue 'dispatch;
	}
	// 821BA8EC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821BA8F0: 409A0034  bne cr6, 0x821ba924
	if !ctx.cr[6].eq {
	pc = 0x821BA924; continue 'dispatch;
	}
	// 821BA8F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BA8F8: 4BFA8F59  bl 0x82163850
	ctx.lr = 0x821BA8FC;
	sub_82163850(ctx, base);
	// 821BA8FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821BA900: 48001529  bl 0x821bbe28
	ctx.lr = 0x821BA904;
	sub_821BBE28(ctx, base);
	// 821BA904: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA908: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BA90C: 386B0F28  addi r3, r11, 0xf28
	ctx.r[3].s64 = ctx.r[11].s64 + 3880;
	// 821BA910: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 821BA914: 483782AD  bl 0x82532bc0
	ctx.lr = 0x821BA918;
	sub_82532BC0(ctx, base);
	// 821BA918: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA91C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821BA920: 994B0F54  stb r10, 0xf54(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3924 as u32), ctx.r[10].u8 ) };
	// 821BA924: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BA928: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA92C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA930: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BA934: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BA938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA940 size=320
    let mut pc: u32 = 0x821BA940;
    'dispatch: loop {
        match pc {
            0x821BA940 => {
    //   block [0x821BA940..0x821BAA80)
	// 821BA940: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA944: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821BA948: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821BA94C: 394A044C  addi r10, r10, 0x44c
	ctx.r[10].s64 = ctx.r[10].s64 + 1100;
	// 821BA950: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BA954: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA958: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821BA95C: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 821BA960: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 821BA964: 4200FFF0  bdnz 0x821ba954
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA954; continue 'dispatch;
	}
	// 821BA968: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA96C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821BA970: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821BA974: 394A0580  addi r10, r10, 0x580
	ctx.r[10].s64 = ctx.r[10].s64 + 1408;
	// 821BA978: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BA97C: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA980: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821BA984: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 821BA988: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 821BA98C: 4200FFF0  bdnz 0x821ba97c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA97C; continue 'dispatch;
	}
	// 821BA990: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA994: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821BA998: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821BA99C: 394A06B4  addi r10, r10, 0x6b4
	ctx.r[10].s64 = ctx.r[10].s64 + 1716;
	// 821BA9A0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BA9A4: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA9A8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821BA9AC: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 821BA9B0: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 821BA9B4: 4200FFF0  bdnz 0x821ba9a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA9A4; continue 'dispatch;
	}
	// 821BA9B8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA9BC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821BA9C0: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821BA9C4: 394A07E8  addi r10, r10, 0x7e8
	ctx.r[10].s64 = ctx.r[10].s64 + 2024;
	// 821BA9C8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BA9CC: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA9D0: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821BA9D4: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 821BA9D8: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 821BA9DC: 4200FFF0  bdnz 0x821ba9cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA9CC; continue 'dispatch;
	}
	// 821BA9E0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA9E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821BA9E8: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821BA9EC: 394A091C  addi r10, r10, 0x91c
	ctx.r[10].s64 = ctx.r[10].s64 + 2332;
	// 821BA9F0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BA9F4: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA9F8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821BA9FC: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 821BAA00: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 821BAA04: 4200FFF0  bdnz 0x821ba9f4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA9F4; continue 'dispatch;
	}
	// 821BAA08: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAA0C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821BAA10: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821BAA14: 394A0A50  addi r10, r10, 0xa50
	ctx.r[10].s64 = ctx.r[10].s64 + 2640;
	// 821BAA18: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BAA1C: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAA20: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821BAA24: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 821BAA28: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 821BAA2C: 4200FFF0  bdnz 0x821baa1c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BAA1C; continue 'dispatch;
	}
	// 821BAA30: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAA34: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821BAA38: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821BAA3C: 394A0B84  addi r10, r10, 0xb84
	ctx.r[10].s64 = ctx.r[10].s64 + 2948;
	// 821BAA40: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BAA44: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAA48: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821BAA4C: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 821BAA50: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 821BAA54: 4200FFF0  bdnz 0x821baa44
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BAA44; continue 'dispatch;
	}
	// 821BAA58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAA5C: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 821BAA60: 396B0CB8  addi r11, r11, 0xcb8
	ctx.r[11].s64 = ctx.r[11].s64 + 3256;
	// 821BAA64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BAA68: A1440000  lhz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAA6C: 38840002  addi r4, r4, 2
	ctx.r[4].s64 = ctx.r[4].s64 + 2;
	// 821BAA70: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 821BAA74: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821BAA78: 4200FFF0  bdnz 0x821baa68
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BAA68; continue 'dispatch;
	}
	// 821BAA7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BAA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BAA80 size=216
    let mut pc: u32 = 0x821BAA80;
    'dispatch: loop {
        match pc {
            0x821BAA80 => {
    //   block [0x821BAA80..0x821BAB58)
	// 821BAA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BAA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BAA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BAA8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BAA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BAA94: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821BAA98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAA9C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAAA0: 914B1004  stw r10, 0x1004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4100 as u32), ctx.r[10].u32 ) };
	// 821BAAA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAAA8: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BAAAC: 914B1008  stw r10, 0x1008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4104 as u32), ctx.r[10].u32 ) };
	// 821BAAB0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAAB4: 88E40004  lbz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BAAB8: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821BAABC: 419A001C  beq cr6, 0x821baad8
	if ctx.cr[6].eq {
	pc = 0x821BAAD8; continue 'dispatch;
	}
	// 821BAAC0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821BAAC4: 480012F5  bl 0x821bbdb8
	ctx.lr = 0x821BAAC8;
	sub_821BBDB8(ctx, base);
	// 821BAAC8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821BAACC: 396BF9C0  addi r11, r11, -0x640
	ctx.r[11].s64 = ctx.r[11].s64 + -1600;
	// 821BAAD0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BAAD4: 419A0060  beq cr6, 0x821bab34
	if ctx.cr[6].eq {
	pc = 0x821BAB34; continue 'dispatch;
	}
	// 821BAAD8: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821BAADC: 419A0014  beq cr6, 0x821baaf0
	if ctx.cr[6].eq {
	pc = 0x821BAAF0; continue 'dispatch;
	}
	// 821BAAE0: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 821BAAE4: 419A000C  beq cr6, 0x821baaf0
	if ctx.cr[6].eq {
	pc = 0x821BAAF0; continue 'dispatch;
	}
	// 821BAAE8: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821BAAEC: 409A0048  bne cr6, 0x821bab34
	if !ctx.cr[6].eq {
	pc = 0x821BAB34; continue 'dispatch;
	}
	// 821BAAF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BAAF4: 4BFA8D5D  bl 0x82163850
	ctx.lr = 0x821BAAF8;
	sub_82163850(ctx, base);
	// 821BAAF8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821BAAFC: 4800132D  bl 0x821bbe28
	ctx.lr = 0x821BAB00;
	sub_821BBE28(ctx, base);
	// 821BAB00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAB04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BAB08: 386B0F28  addi r3, r11, 0xf28
	ctx.r[3].s64 = ctx.r[11].s64 + 3880;
	// 821BAB0C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 821BAB10: 483780B1  bl 0x82532bc0
	ctx.lr = 0x821BAB14;
	sub_82532BC0(ctx, base);
	// 821BAB14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAB18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821BAB1C: 994B0F54  stb r10, 0xf54(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3924 as u32), ctx.r[10].u8 ) };
	// 821BAB20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BAB24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BAB28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BAB2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BAB30: 4E800020  blr
	return;
	// 821BAB34: 38640F28  addi r3, r4, 0xf28
	ctx.r[3].s64 = ctx.r[4].s64 + 3880;
	// 821BAB38: 38860008  addi r4, r6, 8
	ctx.r[4].s64 = ctx.r[6].s64 + 8;
	// 821BAB3C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 821BAB40: 4837A011  bl 0x82534b50
	ctx.lr = 0x821BAB44;
	sub_82534B50(ctx, base);
	// 821BAB44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BAB48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BAB4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BAB50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BAB54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BAB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BAB58 size=208
    let mut pc: u32 = 0x821BAB58;
    'dispatch: loop {
        match pc {
            0x821BAB58 => {
    //   block [0x821BAB58..0x821BAC28)
	// 821BAB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BAB5C: 4837A561  bl 0x825350bc
	ctx.lr = 0x821BAB60;
	sub_82535080(ctx, base);
	// 821BAB60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BAB64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BAB68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BAB6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAB70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAB74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAB78: 4E800421  bctrl
	ctx.lr = 0x821BAB7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAB7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAB80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BAB84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAB88: 4E800421  bctrl
	ctx.lr = 0x821BAB8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAB8C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 821BAB90: 41980090  blt cr6, 0x821bac20
	if ctx.cr[6].lt {
	pc = 0x821BAC20; continue 'dispatch;
	}
	// 821BAB94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAB98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BAB9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BABA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BABA4: 4E800421  bctrl
	ctx.lr = 0x821BABA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BABA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BABAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821BABB0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BABB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BABB8: 4E800421  bctrl
	ctx.lr = 0x821BABBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BABBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BABC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BABC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BABC8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BABCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BABD0: 4E800421  bctrl
	ctx.lr = 0x821BABD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BABD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BABD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821BABDC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BABE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BABE4: 4E800421  bctrl
	ctx.lr = 0x821BABE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BABE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BABEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BABF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BABF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BABF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BABFC: 4E800421  bctrl
	ctx.lr = 0x821BAC00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAC00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAC04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAC08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAC0C: 4E800421  bctrl
	ctx.lr = 0x821BAC10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAC10: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821BAC14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BAC18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BAC1C: 4BFFF2B5  bl 0x821b9ed0
	ctx.lr = 0x821BAC20;
	sub_821B9ED0(ctx, base);
	// 821BAC20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BAC24: 4837A4E8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BAC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BAC28 size=108
    let mut pc: u32 = 0x821BAC28;
    'dispatch: loop {
        match pc {
            0x821BAC28 => {
    //   block [0x821BAC28..0x821BAC94)
	// 821BAC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BAC2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BAC30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BAC34: 3860001E  li r3, 0x1e
	ctx.r[3].s64 = 30;
	// 821BAC38: 38E0001E  li r7, 0x1e
	ctx.r[7].s64 = 30;
	// 821BAC3C: 4800117D  bl 0x821bbdb8
	ctx.lr = 0x821BAC40;
	sub_821BBDB8(ctx, base);
	// 821BAC40: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821BAC44: 396BF9C0  addi r11, r11, -0x640
	ctx.r[11].s64 = ctx.r[11].s64 + -1600;
	// 821BAC48: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BAC4C: 409A0008  bne cr6, 0x821bac54
	if !ctx.cr[6].eq {
	pc = 0x821BAC54; continue 'dispatch;
	}
	// 821BAC50: 38E00021  li r7, 0x21
	ctx.r[7].s64 = 33;
	// 821BAC54: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BAC58: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821BAC5C: 419A0028  beq cr6, 0x821bac84
	if ctx.cr[6].eq {
	pc = 0x821BAC84; continue 'dispatch;
	}
	// 821BAC60: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAC64: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821BAC68: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAC6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAC70: 4E800421  bctrl
	ctx.lr = 0x821BAC74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAC74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAC78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAC7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAC80: 4E800421  bctrl
	ctx.lr = 0x821BAC84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAC84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BAC88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BAC8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BAC90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BAC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BAC98 size=732
    let mut pc: u32 = 0x821BAC98;
    'dispatch: loop {
        match pc {
            0x821BAC98 => {
    //   block [0x821BAC98..0x821BAF74)
	// 821BAC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BAC9C: 4837A415  bl 0x825350b0
	ctx.lr = 0x821BACA0;
	sub_82535080(ctx, base);
	// 821BACA0: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BACA4: 3860001D  li r3, 0x1d
	ctx.r[3].s64 = 29;
	// 821BACA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BACAC: 38E0001D  li r7, 0x1d
	ctx.r[7].s64 = 29;
	// 821BACB0: 48001109  bl 0x821bbdb8
	ctx.lr = 0x821BACB4;
	sub_821BBDB8(ctx, base);
	// 821BACB4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821BACB8: 396BF9C0  addi r11, r11, -0x640
	ctx.r[11].s64 = ctx.r[11].s64 + -1600;
	// 821BACBC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BACC0: 409A0008  bne cr6, 0x821bacc8
	if !ctx.cr[6].eq {
	pc = 0x821BACC8; continue 'dispatch;
	}
	// 821BACC4: 38E00021  li r7, 0x21
	ctx.r[7].s64 = 33;
	// 821BACC8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BACCC: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821BACD0: 409A029C  bne cr6, 0x821baf6c
	if !ctx.cr[6].eq {
	pc = 0x821BAF6C; continue 'dispatch;
	}
	// 821BACD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BACD8: 480002A1  bl 0x821baf78
	ctx.lr = 0x821BACDC;
	sub_821BAF78(ctx, base);
	// 821BACDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BACE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BACE4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821BACE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BACEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BACF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BACF4: 4E800421  bctrl
	ctx.lr = 0x821BACF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BACF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BACFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAD00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAD04: 4E800421  bctrl
	ctx.lr = 0x821BAD08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAD08: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 821BAD0C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAD10: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821BAD14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BAD18: 816B6220  lwz r11, 0x6220(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25120 as u32) ) } as u64;
	// 821BAD1C: 3F4B0010  addis r26, r11, 0x10
	ctx.r[26].s64 = ctx.r[11].s64 + 1048576;
	// 821BAD20: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAD24: 3B5A8F7C  addi r26, r26, -0x7084
	ctx.r[26].s64 = ctx.r[26].s64 + -28804;
	// 821BAD28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAD2C: 4E800421  bctrl
	ctx.lr = 0x821BAD30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAD30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAD34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BAD38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAD3C: 4E800421  bctrl
	ctx.lr = 0x821BAD40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAD40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BAD44: 419A01F0  beq cr6, 0x821baf34
	if ctx.cr[6].eq {
	pc = 0x821BAF34; continue 'dispatch;
	}
	// 821BAD48: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 821BAD4C: 3B6B66EC  addi r27, r11, 0x66ec
	ctx.r[27].s64 = ctx.r[11].s64 + 26348;
	// 821BAD50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAD54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BAD58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAD5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAD60: 4E800421  bctrl
	ctx.lr = 0x821BAD64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAD64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAD68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BAD6C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BAD70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAD74: 4E800421  bctrl
	ctx.lr = 0x821BAD78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAD78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BAD7C: 3860001D  li r3, 0x1d
	ctx.r[3].s64 = 29;
	// 821BAD80: 38A0001D  li r5, 0x1d
	ctx.r[5].s64 = 29;
	// 821BAD84: 4811BD35  bl 0x822d6ab8
	ctx.lr = 0x821BAD88;
	sub_822D6AB8(ctx, base);
	// 821BAD88: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BAD8C: 409A0008  bne cr6, 0x821bad94
	if !ctx.cr[6].eq {
	pc = 0x821BAD94; continue 'dispatch;
	}
	// 821BAD90: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BAD94: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BAD98: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BAD9C: 409A001C  bne cr6, 0x821badb8
	if !ctx.cr[6].eq {
	pc = 0x821BADB8; continue 'dispatch;
	}
	// 821BADA0: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 821BADA4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BADA8: 4817DF89  bl 0x82338d30
	ctx.lr = 0x821BADAC;
	sub_82338D30(ctx, base);
	// 821BADAC: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BADB0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BADB4: 409A00F4  bne cr6, 0x821baea8
	if !ctx.cr[6].eq {
	pc = 0x821BAEA8; continue 'dispatch;
	}
	// 821BADB8: 3860001E  li r3, 0x1e
	ctx.r[3].s64 = 30;
	// 821BADBC: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 821BADC0: 4811BCF9  bl 0x822d6ab8
	ctx.lr = 0x821BADC4;
	sub_822D6AB8(ctx, base);
	// 821BADC4: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BADC8: 409A0008  bne cr6, 0x821badd0
	if !ctx.cr[6].eq {
	pc = 0x821BADD0; continue 'dispatch;
	}
	// 821BADCC: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BADD0: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BADD4: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BADD8: 409A001C  bne cr6, 0x821badf4
	if !ctx.cr[6].eq {
	pc = 0x821BADF4; continue 'dispatch;
	}
	// 821BADDC: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 821BADE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BADE4: 4817DF4D  bl 0x82338d30
	ctx.lr = 0x821BADE8;
	sub_82338D30(ctx, base);
	// 821BADE8: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BADEC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BADF0: 409A00B8  bne cr6, 0x821baea8
	if !ctx.cr[6].eq {
	pc = 0x821BAEA8; continue 'dispatch;
	}
	// 821BADF4: 3860001F  li r3, 0x1f
	ctx.r[3].s64 = 31;
	// 821BADF8: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 821BADFC: 4811BCBD  bl 0x822d6ab8
	ctx.lr = 0x821BAE00;
	sub_822D6AB8(ctx, base);
	// 821BAE00: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BAE04: 409A0008  bne cr6, 0x821bae0c
	if !ctx.cr[6].eq {
	pc = 0x821BAE0C; continue 'dispatch;
	}
	// 821BAE08: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BAE0C: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BAE10: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BAE14: 409A001C  bne cr6, 0x821bae30
	if !ctx.cr[6].eq {
	pc = 0x821BAE30; continue 'dispatch;
	}
	// 821BAE18: 3880001F  li r4, 0x1f
	ctx.r[4].s64 = 31;
	// 821BAE1C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BAE20: 4817DF11  bl 0x82338d30
	ctx.lr = 0x821BAE24;
	sub_82338D30(ctx, base);
	// 821BAE24: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BAE28: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BAE2C: 409A007C  bne cr6, 0x821baea8
	if !ctx.cr[6].eq {
	pc = 0x821BAEA8; continue 'dispatch;
	}
	// 821BAE30: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 821BAE34: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821BAE38: 4811BC81  bl 0x822d6ab8
	ctx.lr = 0x821BAE3C;
	sub_822D6AB8(ctx, base);
	// 821BAE3C: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BAE40: 409A0008  bne cr6, 0x821bae48
	if !ctx.cr[6].eq {
	pc = 0x821BAE48; continue 'dispatch;
	}
	// 821BAE44: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BAE48: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BAE4C: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BAE50: 409A001C  bne cr6, 0x821bae6c
	if !ctx.cr[6].eq {
	pc = 0x821BAE6C; continue 'dispatch;
	}
	// 821BAE54: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821BAE58: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BAE5C: 4817DED5  bl 0x82338d30
	ctx.lr = 0x821BAE60;
	sub_82338D30(ctx, base);
	// 821BAE60: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BAE64: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BAE68: 409A0040  bne cr6, 0x821baea8
	if !ctx.cr[6].eq {
	pc = 0x821BAEA8; continue 'dispatch;
	}
	// 821BAE6C: 38600021  li r3, 0x21
	ctx.r[3].s64 = 33;
	// 821BAE70: 38A00021  li r5, 0x21
	ctx.r[5].s64 = 33;
	// 821BAE74: 4811BC45  bl 0x822d6ab8
	ctx.lr = 0x821BAE78;
	sub_822D6AB8(ctx, base);
	// 821BAE78: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BAE7C: 409A0008  bne cr6, 0x821bae84
	if !ctx.cr[6].eq {
	pc = 0x821BAE84; continue 'dispatch;
	}
	// 821BAE80: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BAE84: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BAE88: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BAE8C: 409A0020  bne cr6, 0x821baeac
	if !ctx.cr[6].eq {
	pc = 0x821BAEAC; continue 'dispatch;
	}
	// 821BAE90: 38800021  li r4, 0x21
	ctx.r[4].s64 = 33;
	// 821BAE94: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BAE98: 4817DE99  bl 0x82338d30
	ctx.lr = 0x821BAE9C;
	sub_82338D30(ctx, base);
	// 821BAE9C: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BAEA0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BAEA4: 419A0008  beq cr6, 0x821baeac
	if ctx.cr[6].eq {
	pc = 0x821BAEAC; continue 'dispatch;
	}
	// 821BAEA8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821BAEAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BAEB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAEB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAEBC: 4E800421  bctrl
	ctx.lr = 0x821BAEC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAEC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAEC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BAEC8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BAECC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAED0: 4E800421  bctrl
	ctx.lr = 0x821BAED4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAED4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BAED8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BAEDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BAEE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAEE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAEE8: 4E800421  bctrl
	ctx.lr = 0x821BAEEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAEEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAEF0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821BAEF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BAEF8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BAEFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAF00: 4E800421  bctrl
	ctx.lr = 0x821BAF04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAF04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAF08: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821BAF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BAF10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAF14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAF18: 4E800421  bctrl
	ctx.lr = 0x821BAF1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAF1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAF20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BAF24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAF28: 4E800421  bctrl
	ctx.lr = 0x821BAF2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAF2C: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821BAF30: 4198FE20  blt cr6, 0x821bad50
	if ctx.cr[6].lt {
	pc = 0x821BAD50; continue 'dispatch;
	}
	// 821BAF34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAF38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BAF3C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821BAF40: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAF44: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821BAF48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAF4C: 4E800421  bctrl
	ctx.lr = 0x821BAF50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAF50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAF54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BAF58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAF5C: 4E800421  bctrl
	ctx.lr = 0x821BAF60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BAF60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BAF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BAF68: 4BFFEFC9  bl 0x821b9f30
	ctx.lr = 0x821BAF6C;
	sub_821B9F30(ctx, base);
	// 821BAF6C: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 821BAF70: 4837A190  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BAF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BAF78 size=112
    let mut pc: u32 = 0x821BAF78;
    'dispatch: loop {
        match pc {
            0x821BAF78 => {
    //   block [0x821BAF78..0x821BAFE8)
	// 821BAF78: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821BAF7C: 38C00021  li r6, 0x21
	ctx.r[6].s64 = 33;
	// 821BAF80: 390A108C  addi r8, r10, 0x108c
	ctx.r[8].s64 = ctx.r[10].s64 + 4236;
	// 821BAF84: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821BAF88: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 821BAF8C: 38EA1090  addi r7, r10, 0x1090
	ctx.r[7].s64 = ctx.r[10].s64 + 4240;
	// 821BAF90: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821BAF94: 394B00F4  addi r10, r11, 0xf4
	ctx.r[10].s64 = ctx.r[11].s64 + 244;
	// 821BAF98: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BAF9C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821BAFA0: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821BAFA4: 38CB01E4  addi r6, r11, 0x1e4
	ctx.r[6].s64 = ctx.r[11].s64 + 484;
	// 821BAFA8: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821BAFAC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BAFB0: 910B01E4  stw r8, 0x1e4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(484 as u32), ctx.r[8].u32 ) };
	// 821BAFB4: 4098002C  bge cr6, 0x821bafe0
	if !ctx.cr[6].lt {
	pc = 0x821BAFE0; continue 'dispatch;
	}
	// 821BAFB8: 7D695050  subf r11, r9, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821BAFBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BAFC0: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BAFC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BAFC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BAFCC: 419A0014  beq cr6, 0x821bafe0
	if ctx.cr[6].eq {
	pc = 0x821BAFE0; continue 'dispatch;
	}
	// 821BAFD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BAFD4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BAFD8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821BAFDC: 4200FFF8  bdnz 0x821bafd4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BAFD4; continue 'dispatch;
	}
	// 821BAFE0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BAFE4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BAFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BAFE8 size=28
    let mut pc: u32 = 0x821BAFE8;
    'dispatch: loop {
        match pc {
            0x821BAFE8 => {
    //   block [0x821BAFE8..0x821BB004)
	// 821BAFE8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821BAFEC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BAFF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BAFF4: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BAFF8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BAFFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BB000: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BB004(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BB004 size=20
    let mut pc: u32 = 0x821BB004;
    'dispatch: loop {
        match pc {
            0x821BB004 => {
    //   block [0x821BB004..0x821BB018)
	// 821BB004: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB008: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821BB00C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BB010: 4200FFF8  bdnz 0x821bb008
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BB008; continue 'dispatch;
	}
	// 821BB014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BB018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BB018 size=852
    let mut pc: u32 = 0x821BB018;
    'dispatch: loop {
        match pc {
            0x821BB018 => {
    //   block [0x821BB018..0x821BB36C)
	// 821BB018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BB01C: 4837A095  bl 0x825350b0
	ctx.lr = 0x821BB020;
	sub_82535080(ctx, base);
	// 821BB020: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BB024: 3860001D  li r3, 0x1d
	ctx.r[3].s64 = 29;
	// 821BB028: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821BB02C: 38E0001D  li r7, 0x1d
	ctx.r[7].s64 = 29;
	// 821BB030: 48000D89  bl 0x821bbdb8
	ctx.lr = 0x821BB034;
	sub_821BBDB8(ctx, base);
	// 821BB034: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821BB038: 396BF9C0  addi r11, r11, -0x640
	ctx.r[11].s64 = ctx.r[11].s64 + -1600;
	// 821BB03C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BB040: 409A0008  bne cr6, 0x821bb048
	if !ctx.cr[6].eq {
	pc = 0x821BB048; continue 'dispatch;
	}
	// 821BB044: 38E00021  li r7, 0x21
	ctx.r[7].s64 = 33;
	// 821BB048: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB04C: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821BB050: 409A0314  bne cr6, 0x821bb364
	if !ctx.cr[6].eq {
	pc = 0x821BB364; continue 'dispatch;
	}
	// 821BB054: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BB058: 4BFFFF21  bl 0x821baf78
	ctx.lr = 0x821BB05C;
	sub_821BAF78(ctx, base);
	// 821BB05C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BB064: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821BB068: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BB06C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB070: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB074: 4E800421  bctrl
	ctx.lr = 0x821BB078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB078: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB07C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB080: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB084: 4E800421  bctrl
	ctx.lr = 0x821BB088;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB088: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 821BB08C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB090: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821BB094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BB098: 816B6220  lwz r11, 0x6220(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25120 as u32) ) } as u64;
	// 821BB09C: 3F4B0010  addis r26, r11, 0x10
	ctx.r[26].s64 = ctx.r[11].s64 + 1048576;
	// 821BB0A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB0A4: 3B5A8F7C  addi r26, r26, -0x7084
	ctx.r[26].s64 = ctx.r[26].s64 + -28804;
	// 821BB0A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB0AC: 4E800421  bctrl
	ctx.lr = 0x821BB0B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB0B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB0B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB0B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB0BC: 4E800421  bctrl
	ctx.lr = 0x821BB0C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB0C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BB0C4: 419A0268  beq cr6, 0x821bb32c
	if ctx.cr[6].eq {
	pc = 0x821BB32C; continue 'dispatch;
	}
	// 821BB0C8: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 821BB0CC: 3B6B66EC  addi r27, r11, 0x66ec
	ctx.r[27].s64 = ctx.r[11].s64 + 26348;
	// 821BB0D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB0D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BB0D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB0DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB0E0: 4E800421  bctrl
	ctx.lr = 0x821BB0E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB0E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB0E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BB0EC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BB0F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB0F4: 4E800421  bctrl
	ctx.lr = 0x821BB0F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB0F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BB0FC: 3860001D  li r3, 0x1d
	ctx.r[3].s64 = 29;
	// 821BB100: 38A0001D  li r5, 0x1d
	ctx.r[5].s64 = 29;
	// 821BB104: 4811B9B5  bl 0x822d6ab8
	ctx.lr = 0x821BB108;
	sub_822D6AB8(ctx, base);
	// 821BB108: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BB10C: 409A0008  bne cr6, 0x821bb114
	if !ctx.cr[6].eq {
	pc = 0x821BB114; continue 'dispatch;
	}
	// 821BB110: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BB114: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BB118: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BB11C: 409A0034  bne cr6, 0x821bb150
	if !ctx.cr[6].eq {
	pc = 0x821BB150; continue 'dispatch;
	}
	// 821BB120: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 821BB124: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB128: 4817DC09  bl 0x82338d30
	ctx.lr = 0x821BB12C;
	sub_82338D30(ctx, base);
	// 821BB12C: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB130: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB134: 409A016C  bne cr6, 0x821bb2a0
	if !ctx.cr[6].eq {
	pc = 0x821BB2A0; continue 'dispatch;
	}
	// 821BB138: 38800154  li r4, 0x154
	ctx.r[4].s64 = 340;
	// 821BB13C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB140: 4817DBF1  bl 0x82338d30
	ctx.lr = 0x821BB144;
	sub_82338D30(ctx, base);
	// 821BB144: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB148: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB14C: 409A0154  bne cr6, 0x821bb2a0
	if !ctx.cr[6].eq {
	pc = 0x821BB2A0; continue 'dispatch;
	}
	// 821BB150: 3860001E  li r3, 0x1e
	ctx.r[3].s64 = 30;
	// 821BB154: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 821BB158: 4811B961  bl 0x822d6ab8
	ctx.lr = 0x821BB15C;
	sub_822D6AB8(ctx, base);
	// 821BB15C: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BB160: 409A0008  bne cr6, 0x821bb168
	if !ctx.cr[6].eq {
	pc = 0x821BB168; continue 'dispatch;
	}
	// 821BB164: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BB168: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BB16C: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BB170: 409A0034  bne cr6, 0x821bb1a4
	if !ctx.cr[6].eq {
	pc = 0x821BB1A4; continue 'dispatch;
	}
	// 821BB174: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 821BB178: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB17C: 4817DBB5  bl 0x82338d30
	ctx.lr = 0x821BB180;
	sub_82338D30(ctx, base);
	// 821BB180: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB184: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB188: 409A0118  bne cr6, 0x821bb2a0
	if !ctx.cr[6].eq {
	pc = 0x821BB2A0; continue 'dispatch;
	}
	// 821BB18C: 38800155  li r4, 0x155
	ctx.r[4].s64 = 341;
	// 821BB190: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB194: 4817DB9D  bl 0x82338d30
	ctx.lr = 0x821BB198;
	sub_82338D30(ctx, base);
	// 821BB198: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB19C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB1A0: 409A0100  bne cr6, 0x821bb2a0
	if !ctx.cr[6].eq {
	pc = 0x821BB2A0; continue 'dispatch;
	}
	// 821BB1A4: 3860001F  li r3, 0x1f
	ctx.r[3].s64 = 31;
	// 821BB1A8: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 821BB1AC: 4811B90D  bl 0x822d6ab8
	ctx.lr = 0x821BB1B0;
	sub_822D6AB8(ctx, base);
	// 821BB1B0: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BB1B4: 409A0008  bne cr6, 0x821bb1bc
	if !ctx.cr[6].eq {
	pc = 0x821BB1BC; continue 'dispatch;
	}
	// 821BB1B8: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BB1BC: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BB1C0: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BB1C4: 409A0034  bne cr6, 0x821bb1f8
	if !ctx.cr[6].eq {
	pc = 0x821BB1F8; continue 'dispatch;
	}
	// 821BB1C8: 3880001F  li r4, 0x1f
	ctx.r[4].s64 = 31;
	// 821BB1CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB1D0: 4817DB61  bl 0x82338d30
	ctx.lr = 0x821BB1D4;
	sub_82338D30(ctx, base);
	// 821BB1D4: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB1D8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB1DC: 409A00C4  bne cr6, 0x821bb2a0
	if !ctx.cr[6].eq {
	pc = 0x821BB2A0; continue 'dispatch;
	}
	// 821BB1E0: 38800156  li r4, 0x156
	ctx.r[4].s64 = 342;
	// 821BB1E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB1E8: 4817DB49  bl 0x82338d30
	ctx.lr = 0x821BB1EC;
	sub_82338D30(ctx, base);
	// 821BB1EC: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB1F0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB1F4: 409A00AC  bne cr6, 0x821bb2a0
	if !ctx.cr[6].eq {
	pc = 0x821BB2A0; continue 'dispatch;
	}
	// 821BB1F8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 821BB1FC: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821BB200: 4811B8B9  bl 0x822d6ab8
	ctx.lr = 0x821BB204;
	sub_822D6AB8(ctx, base);
	// 821BB204: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BB208: 409A0008  bne cr6, 0x821bb210
	if !ctx.cr[6].eq {
	pc = 0x821BB210; continue 'dispatch;
	}
	// 821BB20C: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BB210: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BB214: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BB218: 409A0034  bne cr6, 0x821bb24c
	if !ctx.cr[6].eq {
	pc = 0x821BB24C; continue 'dispatch;
	}
	// 821BB21C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821BB220: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB224: 4817DB0D  bl 0x82338d30
	ctx.lr = 0x821BB228;
	sub_82338D30(ctx, base);
	// 821BB228: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB22C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB230: 409A0070  bne cr6, 0x821bb2a0
	if !ctx.cr[6].eq {
	pc = 0x821BB2A0; continue 'dispatch;
	}
	// 821BB234: 38800157  li r4, 0x157
	ctx.r[4].s64 = 343;
	// 821BB238: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB23C: 4817DAF5  bl 0x82338d30
	ctx.lr = 0x821BB240;
	sub_82338D30(ctx, base);
	// 821BB240: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB244: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB248: 409A0058  bne cr6, 0x821bb2a0
	if !ctx.cr[6].eq {
	pc = 0x821BB2A0; continue 'dispatch;
	}
	// 821BB24C: 38600021  li r3, 0x21
	ctx.r[3].s64 = 33;
	// 821BB250: 38A00021  li r5, 0x21
	ctx.r[5].s64 = 33;
	// 821BB254: 4811B865  bl 0x822d6ab8
	ctx.lr = 0x821BB258;
	sub_822D6AB8(ctx, base);
	// 821BB258: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BB25C: 409A0008  bne cr6, 0x821bb264
	if !ctx.cr[6].eq {
	pc = 0x821BB264; continue 'dispatch;
	}
	// 821BB260: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 821BB264: 817D0FE8  lwz r11, 0xfe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4072 as u32) ) } as u64;
	// 821BB268: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821BB26C: 409A0038  bne cr6, 0x821bb2a4
	if !ctx.cr[6].eq {
	pc = 0x821BB2A4; continue 'dispatch;
	}
	// 821BB270: 38800021  li r4, 0x21
	ctx.r[4].s64 = 33;
	// 821BB274: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB278: 4817DAB9  bl 0x82338d30
	ctx.lr = 0x821BB27C;
	sub_82338D30(ctx, base);
	// 821BB27C: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB280: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB284: 409A001C  bne cr6, 0x821bb2a0
	if !ctx.cr[6].eq {
	pc = 0x821BB2A0; continue 'dispatch;
	}
	// 821BB288: 38800158  li r4, 0x158
	ctx.r[4].s64 = 344;
	// 821BB28C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BB290: 4817DAA1  bl 0x82338d30
	ctx.lr = 0x821BB294;
	sub_82338D30(ctx, base);
	// 821BB294: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB298: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB29C: 419A0008  beq cr6, 0x821bb2a4
	if ctx.cr[6].eq {
	pc = 0x821BB2A4; continue 'dispatch;
	}
	// 821BB2A0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821BB2A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB2A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BB2AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB2B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB2B4: 4E800421  bctrl
	ctx.lr = 0x821BB2B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB2B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB2BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BB2C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BB2C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB2C8: 4E800421  bctrl
	ctx.lr = 0x821BB2CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB2CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BB2D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BB2D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BB2D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB2DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB2E0: 4E800421  bctrl
	ctx.lr = 0x821BB2E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB2E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB2E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821BB2EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BB2F0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BB2F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB2F8: 4E800421  bctrl
	ctx.lr = 0x821BB2FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB2FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB300: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821BB304: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BB308: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB30C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB310: 4E800421  bctrl
	ctx.lr = 0x821BB314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB314: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB318: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB31C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB320: 4E800421  bctrl
	ctx.lr = 0x821BB324;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB324: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821BB328: 4198FDA8  blt cr6, 0x821bb0d0
	if ctx.cr[6].lt {
	pc = 0x821BB0D0; continue 'dispatch;
	}
	// 821BB32C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB330: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BB334: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821BB338: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB33C: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821BB340: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB344: 4E800421  bctrl
	ctx.lr = 0x821BB348;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB348: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB34C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB350: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB354: 4E800421  bctrl
	ctx.lr = 0x821BB358;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB358: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BB35C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BB360: 4BFFEBD1  bl 0x821b9f30
	ctx.lr = 0x821BB364;
	sub_821B9F30(ctx, base);
	// 821BB364: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 821BB368: 48379D98  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BB370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BB370 size=416
    let mut pc: u32 = 0x821BB370;
    'dispatch: loop {
        match pc {
            0x821BB370 => {
    //   block [0x821BB370..0x821BB510)
	// 821BB370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BB374: 48379D41  bl 0x825350b4
	ctx.lr = 0x821BB378;
	sub_82535080(ctx, base);
	// 821BB378: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BB37C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BB380: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BB384: 4BFFFBF5  bl 0x821baf78
	ctx.lr = 0x821BB388;
	sub_821BAF78(ctx, base);
	// 821BB388: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB38C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BB390: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821BB394: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BB398: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB39C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB3A0: 4E800421  bctrl
	ctx.lr = 0x821BB3A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB3A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB3A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB3AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB3B0: 4E800421  bctrl
	ctx.lr = 0x821BB3B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB3B4: 3D608285  lis r11, -0x7d7b
	ctx.r[11].s64 = -2105212928;
	// 821BB3B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB3BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821BB3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BB3C4: 816B6220  lwz r11, 0x6220(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25120 as u32) ) } as u64;
	// 821BB3C8: 3F6B0010  addis r27, r11, 0x10
	ctx.r[27].s64 = ctx.r[11].s64 + 1048576;
	// 821BB3CC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB3D0: 3B7B8F7C  addi r27, r27, -0x7084
	ctx.r[27].s64 = ctx.r[27].s64 + -28804;
	// 821BB3D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB3D8: 4E800421  bctrl
	ctx.lr = 0x821BB3DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB3DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB3E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB3E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB3E8: 4E800421  bctrl
	ctx.lr = 0x821BB3EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB3EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BB3F0: 419A00E0  beq cr6, 0x821bb4d0
	if ctx.cr[6].eq {
	pc = 0x821BB4D0; continue 'dispatch;
	}
	// 821BB3F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BB3FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB400: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB404: 4E800421  bctrl
	ctx.lr = 0x821BB408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB408: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB40C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BB410: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BB414: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB418: 4E800421  bctrl
	ctx.lr = 0x821BB41C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB41C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BB420: 807D0FEC  lwz r3, 0xfec(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4076 as u32) ) } as u64;
	// 821BB424: 4811B8CD  bl 0x822d6cf0
	ctx.lr = 0x821BB428;
	sub_822D6CF0(ctx, base);
	// 821BB428: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821BB42C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821BB430: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BB434: 5564043E  clrlwi r4, r11, 0x10
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821BB438: 4817D8F9  bl 0x82338d30
	ctx.lr = 0x821BB43C;
	sub_82338D30(ctx, base);
	// 821BB43C: 546B077E  clrlwi r11, r3, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 821BB440: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821BB444: 409A005C  bne cr6, 0x821bb4a0
	if !ctx.cr[6].eq {
	pc = 0x821BB4A0; continue 'dispatch;
	}
	// 821BB448: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BB450: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB458: 4E800421  bctrl
	ctx.lr = 0x821BB45C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB45C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB460: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BB464: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BB468: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB46C: 4E800421  bctrl
	ctx.lr = 0x821BB470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB470: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BB474: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821BB478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BB47C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB484: 4E800421  bctrl
	ctx.lr = 0x821BB488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB488: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB48C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821BB490: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BB494: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BB498: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB49C: 4E800421  bctrl
	ctx.lr = 0x821BB4A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB4A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB4A4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821BB4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BB4AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB4B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB4B4: 4E800421  bctrl
	ctx.lr = 0x821BB4B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB4B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB4BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB4C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB4C4: 4E800421  bctrl
	ctx.lr = 0x821BB4C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB4C8: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821BB4CC: 4198FF28  blt cr6, 0x821bb3f4
	if ctx.cr[6].lt {
	pc = 0x821BB3F4; continue 'dispatch;
	}
	// 821BB4D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB4D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BB4D8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821BB4DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB4E0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821BB4E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB4E8: 4E800421  bctrl
	ctx.lr = 0x821BB4EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB4EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB4F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB4F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821BB4F8: 4E800421  bctrl
	ctx.lr = 0x821BB4FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB4FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BB500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BB504: 4BFFEA2D  bl 0x821b9f30
	ctx.lr = 0x821BB508;
	sub_821B9F30(ctx, base);
	// 821BB508: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 821BB50C: 48379BF8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


