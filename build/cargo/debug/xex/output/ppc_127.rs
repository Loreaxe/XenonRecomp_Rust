pub fn sub_82EAE268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAE268 size=184
	// 82EAE268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE26C: 4BDFB195  bl 0x82ca9400
	ctx.lr = 0x82EAE270;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EAE270: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE274: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAE278: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EAE27C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAE280: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EAE284: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE288: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAE28C: 4BFDEFA5  bl 0x82e8d230
	ctx.lr = 0x82EAE290;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8D230);
	// 82EAE290: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE294: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EAE298: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE29C: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE2A0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2A4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2A8: 4BFFC1E1  bl 0x82eaa488
	ctx.lr = 0x82EAE2AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAA488);
	// 82EAE2AC: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EAE2B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EAE2B4: 419A004C  beq cr6, 0x82eae300
	if ctx.cr[6].eq {
	pc = 0x82EAE300; continue 'dispatch;
	}
	// 82EAE2B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE2BC: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82EAE2C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE2C4: 3B6BAFB4  addi r27, r11, -0x504c
	ctx.r[27].s64 = ctx.r[11].s64 + -20556;
	// 82EAE2C8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAE2D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EAE2D4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EAE2DC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82EAE2E0: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EAE2E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAE2E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAE2EC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAE2F0: 4BFFF7D1  bl 0x82eadac0
	ctx.lr = 0x82EAE2F4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EADAC0);
	// 82EAE2F4: 83FF000C  lwz r31, 0xc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAE2F8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE2FC: 4082FFCC  bne 0x82eae2c8
	if !ctx.cr[0].eq {
	pc = 0x82EAE2C8; continue 'dispatch;
	}
	// 82EAE300: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAE304: 4BFFD265  bl 0x82eab568
	ctx.lr = 0x82EAE308;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAB568);
	// 82EAE308: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAE30C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAE310: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAE314: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAE318: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EAE31C: 4BDFB134  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
}

pub fn sub_82EAE320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAE320 size=200
	// 82EAE320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE324: 4BDFB0E1  bl 0x82ca9404
	ctx.lr = 0x82EAE328;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EAE328: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE32C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE330: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAE334: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EAE338: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EAE33C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EAE340: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EAE344: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EAE348: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EAE34C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EAE350: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EAE354: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EAE358: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAE35C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE360: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EAE364: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EAE368: 4082FFF0  bne 0x82eae358
	if !ctx.cr[0].eq {
	pc = 0x82EAE358; continue 'dispatch;
	}
	// 82EAE36C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE370: 4BFFFAB1  bl 0x82eade20
	ctx.lr = 0x82EAE374;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EADE20);
	// 82EAE374: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAE378: 4082000C  bne 0x82eae384
	if !ctx.cr[0].eq {
	pc = 0x82EAE384; continue 'dispatch;
	}
	// 82EAE37C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EAE380: 48000010  b 0x82eae390
	pc = 0x82EAE390; continue 'dispatch;
	// 82EAE384: 4BFFF86D  bl 0x82eadbf0
	ctx.lr = 0x82EAE388;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EADBF0);
	// 82EAE388: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EAE38C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EAE390: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EAE394: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EAE398: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EAE39C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAE3A0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EAE3A4: 409A0010  bne cr6, 0x82eae3b4
	if !ctx.cr[6].eq {
	pc = 0x82EAE3B4; continue 'dispatch;
	}
	// 82EAE3A8: 4BFD16B1  bl 0x82e7fa58
	ctx.lr = 0x82EAE3AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EAE3AC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EAE3B0: 4800000C  b 0x82eae3bc
	pc = 0x82EAE3BC; continue 'dispatch;
	// 82EAE3B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAE3B8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EAE3BC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAE3C0: 41820018  beq 0x82eae3d8
	if ctx.cr[0].eq {
	pc = 0x82EAE3D8; continue 'dispatch;
	}
	// 82EAE3C4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAE3C8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EAE3CC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EAE3D0: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EAE3D4: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EAE3D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE3DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EAE3E0: 4BDFB074  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EAE3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAE3E8 size=96
	// 82EAE3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAE3F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAE3F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE3F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EAE3FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EAE400: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAE404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAE408: 4BFFFF19  bl 0x82eae320
	ctx.lr = 0x82EAE40C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAE320);
	// 82EAE40C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE414: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EAE418: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAE41C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAE420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAE424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAE428: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAE42C: 4E800020  blr
	return;
	// 82EAE430: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE434: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EAE438: 396BA380  addi r11, r11, -0x5c80
	ctx.r[11].s64 = ctx.r[11].s64 + -23680;
	// 82EAE43C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EAE440: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAE444: 4E800020  blr
	return;
}

pub fn sub_82EAE448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EAE448 size=480
	// 82EAE448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE44C: 4BDFAF99  bl 0x82ca93e4
	ctx.lr = 0x82EAE450;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93E4);
	// 82EAE450: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAE458: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAE45C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82EAE460: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82EAE464: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAE46C: 409A01AC  bne cr6, 0x82eae618
	if !ctx.cr[6].eq {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE470: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EAE474: 419A01A4  beq cr6, 0x82eae618
	if ctx.cr[6].eq {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE478: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82EAE47C: 419A019C  beq cr6, 0x82eae618
	if ctx.cr[6].eq {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE480: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82EAE484: 419A0194  beq cr6, 0x82eae618
	if ctx.cr[6].eq {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE488: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EAE48C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE490: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82EAE494: 40990184  ble cr6, 0x82eae618
	if !ctx.cr[6].gt {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE498: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EAE49C: 4099017C  ble cr6, 0x82eae618
	if !ctx.cr[6].gt {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE4A0: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 82EAE4A4: 40990174  ble cr6, 0x82eae618
	if !ctx.cr[6].gt {
	pc = 0x82EAE618; continue 'dispatch;
	}
	// 82EAE4A8: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82EAE4AC: D03F0018  stfs f1, 0x18(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EAE4B0: D05F001C  stfs f2, 0x1c(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EAE4B4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EAE4B8: 6175FFFF  ori r21, r11, 0xffff
	ctx.r[21].u64 = ctx.r[11].u64 | 65535;
	// 82EAE4BC: D07F0020  stfs f3, 0x20(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EAE4C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EAE4C4: D09F0030  stfs f4, 0x30(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EAE4C8: D0BF0034  stfs f5, 0x34(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EAE4CC: 92FF0010  stw r23, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82EAE4D0: D0DF0038  stfs f6, 0x38(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EAE4D4: 931F0014  stw r24, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[24].u32 ) };
	// 82EAE4D8: 3A60FFFF  li r19, -1
	ctx.r[19].s64 = -1;
	// 82EAE4DC: 7F1EA840  cmplw cr6, r30, r21
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82EAE4E0: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE4E4: 57C3103A  slwi r3, r30, 2
	// 82EAE4E8: EDA00824  fdivs f13, f0, f1
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 82EAE4EC: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EAE4F0: ED801024  fdivs f12, f0, f2
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[2].f64) as f32) as f64;
	// 82EAE4F4: D19F0028  stfs f12, 0x28(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EAE4F8: EC001824  fdivs f0, f0, f3
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[3].f64) as f32) as f64;
	// 82EAE4FC: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EAE500: 40990008  ble cr6, 0x82eae508
	if !ctx.cr[6].gt {
	pc = 0x82EAE508; continue 'dispatch;
	}
	// 82EAE504: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82EAE508: 4B768421  bl 0x82616928
	ctx.lr = 0x82EAE50C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAE50C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EAE510: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EAE514: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EAE518: 419A00C8  beq cr6, 0x82eae5e0
	if ctx.cr[6].eq {
	pc = 0x82EAE5E0; continue 'dispatch;
	}
	// 82EAE51C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE520: 7EDAB378  mr r26, r22
	ctx.r[26].u64 = ctx.r[22].u64;
	// 82EAE524: 3A8BAFB4  addi r20, r11, -0x504c
	ctx.r[20].s64 = ctx.r[11].s64 + -20556;
	// 82EAE528: 7F17A840  cmplw cr6, r23, r21
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82EAE52C: 56E3103A  slwi r3, r23, 2
	// 82EAE530: 40990008  ble cr6, 0x82eae538
	if !ctx.cr[6].gt {
	pc = 0x82EAE538; continue 'dispatch;
	}
	// 82EAE534: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82EAE538: 4B7683F1  bl 0x82616928
	ctx.lr = 0x82EAE53C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAE53C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE540: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82EAE544: 7C7A592E  stwx r3, r26, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82EAE548: 419A008C  beq cr6, 0x82eae5d4
	if ctx.cr[6].eq {
	pc = 0x82EAE5D4; continue 'dispatch;
	}
	// 82EAE54C: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	// 82EAE550: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82EAE554: 7F18A840  cmplw cr6, r24, r21
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82EAE558: 5703103A  slwi r3, r24, 2
	// 82EAE55C: 40990008  ble cr6, 0x82eae564
	if !ctx.cr[6].gt {
	pc = 0x82EAE564; continue 'dispatch;
	}
	// 82EAE560: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82EAE564: 4B7683C5  bl 0x82616928
	ctx.lr = 0x82EAE568;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAE568: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE56C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82EAE570: 7D7A582E  lwzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAE574: 7C6BD92E  stwx r3, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[3].u32) };
	// 82EAE578: 419A0050  beq cr6, 0x82eae5c8
	if ctx.cr[6].eq {
	pc = 0x82EAE5C8; continue 'dispatch;
	}
	// 82EAE57C: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EAE580: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82EAE584: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EAE588: 4B7683A1  bl 0x82616928
	ctx.lr = 0x82EAE58C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAE58C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAE590: 41820018  beq 0x82eae5a8
	if ctx.cr[0].eq {
	pc = 0x82EAE5A8; continue 'dispatch;
	}
	// 82EAE594: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EAE598: 92C30004  stw r22, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 82EAE59C: 92830000  stw r20, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 82EAE5A0: 9AC30008  stb r22, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[22].u8 ) };
	// 82EAE5A4: 48000008  b 0x82eae5ac
	pc = 0x82EAE5AC; continue 'dispatch;
	// 82EAE5A8: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 82EAE5AC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE5B0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EAE5B4: 7D5A502E  lwzx r10, r26, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EAE5B8: 7D4AD82E  lwzx r10, r10, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAE5BC: 7D6AE12E  stwx r11, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u32) };
	// 82EAE5C0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EAE5C4: 4082FFC0  bne 0x82eae584
	if !ctx.cr[0].eq {
	pc = 0x82EAE584; continue 'dispatch;
	}
	// 82EAE5C8: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82EAE5CC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EAE5D0: 4082FF84  bne 0x82eae554
	if !ctx.cr[0].eq {
	pc = 0x82EAE554; continue 'dispatch;
	}
	// 82EAE5D4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EAE5D8: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EAE5DC: 4082FF4C  bne 0x82eae528
	if !ctx.cr[0].eq {
	pc = 0x82EAE528; continue 'dispatch;
	}
	// 82EAE5E0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAE5E4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAE5E8: 409A0024  bne cr6, 0x82eae60c
	if !ctx.cr[6].eq {
	pc = 0x82EAE60C; continue 'dispatch;
	}
	// 82EAE5EC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAE5F0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAE5F4: 409A0018  bne cr6, 0x82eae60c
	if !ctx.cr[6].eq {
	pc = 0x82EAE60C; continue 'dispatch;
	}
	// 82EAE5F8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAE5FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAE600: 409A000C  bne cr6, 0x82eae60c
	if !ctx.cr[6].eq {
	pc = 0x82EAE60C; continue 'dispatch;
	}
	// 82EAE604: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82EAE608: 48000008  b 0x82eae610
	pc = 0x82EAE610; continue 'dispatch;
	// 82EAE60C: 9ADF0004  stb r22, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[22].u8 ) };
	// 82EAE610: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAE614: 48000008  b 0x82eae61c
	pc = 0x82EAE61C; continue 'dispatch;
	// 82EAE618: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAE61C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EAE620: 4BDFAE14  b 0x82ca9434
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9434);
	return;
}

pub fn sub_82EAE628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAE628 size=16
	// 82EAE628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE62C: 4BDFADD9  bl 0x82ca9404
	ctx.lr = 0x82EAE630;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EAE630: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 82EAE634: 9421EF50  stwu r1, -0x10b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-4272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EAE708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EAE708 size=1400
	// 82EAE708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAE70C: 4BDFACE1  bl 0x82ca93ec
	ctx.lr = 0x82EAE710;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93EC);
	// 82EAE710: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAE714: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EAE718: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EAE71C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAE720: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAE724: 409A0010  bne cr6, 0x82eae734
	if !ctx.cr[6].eq {
	pc = 0x82EAE734; continue 'dispatch;
	}
	// 82EAE728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAE72C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EAE730: 4BDFAD0C  b 0x82ca943c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA943C);
	return;
	// 82EAE734: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAE738: 3BCBDAC0  addi r30, r11, -0x2540
	ctx.r[30].s64 = ctx.r[11].s64 + -9536;
	// 82EAE73C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EAE740: 388B8EA4  addi r4, r11, -0x715c
	ctx.r[4].s64 = ctx.r[11].s64 + -29020;
	// 82EAE744: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EAE748: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE74C: 4E800421  bctrl
	ctx.lr = 0x82EAE750;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE750: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EAE754: 4182FFD4  beq 0x82eae728
	if ctx.cr[0].eq {
	pc = 0x82EAE728; continue 'dispatch;
	}
	// 82EAE758: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAE75C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE760: 386BA368  addi r3, r11, -0x5c98
	ctx.r[3].s64 = ctx.r[11].s64 + -23704;
	// 82EAE764: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE768: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 82EAE76C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAE770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE774: 4E800421  bctrl
	ctx.lr = 0x82EAE778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE778: 2B030014  cmplwi cr6, r3, 0x14
	ctx.cr[6].compare_u32(ctx.r[3].u32, 20 as u32, &mut ctx.xer);
	// 82EAE77C: 409AFFAC  bne cr6, 0x82eae728
	if !ctx.cr[6].eq {
	pc = 0x82EAE728; continue 'dispatch;
	}
	// 82EAE780: 3EA00100  lis r21, 0x100
	ctx.r[21].s64 = 16777216;
	// 82EAE784: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE788: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE78C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE790: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAE798: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 82EAE79C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE7A0: 4E800421  bctrl
	ctx.lr = 0x82EAE7A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE7A4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE7A8: 419A0018  beq cr6, 0x82eae7c0
	if ctx.cr[6].eq {
	pc = 0x82EAE7C0; continue 'dispatch;
	}
	// 82EAE7AC: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAE7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAE7B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAE7B8: 4E800421  bctrl
	ctx.lr = 0x82EAE7BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE7BC: 4BFFFF6C  b 0x82eae728
	pc = 0x82EAE728; continue 'dispatch;
	// 82EAE7C0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAE7C4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE7C8: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE7CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE7D0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE7D4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE7D8: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE7DC: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE7E0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE7E4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE7E8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE7EC: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE7F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82EAE7F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAE7F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE7FC: 4E800421  bctrl
	ctx.lr = 0x82EAE800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE800: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE804: 409AFFA8  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE808: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAE80C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE810: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE814: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE818: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE81C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE820: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE824: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE828: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE82C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE830: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE834: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE838: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EAE83C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAE840: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE844: 4E800421  bctrl
	ctx.lr = 0x82EAE848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE848: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE84C: 409AFF60  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE850: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAE854: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE858: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE85C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE860: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE864: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE868: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE86C: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE870: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE874: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE878: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE87C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE880: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82EAE884: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAE888: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE88C: 4E800421  bctrl
	ctx.lr = 0x82EAE890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE890: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE894: 409AFF18  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE898: C01D0018  lfs f0, 0x18(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE89C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE8A0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE8A4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE8A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE8AC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE8B0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EAE8B4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE8B8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE8BC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE8C0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE8C4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE8C8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE8CC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE8D0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE8D4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAE8D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE8DC: 4E800421  bctrl
	ctx.lr = 0x82EAE8E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE8E0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE8E4: 409AFEC8  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE8E8: C01D001C  lfs f0, 0x1c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE8EC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE8F0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE8F4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE8F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE8FC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE900: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EAE904: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE908: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE90C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE910: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE914: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE918: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE91C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE920: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE924: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAE928: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE92C: 4E800421  bctrl
	ctx.lr = 0x82EAE930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE930: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE934: 409AFE78  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE938: C01D0020  lfs f0, 0x20(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE93C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE940: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE944: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE948: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE94C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE950: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EAE954: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE958: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE95C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE960: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE964: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE968: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE96C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE970: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE974: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAE978: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE97C: 4E800421  bctrl
	ctx.lr = 0x82EAE980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE980: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE984: 409AFE28  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE988: C01D0024  lfs f0, 0x24(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE98C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE990: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE994: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE998: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE99C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE9A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EAE9A4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE9A8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE9AC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAE9B0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAE9B4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAE9B8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAE9BC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAE9C0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAE9C4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EAE9C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAE9CC: 4E800421  bctrl
	ctx.lr = 0x82EAE9D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAE9D0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAE9D4: 409AFDD8  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAE9D8: C01D0028  lfs f0, 0x28(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAE9DC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE9E0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAE9E4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAE9E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAE9EC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAE9F0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82EAE9F4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAE9F8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAE9FC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEA00: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEA04: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEA08: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEA0C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEA10: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEA14: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAEA18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEA1C: 4E800421  bctrl
	ctx.lr = 0x82EAEA20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEA20: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEA24: 409AFD88  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEA28: C01D002C  lfs f0, 0x2c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAEA2C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEA30: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAEA34: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEA38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEA3C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEA40: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EAEA44: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEA48: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEA4C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEA50: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEA54: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEA58: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEA5C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEA60: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEA64: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAEA68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEA6C: 4E800421  bctrl
	ctx.lr = 0x82EAEA70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEA70: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEA74: 409AFD38  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEA78: C01D0030  lfs f0, 0x30(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAEA7C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEA80: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAEA84: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEA88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEA8C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEA90: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82EAEA94: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEA98: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEA9C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEAA0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEAA4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEAA8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEAAC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEAB0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEAB4: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EAEAB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEABC: 4E800421  bctrl
	ctx.lr = 0x82EAEAC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEAC0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEAC4: 409AFCE8  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEAC8: C01D0034  lfs f0, 0x34(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAEACC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEAD0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAEAD4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEAD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEADC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEAE0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EAEAE4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEAE8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEAEC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEAF0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEAF4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEAF8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEAFC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEB00: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEB04: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EAEB08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEB0C: 4E800421  bctrl
	ctx.lr = 0x82EAEB10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEB10: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEB14: 409AFC98  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEB18: C01D0038  lfs f0, 0x38(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EAEB1C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEB20: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EAEB24: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEB28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEB2C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEB30: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82EAEB34: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEB38: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEB3C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EAEB40: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEB44: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEB48: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82EAEB4C: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEB50: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82EAEB54: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EAEB58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAEB5C: 4E800421  bctrl
	ctx.lr = 0x82EAEB60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEB60: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEB64: 409AFC48  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEB68: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEB6C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EAEB70: 7ED7B378  mr r23, r22
	ctx.r[23].u64 = ctx.r[22].u64;
	// 82EAEB74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEB78: 409900E0  ble cr6, 0x82eaec58
	if !ctx.cr[6].gt {
	pc = 0x82EAEC58; continue 'dispatch;
	}
	// 82EAEB7C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAEB80: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	// 82EAEB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEB88: 409900C0  ble cr6, 0x82eaec48
	if !ctx.cr[6].gt {
	pc = 0x82EAEC48; continue 'dispatch;
	}
	// 82EAEB8C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAEB90: 7ED8B378  mr r24, r22
	ctx.r[24].u64 = ctx.r[22].u64;
	// 82EAEB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEB98: 409900A0  ble cr6, 0x82eaec38
	if !ctx.cr[6].gt {
	pc = 0x82EAEC38; continue 'dispatch;
	}
	// 82EAEB9C: 56FB103A  slwi r27, r23, 2
	// 82EAEBA0: 573A103A  slwi r26, r25, 2
	// 82EAEBA4: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EAEBA8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEBAC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EAEBB0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EAEBB4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EAEBB8: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAEBBC: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAEBC0: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAEBC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAEBC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEBCC: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAEBD0: 409A0020  bne cr6, 0x82eaebf0
	if !ctx.cr[6].eq {
	pc = 0x82EAEBF0; continue 'dispatch;
	}
	// 82EAEBD4: 92C10088  stw r22, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[22].u32 ) };
	// 82EAEBD8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82EAEBDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEBE0: 4E800421  bctrl
	ctx.lr = 0x82EAEBE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEBE4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEBE8: 409AFBC4  bne cr6, 0x82eae7ac
	if !ctx.cr[6].eq {
	pc = 0x82EAE7AC; continue 'dispatch;
	}
	// 82EAEBEC: 48000038  b 0x82eaec24
	pc = 0x82EAEC24; continue 'dispatch;
	// 82EAEBF0: 92A1008C  stw r21, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[21].u32 ) };
	// 82EAEBF4: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82EAEBF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEBFC: 4E800421  bctrl
	ctx.lr = 0x82EAEC00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEC00: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EAEC04: 409A005C  bne cr6, 0x82eaec60
	if !ctx.cr[6].eq {
	pc = 0x82EAEC60; continue 'dispatch;
	}
	// 82EAEC08: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEC0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAEC10: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAEC14: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAEC18: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAEC1C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAEC20: 4BFF5B39  bl 0x82ea4758
	ctx.lr = 0x82EAEC24;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EA4758);
	// 82EAEC24: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAEC28: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EAEC2C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EAEC30: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAEC34: 4198FF74  blt cr6, 0x82eaeba8
	if ctx.cr[6].lt {
	pc = 0x82EAEBA8; continue 'dispatch;
	}
	// 82EAEC38: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAEC3C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EAEC40: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAEC44: 4198FF48  blt cr6, 0x82eaeb8c
	if ctx.cr[6].lt {
	pc = 0x82EAEB8C; continue 'dispatch;
	}
	// 82EAEC48: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEC4C: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EAEC50: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAEC54: 4198FF28  blt cr6, 0x82eaeb7c
	if ctx.cr[6].lt {
	pc = 0x82EAEB7C; continue 'dispatch;
	}
	// 82EAEC58: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EAEC5C: 48000008  b 0x82eaec64
	pc = 0x82EAEC64; continue 'dispatch;
	// 82EAEC60: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 82EAEC64: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAEC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEC6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEC70: 4E800421  bctrl
	ctx.lr = 0x82EAEC74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEC74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EAEC78: 4BFFFAB4  b 0x82eae72c
	pc = 0x82EAE72C; continue 'dispatch;
}

pub fn sub_82EAEC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAEC80 size=328
	// 82EAEC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAEC84: 4BDFA76D  bl 0x82ca93f0
	ctx.lr = 0x82EAEC88;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93F0);
	// 82EAEC88: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAEC8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAEC90: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAEC98: 419A011C  beq cr6, 0x82eaedb4
	if ctx.cr[6].eq {
	pc = 0x82EAEDB4; continue 'dispatch;
	}
	// 82EAEC9C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAECA0: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EAECA4: 3F008330  lis r24, -0x7cd0
	ctx.r[24].s64 = -2094006272;
	// 82EAECA8: 7EF6BB78  mr r22, r23
	ctx.r[22].u64 = ctx.r[23].u64;
	// 82EAECAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAECB0: 409900F0  ble cr6, 0x82eaeda0
	if !ctx.cr[6].gt {
	pc = 0x82EAEDA0; continue 'dispatch;
	}
	// 82EAECB4: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82EAECB8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAECBC: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82EAECC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAECC4: 409900B4  ble cr6, 0x82eaed78
	if !ctx.cr[6].gt {
	pc = 0x82EAED78; continue 'dispatch;
	}
	// 82EAECC8: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82EAECCC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAECD0: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 82EAECD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAECD8: 40990074  ble cr6, 0x82eaed4c
	if !ctx.cr[6].gt {
	pc = 0x82EAED4C; continue 'dispatch;
	}
	// 82EAECDC: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 82EAECE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAECE4: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAECE8: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAECEC: 7FCBE82E  lwzx r30, r11, r29
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EAECF0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAECF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAECF8: 41820028  beq 0x82eaed20
	if ctx.cr[0].eq {
	pc = 0x82EAED20; continue 'dispatch;
	}
	// 82EAECFC: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAED00: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAED04: 409A001C  bne cr6, 0x82eaed20
	if !ctx.cr[6].eq {
	pc = 0x82EAED20; continue 'dispatch;
	}
	// 82EAED08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAED0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAED10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAED14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAED18: 4E800421  bctrl
	ctx.lr = 0x82EAED1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAED1C: 92FE0004  stw r23, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 82EAED20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAED24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAED28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAED2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAED30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAED34: 4E800421  bctrl
	ctx.lr = 0x82EAED38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAED38: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAED3C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EAED40: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EAED44: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAED48: 4198FF98  blt cr6, 0x82eaece0
	if ctx.cr[6].lt {
	pc = 0x82EAECE0; continue 'dispatch;
	}
	// 82EAED4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAED50: 8158DAB4  lwz r10, -0x254c(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAED54: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAED58: 7C6BE02E  lwzx r3, r11, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAED5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EAED60: 4E800421  bctrl
	ctx.lr = 0x82EAED64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAED64: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAED68: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EAED6C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EAED70: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAED74: 4198FF58  blt cr6, 0x82eaeccc
	if ctx.cr[6].lt {
	pc = 0x82EAECCC; continue 'dispatch;
	}
	// 82EAED78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAED7C: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAED80: 8178DAB4  lwz r11, -0x254c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAED84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAED88: 4E800421  bctrl
	ctx.lr = 0x82EAED8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAED8C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAED90: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82EAED94: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EAED98: 7F165840  cmplw cr6, r22, r11
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAED9C: 4198FF1C  blt cr6, 0x82eaecb8
	if ctx.cr[6].lt {
	pc = 0x82EAECB8; continue 'dispatch;
	}
	// 82EAEDA0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEDA4: 8178DAB4  lwz r11, -0x254c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAEDA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEDAC: 4E800421  bctrl
	ctx.lr = 0x82EAEDB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEDB0: 92FF0008  stw r23, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82EAEDB4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EAEDB8: 4BDFA688  b 0x82ca9440
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9440);
	return;
}

pub fn sub_82EAEDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAEDC8 size=72
	// 82EAEDC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAEDCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAEDD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAEDD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAEDD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAEDDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAEDE0: 396BA380  addi r11, r11, -0x5c80
	ctx.r[11].s64 = ctx.r[11].s64 + -23680;
	// 82EAEDE4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEDE8: 4BFFFE99  bl 0x82eaec80
	ctx.lr = 0x82EAEDEC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAEC80);
	// 82EAEDEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EAEDF0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EAEDF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEDF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAEDFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAEE00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAEE04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAEE08: 4E800020  blr
	return;
}

pub fn sub_82EAEE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAEE10 size=1856
	// 82EAEE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAEE14: 4BDFA5C1  bl 0x82ca93d4
	ctx.lr = 0x82EAEE18;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93D4);
	// 82EAEE18: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAEE1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAEE20: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EAEE24: 4BFFFE5D  bl 0x82eaec80
	ctx.lr = 0x82EAEE28;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAEC80);
	// 82EAEE28: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAEE2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEE30: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EAEE34: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAEE38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEE3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEE40: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAEE44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEE48: 4E800421  bctrl
	ctx.lr = 0x82EAEE4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEE4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAEE50: 418206F0  beq 0x82eaf540
	if ctx.cr[0].eq {
	pc = 0x82EAF540; continue 'dispatch;
	}
	// 82EAEE54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEE58: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 82EAEE5C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EAEE60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEE68: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEE6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEE70: 4E800421  bctrl
	ctx.lr = 0x82EAEE74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEE74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEE78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EAEE7C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEE80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EAEE84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEE88: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEE8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEE90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEE94: 4E800421  bctrl
	ctx.lr = 0x82EAEE98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEE98: 2B1C0014  cmplwi cr6, r28, 0x14
	ctx.cr[6].compare_u32(ctx.r[28].u32, 20 as u32, &mut ctx.xer);
	// 82EAEE9C: 409A068C  bne cr6, 0x82eaf528
	if !ctx.cr[6].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAEEA0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAEEA4: 409A0684  bne cr6, 0x82eaf528
	if !ctx.cr[6].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAEEA8: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 82EAEEAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAEEB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EAEEB4: 388BA368  addi r4, r11, -0x5c98
	ctx.r[4].s64 = ctx.r[11].s64 + -23704;
	// 82EAEEB8: 9A210074  stb r17, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[17].u8 ) };
	// 82EAEEBC: 4BDFDC95  bl 0x82cacb50
	ctx.lr = 0x82EAEEC0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EAEEC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EAEEC4: 40820664  bne 0x82eaf528
	if !ctx.cr[0].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAEEC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EAEECC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEED4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAEED8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEEDC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEEE0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEEE4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAEEE8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEEEC: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAEEF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAEEF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAEEF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEEFC: 409A0638  bne cr6, 0x82eaf534
	if !ctx.cr[6].eq {
	pc = 0x82EAF534; continue 'dispatch;
	}
	// 82EAEF00: 39FE000C  addi r15, r30, 0xc
	ctx.r[15].s64 = ctx.r[30].s64 + 12;
	// 82EAEF04: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEF08: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEF0C: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 82EAEF10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEF14: 4E800421  bctrl
	ctx.lr = 0x82EAEF18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEF18: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAEF1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEF24: 409A060C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAEF28: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEF2C: 3A1E0010  addi r16, r30, 0x10
	ctx.r[16].s64 = ctx.r[30].s64 + 16;
	// 82EAEF30: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEF34: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAEF38: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEF3C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEF40: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEF44: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAEF48: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEF4C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 82EAEF50: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAEF54: 916F0000  stw r11, 0(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEF58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEF5C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEF60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEF64: 4E800421  bctrl
	ctx.lr = 0x82EAEF68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEF68: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAEF6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEF74: 409A05BC  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAEF78: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEF7C: 3A5E0014  addi r18, r30, 0x14
	ctx.r[18].s64 = ctx.r[30].s64 + 20;
	// 82EAEF80: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEF84: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAEF88: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEF8C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEF90: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEF94: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAEF98: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEF9C: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 82EAEFA0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAEFA4: 91700000  stw r11, 0(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEFA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEFAC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAEFB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAEFB4: 4E800421  bctrl
	ctx.lr = 0x82EAEFB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAEFB8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAEFBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAEFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAEFC4: 409A056C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAEFC8: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEFCC: 3B9E0018  addi r28, r30, 0x18
	ctx.r[28].s64 = ctx.r[30].s64 + 24;
	// 82EAEFD0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAEFD4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAEFD8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAEFDC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAEFE0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAEFE4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAEFE8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAEFEC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAEFF0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAEFF4: 91720000  stw r11, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAEFF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAEFFC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF004: 4E800421  bctrl
	ctx.lr = 0x82EAF008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF008: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF00C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF014: 409A051C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF018: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF01C: 3B7E001C  addi r27, r30, 0x1c
	ctx.r[27].s64 = ctx.r[30].s64 + 28;
	// 82EAF020: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF024: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF028: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF02C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF030: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF034: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF038: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF03C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EAF040: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF044: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF048: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF04C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF054: 4E800421  bctrl
	ctx.lr = 0x82EAF058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF058: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF05C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF064: 409A04CC  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF068: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF06C: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 82EAF070: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF074: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF078: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF07C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF080: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF084: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF088: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF08C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAF090: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF094: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF098: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF09C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF0A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF0A4: 4E800421  bctrl
	ctx.lr = 0x82EAF0A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF0A8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF0AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF0B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF0B4: 409A047C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF0B8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF0BC: 3B7E0024  addi r27, r30, 0x24
	ctx.r[27].s64 = ctx.r[30].s64 + 36;
	// 82EAF0C0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF0C4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF0C8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF0CC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF0D0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF0D4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF0D8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF0DC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EAF0E0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF0E4: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF0E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF0EC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF0F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF0F4: 4E800421  bctrl
	ctx.lr = 0x82EAF0F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF0F8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF0FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF104: 409A042C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF108: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF10C: 3B9E0028  addi r28, r30, 0x28
	ctx.r[28].s64 = ctx.r[30].s64 + 40;
	// 82EAF110: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF114: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF118: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF11C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF120: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF124: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF128: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF12C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAF130: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF134: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF138: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF13C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF144: 4E800421  bctrl
	ctx.lr = 0x82EAF148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF148: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF14C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF154: 409A03DC  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF158: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF15C: 3B7E002C  addi r27, r30, 0x2c
	ctx.r[27].s64 = ctx.r[30].s64 + 44;
	// 82EAF160: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF164: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF168: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF16C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF170: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF174: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF178: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF17C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EAF180: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF184: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF188: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF18C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF190: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF194: 4E800421  bctrl
	ctx.lr = 0x82EAF198;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF198: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF19C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF1A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF1A4: 409A038C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF1A8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF1AC: 3B9E0030  addi r28, r30, 0x30
	ctx.r[28].s64 = ctx.r[30].s64 + 48;
	// 82EAF1B0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF1B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF1B8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF1BC: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF1C0: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF1C4: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF1C8: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF1CC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAF1D0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF1D4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF1D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF1DC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF1E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF1E4: 4E800421  bctrl
	ctx.lr = 0x82EAF1E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF1E8: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF1EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF1F4: 409A033C  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF1F8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF1FC: 3B7E0034  addi r27, r30, 0x34
	ctx.r[27].s64 = ctx.r[30].s64 + 52;
	// 82EAF200: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF204: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF208: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF20C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF210: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF214: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF218: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF21C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EAF220: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF224: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF228: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF22C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF230: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF234: 4E800421  bctrl
	ctx.lr = 0x82EAF238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF238: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF23C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF244: 409A02EC  bne cr6, 0x82eaf530
	if !ctx.cr[6].eq {
	pc = 0x82EAF530; continue 'dispatch;
	}
	// 82EAF248: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF24C: 3B9E0038  addi r28, r30, 0x38
	ctx.r[28].s64 = ctx.r[30].s64 + 56;
	// 82EAF250: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF254: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF258: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF25C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF260: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF264: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF268: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF26C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EAF270: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF274: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF278: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF27C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF284: 4E800421  bctrl
	ctx.lr = 0x82EAF288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF288: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF28C: 409A029C  bne cr6, 0x82eaf528
	if !ctx.cr[6].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAF290: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82EAF294: 3A60FFFF  li r19, -1
	ctx.r[19].s64 = -1;
	// 82EAF298: 6176FFFF  ori r22, r11, 0xffff
	ctx.r[22].u64 = ctx.r[11].u64 | 65535;
	// 82EAF29C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF2A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF2A4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF2A8: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF2AC: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF2B0: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF2B4: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF2B8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EAF2BC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAF2C0: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF2C4: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82EAF2C8: 5563103A  slwi r3, r11, 2
	// 82EAF2CC: 40990008  ble cr6, 0x82eaf2d4
	if !ctx.cr[6].gt {
	pc = 0x82EAF2D4; continue 'dispatch;
	}
	// 82EAF2D0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82EAF2D4: 4B767655  bl 0x82616928
	ctx.lr = 0x82EAF2D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAF2D8: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF2DC: 7E378B78  mr r23, r17
	ctx.r[23].u64 = ctx.r[17].u64;
	// 82EAF2E0: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EAF2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAF2E8: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 82EAF2EC: 409901AC  ble cr6, 0x82eaf498
	if !ctx.cr[6].gt {
	pc = 0x82EAF498; continue 'dispatch;
	}
	// 82EAF2F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAF2F4: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 82EAF2F8: 3AABAFB4  addi r21, r11, -0x504c
	ctx.r[21].s64 = ctx.r[11].s64 + -20556;
	// 82EAF2FC: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF300: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82EAF304: 5563103A  slwi r3, r11, 2
	// 82EAF308: 40990008  ble cr6, 0x82eaf310
	if !ctx.cr[6].gt {
	pc = 0x82EAF310; continue 'dispatch;
	}
	// 82EAF30C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82EAF310: 4B767619  bl 0x82616928
	ctx.lr = 0x82EAF314;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAF314: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF318: 7E388B78  mr r24, r17
	ctx.r[24].u64 = ctx.r[17].u64;
	// 82EAF31C: 7C6BD12E  stwx r3, r11, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32), ctx.r[3].u32) };
	// 82EAF320: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAF328: 4099015C  ble cr6, 0x82eaf484
	if !ctx.cr[6].gt {
	pc = 0x82EAF484; continue 'dispatch;
	}
	// 82EAF32C: 7E3B8B78  mr r27, r17
	ctx.r[27].u64 = ctx.r[17].u64;
	// 82EAF330: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF334: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82EAF338: 5563103A  slwi r3, r11, 2
	// 82EAF33C: 40990008  ble cr6, 0x82eaf344
	if !ctx.cr[6].gt {
	pc = 0x82EAF344; continue 'dispatch;
	}
	// 82EAF340: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82EAF344: 4B7675E5  bl 0x82616928
	ctx.lr = 0x82EAF348;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAF348: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF34C: 7E398B78  mr r25, r17
	ctx.r[25].u64 = ctx.r[17].u64;
	// 82EAF350: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF354: 7C6BD92E  stwx r3, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[3].u32) };
	// 82EAF358: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF35C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAF360: 40990110  ble cr6, 0x82eaf470
	if !ctx.cr[6].gt {
	pc = 0x82EAF470; continue 'dispatch;
	}
	// 82EAF364: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	// 82EAF368: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EAF36C: 4B7675BD  bl 0x82616928
	ctx.lr = 0x82EAF370;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAF370: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAF374: 41820018  beq 0x82eaf38c
	if ctx.cr[0].eq {
	pc = 0x82EAF38C; continue 'dispatch;
	}
	// 82EAF378: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EAF37C: 92230004  stw r17, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 82EAF380: 92A30000  stw r21, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 82EAF384: 9A230008  stb r17, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[17].u8 ) };
	// 82EAF388: 48000008  b 0x82eaf390
	pc = 0x82EAF390; continue 'dispatch;
	// 82EAF38C: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82EAF390: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF394: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82EAF398: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82EAF39C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF3A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF3A4: 7D4AD02E  lwzx r10, r10, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF3A8: 7D4AD82E  lwzx r10, r10, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAF3AC: 7D6AE12E  stwx r11, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u32) };
	// 82EAF3B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF3B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF3B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF3BC: 4E800421  bctrl
	ctx.lr = 0x82EAF3C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF3C0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 82EAF3C4: 409A0164  bne cr6, 0x82eaf528
	if !ctx.cr[6].eq {
	pc = 0x82EAF528; continue 'dispatch;
	}
	// 82EAF3C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAF3CC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EAF3D0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EAF3D4: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82EAF3D8: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82EAF3DC: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EAF3E0: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82EAF3E4: 7D6B5379  or. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAF3E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAF3EC: 41820070  beq 0x82eaf45c
	if ctx.cr[0].eq {
	pc = 0x82EAF45C; continue 'dispatch;
	}
	// 82EAF3F0: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 82EAF3F4: 4B767535  bl 0x82616928
	ctx.lr = 0x82EAF3F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAF3F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAF3FC: 4182000C  beq 0x82eaf408
	if ctx.cr[0].eq {
	pc = 0x82EAF408; continue 'dispatch;
	}
	// 82EAF400: 4BFF68F9  bl 0x82ea5cf8
	ctx.lr = 0x82EAF404;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EA5CF8);
	// 82EAF404: 48000008  b 0x82eaf40c
	pc = 0x82EAF40C; continue 'dispatch;
	// 82EAF408: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 82EAF40C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF410: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EAF414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF418: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF41C: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAF420: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAF424: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EAF428: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF42C: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF430: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAF434: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAF438: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAF43C: 4BFF7EBD  bl 0x82ea72f8
	ctx.lr = 0x82EAF440;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EA72F8);
	// 82EAF440: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAF444: 41820080  beq 0x82eaf4c4
	if ctx.cr[0].eq {
	pc = 0x82EAF4C4; continue 'dispatch;
	}
	// 82EAF448: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF44C: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82EAF450: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EAF454: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82EAF458: 9A8B0008  stb r20, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[20].u8 ) };
	// 82EAF45C: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF460: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82EAF464: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EAF468: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAF46C: 4198FEFC  blt cr6, 0x82eaf368
	if ctx.cr[6].lt {
	pc = 0x82EAF368; continue 'dispatch;
	}
	// 82EAF470: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF474: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82EAF478: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EAF47C: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAF480: 4198FEB0  blt cr6, 0x82eaf330
	if ctx.cr[6].lt {
	pc = 0x82EAF330; continue 'dispatch;
	}
	// 82EAF484: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF488: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EAF48C: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EAF490: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EAF494: 4198FE68  blt cr6, 0x82eaf2fc
	if ctx.cr[6].lt {
	pc = 0x82EAF2FC; continue 'dispatch;
	}
	// 82EAF498: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF49C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAF4A0: 409A007C  bne cr6, 0x82eaf51c
	if !ctx.cr[6].eq {
	pc = 0x82EAF51C; continue 'dispatch;
	}
	// 82EAF4A4: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF4A8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAF4AC: 409A0070  bne cr6, 0x82eaf51c
	if !ctx.cr[6].eq {
	pc = 0x82EAF51C; continue 'dispatch;
	}
	// 82EAF4B0: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF4B4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAF4B8: 409A0064  bne cr6, 0x82eaf51c
	if !ctx.cr[6].eq {
	pc = 0x82EAF51C; continue 'dispatch;
	}
	// 82EAF4BC: 9A9E0004  stb r20, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u8 ) };
	// 82EAF4C0: 48000060  b 0x82eaf520
	pc = 0x82EAF520; continue 'dispatch;
	// 82EAF4C4: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF4C8: 56EB103A  slwi r11, r23, 2
	// 82EAF4CC: 570A103A  slwi r10, r24, 2
	// 82EAF4D0: 5729103A  slwi r9, r25, 2
	// 82EAF4D4: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	// 82EAF4D8: 7D08582E  lwzx r8, r8, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAF4DC: 7D08502E  lwzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EAF4E0: 7D08482E  lwzx r8, r8, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EAF4E4: 92280004  stw r17, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 82EAF4E8: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF4EC: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EAF4F0: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EAF4F4: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EAF4F8: 9A2B0008  stb r17, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[17].u8 ) };
	// 82EAF4FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF500: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF508: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAF50C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF510: 4E800421  bctrl
	ctx.lr = 0x82EAF514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF514: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EAF518: 4800002C  b 0x82eaf544
	pc = 0x82EAF544; continue 'dispatch;
	// 82EAF51C: 9A3E0004  stb r17, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[17].u8 ) };
	// 82EAF520: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 82EAF524: 4BFFFFD8  b 0x82eaf4fc
	pc = 0x82EAF4FC; continue 'dispatch;
	// 82EAF528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF52C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EAF530: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAF534: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAF538: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF53C: 4E800421  bctrl
	ctx.lr = 0x82EAF540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF540: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAF544: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82EAF548: 4BDF9EDC  b 0x82ca9424
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9424);
	return;
}

pub fn sub_82EAF550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF550 size=560
	// 82EAF550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF558: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAF55C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF560: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF568: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAF56C: 4BFFF85D  bl 0x82eaedc8
	ctx.lr = 0x82EAF570;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAEDC8);
	// 82EAF570: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EAF574: 41820018  beq 0x82eaf58c
	if ctx.cr[0].eq {
	pc = 0x82EAF58C; continue 'dispatch;
	}
	// 82EAF578: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAF57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF580: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EAF584: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF588: 4E800421  bctrl
	ctx.lr = 0x82EAF58C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF58C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF590: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAF594: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAF598: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAF59C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAF5A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAF5A4: 4E800020  blr
	return;
	// 82EAF5A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAF5AC: 392003E8  li r9, 0x3e8
	ctx.r[9].s64 = 1000;
	// 82EAF5B0: 394BAFB4  addi r10, r11, -0x504c
	ctx.r[10].s64 = ctx.r[11].s64 + -20556;
	// 82EAF5B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAF5B8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EAF5BC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EAF5C0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EAF5C4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EAF5C8: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EAF5CC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EAF5D0: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EAF5D4: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EAF5D8: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EAF5DC: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EAF5E0: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EAF5E4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EAF5E8: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EAF5EC: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82EAF5F0: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82EAF5F4: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82EAF5F8: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EAF5FC: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EAF600: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82EAF604: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EAF608: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82EAF60C: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EAF610: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EAF614: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAF618: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAF61C: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EAF620: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAF624: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAF628: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAF62C: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EAF630: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAF634: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAF638: 9163007C  stw r11, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EAF63C: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EAF640: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EAF644: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EAF648: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EAF64C: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EAF650: 4E800020  blr
	return;
}

pub fn sub_82EAF780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF780 size=376
	// 82EAF780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAF78C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF790: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF798: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAF79C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EAF7A0: 394BDE74  addi r10, r11, -0x218c
	ctx.r[10].s64 = ctx.r[11].s64 + -8588;
	// 82EAF7A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF7A8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EAF7AC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82EAF7B0: 9169FEF4  stw r11, -0x10c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-268 as u32), ctx.r[11].u32 ) };
	// 82EAF7B4: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EAF7B8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EAF7BC: 9169FEF8  stw r11, -0x108(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-264 as u32), ctx.r[11].u32 ) };
	// 82EAF7C0: 4BFFFE99  bl 0x82eaf658
	ctx.lr = 0x82EAF7C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAF658);
	// 82EAF7C4: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82EAF7C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAF7CC: 915E8684  stw r10, -0x797c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-31100 as u32), ctx.r[10].u32 ) };
	// 82EAF7D0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EAF7D4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAF7D8: 4BFCFE81  bl 0x82e7f658
	ctx.lr = 0x82EAF7DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7F658);
	// 82EAF7DC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAF7E0: 386B8698  addi r3, r11, -0x7968
	ctx.r[3].s64 = ctx.r[11].s64 + -31080;
	// 82EAF7E4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF7E8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EAF7EC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EAF7F0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EAF7F4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAF7F8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EAF7FC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EAF800: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EAF804: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EAF808: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EAF80C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EAF810: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EAF814: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EAF818: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EAF81C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EAF820: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EAF824: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EAF828: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82EAF82C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EAF830: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EAF834: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EAF838: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EAF83C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EAF840: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EAF844: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EAF848: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EAF84C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EAF850: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82EAF854: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EAF858: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EAF85C: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EAF860: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82EAF864: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EAF868: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EAF86C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EAF870: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82EAF874: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EAF878: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EAF87C: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EAF880: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EAF884: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EAF888: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EAF88C: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EAF890: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82EAF894: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAF898: 906BFEF0  stw r3, -0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-272 as u32), ctx.r[3].u32 ) };
	// 82EAF89C: 817E8684  lwz r11, -0x797c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-31100 as u32) ) } as u64;
	// 82EAF8A0: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EAF8A4: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EAF8A8: 808B0024  lwz r4, 0x24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EAF8AC: 4BFD595D  bl 0x82e85208
	ctx.lr = 0x82EAF8B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85208);
	// 82EAF8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAF8B4: 4BFD01CD  bl 0x82e7fa80
	ctx.lr = 0x82EAF8B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA80);
	// 82EAF8B8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EAF8BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EAF8C0: 409A002C  bne cr6, 0x82eaf8ec
	if !ctx.cr[6].eq {
	pc = 0x82EAF8EC; continue 'dispatch;
	}
	// 82EAF8C4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EAF8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EAF8CC: 4BCE75AD  bl 0x82b96e78
	ctx.lr = 0x82EAF8D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82B96E78);
	// 82EAF8D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF8D4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EAF8D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAF8DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAF8E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAF8E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAF8E8: 4E800020  blr
	return;
	// 82EAF8EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EAF8F0: 4BFFFFD8  b 0x82eaf8c8
	pc = 0x82EAF8C8; continue 'dispatch;
}

pub fn sub_82EAF8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF8F8 size=104
	// 82EAF8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAF904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF90C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAF910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF914: 3BCB8698  addi r30, r11, -0x7968
	ctx.r[30].s64 = ctx.r[11].s64 + -31080;
	// 82EAF918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF91C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EAF920: 4BFD53D1  bl 0x82e84cf0
	ctx.lr = 0x82EAF924;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E84CF0);
	// 82EAF924: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAF928: 814BFEF8  lwz r10, -0x108(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-264 as u32) ) } as u64;
	// 82EAF92C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAF930: 419A0018  beq cr6, 0x82eaf948
	if ctx.cr[6].eq {
	pc = 0x82EAF948; continue 'dispatch;
	}
	// 82EAF934: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAF938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAF93C: 554B003E  slwi r11, r10, 0
	// 82EAF940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAF944: 4E800421  bctrl
	ctx.lr = 0x82EAF948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAF948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAF94C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAF950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAF954: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAF958: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAF95C: 4E800020  blr
	return;
}

pub fn sub_82EAF960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF960 size=104
	// 82EAF960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF964: 4BDF9AA9  bl 0x82ca940c
	ctx.lr = 0x82EAF968;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EAF968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAF970: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EAF974: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EAF978: 419A0048  beq cr6, 0x82eaf9c0
	if ctx.cr[6].eq {
	pc = 0x82EAF9C0; continue 'dispatch;
	}
	// 82EAF97C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82EAF980: 4B766FA9  bl 0x82616928
	ctx.lr = 0x82EAF984;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAF984: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EAF988: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82EAF98C: 41820018  beq 0x82eaf9a4
	if ctx.cr[0].eq {
	pc = 0x82EAF9A4; continue 'dispatch;
	}
	// 82EAF990: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EAF994: 80BDFEF0  lwz r5, -0x110(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82EAF998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EAF99C: 4BFD58F5  bl 0x82e85290
	ctx.lr = 0x82EAF9A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85290);
	// 82EAF9A0: 48000008  b 0x82eaf9a8
	pc = 0x82EAF9A8; continue 'dispatch;
	// 82EAF9A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EAF9A8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAF9AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAF9B0: 396B8688  addi r11, r11, -0x7978
	ctx.r[11].s64 = ctx.r[11].s64 + -31096;
	// 82EAF9B4: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EAF9B8: 419A0008  beq cr6, 0x82eaf9c0
	if ctx.cr[6].eq {
	pc = 0x82EAF9C0; continue 'dispatch;
	}
	// 82EAF9BC: 907DFEF0  stw r3, -0x110(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-272 as u32), ctx.r[3].u32 ) };
	// 82EAF9C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAF9C4: 4BDF9A98  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EAF9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAF9C8 size=152
	// 82EAF9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAF9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAF9D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAF9D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAF9D8: 3FE08335  lis r31, -0x7ccb
	ctx.r[31].s64 = -2093678592;
	// 82EAF9DC: 807F8688  lwz r3, -0x7978(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-31096 as u32) ) } as u64;
	// 82EAF9E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAF9E4: 419A003C  beq cr6, 0x82eafa20
	if ctx.cr[6].eq {
	pc = 0x82EAFA20; continue 'dispatch;
	}
	// 82EAF9E8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EAF9EC: 814BFEF0  lwz r10, -0x110(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82EAF9F0: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EAF9F4: 409A0010  bne cr6, 0x82eafa04
	if !ctx.cr[6].eq {
	pc = 0x82EAFA04; continue 'dispatch;
	}
	// 82EAF9F8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EAF9FC: 394A8698  addi r10, r10, -0x7968
	ctx.r[10].s64 = ctx.r[10].s64 + -31080;
	// 82EAFA00: 914BFEF0  stw r10, -0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-272 as u32), ctx.r[10].u32 ) };
	// 82EAFA04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFA08: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAFA0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFA14: 4E800421  bctrl
	ctx.lr = 0x82EAFA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFA18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAFA1C: 917F8688  stw r11, -0x7978(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-31096 as u32), ctx.r[11].u32 ) };
	// 82EAFA20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFA24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFA28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFA2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFA30: 4E800020  blr
	return;
}

pub fn sub_82EAFA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFA60 size=20
	// 82EAFA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFA68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFA6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFA70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EAFAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFAC0 size=20
	// 82EAFAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFAC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFAD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EAFB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFB20 size=20
	// 82EAFB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFB28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFB2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFB30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EAFB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFB80 size=112
	// 82EAFB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFB88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFB8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFB90: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFB94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EAFB98: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EAFB9C: 816B8688  lwz r11, -0x7978(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31096 as u32) ) } as u64;
	// 82EAFBA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAFBA4: 409A0014  bne cr6, 0x82eafbb8
	if !ctx.cr[6].eq {
	pc = 0x82EAFBB8; continue 'dispatch;
	}
	// 82EAFBA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAFBAC: 419A000C  beq cr6, 0x82eafbb8
	if ctx.cr[6].eq {
	pc = 0x82EAFBB8; continue 'dispatch;
	}
	// 82EAFBB0: 38800064  li r4, 0x64
	ctx.r[4].s64 = 100;
	// 82EAFBB4: 4BFFFDAD  bl 0x82eaf960
	ctx.lr = 0x82EAFBB8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAF960);
	// 82EAFBB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAFBBC: 396BDE74  addi r11, r11, -0x218c
	ctx.r[11].s64 = ctx.r[11].s64 + -8588;
	// 82EAFBC0: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EAFBC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFBC8: 4E800421  bctrl
	ctx.lr = 0x82EAFBCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFBCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EAFBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFBD4: 4BFD0865  bl 0x82e80438
	ctx.lr = 0x82EAFBD8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E80438);
	// 82EAFBD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFBDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFBE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFBE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFBE8: 4E800020  blr
	return;
}

pub fn sub_82EAFBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFBF0 size=80
	// 82EAFBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFBF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFBFC: 4BFD006D  bl 0x82e7fc68
	ctx.lr = 0x82EAFC00;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FC68);
	// 82EAFC00: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFC04: 816B8684  lwz r11, -0x797c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31100 as u32) ) } as u64;
	// 82EAFC08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAFC0C: 419A001C  beq cr6, 0x82eafc28
	if ctx.cr[6].eq {
	pc = 0x82EAFC28; continue 'dispatch;
	}
	// 82EAFC10: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EAFC14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAFC18: 419A0010  beq cr6, 0x82eafc28
	if ctx.cr[6].eq {
	pc = 0x82EAFC28; continue 'dispatch;
	}
	// 82EAFC1C: 554B003E  slwi r11, r10, 0
	// 82EAFC20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFC24: 4E800421  bctrl
	ctx.lr = 0x82EAFC28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFC28: 4BFFFDA1  bl 0x82eaf9c8
	ctx.lr = 0x82EAFC2C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAF9C8);
	// 82EAFC2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFC30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFC34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFC38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFC3C: 4E800020  blr
	return;
}

pub fn sub_82EAFC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFC40 size=104
	// 82EAFC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFC44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFC48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFC4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EAFC50: 419A0018  beq cr6, 0x82eafc68
	if ctx.cr[6].eq {
	pc = 0x82EAFC68; continue 'dispatch;
	}
	// 82EAFC54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFC58: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EAFC5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFC64: 4E800421  bctrl
	ctx.lr = 0x82EAFC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFC68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFC6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EAFC70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFC74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFC78: 4E800020  blr
	return;
}

pub fn sub_82EAFCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFCA8 size=160
	// 82EAFCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFCAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFCB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFCB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFCB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFCBC: 4BFCFDCD  bl 0x82e7fa88
	ctx.lr = 0x82EAFCC0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA88);
	// 82EAFCC0: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82EAFCC4: 817E8684  lwz r11, -0x797c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-31100 as u32) ) } as u64;
	// 82EAFCC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EAFCCC: 419A001C  beq cr6, 0x82eafce8
	if ctx.cr[6].eq {
	pc = 0x82EAFCE8; continue 'dispatch;
	}
	// 82EAFCD0: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EAFCD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EAFCD8: 419A0010  beq cr6, 0x82eafce8
	if ctx.cr[6].eq {
	pc = 0x82EAFCE8; continue 'dispatch;
	}
	// 82EAFCDC: 554B003E  slwi r11, r10, 0
	// 82EAFCE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFCE4: 4E800421  bctrl
	ctx.lr = 0x82EAFCE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFCE8: 4BFFFCE1  bl 0x82eaf9c8
	ctx.lr = 0x82EAFCEC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EAF9C8);
	// 82EAFCEC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EAFCF0: 3FE08330  lis r31, -0x7cd0
	ctx.r[31].s64 = -2094006272;
	// 82EAFCF4: 386B8698  addi r3, r11, -0x7968
	ctx.r[3].s64 = ctx.r[11].s64 + -31080;
	// 82EAFCF8: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EAFCFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EAFD00: 396BF8F8  addi r11, r11, -0x708
	ctx.r[11].s64 = ctx.r[11].s64 + -1800;
	// 82EAFD04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EAFD08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EAFD0C: 917FDAB4  stw r11, -0x254c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-9548 as u32), ctx.r[11].u32 ) };
	// 82EAFD10: 4BFD54F9  bl 0x82e85208
	ctx.lr = 0x82EAFD14;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85208);
	// 82EAFD14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EAFD18: 3D4082E8  lis r10, -0x7d18
	ctx.r[10].s64 = -2098724864;
	// 82EAFD1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EAFD20: 917E8684  stw r11, -0x797c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-31100 as u32), ctx.r[11].u32 ) };
	// 82EAFD24: 396AF5F0  addi r11, r10, -0xa10
	ctx.r[11].s64 = ctx.r[10].s64 + -2576;
	// 82EAFD28: 917FDAB4  stw r11, -0x254c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-9548 as u32), ctx.r[11].u32 ) };
	// 82EAFD2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFD30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFD34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFD38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFD3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFD40: 4E800020  blr
	return;
}

pub fn sub_82EAFD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EAFD48 size=720
	// 82EAFD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EAFD4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EAFD50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EAFD54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EAFD58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EAFD5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EAFD60: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EAFD64: 4B766BC5  bl 0x82616928
	ctx.lr = 0x82EAFD68;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EAFD68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EAFD6C: 4182001C  beq 0x82eafd88
	if ctx.cr[0].eq {
	pc = 0x82EAFD88; continue 'dispatch;
	}
	// 82EAFD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFD74: 4BFD4495  bl 0x82e84208
	ctx.lr = 0x82EAFD78;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E84208);
	// 82EAFD78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EAFD7C: 396BA39C  addi r11, r11, -0x5c64
	ctx.r[11].s64 = ctx.r[11].s64 + -23652;
	// 82EAFD80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EAFD84: 48000008  b 0x82eafd8c
	pc = 0x82EAFD8C; continue 'dispatch;
	// 82EAFD88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EAFD8C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EAFD90: 396BDE74  addi r11, r11, -0x218c
	ctx.r[11].s64 = ctx.r[11].s64 + -8588;
	// 82EAFD94: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EAFD98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFD9C: 4E800421  bctrl
	ctx.lr = 0x82EAFDA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EAFDA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EAFDA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EAFDAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EAFDB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EAFDB4: 4E800421  bctrl
	ctx.lr = 0x82EAFDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EAFDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EAFDBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EAFDC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EAFDC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EAFDC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EAFDCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EAFDD0: 4E800020  blr
	return;
}

pub fn sub_82EB0018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0018 size=728
	// 82EB0018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB001C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB0020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB0024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB0028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB002C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0030: 4BFD58D1  bl 0x82e85900
	ctx.lr = 0x82EB0034;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85900);
	// 82EB0034: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB0038: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EB003C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB0040: 396BA3B0  addi r11, r11, -0x5c50
	ctx.r[11].s64 = ctx.r[11].s64 + -23632;
	// 82EB0044: 394A8704  addi r10, r10, -0x78fc
	ctx.r[10].s64 = ctx.r[10].s64 + -30972;
	// 82EB0048: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB004C: 3929990C  addi r9, r9, -0x66f4
	ctx.r[9].s64 = ctx.r[9].s64 + -26356;
	// 82EB0050: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB0054: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB0058: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EB005C: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82EB0060: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82EB0064: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82EB0068: 4BFE2ED1  bl 0x82e92f38
	ctx.lr = 0x82EB006C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E92F38);
	// 82EB006C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0070: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EB0074: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0078: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB007C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EB0080: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EB0084: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EB0088: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EB008C: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EB0090: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EB0094: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB0098: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB009C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB00A0: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EB00A4: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EB00A8: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EB00AC: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EB00B0: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EB00B4: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EB00B8: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB00BC: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB00C0: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB00C4: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82EB00C8: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82EB00CC: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82EB00D0: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82EB00D4: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82EB00D8: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EB00DC: D01F0128  stfs f0, 0x128(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EB00E0: D01F012C  stfs f0, 0x12c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EB00E4: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82EB00E8: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EB00EC: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EB00F0: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82EB00F4: 997F00BC  stb r11, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	// 82EB00F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB00FC: 9BDF01B5  stb r30, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[30].u8 ) };
	// 82EB0100: 9BDF00BF  stb r30, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[30].u8 ) };
	// 82EB0104: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82EB0108: 93DF0174  stw r30, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[30].u32 ) };
	// 82EB010C: 93DF0178  stw r30, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[30].u32 ) };
	// 82EB0110: 9BDF00BE  stb r30, 0xbe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(190 as u32), ctx.r[30].u8 ) };
	// 82EB0114: 9BDF00C0  stb r30, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u8 ) };
	// 82EB0118: 9BDF00C1  stb r30, 0xc1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(193 as u32), ctx.r[30].u8 ) };
	// 82EB011C: 9BDF00BD  stb r30, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[30].u8 ) };
	// 82EB0120: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 82EB0124: 93DF0138  stw r30, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[30].u32 ) };
	// 82EB0128: 93DF0134  stw r30, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u32 ) };
	// 82EB012C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0130: D1BF00EC  stfs f13, 0xec(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EB0134: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0138: D1BF00F0  stfs f13, 0xf0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EB013C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0140: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EB0144: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0148: D1BF00E0  stfs f13, 0xe0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB014C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0150: D1BF00E4  stfs f13, 0xe4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB0154: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0158: D1BF00E8  stfs f13, 0xe8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB015C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0160: D1BF00F8  stfs f13, 0xf8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EB0164: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0168: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EB016C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0170: D1BF0100  stfs f13, 0x100(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EB0174: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 82EB0178: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB017C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0180: D1BF0144  stfs f13, 0x144(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EB0184: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0188: D1BF0148  stfs f13, 0x148(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EB018C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0194: D1BF014C  stfs f13, 0x14c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82EB0198: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82EB019C: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB01A0: 93DF0154  stw r30, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[30].u32 ) };
	// 82EB01A4: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB01A8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82EB01AC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EB01B0: 93DF01B0  stw r30, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[30].u32 ) };
	// 82EB01B4: C1AB0B24  lfs f13, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB01B8: 93DF01AC  stw r30, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[30].u32 ) };
	// 82EB01BC: D1BF0194  stfs f13, 0x194(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82EB01C0: 93DF01CC  stw r30, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 82EB01C4: 9BDF01C8  stb r30, 0x1c8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[30].u8 ) };
	// 82EB01C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB01CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB01D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB01D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB01D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB01DC: 4E800020  blr
	return;
	// 82EB01E0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB01E4: 386B8C64  addi r3, r11, -0x739c
	ctx.r[3].s64 = ctx.r[11].s64 + -29596;
	// 82EB01E8: 4E800020  blr
	return;
}

pub fn sub_82EB02F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB02F0 size=2272
	// 82EB02F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB02F4: 4BDF90FD  bl 0x82ca93f0
	ctx.lr = 0x82EB02F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93F0);
	// 82EB02F8: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82EB02FC: 4BDFD9DD  bl 0x82cadcd8
	ctx.lr = 0x82EB0300;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCD8);
	// 82EB0300: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0308: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82EB030C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82EB0310: 4B3B06A9  bl 0x822609b8
	ctx.lr = 0x82EB0314;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB0314: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0318: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EB031C: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0320: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0324: 4BFD1435  bl 0x82e81758
	ctx.lr = 0x82EB0328;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81758);
	// 82EB0328: 987F00C0  stb r3, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[3].u8 ) };
	// 82EB032C: C1BF0110  lfs f13, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0330: C19F0114  lfs f12, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0334: C17F0118  lfs f11, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0338: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB033C: 4182001C  beq 0x82eb0358
	if ctx.cr[0].eq {
	pc = 0x82EB0358; continue 'dispatch;
	}
	// 82EB0340: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0344: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB0348: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB034C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0350: C19F00E8  lfs f12, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0354: 48000018  b 0x82eb036c
	pc = 0x82EB036C; continue 'dispatch;
	// 82EB0358: C01F0144  lfs f0, 0x144(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB035C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB0360: C1BF0148  lfs f13, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0364: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0368: C19F014C  lfs f12, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB036C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0370: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0374: D19F00DC  stfs f12, 0xdc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EB0378: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82EB037C: D1BF00D8  stfs f13, 0xd8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EB0380: 3B7F00F8  addi r27, r31, 0xf8
	ctx.r[27].s64 = ctx.r[31].s64 + 248;
	// 82EB0384: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EB0388: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82EB038C: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 82EB0390: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0394: D0170000  stfs f0, 0(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0398: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB039C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB03A0: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB03A4: D0170004  stfs f0, 4(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB03A8: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB03AC: D0170008  stfs f0, 8(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB03B0: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB03B4: D017000C  stfs f0, 0xc(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB03B8: 9B17001C  stb r24, 0x1c(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(28 as u32), ctx.r[24].u8 ) };
	// 82EB03BC: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB03C0: C3DB0000  lfs f30, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB03C4: C3BB0004  lfs f29, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB03C8: C39B0008  lfs f28, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EB03CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB03D0: 41820048  beq 0x82eb0418
	if ctx.cr[0].eq {
	pc = 0x82EB0418; continue 'dispatch;
	}
	// 82EB03D4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB03D8: 419A0040  beq cr6, 0x82eb0418
	if ctx.cr[6].eq {
	pc = 0x82EB0418; continue 'dispatch;
	}
	// 82EB03DC: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB03E0: 556B103A  slwi r11, r11, 2
	// 82EB03E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB03E8: 83ABFFFC  lwz r29, -4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB03EC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB03F0: 41820028  beq 0x82eb0418
	if ctx.cr[0].eq {
	pc = 0x82EB0418; continue 'dispatch;
	}
	// 82EB03F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB03F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB03FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0400: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EB0404: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB040C: 4E800421  bctrl
	ctx.lr = 0x82EB0410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0410: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0414: 41820020  beq 0x82eb0434
	if ctx.cr[0].eq {
	pc = 0x82EB0434; continue 'dispatch;
	}
	// 82EB0418: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EB041C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0420: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0424: 4E800421  bctrl
	ctx.lr = 0x82EB0428;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0428: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB042C: 41820008  beq 0x82eb0434
	if ctx.cr[0].eq {
	pc = 0x82EB0434; continue 'dispatch;
	}
	// 82EB0430: 9ADF00BC  stb r22, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[22].u8 ) };
	// 82EB0434: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EB0438: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB043C: 419A002C  beq cr6, 0x82eb0468
	if ctx.cr[6].eq {
	pc = 0x82EB0468; continue 'dispatch;
	}
	// 82EB0440: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0444: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB0448: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB044C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EB0450: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0458: 4E800421  bctrl
	ctx.lr = 0x82EB045C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB045C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB0460: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB0464: 409A00F0  bne cr6, 0x82eb0554
	if !ctx.cr[6].eq {
	pc = 0x82EB0554; continue 'dispatch;
	}
	// 82EB0468: 897F01B5  lbz r11, 0x1b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82EB046C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0470: 408200E0  bne 0x82eb0550
	if !ctx.cr[0].eq {
	pc = 0x82EB0550; continue 'dispatch;
	}
	// 82EB0474: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB0478: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB047C: 408200D4  bne 0x82eb0550
	if !ctx.cr[0].eq {
	pc = 0x82EB0550; continue 'dispatch;
	}
	// 82EB0480: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0484: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0488: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB048C: C19F00EC  lfs f12, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0490: EC0D6028  fsubs f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0494: C15F00E4  lfs f10, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB0498: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB049C: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB04A0: C19F00E8  lfs f12, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB04A4: C15F00F4  lfs f10, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB04A8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB04AC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB04B0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB04B4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB04B8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB04BC: 40990008  ble cr6, 0x82eb04c4
	if !ctx.cr[6].gt {
	pc = 0x82EB04C4; continue 'dispatch;
	}
	// 82EB04C0: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB04C4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB04C8: 4082002C  bne 0x82eb04f4
	if !ctx.cr[0].eq {
	pc = 0x82EB04F4; continue 'dispatch;
	}
	// 82EB04CC: 897F0094  lbz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB04D0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB04D4: 409A0020  bne cr6, 0x82eb04f4
	if !ctx.cr[6].eq {
	pc = 0x82EB04F4; continue 'dispatch;
	}
	// 82EB04D8: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB04DC: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB04E0: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82EB04E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB04E8: 4198000C  blt cr6, 0x82eb04f4
	if ctx.cr[6].lt {
	pc = 0x82EB04F4; continue 'dispatch;
	}
	// 82EB04EC: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB04F0: 9ADF01B5  stb r22, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[22].u8 ) };
	// 82EB04F4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB04F8: 4082005C  bne 0x82eb0554
	if !ctx.cr[0].eq {
	pc = 0x82EB0554; continue 'dispatch;
	}
	// 82EB04FC: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EB0500: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0504: 40820050  bne 0x82eb0554
	if !ctx.cr[0].eq {
	pc = 0x82EB0554; continue 'dispatch;
	}
	// 82EB0508: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB050C: 409A001C  bne cr6, 0x82eb0528
	if !ctx.cr[6].eq {
	pc = 0x82EB0528; continue 'dispatch;
	}
	// 82EB0510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0518: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EB051C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0520: 4E800421  bctrl
	ctx.lr = 0x82EB0524;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0524: 48000024  b 0x82eb0548
	pc = 0x82EB0548; continue 'dispatch;
	// 82EB0528: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB052C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB0530: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0534: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB0538: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB053C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0540: 4E800421  bctrl
	ctx.lr = 0x82EB0544;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0544: 987F0190  stb r3, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[3].u8 ) };
	// 82EB0548: 8BDF0190  lbz r30, 0x190(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB054C: 48000008  b 0x82eb0554
	pc = 0x82EB0554; continue 'dispatch;
	// 82EB0550: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB0554: 57DE063F  clrlwi. r30, r30, 0x18
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB0558: 4182006C  beq 0x82eb05c4
	if ctx.cr[0].eq {
	pc = 0x82EB05C4; continue 'dispatch;
	}
	// 82EB055C: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB0560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0564: 40820060  bne 0x82eb05c4
	if !ctx.cr[0].eq {
	pc = 0x82EB05C4; continue 'dispatch;
	}
	// 82EB0568: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB056C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0570: 9ADF00BE  stb r22, 0xbe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(190 as u32), ctx.r[22].u8 ) };
	// 82EB0574: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0578: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB057C: 4BFD16BD  bl 0x82e81c38
	ctx.lr = 0x82EB0580;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81C38);
	// 82EB0580: C01F0144  lfs f0, 0x144(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0584: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EB0588: C01F0148  lfs f0, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB058C: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EB0590: C01F014C  lfs f0, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0594: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EB0598: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82EB059C: 815F0154  lwz r10, 0x154(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82EB05A0: 893F00BF  lbz r9, 0xbf(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB05A4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05A8: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82EB05AC: 915F0138  stw r10, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[10].u32 ) };
	// 82EB05B0: 41820014  beq 0x82eb05c4
	if ctx.cr[0].eq {
	pc = 0x82EB05C4; continue 'dispatch;
	}
	// 82EB05B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB05B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB05BC: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB05C0: 4BFD1049  bl 0x82e81608
	ctx.lr = 0x82EB05C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81608);
	// 82EB05C4: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EB05C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05CC: 41820018  beq 0x82eb05e4
	if ctx.cr[0].eq {
	pc = 0x82EB05E4; continue 'dispatch;
	}
	// 82EB05D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB05D4: 419A05E4  beq cr6, 0x82eb0bb8
	if ctx.cr[6].eq {
	pc = 0x82EB0BB8; continue 'dispatch;
	}
	// 82EB05D8: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB05DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05E0: 418205D8  beq 0x82eb0bb8
	if ctx.cr[0].eq {
	pc = 0x82EB0BB8; continue 'dispatch;
	}
	// 82EB05E4: 897F00BE  lbz r11, 0xbe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(190 as u32) ) } as u64;
	// 82EB05E8: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82EB05EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB05F0: 408201B8  bne 0x82eb07a8
	if !ctx.cr[0].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB05F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB05F8: 419A01B0  beq cr6, 0x82eb07a8
	if ctx.cr[6].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB05FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB0600: 419A002C  beq cr6, 0x82eb062c
	if ctx.cr[6].eq {
	pc = 0x82EB062C; continue 'dispatch;
	}
	// 82EB0604: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB060C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0610: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EB0614: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0618: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB061C: 4E800421  bctrl
	ctx.lr = 0x82EB0620;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0620: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB0624: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB0628: 409A0180  bne cr6, 0x82eb07a8
	if !ctx.cr[6].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB062C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0630: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0634: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0638: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EB063C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0640: 4BFD14B1  bl 0x82e81af0
	ctx.lr = 0x82EB0644;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81AF0);
	// 82EB0644: 9B1F00BC  stb r24, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[24].u8 ) };
	// 82EB0648: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB064C: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EB0650: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EB0654: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0658: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EB065C: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EB0660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0664: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0668: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EB066C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0670: 889F0190  lbz r4, 0x190(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB0674: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB0678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB067C: 4E800421  bctrl
	ctx.lr = 0x82EB0680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0680: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB0684: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0688: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB068C: 9B1F01B5  stb r24, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[24].u8 ) };
	// 82EB0690: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB0694: 997F00BD  stb r11, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[11].u8 ) };
	// 82EB0698: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB069C: 4BFD164D  bl 0x82e81ce8
	ctx.lr = 0x82EB06A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81CE8);
	// 82EB06A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB06A4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB06A8: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB06AC: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB06B0: 4BFD13C1  bl 0x82e81a70
	ctx.lr = 0x82EB06B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81A70);
	// 82EB06B4: C01F00E0  lfs f0, 0xe0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB06B8: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 82EB06BC: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB06C0: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 82EB06C4: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB06C8: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82EB06CC: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB06D0: 815F0138  lwz r10, 0x138(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB06D4: 893F00BF  lbz r9, 0xbf(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB06D8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB06DC: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82EB06E0: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 82EB06E4: 4182000C  beq 0x82eb06f0
	if ctx.cr[0].eq {
	pc = 0x82EB06F0; continue 'dispatch;
	}
	// 82EB06E8: 9B1F00BD  stb r24, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[24].u8 ) };
	// 82EB06EC: 480004CC  b 0x82eb0bb8
	pc = 0x82EB0BB8; continue 'dispatch;
	// 82EB06F0: 897F00BD  lbz r11, 0xbd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB06F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB06F8: 418200B0  beq 0x82eb07a8
	if ctx.cr[0].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB06FC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB0700: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0704: 40820010  bne 0x82eb0714
	if !ctx.cr[0].eq {
	pc = 0x82EB0714; continue 'dispatch;
	}
	// 82EB0708: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB070C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0710: 41820098  beq 0x82eb07a8
	if ctx.cr[0].eq {
	pc = 0x82EB07A8; continue 'dispatch;
	}
	// 82EB0714: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB0718: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EB071C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0720: 40820020  bne 0x82eb0740
	if !ctx.cr[0].eq {
	pc = 0x82EB0740; continue 'dispatch;
	}
	// 82EB0724: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB0728: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB072C: 4BFE2B05  bl 0x82e93230
	ctx.lr = 0x82EB0730;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E93230);
	// 82EB0730: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB0734: 419A000C  beq cr6, 0x82eb0740
	if ctx.cr[6].eq {
	pc = 0x82EB0740; continue 'dispatch;
	}
	// 82EB0738: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB073C: 907F013C  stw r3, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[3].u32 ) };
	// 82EB0740: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0744: 40820050  bne 0x82eb0794
	if !ctx.cr[0].eq {
	pc = 0x82EB0794; continue 'dispatch;
	}
	// 82EB0748: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB074C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB0750: 419A0024  beq cr6, 0x82eb0774
	if ctx.cr[6].eq {
	pc = 0x82EB0774; continue 'dispatch;
	}
	// 82EB0754: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0758: 931F013C  stw r24, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[24].u32 ) };
	// 82EB075C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0760: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0764: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0768: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB076C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0770: 48000020  b 0x82eb0790
	pc = 0x82EB0790; continue 'dispatch;
	// 82EB0774: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB0778: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82EB077C: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0780: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0784: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0788: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB078C: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0790: D01B0008  stfs f0, 8(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB0794: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB079C: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB07A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB07A4: 4E800421  bctrl
	ctx.lr = 0x82EB07A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB07A8: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB07AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB07B0: 41820020  beq 0x82eb07d0
	if ctx.cr[0].eq {
	pc = 0x82EB07D0; continue 'dispatch;
	}
	// 82EB07B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB07B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB07BC: 9B1F00BD  stb r24, 0xbd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(189 as u32), ctx.r[24].u8 ) };
	// 82EB07C0: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB07C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB07C8: 4E800421  bctrl
	ctx.lr = 0x82EB07CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB07CC: 480003EC  b 0x82eb0bb8
	pc = 0x82EB0BB8; continue 'dispatch;
	// 82EB07D0: 897F00BD  lbz r11, 0xbd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB07D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB07D8: 4082000C  bne 0x82eb07e4
	if !ctx.cr[0].eq {
	pc = 0x82EB07E4; continue 'dispatch;
	}
	// 82EB07DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB07E0: 480003DC  b 0x82eb0bbc
	pc = 0x82EB0BBC; continue 'dispatch;
	// 82EB07E4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB07E8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EB07EC: 40820074  bne 0x82eb0860
	if !ctx.cr[0].eq {
	pc = 0x82EB0860; continue 'dispatch;
	}
	// 82EB07F0: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB07F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB07F8: 41820020  beq 0x82eb0818
	if ctx.cr[0].eq {
	pc = 0x82EB0818; continue 'dispatch;
	}
	// 82EB07FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0800: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0804: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB0808: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB080C: 4B2FF5E5  bl 0x821afdf0
	ctx.lr = 0x82EB0810;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AFDF0);
	// 82EB0810: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB0814: 4800004C  b 0x82eb0860
	pc = 0x82EB0860; continue 'dispatch;
	// 82EB0818: 4B3B01A1  bl 0x822609b8
	ctx.lr = 0x82EB081C;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB081C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0820: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB0824: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB0828: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB082C: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0830: C3EB004C  lfs f31, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB0834: 4BFD0E9D  bl 0x82e816d0
	ctx.lr = 0x82EB0838;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E816D0);
	// 82EB0838: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB083C: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB0840: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EB0844: 4BFD0ABD  bl 0x82e81300
	ctx.lr = 0x82EB0848;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81300);
	// 82EB0848: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB084C: C00B0C4C  lfs f0, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0850: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0854: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EB0858: 40990008  ble cr6, 0x82eb0860
	if !ctx.cr[6].gt {
	pc = 0x82EB0860; continue 'dispatch;
	}
	// 82EB085C: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB0860: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0864: 418200CC  beq 0x82eb0930
	if ctx.cr[0].eq {
	pc = 0x82EB0930; continue 'dispatch;
	}
	// 82EB0868: 83DF013C  lwz r30, 0x13c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB086C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0870: 41820024  beq 0x82eb0894
	if ctx.cr[0].eq {
	pc = 0x82EB0894; continue 'dispatch;
	}
	// 82EB0874: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB0878: 419A001C  beq cr6, 0x82eb0894
	if ctx.cr[6].eq {
	pc = 0x82EB0894; continue 'dispatch;
	}
	// 82EB087C: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB0880: 57CB103A  slwi r11, r30, 2
	// 82EB0884: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB0888: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB088C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0890: 4082006C  bne 0x82eb08fc
	if !ctx.cr[0].eq {
	pc = 0x82EB08FC; continue 'dispatch;
	}
	// 82EB0894: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82EB0898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB089C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB08A0: 40820014  bne 0x82eb08b4
	if !ctx.cr[0].eq {
	pc = 0x82EB08B4; continue 'dispatch;
	}
	// 82EB08A4: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EB08A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB08AC: 4E800421  bctrl
	ctx.lr = 0x82EB08B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB08B0: 48000038  b 0x82eb08e8
	pc = 0x82EB08E8; continue 'dispatch;
	// 82EB08B4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EB08B8: 409A0014  bne cr6, 0x82eb08cc
	if !ctx.cr[6].eq {
	pc = 0x82EB08CC; continue 'dispatch;
	}
	// 82EB08BC: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EB08C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB08C4: 4E800421  bctrl
	ctx.lr = 0x82EB08C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB08C8: 48000008  b 0x82eb08d0
	pc = 0x82EB08D0; continue 'dispatch;
	// 82EB08CC: 48003AA5  bl 0x82eb4370
	ctx.lr = 0x82EB08D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB4370);
	// 82EB08D0: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB08D4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB08D8: 419A0010  beq cr6, 0x82eb08e8
	if ctx.cr[6].eq {
	pc = 0x82EB08E8; continue 'dispatch;
	}
	// 82EB08DC: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82EB08E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB08E4: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82EB08E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB08EC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB08F0: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB08F4: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB08F8: 4B414941  bl 0x822c5238
	ctx.lr = 0x82EB08FC;
	crate::recompiler::externs::call(&mut ctx, base, 0x822C5238);
	// 82EB08FC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EB0900: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0904: 41820014  beq 0x82eb0918
	if ctx.cr[0].eq {
	pc = 0x82EB0918; continue 'dispatch;
	}
	// 82EB0908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB090C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0910: 4E800421  bctrl
	ctx.lr = 0x82EB0914;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0914: 4800001C  b 0x82eb0930
	pc = 0x82EB0930; continue 'dispatch;
	// 82EB0918: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB091C: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB0920: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0924: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB0928: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB092C: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB0930: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB0934: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0938: 41820148  beq 0x82eb0a80
	if ctx.cr[0].eq {
	pc = 0x82EB0A80; continue 'dispatch;
	}
	// 82EB093C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB0940: 419A0140  beq cr6, 0x82eb0a80
	if ctx.cr[6].eq {
	pc = 0x82EB0A80; continue 'dispatch;
	}
	// 82EB0944: 813F008C  lwz r9, 0x8c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB0948: 556A103A  slwi r10, r11, 2
	// 82EB094C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EB0950: 806AFFFC  lwz r3, -4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB0954: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0958: 41820128  beq 0x82eb0a80
	if ctx.cr[0].eq {
	pc = 0x82EB0A80; continue 'dispatch;
	}
	// 82EB095C: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0960: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0964: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB0968: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB096C: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0970: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB0974: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB0978: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB097C: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0980: 9B010050  stb r24, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u8 ) };
	// 82EB0984: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB0988: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB098C: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0990: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0994: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82EB0998: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EB099C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB09A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB09A4: 4E800421  bctrl
	ctx.lr = 0x82EB09A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB09A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB09AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB09B0: 409A000C  bne cr6, 0x82eb09bc
	if !ctx.cr[6].eq {
	pc = 0x82EB09BC; continue 'dispatch;
	}
	// 82EB09B4: 9B1F01B4  stb r24, 0x1b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[24].u8 ) };
	// 82EB09B8: 4800001C  b 0x82eb09d4
	pc = 0x82EB09D4; continue 'dispatch;
	// 82EB09BC: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EB09C0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EB09C4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EB09C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB09CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB09D0: 4E800421  bctrl
	ctx.lr = 0x82EB09D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB09D4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB09D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB09DC: 4182008C  beq 0x82eb0a68
	if ctx.cr[0].eq {
	pc = 0x82EB0A68; continue 'dispatch;
	}
	// 82EB09E0: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB09E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB09E8: 41820014  beq 0x82eb09fc
	if ctx.cr[0].eq {
	pc = 0x82EB09FC; continue 'dispatch;
	}
	// 82EB09EC: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB09F0: 556B103A  slwi r11, r11, 2
	// 82EB09F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB09F8: 930BFFFC  stw r24, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[24].u32 ) };
	// 82EB09FC: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB0A00: 813F007C  lwz r9, 0x7c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB0A04: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB0A08: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB0A0C: 4098002C  bge cr6, 0x82eb0a38
	if !ctx.cr[6].lt {
	pc = 0x82EB0A38; continue 'dispatch;
	}
	// 82EB0A10: 813F0088  lwz r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0A14: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 * 12;
	// 82EB0A18: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82EB0A1C: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 82EB0A20: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A24: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0A28: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A2C: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB0A30: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A34: 48000018  b 0x82eb0a4c
	pc = 0x82EB0A4C; continue 'dispatch;
	// 82EB0A38: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A3C: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB0A40: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A44: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB0A48: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A4C: D01B0008  stfs f0, 8(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB0A50: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A54: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB0A58: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A5C: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB0A60: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0A64: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB0A68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0A6C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0A70: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0A74: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0A78: 4B4147C1  bl 0x822c5238
	ctx.lr = 0x82EB0A7C;
	crate::recompiler::externs::call(&mut ctx, base, 0x822C5238);
	// 82EB0A7C: 480000DC  b 0x82eb0b58
	pc = 0x82EB0B58; continue 'dispatch;
	// 82EB0A80: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB0A84: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82EB0A88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0A8C: 41820020  beq 0x82eb0aac
	if ctx.cr[0].eq {
	pc = 0x82EB0AAC; continue 'dispatch;
	}
	// 82EB0A90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0A94: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0A98: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0A9C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0AA0: 4B2FF351  bl 0x821afdf0
	ctx.lr = 0x82EB0AA4;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AFDF0);
	// 82EB0AA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB0AA8: 4800004C  b 0x82eb0af4
	pc = 0x82EB0AF4; continue 'dispatch;
	// 82EB0AAC: 4B3AFF0D  bl 0x822609b8
	ctx.lr = 0x82EB0AB0;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB0AB0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0AB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB0AB8: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0ABC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0AC0: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0AC4: C3EB004C  lfs f31, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB0AC8: 4BFD0C09  bl 0x82e816d0
	ctx.lr = 0x82EB0ACC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E816D0);
	// 82EB0ACC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0AD0: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0AD4: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EB0AD8: 4BFD0829  bl 0x82e81300
	ctx.lr = 0x82EB0ADC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81300);
	// 82EB0ADC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0AE0: C00B0A98  lfs f0, 0xa98(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0AE4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0AE8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EB0AEC: 40990008  ble cr6, 0x82eb0af4
	if !ctx.cr[6].gt {
	pc = 0x82EB0AF4; continue 'dispatch;
	}
	// 82EB0AF0: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB0AF4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0AF8: 41820030  beq 0x82eb0b28
	if ctx.cr[0].eq {
	pc = 0x82EB0B28; continue 'dispatch;
	}
	// 82EB0AFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0B00: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB0B04: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB0B08: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0B0C: 4B41472D  bl 0x822c5238
	ctx.lr = 0x82EB0B10;
	crate::recompiler::externs::call(&mut ctx, base, 0x822C5238);
	// 82EB0B10: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EB0B14: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 82EB0B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0B1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0B20: 4E800421  bctrl
	ctx.lr = 0x82EB0B24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0B24: 987F01B6  stb r3, 0x1b6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(438 as u32), ctx.r[3].u8 ) };
	// 82EB0B28: 897F01B6  lbz r11, 0x1b6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(438 as u32) ) } as u64;
	// 82EB0B2C: 38BF0104  addi r5, r31, 0x104
	ctx.r[5].s64 = ctx.r[31].s64 + 260;
	// 82EB0B30: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EB0B34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0B3C: 4182000C  beq 0x82eb0b48
	if ctx.cr[0].eq {
	pc = 0x82EB0B48; continue 'dispatch;
	}
	// 82EB0B40: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EB0B44: 48000008  b 0x82eb0b4c
	pc = 0x82EB0B4C; continue 'dispatch;
	// 82EB0B48: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 82EB0B4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0B50: 4E800421  bctrl
	ctx.lr = 0x82EB0B54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0B54: 9B1F00BC  stb r24, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[24].u8 ) };
	// 82EB0B58: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0B5C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EB0B60: 409A0020  bne cr6, 0x82eb0b80
	if !ctx.cr[6].eq {
	pc = 0x82EB0B80; continue 'dispatch;
	}
	// 82EB0B64: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0B68: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EB0B6C: 409A0014  bne cr6, 0x82eb0b80
	if !ctx.cr[6].eq {
	pc = 0x82EB0B80; continue 'dispatch;
	}
	// 82EB0B70: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0B74: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82EB0B78: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 82EB0B7C: 419A0008  beq cr6, 0x82eb0b84
	if ctx.cr[6].eq {
	pc = 0x82EB0B84; continue 'dispatch;
	}
	// 82EB0B80: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 82EB0B84: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB0B88: 41820018  beq 0x82eb0ba0
	if ctx.cr[0].eq {
	pc = 0x82EB0BA0; continue 'dispatch;
	}
	// 82EB0B8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0B94: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB0B98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0B9C: 4E800421  bctrl
	ctx.lr = 0x82EB0BA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0BA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB0BA4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EB0BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB0BAC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB0BB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB0BB4: 4E800421  bctrl
	ctx.lr = 0x82EB0BB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB0BB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB0BBC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB0BC0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82EB0BC4: 4BDFD161  bl 0x82cadd24
	ctx.lr = 0x82EB0BC8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADD24);
	// 82EB0BC8: 4BDF8878  b 0x82ca9440
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9440);
	return;
}

pub fn sub_82EB0BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0BD0 size=184
	// 82EB0BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB0BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB0BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB0BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0BE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0BEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB0BF0: C1BF01A0  lfs f13, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0BF4: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0BF8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB0BFC: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0C00: C01F0124  lfs f0, 0x124(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0C04: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0C08: C19F011C  lfs f12, 0x11c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0C0C: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0C10: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB0C14: C17F0120  lfs f11, 0x120(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0C18: C19F0114  lfs f12, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0C1C: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0C20: 419A0020  beq cr6, 0x82eb0c40
	if ctx.cr[6].eq {
	pc = 0x82EB0C40; continue 'dispatch;
	}
	// 82EB0C24: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0C28: C17F0198  lfs f11, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0C2C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB0C30: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB0C34: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB0C38: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EB0C3C: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB0C40: 4B3AFD79  bl 0x822609b8
	ctx.lr = 0x82EB0C44;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB0C44: C1630058  lfs f11, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0C48: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0C4C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB0C50: C1BF01A8  lfs f13, 0x1a8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0C54: C19F019C  lfs f12, 0x19c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0C58: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82EB0C5C: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 82EB0C60: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB0C64: D01F01A8  stfs f0, 0x1a8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82EB0C68: EDAB602A  fadds f13, f11, f12
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EB0C6C: D1BF019C  stfs f13, 0x19c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB0C70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB0C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB0C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB0C7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB0C80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB0C84: 4E800020  blr
	return;
}

pub fn sub_82EB0C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB0C88 size=160
	// 82EB0C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB0C90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB0C94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB0C98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0C9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB0CA0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB0CA4: 83E30184  lwz r31, 0x184(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(388 as u32) ) } as u64;
	// 82EB0CA8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB0CAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB0CB0: D0030198  stfs f0, 0x198(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82EB0CB4: D003019C  stfs f0, 0x19c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82EB0CB8: 99630190  stb r11, 0x190(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 82EB0CBC: C1830110  lfs f12, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0CC0: C1A300F8  lfs f13, 0xf8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB0CC4: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0CC8: C16300FC  lfs f11, 0xfc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0CCC: C1830114  lfs f12, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB0CD0: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB0CD4: C1430118  lfs f10, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB0CD8: C1630100  lfs f11, 0x100(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB0CDC: D00301A8  stfs f0, 0x1a8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82EB0CE0: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB0CE4: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB0CE8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB0CEC: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB0CF0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB0CF4: D00301A4  stfs f0, 0x1a4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82EB0CF8: 83CA0014  lwz r30, 0x14(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB0CFC: 4B3AFCBD  bl 0x822609b8
	ctx.lr = 0x82EB0D00;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB0D00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB0D04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB0D08: 4B414531  bl 0x822c5238
	ctx.lr = 0x82EB0D0C;
	crate::recompiler::externs::call(&mut ctx, base, 0x822C5238);
	// 82EB0D0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB0D10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB0D14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB0D18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB0D1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB0D20: 4E800020  blr
	return;
}

pub fn sub_82EB0D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB0D28 size=12
	// 82EB0D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0D2C: 4BDF86E1  bl 0x82ca940c
	ctx.lr = 0x82EB0D30;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB0D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB0E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB0E20 size=12
	// 82EB0E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0E24: 4BDF85E1  bl 0x82ca9404
	ctx.lr = 0x82EB0E28;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EB0E28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB0F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB0F80 size=528
	// 82EB0F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB0F84: 4BDF8485  bl 0x82ca9408
	ctx.lr = 0x82EB0F88;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EB0F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB0F8C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB0F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB0F94: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EB0F98: 409A0020  bne cr6, 0x82eb0fb8
	if !ctx.cr[6].eq {
	pc = 0x82EB0FB8; continue 'dispatch;
	}
	// 82EB0F9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB0FA0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EB0FA4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EB0FA8: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB0FAC: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 82EB0FB0: 917F0178  stw r11, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82EB0FB4: 480000AC  b 0x82eb1060
	pc = 0x82EB1060; continue 'dispatch;
	// 82EB0FB8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0FBC: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82EB0FC0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB0FC4: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB0FC8: 4B3B6C59  bl 0x82267c20
	ctx.lr = 0x82EB0FCC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EB0FCC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB0FD0: 4082000C  bne 0x82eb0fdc
	if !ctx.cr[0].eq {
	pc = 0x82EB0FDC; continue 'dispatch;
	}
	// 82EB0FD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB0FD8: 48000114  b 0x82eb10ec
	pc = 0x82EB10EC; continue 'dispatch;
	// 82EB0FDC: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB0FE0: 939F006C  stw r28, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82EB0FE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0FE8: 4182003C  beq 0x82eb1024
	if ctx.cr[0].eq {
	pc = 0x82EB1024; continue 'dispatch;
	}
	// 82EB0FEC: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB0FF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB0FF4: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB0FF8: 4182002C  beq 0x82eb1024
	if ctx.cr[0].eq {
	pc = 0x82EB1024; continue 'dispatch;
	}
	// 82EB0FFC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1000: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82EB1004: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1008: 80E70084  lwz r7, 0x84(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EB100C: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EB1010: 419A00E4  beq cr6, 0x82eb10f4
	if ctx.cr[6].eq {
	pc = 0x82EB10F4; continue 'dispatch;
	}
	// 82EB1014: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB1018: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB101C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB1020: 4198FFE4  blt cr6, 0x82eb1004
	if ctx.cr[6].lt {
	pc = 0x82EB1004; continue 'dispatch;
	}
	// 82EB1024: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB1028: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB102C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1030: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB1034: 38AB70AC  addi r5, r11, 0x70ac
	ctx.r[5].s64 = ctx.r[11].s64 + 28844;
	// 82EB1038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB103C: 4BFDC055  bl 0x82e8d090
	ctx.lr = 0x82EB1040;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8D090);
	// 82EB1040: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB1044: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1048: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB104C: 38AB5D84  addi r5, r11, 0x5d84
	ctx.r[5].s64 = ctx.r[11].s64 + 23940;
	// 82EB1050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB1054: 915F0174  stw r10, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 82EB1058: 4BFDC039  bl 0x82e8d090
	ctx.lr = 0x82EB105C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8D090);
	// 82EB105C: 907F0178  stw r3, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[3].u32 ) };
	// 82EB1060: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1068: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB106C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1070: 4E800421  bctrl
	ctx.lr = 0x82EB1074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1074: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1078: 4182002C  beq 0x82eb10a4
	if ctx.cr[0].eq {
	pc = 0x82EB10A4; continue 'dispatch;
	}
	// 82EB107C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1084: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB1088: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB108C: 4E800421  bctrl
	ctx.lr = 0x82EB1090;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1094: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB1098: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB109C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10A0: 4E800421  bctrl
	ctx.lr = 0x82EB10A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB10A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB10AC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB10B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10B4: 4E800421  bctrl
	ctx.lr = 0x82EB10B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB10BC: 4182002C  beq 0x82eb10e8
	if ctx.cr[0].eq {
	pc = 0x82EB10E8; continue 'dispatch;
	}
	// 82EB10C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB10C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB10C8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB10CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10D0: 4E800421  bctrl
	ctx.lr = 0x82EB10D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB10D8: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB10DC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB10E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB10E4: 4E800421  bctrl
	ctx.lr = 0x82EB10E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB10E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB10EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB10F0: 4BDF8368  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
	// 82EB10F4: 556B103A  slwi r11, r11, 2
	// 82EB10F8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82EB10FC: 348B0004  addic. r4, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EB1100: 4182FF24  beq 0x82eb1024
	if ctx.cr[0].eq {
	pc = 0x82EB1024; continue 'dispatch;
	}
	// 82EB1104: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1108: 3BBF0070  addi r29, r31, 0x70
	ctx.r[29].s64 = ctx.r[31].s64 + 112;
	// 82EB110C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB1110: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EB1114: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1118: 4E800421  bctrl
	ctx.lr = 0x82EB111C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB111C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1120: 4082FF0C  bne 0x82eb102c
	if !ctx.cr[0].eq {
	pc = 0x82EB102C; continue 'dispatch;
	}
	// 82EB1124: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB1128: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB112C: 4BFFFF00  b 0x82eb102c
	pc = 0x82EB102C; continue 'dispatch;
	// 82EB1130: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB1134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB1138: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EB113C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1140: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EB1144: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB1148: 816A0090  lwz r11, 0x90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB114C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1150: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82EB1154: 4E800020  blr
	return;
	// 82EB1158: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB115C: 996301B5  stb r11, 0x1b5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(437 as u32), ctx.r[11].u8 ) };
	// 82EB1160: 4E800020  blr
	return;
}

pub fn sub_82EB1190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB1190 size=1016
	// 82EB1190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1194: 4BDF826D  bl 0x82ca9400
	ctx.lr = 0x82EB1198;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EB1198: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB119C: 4BDFCB3D  bl 0x82cadcd8
	ctx.lr = 0x82EB11A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCD8);
	// 82EB11A0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB11A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB11A8: 3BDF00F8  addi r30, r31, 0xf8
	ctx.r[30].s64 = ctx.r[31].s64 + 248;
	// 82EB11AC: 3BBF0104  addi r29, r31, 0x104
	ctx.r[29].s64 = ctx.r[31].s64 + 260;
	// 82EB11B0: 3B7F0110  addi r27, r31, 0x110
	ctx.r[27].s64 = ctx.r[31].s64 + 272;
	// 82EB11B4: 3B9F0074  addi r28, r31, 0x74
	ctx.r[28].s64 = ctx.r[31].s64 + 116;
	// 82EB11B8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB11BC: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB11C0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB11C4: 409A0028  bne cr6, 0x82eb11ec
	if !ctx.cr[6].eq {
	pc = 0x82EB11EC; continue 'dispatch;
	}
	// 82EB11C8: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB11CC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB11D0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB11D4: 409A0018  bne cr6, 0x82eb11ec
	if !ctx.cr[6].eq {
	pc = 0x82EB11EC; continue 'dispatch;
	}
	// 82EB11D8: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB11DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB11E0: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB11E4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB11E8: 419A0008  beq cr6, 0x82eb11f0
	if ctx.cr[6].eq {
	pc = 0x82EB11F0; continue 'dispatch;
	}
	// 82EB11EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB11F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB11F4: 41820020  beq 0x82eb1214
	if ctx.cr[0].eq {
	pc = 0x82EB1214; continue 'dispatch;
	}
	// 82EB11F8: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB11FC: 556A103A  slwi r10, r11, 2
	// 82EB1200: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB1204: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1208: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB120C: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB1210: 48000364  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB1214: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB1218: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB121C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1220: 409802D0  bge cr6, 0x82eb14f0
	if !ctx.cr[6].lt {
	pc = 0x82EB14F0; continue 'dispatch;
	}
	// 82EB1224: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1228: 5569103A  slwi r9, r11, 2
	// 82EB122C: 811F01BC  lwz r8, 0x1bc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB1230: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB1234: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1238: 409A02B8  bne cr6, 0x82eb14f0
	if !ctx.cr[6].eq {
	pc = 0x82EB14F0; continue 'dispatch;
	}
	// 82EB123C: 815F013C  lwz r10, 0x13c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB1240: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1244: 419902AC  bgt cr6, 0x82eb14f0
	if ctx.cr[6].gt {
	pc = 0x82EB14F0; continue 'dispatch;
	}
	// 82EB1248: 835F0188  lwz r26, 0x188(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB124C: 4B3AF76D  bl 0x822609b8
	ctx.lr = 0x82EB1250;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB1250: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EB1254: 4BFD00AD  bl 0x82e81300
	ctx.lr = 0x82EB1258;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81300);
	// 82EB1258: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB125C: C3AB0C18  lfs f29, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB1260: FF01E800  fcmpu cr6, f1, f29
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 82EB1264: 419A0010  beq cr6, 0x82eb1274
	if ctx.cr[6].eq {
	pc = 0x82EB1274; continue 'dispatch;
	}
	// 82EB1268: C01F01C4  lfs f0, 0x1c4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB126C: EF800072  fmuls f28, f0, f1
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EB1270: 480001C0  b 0x82eb1430
	pc = 0x82EB1430; continue 'dispatch;
	// 82EB1274: 4B3AF745  bl 0x822609b8
	ctx.lr = 0x82EB1278;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB1278: C01F01C4  lfs f0, 0x1c4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB127C: C1A30058  lfs f13, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1280: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1284: 480001AC  b 0x82eb1430
	pc = 0x82EB1430; continue 'dispatch;
	// 82EB1288: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB128C: C11D0000  lfs f8, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB1290: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB1294: C0FD0004  lfs f7, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EB1298: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82EB129C: C0DD0008  lfs f6, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EB12A0: D1010070  stfs f8, 0x70(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EB12A4: D0E10074  stfs f7, 0x74(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EB12A8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB12AC: D0C10078  stfs f6, 0x78(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EB12B0: D3A10050  stfs f29, 0x50(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB12B4: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB12B8: D3A10058  stfs f29, 0x58(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB12BC: 41980070  blt cr6, 0x82eb132c
	if ctx.cr[6].lt {
	pc = 0x82EB132C; continue 'dispatch;
	}
	// 82EB12C0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB12C4: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB12C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB12CC: 409A0028  bne cr6, 0x82eb12f4
	if !ctx.cr[6].eq {
	pc = 0x82EB12F4; continue 'dispatch;
	}
	// 82EB12D0: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB12D4: C17F00E4  lfs f11, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB12D8: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82EB12DC: 409A0018  bne cr6, 0x82eb12f4
	if !ctx.cr[6].eq {
	pc = 0x82EB12F4; continue 'dispatch;
	}
	// 82EB12E0: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB12E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB12E8: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB12EC: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82EB12F0: 419A0008  beq cr6, 0x82eb12f8
	if ctx.cr[6].eq {
	pc = 0x82EB12F8; continue 'dispatch;
	}
	// 82EB12F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB12F8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB12FC: 41820018  beq 0x82eb1314
	if ctx.cr[0].eq {
	pc = 0x82EB1314; continue 'dispatch;
	}
	// 82EB1300: C19F00E4  lfs f12, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1304: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1308: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB130C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1310: 48000040  b 0x82eb1350
	pc = 0x82EB1350; continue 'dispatch;
	// 82EB1314: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1318: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EB131C: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1320: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1324: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1328: 48000028  b 0x82eb1350
	pc = 0x82EB1350; continue 'dispatch;
	// 82EB132C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB1330: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1334: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB1338: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB133C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1340: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1344: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1348: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB134C: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1350: ED4D4028  fsubs f10, f13, f8
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB1354: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1358: EC0C3828  fsubs f0, f12, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB135C: ED2B3028  fsubs f9, f11, f6
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EB1360: ED4A02B2  fmuls f10, f10, f10
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EB1364: EC00503A  fmadds f0, f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EB1368: EC09027A  fmadds f0, f9, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB136C: EFE0002C  fsqrts f31, f0
	ctx.f[31].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB1370: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EB1374: 419A0014  beq cr6, 0x82eb1388
	if ctx.cr[6].eq {
	pc = 0x82EB1388; continue 'dispatch;
	}
	// 82EB1378: C01F01C0  lfs f0, 0x1c0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB137C: EFDC002A  fadds f30, f28, f0
	ctx.f[30].f64 = ((ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB1380: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82EB1384: 419800B8  blt cr6, 0x82eb143c
	if ctx.cr[6].lt {
	pc = 0x82EB143C; continue 'dispatch;
	}
	// 82EB1388: C01F01C0  lfs f0, 0x1c0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB138C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB1390: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB1394: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EB1398: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EB139C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB13A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB13A4: EF9C0028  fsubs f28, f28, f0
	ctx.f[28].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB13A8: 4B3D7D71  bl 0x82289118
	ctx.lr = 0x82EB13AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82289118);
	// 82EB13AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB13B0: 408200E0  bne 0x82eb1490
	if !ctx.cr[0].eq {
	pc = 0x82EB1490; continue 'dispatch;
	}
	// 82EB13B4: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB13B8: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB13BC: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB13C0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB13C4: D1BD0004  stfs f13, 4(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB13C8: D19D0008  stfs f12, 8(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB13CC: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB13D0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB13D4: 409A0020  bne cr6, 0x82eb13f4
	if !ctx.cr[6].eq {
	pc = 0x82EB13F4; continue 'dispatch;
	}
	// 82EB13D8: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB13DC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB13E0: 409A0014  bne cr6, 0x82eb13f4
	if !ctx.cr[6].eq {
	pc = 0x82EB13F4; continue 'dispatch;
	}
	// 82EB13E4: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB13E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB13EC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EB13F0: 419A0008  beq cr6, 0x82eb13f8
	if ctx.cr[6].eq {
	pc = 0x82EB13F8; continue 'dispatch;
	}
	// 82EB13F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB13F8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB13FC: 408200EC  bne 0x82eb14e8
	if !ctx.cr[0].eq {
	pc = 0x82EB14E8; continue 'dispatch;
	}
	// 82EB1400: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB1404: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB1408: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB140C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB1410: 40980008  bge cr6, 0x82eb1418
	if !ctx.cr[6].lt {
	pc = 0x82EB1418; continue 'dispatch;
	}
	// 82EB1414: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB1418: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB141C: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1420: 556B103A  slwi r11, r11, 2
	// 82EB1424: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB1428: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB142C: D3BF01C0  stfs f29, 0x1c0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB1430: FF1CE800  fcmpu cr6, f28, f29
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[29].f64);
	// 82EB1434: 4199FE54  bgt cr6, 0x82eb1288
	if ctx.cr[6].gt {
	pc = 0x82EB1288; continue 'dispatch;
	}
	// 82EB1438: 4800013C  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB143C: EDAD4028  fsubs f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB1440: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB1444: EC1EF824  fdivs f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 82EB1448: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EB144C: ED8C3828  fsubs f12, f12, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB1450: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EB1454: ED6B3028  fsubs f11, f11, f6
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EB1458: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB145C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB1460: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1464: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1468: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB146C: EDAD402A  fadds f13, f13, f8
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EB1470: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1474: EDAC382A  fadds f13, f12, f7
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EB1478: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB147C: EC00302A  fadds f0, f0, f6
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64;
	// 82EB1480: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1484: 4B3D7C95  bl 0x82289118
	ctx.lr = 0x82EB1488;
	crate::recompiler::externs::call(&mut ctx, base, 0x82289118);
	// 82EB1488: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB148C: 4182003C  beq 0x82eb14c8
	if ctx.cr[0].eq {
	pc = 0x82EB14C8; continue 'dispatch;
	}
	// 82EB1490: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1494: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB1498: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB149C: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB14A0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14A4: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB14A8: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB14AC: 556A103A  slwi r10, r11, 2
	// 82EB14B0: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB14B4: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB14B8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB14BC: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB14C0: D3BF01C0  stfs f29, 0x1c0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB14C4: 480000B0  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB14C8: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14CC: D3DF01C0  stfs f30, 0x1c0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB14D0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB14D4: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14D8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB14DC: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14E0: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB14E4: 48000090  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB14E8: D3FF01C0  stfs f31, 0x1c0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB14EC: 48000088  b 0x82eb1574
	pc = 0x82EB1574; continue 'dispatch;
	// 82EB14F0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB14F4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB14F8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB14FC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1500: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1504: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB1508: 556A103A  slwi r10, r11, 2
	// 82EB150C: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB1510: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB1514: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB1518: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB151C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1520: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1524: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1528: 409A0028  bne cr6, 0x82eb1550
	if !ctx.cr[6].eq {
	pc = 0x82EB1550; continue 'dispatch;
	}
	// 82EB152C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1530: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1534: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1538: 409A0018  bne cr6, 0x82eb1550
	if !ctx.cr[6].eq {
	pc = 0x82EB1550; continue 'dispatch;
	}
	// 82EB153C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1540: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB1544: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1548: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB154C: 419A0008  beq cr6, 0x82eb1554
	if ctx.cr[6].eq {
	pc = 0x82EB1554; continue 'dispatch;
	}
	// 82EB1550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB1554: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1558: 41820010  beq 0x82eb1568
	if ctx.cr[0].eq {
	pc = 0x82EB1568; continue 'dispatch;
	}
	// 82EB155C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1560: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1564: 4800000C  b 0x82eb1570
	pc = 0x82EB1570; continue 'dispatch;
	// 82EB1568: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB156C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1570: D01F01C0  stfs f0, 0x1c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB1574: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB1578: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB157C: 4BDFC7A9  bl 0x82cadd24
	ctx.lr = 0x82EB1580;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADD24);
	// 82EB1580: 4BDF7ED0  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
}

pub fn sub_82EB1588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1588 size=72
	// 82EB1588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB158C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB1594: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB159C: 386001D0  li r3, 0x1d0
	ctx.r[3].s64 = 464;
	// 82EB15A0: 4B765389  bl 0x82616928
	ctx.lr = 0x82EB15A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EB15A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB15A8: 41820010  beq 0x82eb15b8
	if ctx.cr[0].eq {
	pc = 0x82EB15B8; continue 'dispatch;
	}
	// 82EB15AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB15B0: 4BFFEA69  bl 0x82eb0018
	ctx.lr = 0x82EB15B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB0018);
	// 82EB15B4: 48000008  b 0x82eb15bc
	pc = 0x82EB15BC; continue 'dispatch;
	// 82EB15B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB15BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB15C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB15C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB15C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB15CC: 4E800020  blr
	return;
}

pub fn sub_82EB15D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB15D0 size=232
	// 82EB15D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB15D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB15D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB15DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB15E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB15E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB15E8: 396BA3B0  addi r11, r11, -0x5c50
	ctx.r[11].s64 = ctx.r[11].s64 + -23632;
	// 82EB15EC: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB15F0: 388A5E98  addi r4, r10, 0x5e98
	ctx.r[4].s64 = ctx.r[10].s64 + 24216;
	// 82EB15F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB15F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB15FC: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB1600: 4B3B6621  bl 0x82267c20
	ctx.lr = 0x82EB1604;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EB1604: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1608: 4182001C  beq 0x82eb1624
	if ctx.cr[0].eq {
	pc = 0x82EB1624; continue 'dispatch;
	}
	// 82EB160C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1610: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB1614: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB1618: 388B1130  addi r4, r11, 0x1130
	ctx.r[4].s64 = ctx.r[11].s64 + 4400;
	// 82EB161C: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1620: 4BFE6EC1  bl 0x82e984e0
	ctx.lr = 0x82EB1624;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E984E0);
	// 82EB1624: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB1628: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB162C: 41820034  beq 0x82eb1660
	if ctx.cr[0].eq {
	pc = 0x82EB1660; continue 'dispatch;
	}
	// 82EB1630: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB1634: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82EB1638: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB163C: 419A0020  beq cr6, 0x82eb165c
	if ctx.cr[6].eq {
	pc = 0x82EB165C; continue 'dispatch;
	}
	// 82EB1640: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1644: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EB1648: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EB164C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1654: 4E800421  bctrl
	ctx.lr = 0x82EB1658;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1658: 48000008  b 0x82eb1660
	pc = 0x82EB1660; continue 'dispatch;
	// 82EB165C: 4B994155  bl 0x828457b0
	ctx.lr = 0x82EB1660;
	crate::recompiler::externs::call(&mut ctx, base, 0x828457B0);
	// 82EB1660: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB1664: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1668: 41820018  beq 0x82eb1680
	if ctx.cr[0].eq {
	pc = 0x82EB1680; continue 'dispatch;
	}
	// 82EB166C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1670: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EB1674: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB167C: 4E800421  bctrl
	ctx.lr = 0x82EB1680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1680: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB1684: 4BFE18ED  bl 0x82e92f70
	ctx.lr = 0x82EB1688;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E92F70);
	// 82EB1688: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB168C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1690: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB1694: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EB1698: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EB169C: 4BFD41DD  bl 0x82e85878
	ctx.lr = 0x82EB16A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85878);
	// 82EB16A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB16A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB16A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB16AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB16B0: 4E800020  blr
	return;
}

pub fn sub_82EB16B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB16B8 size=12
	// 82EB16B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB16BC: 4BDF7D51  bl 0x82ca940c
	ctx.lr = 0x82EB16C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB16C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB17F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB17F8 size=1040
	// 82EB17F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB17FC: 4BDF7C11  bl 0x82ca940c
	ctx.lr = 0x82EB1800;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB1800: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EB1804: 4BDFC4C1  bl 0x82cadcc4
	ctx.lr = 0x82EB1808;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCC4);
	// 82EB1808: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB180C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EB1810: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB1814: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82EB1818: 394A115C  addi r10, r10, 0x115c
	ctx.r[10].s64 = ctx.r[10].s64 + 4444;
	// 82EB181C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1820: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82EB1824: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1828: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB182C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB1830: 409A0028  bne cr6, 0x82eb1858
	if !ctx.cr[6].eq {
	pc = 0x82EB1858; continue 'dispatch;
	}
	// 82EB1834: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1838: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB183C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB1840: 409A0018  bne cr6, 0x82eb1858
	if !ctx.cr[6].eq {
	pc = 0x82EB1858; continue 'dispatch;
	}
	// 82EB1844: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1848: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB184C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1850: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB1854: 419A0008  beq cr6, 0x82eb185c
	if ctx.cr[6].eq {
	pc = 0x82EB185C; continue 'dispatch;
	}
	// 82EB1858: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82EB185C: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB1860: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB1864: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB1868: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB186C: C3280C18  lfs f25, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EB1870: C2E90EE0  lfs f23, 0xee0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3808 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82EB1874: C30A0C14  lfs f24, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EB1878: 418202C0  beq 0x82eb1b38
	if ctx.cr[0].eq {
	pc = 0x82EB1B38; continue 'dispatch;
	}
	// 82EB187C: 815F0164  lwz r10, 0x164(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB1880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB1884: 419A00C0  beq cr6, 0x82eb1944
	if ctx.cr[6].eq {
	pc = 0x82EB1944; continue 'dispatch;
	}
	// 82EB1888: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EB188C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EB1890: 4BFD44D9  bl 0x82e85d68
	ctx.lr = 0x82EB1894;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85D68);
	// 82EB1894: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1898: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB189C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB18A0: C00B0044  lfs f0, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB18A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB18A8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB18AC: C1AB0A44  lfs f13, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB18B4: 40990014  ble cr6, 0x82eb18c8
	if !ctx.cr[6].gt {
	pc = 0x82EB18C8; continue 'dispatch;
	}
	// 82EB18B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB18BC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18C0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB18C4: 48000020  b 0x82eb18e4
	pc = 0x82EB18E4; continue 'dispatch;
	// 82EB18C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB18CC: C1AB89C8  lfs f13, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB18D4: 40980010  bge cr6, 0x82eb18e4
	if !ctx.cr[6].lt {
	pc = 0x82EB18E4; continue 'dispatch;
	}
	// 82EB18D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB18DC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18E0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB18E4: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EB18E8: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB18EC: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB18F0: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EB18F4: 40980034  bge cr6, 0x82eb1928
	if !ctx.cr[6].lt {
	pc = 0x82EB1928; continue 'dispatch;
	}
	// 82EB18F8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EB18FC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1900: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82EB1904: 41980010  blt cr6, 0x82eb1914
	if ctx.cr[6].lt {
	pc = 0x82EB1914; continue 'dispatch;
	}
	// 82EB1908: FF00C000  fcmpu cr6, f0, f24
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[24].f64);
	// 82EB190C: 41990008  bgt cr6, 0x82eb1914
	if ctx.cr[6].gt {
	pc = 0x82EB1914; continue 'dispatch;
	}
	// 82EB1910: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EB1914: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EB1918: 409AFFE8  bne cr6, 0x82eb1900
	if !ctx.cr[6].eq {
	pc = 0x82EB1900; continue 'dispatch;
	}
	// 82EB191C: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1920: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1924: 48000214  b 0x82eb1b38
	pc = 0x82EB1B38; continue 'dispatch;
	// 82EB1928: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82EB192C: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1930: 4099000C  ble cr6, 0x82eb193c
	if !ctx.cr[6].gt {
	pc = 0x82EB193C; continue 'dispatch;
	}
	// 82EB1934: D30B0008  stfs f24, 8(r11)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1938: 48000200  b 0x82eb1b38
	pc = 0x82EB1B38; continue 'dispatch;
	// 82EB193C: D2EB0008  stfs f23, 8(r11)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1940: 480001F8  b 0x82eb1b38
	pc = 0x82EB1B38; continue 'dispatch;
	// 82EB1944: 815F0160  lwz r10, 0x160(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB1948: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB194C: 419A02A8  beq cr6, 0x82eb1bf4
	if ctx.cr[6].eq {
	pc = 0x82EB1BF4; continue 'dispatch;
	}
	// 82EB1950: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1954: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB1958: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB195C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EB1960: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1964: D3210054  stfs f25, 0x54(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1968: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB196C: 4B3CD8FD  bl 0x8227f268
	ctx.lr = 0x82EB1970;
	crate::recompiler::externs::call(&mut ctx, base, 0x8227F268);
	// 82EB1970: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1974: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1978: C3E30008  lfs f31, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB197C: C3C30000  lfs f30, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB1980: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1984: C1AB0050  lfs f13, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1988: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB198C: C1AB0054  lfs f13, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1990: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1994: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB1998: EC2C07BA  fmadds f1, f12, f30, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB199C: FF01C000  fcmpu cr6, f1, f24
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[24].f64);
	// 82EB19A0: 4198000C  blt cr6, 0x82eb19ac
	if ctx.cr[6].lt {
	pc = 0x82EB19AC; continue 'dispatch;
	}
	// 82EB19A4: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	// 82EB19A8: 48000020  b 0x82eb19c8
	pc = 0x82EB19C8; continue 'dispatch;
	// 82EB19AC: FF01B800  fcmpu cr6, f1, f23
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[23].f64);
	// 82EB19B0: 41990010  bgt cr6, 0x82eb19c0
	if ctx.cr[6].gt {
	pc = 0x82EB19C0; continue 'dispatch;
	}
	// 82EB19B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB19B8: C00BA3A4  lfs f0, -0x5c5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB19BC: 4800000C  b 0x82eb19c8
	pc = 0x82EB19C8; continue 'dispatch;
	// 82EB19C0: 4B3AEF81  bl 0x82260940
	ctx.lr = 0x82EB19C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82260940);
	// 82EB19C4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB19C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB19CC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB19D0: C1AB004C  lfs f13, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB19D4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB19D8: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB19DC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB19E0: EDAC6FB8  fmsubs f13, f12, f30, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB19E4: FF0DC800  fcmpu cr6, f13, f25
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[25].f64);
	// 82EB19E8: C1ABDF1C  lfs f13, -0x20e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB19EC: 4099000C  ble cr6, 0x82eb19f8
	if !ctx.cr[6].gt {
	pc = 0x82EB19F8; continue 'dispatch;
	}
	// 82EB19F0: EFC06824  fdivs f30, f0, f13
	ctx.f[30].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EB19F4: 4800000C  b 0x82eb1a00
	pc = 0x82EB1A00; continue 'dispatch;
	// 82EB19F8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EB19FC: FFC00050  fneg f30, f0
	ctx.f[30].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB1A00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1A04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB1A08: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB1A0C: FF60F210  fabs f27, f30
	ctx.f[27].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82EB1A10: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1A14: C3AA0A44  lfs f29, 0xa44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2628 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB1A18: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EB1A1C: C3E989CC  lfs f31, -0x7634(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB1A20: C0030044  lfs f0, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1A24: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EB1A28: C38A89C8  lfs f28, -0x7638(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EB1A2C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EB1A30: 4099000C  ble cr6, 0x82eb1a3c
	if !ctx.cr[6].gt {
	pc = 0x82EB1A3C; continue 'dispatch;
	}
	// 82EB1A34: EF40F828  fsubs f26, f0, f31
	ctx.f[26].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EB1A38: 48000018  b 0x82eb1a50
	pc = 0x82EB1A50; continue 'dispatch;
	// 82EB1A3C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EB1A40: 4098000C  bge cr6, 0x82eb1a4c
	if !ctx.cr[6].lt {
	pc = 0x82EB1A4C; continue 'dispatch;
	}
	// 82EB1A44: EF40F82A  fadds f26, f0, f31
	ctx.f[26].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB1A48: 48000008  b 0x82eb1a50
	pc = 0x82EB1A50; continue 'dispatch;
	// 82EB1A4C: FF400090  fmr f26, f0
	ctx.f[26].f64 = ctx.f[0].f64;
	// 82EB1A50: 895D001C  lbz r10, 0x1c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EB1A54: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1A58: 41820058  beq 0x82eb1ab0
	if ctx.cr[0].eq {
	pc = 0x82EB1AB0; continue 'dispatch;
	}
	// 82EB1A5C: 895F0069  lbz r10, 0x69(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(105 as u32) ) } as u64;
	// 82EB1A60: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1A64: 4182004C  beq 0x82eb1ab0
	if ctx.cr[0].eq {
	pc = 0x82EB1AB0; continue 'dispatch;
	}
	// 82EB1A68: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB1A6C: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB1A70: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB1A74: 388AC904  addi r4, r10, -0x36fc
	ctx.r[4].s64 = ctx.r[10].s64 + -14076;
	// 82EB1A78: 4BFCBC49  bl 0x82e7d6c0
	ctx.lr = 0x82EB1A7C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EB1A7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1A80: 4182003C  beq 0x82eb1abc
	if ctx.cr[0].eq {
	pc = 0x82EB1ABC; continue 'dispatch;
	}
	// 82EB1A84: C01D0014  lfs f0, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1A88: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EB1A8C: 4099000C  ble cr6, 0x82eb1a98
	if !ctx.cr[6].gt {
	pc = 0x82EB1A98; continue 'dispatch;
	}
	// 82EB1A90: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EB1A94: 48000010  b 0x82eb1aa4
	pc = 0x82EB1AA4; continue 'dispatch;
	// 82EB1A98: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EB1A9C: 40980008  bge cr6, 0x82eb1aa4
	if !ctx.cr[6].lt {
	pc = 0x82EB1AA4; continue 'dispatch;
	}
	// 82EB1AA0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB1AA4: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB1AA8: 9BC30004  stb r30, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1AAC: 48000010  b 0x82eb1abc
	pc = 0x82EB1ABC; continue 'dispatch;
	// 82EB1AB0: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1AB4: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EB1AB8: 40980010  bge cr6, 0x82eb1ac8
	if !ctx.cr[6].lt {
	pc = 0x82EB1AC8; continue 'dispatch;
	}
	// 82EB1ABC: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB1AC0: D34B0008  stfs f26, 8(r11)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1AC4: 4BFFFE5C  b 0x82eb1920
	pc = 0x82EB1920; continue 'dispatch;
	// 82EB1AC8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1ACC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB1AD0: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EB1AD4: 4B336BA5  bl 0x821e8678
	ctx.lr = 0x82EB1AD8;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EB1AD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1ADC: 40820018  bne 0x82eb1af4
	if !ctx.cr[0].eq {
	pc = 0x82EB1AF4; continue 'dispatch;
	}
	// 82EB1AE0: C01F0050  lfs f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1AE4: EC00D824  fdivs f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[27].f64) as f32) as f64;
	// 82EB1AE8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1AEC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1AF0: 48000014  b 0x82eb1b04
	pc = 0x82EB1B04; continue 'dispatch;
	// 82EB1AF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1AF8: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1AFC: C00B0BF8  lfs f0, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B00: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1B04: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB1B08: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1B0C: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB1B10: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B14: FF1EC800  fcmpu cr6, f30, f25
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[25].f64);
	// 82EB1B18: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1B1C: C1AA0044  lfs f13, 0x44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1B20: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1B24: 4099000C  ble cr6, 0x82eb1b30
	if !ctx.cr[6].gt {
	pc = 0x82EB1B30; continue 'dispatch;
	}
	// 82EB1B28: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB1B2C: 48000008  b 0x82eb1b34
	pc = 0x82EB1B34; continue 'dispatch;
	// 82EB1B30: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB1B34: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B38: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB1B3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1B40: 41820040  beq 0x82eb1b80
	if ctx.cr[0].eq {
	pc = 0x82EB1B80; continue 'dispatch;
	}
	// 82EB1B44: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1B48: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B4C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1B50: C1AA0058  lfs f13, 0x58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1B54: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1B58: 4099000C  ble cr6, 0x82eb1b64
	if !ctx.cr[6].gt {
	pc = 0x82EB1B64; continue 'dispatch;
	}
	// 82EB1B5C: D30B0008  stfs f24, 8(r11)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B60: 48000034  b 0x82eb1b94
	pc = 0x82EB1B94; continue 'dispatch;
	// 82EB1B64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB1B68: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1B6C: 4098000C  bge cr6, 0x82eb1b78
	if !ctx.cr[6].lt {
	pc = 0x82EB1B78; continue 'dispatch;
	}
	// 82EB1B70: D2EB0008  stfs f23, 8(r11)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B74: 48000024  b 0x82eb1b98
	pc = 0x82EB1B98; continue 'dispatch;
	// 82EB1B78: D32B0008  stfs f25, 8(r11)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B7C: 4800001C  b 0x82eb1b98
	pc = 0x82EB1B98; continue 'dispatch;
	// 82EB1B80: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB1B84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1B88: 4182006C  beq 0x82eb1bf4
	if ctx.cr[0].eq {
	pc = 0x82EB1BF4; continue 'dispatch;
	}
	// 82EB1B8C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1B90: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1B94: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1B98: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82EB1B9C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1BA0: 4182004C  beq 0x82eb1bec
	if ctx.cr[0].eq {
	pc = 0x82EB1BEC; continue 'dispatch;
	}
	// 82EB1BA4: 896B0004  lbz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1BA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1BAC: 41820040  beq 0x82eb1bec
	if ctx.cr[0].eq {
	pc = 0x82EB1BEC; continue 'dispatch;
	}
	// 82EB1BB0: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82EB1BB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1BB8: 4182003C  beq 0x82eb1bf4
	if ctx.cr[0].eq {
	pc = 0x82EB1BF4; continue 'dispatch;
	}
	// 82EB1BBC: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1BC0: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1BC4: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1BC8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1BCC: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1BD0: EC00C03C  fnmsubs f0, f0, f0, f24
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[24].f64) as f32) as f64);
	// 82EB1BD4: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB1BD8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1BDC: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82EB1BE0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB1BE4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1BE8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB1BEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB1BF0: 48000008  b 0x82eb1bf8
	pc = 0x82EB1BF8; continue 'dispatch;
	// 82EB1BF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB1BF8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB1BFC: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EB1C00: 4BDFC111  bl 0x82cadd10
	ctx.lr = 0x82EB1C04;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADD10);
	// 82EB1C04: 4BDF7858  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EB1C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB1C08 size=752
	// 82EB1C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1C0C: 4BDF77F5  bl 0x82ca9400
	ctx.lr = 0x82EB1C10;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EB1C10: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB1C14: 4BDFC091  bl 0x82cadca4
	ctx.lr = 0x82EB1C18;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCA4);
	// 82EB1C18: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1C1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB1C20: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB1C24: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB1C28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1C2C: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EB1C30: C17E0000  lfs f11, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1C34: C19D0000  lfs f12, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1C38: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB1C3C: C13E0004  lfs f9, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB1C40: C15D0004  lfs f10, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB1C44: ED4A4828  fsubs f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB1C48: C11D0008  lfs f8, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB1C4C: C13E0008  lfs f9, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB1C50: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB1C54: ED284828  fsubs f9, f8, f9
	ctx.f[9].f64 = (((ctx.f[8].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB1C58: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1C5C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1C60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1C64: ED0C02F2  fmuls f8, f12, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1C68: C30B0C18  lfs f24, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EB1C6C: ECEA0372  fmuls f7, f10, f13
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1C70: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1C74: EDA94378  fmsubs f13, f9, f13, f8
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB1C78: EC0C3838  fmsubs f0, f12, f0, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB1C7C: ED8A32F8  fmsubs f12, f10, f11, f6
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EB1C80: ED6D0372  fmuls f11, f13, f13
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1C84: ED60583A  fmadds f11, f0, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB1C88: ED6C5B3A  fmadds f11, f12, f12, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB1C8C: ED60582C  fsqrts f11, f11
	ctx.f[11].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 82EB1C90: FF0BC000  fcmpu cr6, f11, f24
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[24].f64);
	// 82EB1C94: 419A0244  beq cr6, 0x82eb1ed8
	if ctx.cr[6].eq {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1C98: 815F0158  lwz r10, 0x158(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB1C9C: C15F0060  lfs f10, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB1CA0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1CA4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB1CA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB1CAC: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EB1CB0: C12A0004  lfs f9, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB1CB4: ED695824  fdivs f11, f9, f11
	ctx.f[11].f64 = ((ctx.f[9].f64 / ctx.f[11].f64) as f32) as f64;
	// 82EB1CB8: 80690014  lwz r3, 0x14(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1CBC: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EB1CC0: EECC02F2  fmuls f22, f12, f11
	ctx.f[22].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1CC4: EEAD02F2  fmuls f21, f13, f11
	ctx.f[21].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1CC8: EE8002F2  fmuls f20, f0, f11
	ctx.f[20].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1CCC: 4B3369AD  bl 0x821e8678
	ctx.lr = 0x82EB1CD0;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EB1CD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB1CD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB1CD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1CDC: 3F608334  lis r27, -0x7ccc
	ctx.r[27].s64 = -2093744128;
	// 82EB1CE0: C1EA0C14  lfs f15, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 82EB1CE4: C22B0BFC  lfs f17, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82EB1CE8: 41820010  beq 0x82eb1cf8
	if ctx.cr[0].eq {
	pc = 0x82EB1CF8; continue 'dispatch;
	}
	// 82EB1CEC: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1CF0: EE600472  fmuls f19, f0, f17
	ctx.f[19].f64 = (((ctx.f[0].f64 * ctx.f[17].f64) as f32) as f64);
	// 82EB1CF4: 4800001C  b 0x82eb1d10
	pc = 0x82EB1D10; continue 'dispatch;
	// 82EB1CF8: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB1CFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1D00: 4182000C  beq 0x82eb1d0c
	if ctx.cr[0].eq {
	pc = 0x82EB1D0C; continue 'dispatch;
	}
	// 82EB1D04: C26B000C  lfs f19, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82EB1D08: 48000008  b 0x82eb1d10
	pc = 0x82EB1D10; continue 'dispatch;
	// 82EB1D0C: FE607890  fmr f19, f15
	ctx.f[19].f64 = ctx.f[15].f64;
	// 82EB1D10: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82EB1D14: C25F0058  lfs f18, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82EB1D18: D3010050  stfs f24, 0x50(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1D1C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB1D20: D3010054  stfs f24, 0x54(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1D24: D3010058  stfs f24, 0x58(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1D28: D3010060  stfs f24, 0x60(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1D2C: C20B84AC  lfs f16, -0x7b54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31572 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 82EB1D30: D3010064  stfs f24, 0x64(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB1D34: D3010068  stfs f24, 0x68(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1D38: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1D3C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82EB1D40: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D44: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB1D48: 409A002C  bne cr6, 0x82eb1d74
	if !ctx.cr[6].eq {
	pc = 0x82EB1D74; continue 'dispatch;
	}
	// 82EB1D4C: EFC0B02A  fadds f30, f0, f22
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[22].f64) as f32) as f64;
	// 82EB1D50: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1D54: EFB5682A  fadds f29, f21, f13
	ctx.f[29].f64 = ((ctx.f[21].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB1D58: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D5C: EF80A02A  fadds f28, f0, f20
	ctx.f[28].f64 = ((ctx.f[0].f64 + ctx.f[20].f64) as f32) as f64;
	// 82EB1D60: EC16682A  fadds f0, f22, f13
	ctx.f[0].f64 = ((ctx.f[22].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB1D64: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D68: ED8CA82A  fadds f12, f12, f21
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[21].f64) as f32) as f64;
	// 82EB1D6C: EDB4682A  fadds f13, f20, f13
	ctx.f[13].f64 = ((ctx.f[20].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB1D70: 48000028  b 0x82eb1d98
	pc = 0x82EB1D98; continue 'dispatch;
	// 82EB1D74: EFC0B028  fsubs f30, f0, f22
	ctx.f[30].f64 = (((ctx.f[0].f64 - ctx.f[22].f64) as f32) as f64);
	// 82EB1D78: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1D7C: EFADA828  fsubs f29, f13, f21
	ctx.f[29].f64 = (((ctx.f[13].f64 - ctx.f[21].f64) as f32) as f64);
	// 82EB1D80: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D84: EF80A028  fsubs f28, f0, f20
	ctx.f[28].f64 = (((ctx.f[0].f64 - ctx.f[20].f64) as f32) as f64);
	// 82EB1D88: EC0DB028  fsubs f0, f13, f22
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[22].f64) as f32) as f64);
	// 82EB1D8C: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB1D90: ED8CA828  fsubs f12, f12, f21
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[21].f64) as f32) as f64);
	// 82EB1D94: EDADA028  fsubs f13, f13, f20
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[20].f64) as f32) as f64);
	// 82EB1D98: ED8CE828  fsubs f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EB1D9C: ED60F028  fsubs f11, f0, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82EB1DA0: EDADE028  fsubs f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EB1DA4: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB1DA8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB1DAC: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB1DB0: EEE0002C  fsqrts f23, f0
	ctx.f[23].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB1DB4: FF17C000  fcmpu cr6, f23, f24
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[24].f64);
	// 82EB1DB8: 419A0120  beq cr6, 0x82eb1ed8
	if ctx.cr[6].eq {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1DBC: EC0FB824  fdivs f0, f15, f23
	ctx.f[0].f64 = ((ctx.f[15].f64 / ctx.f[23].f64) as f32) as f64;
	// 82EB1DC0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB1DC4: FFE0C090  fmr f31, f24
	ctx.f[31].f64 = ctx.f[24].f64;
	// 82EB1DC8: EF6002F2  fmuls f27, f0, f11
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB1DCC: EF400332  fmuls f26, f0, f12
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB1DD0: EF200372  fmuls f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB1DD4: FF1FB800  fcmpu cr6, f31, f23
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[23].f64);
	// 82EB1DD8: 41990100  bgt cr6, 0x82eb1ed8
	if ctx.cr[6].gt {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1DDC: EDBA07F2  fmuls f13, f26, f31
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB1DE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1DE4: EC1B07F2  fmuls f0, f27, f31
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB1DE8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB1DEC: ED72982A  fadds f11, f18, f19
	ctx.f[11].f64 = ((ctx.f[18].f64 + ctx.f[19].f64) as f32) as f64;
	// 82EB1DF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB1DF4: ED9907F2  fmuls f12, f25, f31
	ctx.f[12].f64 = (((ctx.f[25].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB1DF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EB1DFC: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 82EB1E00: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1E04: EDADE82A  fadds f13, f13, f29
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EB1E08: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1E0C: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EB1E10: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1E14: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1E18: ED8CE02A  fadds f12, f12, f28
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EB1E1C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1E20: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1E24: EC0D5828  fsubs f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB1E28: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB1E2C: 4B77D6E5  bl 0x8262f510
	ctx.lr = 0x82EB1E30;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262F510);
	// 82EB1E30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1E34: 418200B8  beq 0x82eb1eec
	if ctx.cr[0].eq {
	pc = 0x82EB1EEC; continue 'dispatch;
	}
	// 82EB1E38: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB1E3C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB1E40: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB1E44: 4182000C  beq 0x82eb1e50
	if ctx.cr[0].eq {
	pc = 0x82EB1E50; continue 'dispatch;
	}
	// 82EB1E48: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB1E4C: 48000008  b 0x82eb1e54
	pc = 0x82EB1E54; continue 'dispatch;
	// 82EB1E50: FC007890  fmr f0, f15
	ctx.f[0].f64 = ctx.f[15].f64;
	// 82EB1E54: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB1E58: 2B1C0002  cmplwi cr6, r28, 2
	ctx.cr[6].compare_u32(ctx.r[28].u32, 2 as u32, &mut ctx.xer);
	// 82EB1E5C: 4198FF78  blt cr6, 0x82eb1dd4
	if ctx.cr[6].lt {
	pc = 0x82EB1DD4; continue 'dispatch;
	}
	// 82EB1E60: FF1FB800  fcmpu cr6, f31, f23
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[23].f64);
	// 82EB1E64: 41990074  bgt cr6, 0x82eb1ed8
	if ctx.cr[6].gt {
	pc = 0x82EB1ED8; continue 'dispatch;
	}
	// 82EB1E68: EC17F828  fsubs f0, f23, f31
	ctx.f[0].f64 = (((ctx.f[23].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EB1E6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1E70: ED529C3A  fmadds f10, f18, f16, f19
	ctx.f[10].f64 = (((ctx.f[18].f64 * ctx.f[16].f64 + ctx.f[19].f64) as f32) as f64);
	// 82EB1E74: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB1E78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB1E7C: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 82EB1E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EB1E84: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB1E88: EC00FC7A  fmadds f0, f0, f17, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[17].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EB1E8C: EDBB0032  fmuls f13, f27, f0
	ctx.f[13].f64 = (((ctx.f[27].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1E90: ED9A0032  fmuls f12, f26, f0
	ctx.f[12].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1E94: ED790032  fmuls f11, f25, f0
	ctx.f[11].f64 = (((ctx.f[25].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB1E98: EC0DF02A  fadds f0, f13, f30
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EB1E9C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB1EA0: EDACE82A  fadds f13, f12, f29
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EB1EA4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB1EA8: ED8BE02A  fadds f12, f11, f28
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EB1EAC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB1EB0: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB1EB4: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB1EB8: EC0D5028  fsubs f0, f13, f10
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB1EBC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB1EC0: 4B77D651  bl 0x8262f510
	ctx.lr = 0x82EB1EC4;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262F510);
	// 82EB1EC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1EC8: 41820024  beq 0x82eb1eec
	if ctx.cr[0].eq {
	pc = 0x82EB1EEC; continue 'dispatch;
	}
	// 82EB1ECC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EB1ED0: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 82EB1ED4: 4198FE64  blt cr6, 0x82eb1d38
	if ctx.cr[6].lt {
	pc = 0x82EB1D38; continue 'dispatch;
	}
	// 82EB1ED8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB1EDC: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82EB1EE0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EB1EE4: 4BDFBE0D  bl 0x82cadcf0
	ctx.lr = 0x82EB1EE8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCF0);
	// 82EB1EE8: 4BDF7568  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
	// 82EB1EEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB1EF0: 4BFFFFEC  b 0x82eb1edc
	pc = 0x82EB1EDC; continue 'dispatch;
}

pub fn sub_82EB1EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1EF8 size=112
	// 82EB1EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1F00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1F04: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB1F08: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82EB1F0C: 8124006C  lwz r9, 0x6c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB1F10: 81030060  lwz r8, 0x60(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB1F14: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB1F18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1F1C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82EB1F20: 7C8B5396  divwu r4, r11, r10
	ctx.r[4].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EB1F24: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB1F28: 4098002C  bge cr6, 0x82eb1f54
	if !ctx.cr[6].lt {
	pc = 0x82EB1F54; continue 'dispatch;
	}
	// 82EB1F2C: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB1F30: 5489103A  slwi r9, r4, 2
	// 82EB1F34: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB1F38: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EB1F3C: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82EB1F40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB1F44: 80630064  lwz r3, 0x64(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB1F48: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82EB1F4C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EB1F50: 4BFD71A9  bl 0x82e890f8
	ctx.lr = 0x82EB1F54;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E890F8);
	// 82EB1F54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB1F58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB1F5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB1F60: 4E800020  blr
	return;
}

pub fn sub_82EB1F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1F68 size=88
	// 82EB1F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1F70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB1F74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB1F78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB1F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB1F80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB1F84: 4BFFF64D  bl 0x82eb15d0
	ctx.lr = 0x82EB1F88;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB15D0);
	// 82EB1F88: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB1F8C: 41820018  beq 0x82eb1fa4
	if ctx.cr[0].eq {
	pc = 0x82EB1FA4; continue 'dispatch;
	}
	// 82EB1F90: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB1F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1F98: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB1F9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB1FA0: 4E800421  bctrl
	ctx.lr = 0x82EB1FA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB1FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB1FA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB1FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB1FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB1FB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB1FB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB1FBC: 4E800020  blr
	return;
}

pub fn sub_82EB1FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB1FC0 size=20
	// 82EB1FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB1FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB1FC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB1FCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB1FD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB21B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB21B0 size=152
	// 82EB21B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB21B4: 4BDF7255  bl 0x82ca9408
	ctx.lr = 0x82EB21B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EB21B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB21BC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB21C0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EB21C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB21C8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EB21CC: 4BFFFDF5  bl 0x82eb1fc0
	ctx.lr = 0x82EB21D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB1FC0);
	// 82EB21D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB21D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB21D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB21DC: 4BFFFDE5  bl 0x82eb1fc0
	ctx.lr = 0x82EB21E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB1FC0);
	// 82EB21E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB21E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB21E8: 419A0048  beq cr6, 0x82eb2230
	if ctx.cr[6].eq {
	pc = 0x82EB2230; continue 'dispatch;
	}
	// 82EB21EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB21F0: 419A0040  beq cr6, 0x82eb2230
	if ctx.cr[6].eq {
	pc = 0x82EB2230; continue 'dispatch;
	}
	// 82EB21F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB21F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB21FC: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB2200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2204: 4E800421  bctrl
	ctx.lr = 0x82EB2208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2208: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB220C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB2210: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB2214: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB2218: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB221C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2220: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2224: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2228: 4E800421  bctrl
	ctx.lr = 0x82EB222C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB222C: 48000008  b 0x82eb2234
	pc = 0x82EB2234; continue 'dispatch;
	// 82EB2230: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB2234: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB2238: 4BDF7220  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EB2248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB2248 size=856
	// 82EB2248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB224C: 4BDF71B1  bl 0x82ca93fc
	ctx.lr = 0x82EB2250;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93FC);
	// 82EB2250: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB2258: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB225C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB2260: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EB2264: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB2268: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB226C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EB2270: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EB2274: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82EB2278: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EB227C: 81670014  lwz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2280: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB2284: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB2288: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB228C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EB2290: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2294: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EB2298: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB229C: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EB22A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB22A4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB22A8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB22AC: 4200FFF8  bdnz 0x82eb22a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB22A4; continue 'dispatch;
	}
	// 82EB22B0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EB22B4: 9B4100C8  stb r26, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u8 ) };
	// 82EB22B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB22BC: 4BFFFD05  bl 0x82eb1fc0
	ctx.lr = 0x82EB22C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB1FC0);
	// 82EB22C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB22C4: 895F0068  lbz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB22C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB22CC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB22D0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82EB22D4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EB22D8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB22DC: 409A0060  bne cr6, 0x82eb233c
	if !ctx.cr[6].eq {
	pc = 0x82EB233C; continue 'dispatch;
	}
	// 82EB22E0: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB22E4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB22E8: 409A0054  bne cr6, 0x82eb233c
	if !ctx.cr[6].eq {
	pc = 0x82EB233C; continue 'dispatch;
	}
	// 82EB22EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB22F0: 419A0068  beq cr6, 0x82eb2358
	if ctx.cr[6].eq {
	pc = 0x82EB2358; continue 'dispatch;
	}
	// 82EB22F4: C01F00EC  lfs f0, 0xec(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB22F8: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB22FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB2300: 409A0028  bne cr6, 0x82eb2328
	if !ctx.cr[6].eq {
	pc = 0x82EB2328; continue 'dispatch;
	}
	// 82EB2304: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2308: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB230C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB2310: 409A0018  bne cr6, 0x82eb2328
	if !ctx.cr[6].eq {
	pc = 0x82EB2328; continue 'dispatch;
	}
	// 82EB2314: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2318: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EB231C: C1BF00F4  lfs f13, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB2320: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB2324: 419A0008  beq cr6, 0x82eb232c
	if ctx.cr[6].eq {
	pc = 0x82EB232C; continue 'dispatch;
	}
	// 82EB2328: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82EB232C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2330: 4182000C  beq 0x82eb233c
	if ctx.cr[0].eq {
	pc = 0x82EB233C; continue 'dispatch;
	}
	// 82EB2334: 807F0138  lwz r3, 0x138(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2338: 48000018  b 0x82eb2350
	pc = 0x82EB2350; continue 'dispatch;
	// 82EB233C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB2340: 419A0018  beq cr6, 0x82eb2358
	if ctx.cr[6].eq {
	pc = 0x82EB2358; continue 'dispatch;
	}
	// 82EB2344: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB2348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB234C: 4BFFFC75  bl 0x82eb1fc0
	ctx.lr = 0x82EB2350;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB1FC0);
	// 82EB2350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB2354: 409A0020  bne cr6, 0x82eb2374
	if !ctx.cr[6].eq {
	pc = 0x82EB2374; continue 'dispatch;
	}
	// 82EB2358: 817F00A0  lwz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB235C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB2360: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2364: 389F00E0  addi r4, r31, 0xe0
	ctx.r[4].s64 = ctx.r[31].s64 + 224;
	// 82EB2368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB236C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2370: 4E800421  bctrl
	ctx.lr = 0x82EB2374;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2374: 897F00BF  lbz r11, 0xbf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(191 as u32) ) } as u64;
	// 82EB2378: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB237C: 40820048  bne 0x82eb23c4
	if !ctx.cr[0].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB2380: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2384: 41820010  beq 0x82eb2394
	if ctx.cr[0].eq {
	pc = 0x82EB2394; continue 'dispatch;
	}
	// 82EB2388: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB238C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB2390: 409A0034  bne cr6, 0x82eb23c4
	if !ctx.cr[6].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB2394: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2398: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB239C: 409A0028  bne cr6, 0x82eb23c4
	if !ctx.cr[6].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB23A0: 897F01B5  lbz r11, 0x1b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82EB23A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB23A8: 4082001C  bne 0x82eb23c4
	if !ctx.cr[0].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB23AC: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82EB23B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB23B4: 40820010  bne 0x82eb23c4
	if !ctx.cr[0].eq {
	pc = 0x82EB23C4; continue 'dispatch;
	}
	// 82EB23B8: 9B5B0000  stb r26, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82EB23BC: 887F00BD  lbz r3, 0xbd(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82EB23C0: 480001D8  b 0x82eb2598
	pc = 0x82EB2598; continue 'dispatch;
	// 82EB23C4: 9B3B0000  stb r25, 0(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82EB23C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB23CC: 93BF0134  stw r29, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[29].u32 ) };
	// 82EB23D0: 907F0138  stw r3, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[3].u32 ) };
	// 82EB23D4: 419A01BC  beq cr6, 0x82eb2590
	if ctx.cr[6].eq {
	pc = 0x82EB2590; continue 'dispatch;
	}
	// 82EB23D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB23DC: 419A01B4  beq cr6, 0x82eb2590
	if ctx.cr[6].eq {
	pc = 0x82EB2590; continue 'dispatch;
	}
	// 82EB23E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB23E4: 3BDF0074  addi r30, r31, 0x74
	ctx.r[30].s64 = ctx.r[31].s64 + 116;
	// 82EB23E8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB23EC: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EB23F0: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82EB23F4: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EB23F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB23FC: 419A0058  beq cr6, 0x82eb2454
	if ctx.cr[6].eq {
	pc = 0x82EB2454; continue 'dispatch;
	}
	// 82EB2400: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2408: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB240C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2410: 4E800421  bctrl
	ctx.lr = 0x82EB2414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2418: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB241C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2420: 4E800421  bctrl
	ctx.lr = 0x82EB2424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2424: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2428: 396B52B8  addi r11, r11, 0x52b8
	ctx.r[11].s64 = ctx.r[11].s64 + 21176;
	// 82EB242C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB2430: 409A0024  bne cr6, 0x82eb2454
	if !ctx.cr[6].eq {
	pc = 0x82EB2454; continue 'dispatch;
	}
	// 82EB2434: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2438: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB243C: 815F0134  lwz r10, 0x134(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB2440: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EB2444: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2448: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB244C: 4BFED4F5  bl 0x82e9f940
	ctx.lr = 0x82EB2450;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9F940);
	// 82EB2450: 48000148  b 0x82eb2598
	pc = 0x82EB2598; continue 'dispatch;
	// 82EB2454: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB245C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB2460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2464: 4E800421  bctrl
	ctx.lr = 0x82EB2468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2468: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB246C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB2470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2474: 916A0054  stw r11, 0x54(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB2478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB247C: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB2480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2484: 4E800421  bctrl
	ctx.lr = 0x82EB2488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2488: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB248C: 906B0058  stw r3, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EB2490: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB2494: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2498: 40820028  bne 0x82eb24c0
	if !ctx.cr[0].eq {
	pc = 0x82EB24C0; continue 'dispatch;
	}
	// 82EB249C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB24A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB24A4: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB24A8: 80BF0134  lwz r5, 0x134(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB24AC: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB24B0: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB24B4: 4BFF158D  bl 0x82ea3a40
	ctx.lr = 0x82EB24B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EA3A40);
	// 82EB24B8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EB24BC: 480000D8  b 0x82eb2594
	pc = 0x82EB2594; continue 'dispatch;
	// 82EB24C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB24C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB24C8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB24CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB24D0: 4E800421  bctrl
	ctx.lr = 0x82EB24D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB24D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB24D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB24DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB24E0: 4E800421  bctrl
	ctx.lr = 0x82EB24E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB24E4: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB24E8: 4B3AE4D1  bl 0x822609b8
	ctx.lr = 0x82EB24EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB24EC: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB24F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB24F4: 4BFCF025  bl 0x82e81518
	ctx.lr = 0x82EB24F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81518);
	// 82EB24F8: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82EB24FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB2500: C00B0A8C  lfs f0, 0xa8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2504: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EB2508: 40980008  bge cr6, 0x82eb2510
	if !ctx.cr[6].lt {
	pc = 0x82EB2510; continue 'dispatch;
	}
	// 82EB250C: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 82EB2510: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB2514: 1D5D0014  mulli r10, r29, 0x14
	ctx.r[10].s64 = ctx.r[29].s64 * 20;
	// 82EB2518: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB251C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2520: 9B5F00BF  stb r26, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[26].u8 ) };
	// 82EB2524: 80DF0138  lwz r6, 0x138(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB2528: 80BF0134  lwz r5, 0x134(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB252C: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB2530: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2534: 895F01B5  lbz r10, 0x1b5(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82EB2538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB253C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 82EB2540: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 82EB2544: 99410067  stb r10, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[10].u8 ) };
	// 82EB2548: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82EB254C: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB2550: 4BFF0D49  bl 0x82ea3298
	ctx.lr = 0x82EB2554;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EA3298);
	// 82EB2554: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EB2558: 4198003C  blt cr6, 0x82eb2594
	if ctx.cr[6].lt {
	pc = 0x82EB2594; continue 'dispatch;
	}
	// 82EB255C: 419A002C  beq cr6, 0x82eb2588
	if ctx.cr[6].eq {
	pc = 0x82EB2588; continue 'dispatch;
	}
	// 82EB2560: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82EB2564: 40980030  bge cr6, 0x82eb2594
	if !ctx.cr[6].lt {
	pc = 0x82EB2594; continue 'dispatch;
	}
	// 82EB2568: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB256C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EB2570: 9B3F00BF  stb r25, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[25].u8 ) };
	// 82EB2574: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2578: 4BFCF091  bl 0x82e81608
	ctx.lr = 0x82EB257C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81608);
	// 82EB257C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EB2580: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82EB2584: 4BFCF4C5  bl 0x82e81a48
	ctx.lr = 0x82EB2588;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81A48);
	// 82EB2588: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82EB258C: 48000008  b 0x82eb2594
	pc = 0x82EB2594; continue 'dispatch;
	// 82EB2590: 9B5F00BF  stb r26, 0xbf(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(191 as u32), ctx.r[26].u8 ) };
	// 82EB2594: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB2598: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82EB259C: 4BDF6EB0  b 0x82ca944c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA944C);
	return;
}

pub fn sub_82EB25A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB25A0 size=464
	// 82EB25A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB25A4: 4BDF6E65  bl 0x82ca9408
	ctx.lr = 0x82EB25A8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EB25A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB25AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB25B0: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB25B4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EB25B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB25BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB25C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB25C4: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB25CC: 409A0028  bne cr6, 0x82eb25f4
	if !ctx.cr[6].eq {
	pc = 0x82EB25F4; continue 'dispatch;
	}
	// 82EB25D0: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25D4: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB25D8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB25DC: 409A0018  bne cr6, 0x82eb25f4
	if !ctx.cr[6].eq {
	pc = 0x82EB25F4; continue 'dispatch;
	}
	// 82EB25E0: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB25E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB25E8: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25EC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EB25F0: 419A0008  beq cr6, 0x82eb25f8
	if ctx.cr[6].eq {
	pc = 0x82EB25F8; continue 'dispatch;
	}
	// 82EB25F4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EB25F8: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB25FC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB2600: 4182005C  beq 0x82eb265c
	if ctx.cr[0].eq {
	pc = 0x82EB265C; continue 'dispatch;
	}
	// 82EB2604: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB2608: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB260C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB2610: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82EB2614: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB2618: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB261C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EB2620: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EB2624: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB2628: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB262C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2630: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB2634: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB2638: 4200FFF8  bdnz 0x82eb2630
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB2630; continue 'dispatch;
	}
	// 82EB263C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB2640: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 82EB2644: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB2648: 4BFFF979  bl 0x82eb1fc0
	ctx.lr = 0x82EB264C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB1FC0);
	// 82EB264C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB2650: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB2654: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB2658: 48000030  b 0x82eb2688
	pc = 0x82EB2688; continue 'dispatch;
	// 82EB265C: D1A10054  stfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB2660: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB2664: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB2668: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB266C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB2670: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB2674: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB2678: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EB267C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB2680: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2684: 4E800421  bctrl
	ctx.lr = 0x82EB2688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2688: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB268C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB2690: 409A004C  bne cr6, 0x82eb26dc
	if !ctx.cr[6].eq {
	pc = 0x82EB26DC; continue 'dispatch;
	}
	// 82EB2694: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2698: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82EB269C: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82EB26A0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EB26A4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB26A8: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26AC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB26B0: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26B4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB26B8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26BC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB26C0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82EB26C4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB26C8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB26CC: 4200FFF8  bdnz 0x82eb26c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB26C4; continue 'dispatch;
	}
	// 82EB26D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB26D4: 9B9F0058  stb r28, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EB26D8: 48000090  b 0x82eb2768
	pc = 0x82EB2768; continue 'dispatch;
	// 82EB26DC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26E0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB26E4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB26E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB26EC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26F0: 388B60C0  addi r4, r11, 0x60c0
	ctx.r[4].s64 = ctx.r[11].s64 + 24768;
	// 82EB26F4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB26F8: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB26FC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB2700: 9B9F0058  stb r28, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EB2704: 4BFD6FDD  bl 0x82e896e0
	ctx.lr = 0x82EB2708;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EB2708: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EB270C: 41820018  beq 0x82eb2724
	if ctx.cr[0].eq {
	pc = 0x82EB2724; continue 'dispatch;
	}
	// 82EB2710: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB2714: 93C40004  stw r30, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EB2718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB271C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB2720: 4B2FBF89  bl 0x821ae6a8
	ctx.lr = 0x82EB2724;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB2724: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB2728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB272C: 388B20C0  addi r4, r11, 0x20c0
	ctx.r[4].s64 = ctx.r[11].s64 + 8384;
	// 82EB2730: 4BFD6FB1  bl 0x82e896e0
	ctx.lr = 0x82EB2734;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EB2734: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB2738: 4182002C  beq 0x82eb2764
	if ctx.cr[0].eq {
	pc = 0x82EB2764; continue 'dispatch;
	}
	// 82EB273C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB2740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB2744: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB2748: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB274C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB2750: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB2754: 4E800421  bctrl
	ctx.lr = 0x82EB2758;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB2758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB275C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2760: 4B2FBF49  bl 0x821ae6a8
	ctx.lr = 0x82EB2764;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB2764: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB2768: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EB276C: 4BDF6CEC  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EB2770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2770 size=120
	// 82EB2770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB277C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2780: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB2784: 816A86F8  lwz r11, -0x7908(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30984 as u32) ) } as u64;
	// 82EB2788: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB278C: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB2790: 3BE986B0  addi r31, r9, -0x7950
	ctx.r[31].s64 = ctx.r[9].s64 + -31056;
	// 82EB2794: 40820038  bne 0x82eb27cc
	if !ctx.cr[0].eq {
	pc = 0x82EB27CC; continue 'dispatch;
	}
	// 82EB2798: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EB279C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EB27A0: 8909DF21  lbz r8, -0x20df(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8415 as u32) ) } as u64;
	// 82EB27A4: 916A86F8  stw r11, -0x7908(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-30984 as u32), ctx.r[11].u32 ) };
	// 82EB27A8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB27AC: 4182000C  beq 0x82eb27b8
	if ctx.cr[0].eq {
	pc = 0x82EB27B8; continue 'dispatch;
	}
	// 82EB27B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB27B4: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EB27B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB27BC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EB27C0: 386A88F0  addi r3, r10, -0x7710
	ctx.r[3].s64 = ctx.r[10].s64 + -30480;
	// 82EB27C4: 9969DF21  stb r11, -0x20df(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8415 as u32), ctx.r[11].u8 ) };
	// 82EB27C8: 4BDF7759  bl 0x82ca9f20
	ctx.lr = 0x82EB27CC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EB27CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB27D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB27D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB27D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB27DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB27E0: 4E800020  blr
	return;
}

pub fn sub_82EB27E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB27E8 size=120
	// 82EB27E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB27EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB27F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB27F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB27F8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB27FC: 816A8748  lwz r11, -0x78b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30904 as u32) ) } as u64;
	// 82EB2800: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2804: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB2808: 3BE98700  addi r31, r9, -0x7900
	ctx.r[31].s64 = ctx.r[9].s64 + -30976;
	// 82EB280C: 40820038  bne 0x82eb2844
	if !ctx.cr[0].eq {
	pc = 0x82EB2844; continue 'dispatch;
	}
	// 82EB2810: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EB2814: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EB2818: 8909DF20  lbz r8, -0x20e0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8416 as u32) ) } as u64;
	// 82EB281C: 916A8748  stw r11, -0x78b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-30904 as u32), ctx.r[11].u32 ) };
	// 82EB2820: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2824: 4182000C  beq 0x82eb2830
	if ctx.cr[0].eq {
	pc = 0x82EB2830; continue 'dispatch;
	}
	// 82EB2828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB282C: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EB2830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2834: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EB2838: 386A88D8  addi r3, r10, -0x7728
	ctx.r[3].s64 = ctx.r[10].s64 + -30504;
	// 82EB283C: 9969DF20  stb r11, -0x20e0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8416 as u32), ctx.r[11].u8 ) };
	// 82EB2840: 4BDF76E1  bl 0x82ca9f20
	ctx.lr = 0x82EB2844;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EB2844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2848: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB284C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2854: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2858: 4E800020  blr
	return;
}

pub fn sub_82EB2860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2860 size=20
	// 82EB2860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB286C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB2920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2920 size=20
	// 82EB2920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2928: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB292C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2930: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB29E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB29E0 size=20
	// 82EB29E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB29E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB29E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB29EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB29F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB2AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2AA0 size=20
	// 82EB2AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB2B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2B60 size=20
	// 82EB2B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2B68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2B6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2B70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB2C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2C20 size=20
	// 82EB2C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2C28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2C2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2C30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB2CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2CE0 size=20
	// 82EB2CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2CE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB2CEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2CF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB2DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2DA0 size=120
	// 82EB2DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2DA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2DAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB2DB0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB2DB4: 816A8B54  lwz r11, -0x74ac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29868 as u32) ) } as u64;
	// 82EB2DB8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB2DBC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB2DC0: 3BE98750  addi r31, r9, -0x78b0
	ctx.r[31].s64 = ctx.r[9].s64 + -30896;
	// 82EB2DC4: 40820038  bne 0x82eb2dfc
	if !ctx.cr[0].eq {
	pc = 0x82EB2DFC; continue 'dispatch;
	}
	// 82EB2DC8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EB2DCC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EB2DD0: 8909DF22  lbz r8, -0x20de(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8414 as u32) ) } as u64;
	// 82EB2DD4: 916A8B54  stw r11, -0x74ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-29868 as u32), ctx.r[11].u32 ) };
	// 82EB2DD8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB2DDC: 4182000C  beq 0x82eb2de8
	if ctx.cr[0].eq {
	pc = 0x82EB2DE8; continue 'dispatch;
	}
	// 82EB2DE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2DE4: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EB2DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB2DEC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EB2DF0: 386A8908  addi r3, r10, -0x76f8
	ctx.r[3].s64 = ctx.r[10].s64 + -30456;
	// 82EB2DF4: 9969DF22  stb r11, -0x20de(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8414 as u32), ctx.r[11].u8 ) };
	// 82EB2DF8: 4BDF7129  bl 0x82ca9f20
	ctx.lr = 0x82EB2DFC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EB2DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB2E00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB2E04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB2E08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB2E0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB2E10: 4E800020  blr
	return;
}

pub fn sub_82EB2E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2E18 size=16
	// 82EB2E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB2E20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB2E24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB2EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB2EB8 size=20
	// 82EB2EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2EBC: 4BDF6551  bl 0x82ca940c
	ctx.lr = 0x82EB2EC0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB2EC0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EB2EC4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EB2EC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB2FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB2FF8 size=1848
	// 82EB2FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB2FFC: 4BDF6405  bl 0x82ca9400
	ctx.lr = 0x82EB3000;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EB3000: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82EB3004: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EB3008: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB300C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EB3010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB3014: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82EB3018: 419A0704  beq cr6, 0x82eb371c
	if ctx.cr[6].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB301C: 4BFD29D5  bl 0x82e859f0
	ctx.lr = 0x82EB3020;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E859F0);
	// 82EB3020: 83A30400  lwz r29, 0x400(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB3024: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82EB3028: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB302C: 40820010  bne 0x82eb303c
	if !ctx.cr[0].eq {
	pc = 0x82EB303C; continue 'dispatch;
	}
	// 82EB3030: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82EB3034: 4B437185  bl 0x822ea1b8
	ctx.lr = 0x82EB3038;
	crate::recompiler::externs::call(&mut ctx, base, 0x822EA1B8);
	// 82EB3038: 48000034  b 0x82eb306c
	pc = 0x82EB306C; continue 'dispatch;
	// 82EB303C: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 82EB3040: 616BCCCC  ori r11, r11, 0xcccc
	ctx.r[11].u64 = ctx.r[11].u64 | 52428;
	// 82EB3044: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB3048: 1D7D0014  mulli r11, r29, 0x14
	ctx.r[11].s64 = ctx.r[29].s64 * 20;
	// 82EB304C: 40990008  ble cr6, 0x82eb3054
	if !ctx.cr[6].gt {
	pc = 0x82EB3054; continue 'dispatch;
	}
	// 82EB3050: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EB3054: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EB3058: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EB305C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB3060: 40990008  ble cr6, 0x82eb3068
	if !ctx.cr[6].gt {
	pc = 0x82EB3068; continue 'dispatch;
	}
	// 82EB3064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB3068: 4B7638C1  bl 0x82616928
	ctx.lr = 0x82EB306C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EB306C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB3070: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB3078: C16A0A94  lfs f11, 0xa94(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2708 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB307C: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB3080: 419A0050  beq cr6, 0x82eb30d0
	if ctx.cr[6].eq {
	pc = 0x82EB30D0; continue 'dispatch;
	}
	// 82EB3084: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 82EB3088: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EB308C: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB3090: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB3094: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB3098: 41800040  blt 0x82eb30d8
	if ctx.cr[0].lt {
	pc = 0x82EB30D8; continue 'dispatch;
	}
	// 82EB309C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB30A0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB30A4: 3929A3A8  addi r9, r9, -0x5c58
	ctx.r[9].s64 = ctx.r[9].s64 + -23640;
	// 82EB30A8: C0080A8C  lfs f0, 0xa8c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB30AC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB30B0: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EB30B4: D3CB000C  stfs f30, 0xc(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB30B8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB30BC: D16B0010  stfs f11, 0x10(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB30C0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB30C4: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EB30C8: 4080FFE4  bge 0x82eb30ac
	if !ctx.cr[0].lt {
	pc = 0x82EB30AC; continue 'dispatch;
	}
	// 82EB30CC: 4800000C  b 0x82eb30d8
	pc = 0x82EB30D8; continue 'dispatch;
	// 82EB30D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB30D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB30D8: 3D4082EB  lis r10, -0x7d15
	ctx.r[10].s64 = -2098528256;
	// 82EB30DC: D3DF01C0  stfs f30, 0x1c0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82EB30E0: 3CA082EB  lis r5, -0x7d15
	ctx.r[5].s64 = -2098528256;
	// 82EB30E4: 909F01AC  stw r4, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[4].u32 ) };
	// 82EB30E8: 394A4370  addi r10, r10, 0x4370
	ctx.r[10].s64 = ctx.r[10].s64 + 17264;
	// 82EB30EC: 93BF00AC  stw r29, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[29].u32 ) };
	// 82EB30F0: 3CC082EB  lis r6, -0x7d15
	ctx.r[6].s64 = -2098528256;
	// 82EB30F4: 93DF01B8  stw r30, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[30].u32 ) };
	// 82EB30F8: 3CE082EA  lis r7, -0x7d16
	ctx.r[7].s64 = -2098593792;
	// 82EB30FC: 93DF01BC  stw r30, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[30].u32 ) };
	// 82EB3100: 3D0082EB  lis r8, -0x7d15
	ctx.r[8].s64 = -2098528256;
	// 82EB3104: 3D2082EB  lis r9, -0x7d15
	ctx.r[9].s64 = -2098528256;
	// 82EB3108: 3D6082EA  lis r11, -0x7d16
	ctx.r[11].s64 = -2098593792;
	// 82EB310C: 915F00A8  stw r10, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	// 82EB3110: 38A54270  addi r5, r5, 0x4270
	ctx.r[5].s64 = ctx.r[5].s64 + 17008;
	// 82EB3114: 396B63A8  addi r11, r11, 0x63a8
	ctx.r[11].s64 = ctx.r[11].s64 + 25512;
	// 82EB3118: 38C642E0  addi r6, r6, 0x42e0
	ctx.r[6].s64 = ctx.r[6].s64 + 17120;
	// 82EB311C: 38E763A8  addi r7, r7, 0x63a8
	ctx.r[7].s64 = ctx.r[7].s64 + 25512;
	// 82EB3120: 39084BA0  addi r8, r8, 0x4ba0
	ctx.r[8].s64 = ctx.r[8].s64 + 19360;
	// 82EB3124: 39294BA0  addi r9, r9, 0x4ba0
	ctx.r[9].s64 = ctx.r[9].s64 + 19360;
	// 82EB3128: 90BF009C  stw r5, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[5].u32 ) };
	// 82EB312C: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82EB3130: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EB3134: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB3138: 90DF00A0  stw r6, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[6].u32 ) };
	// 82EB313C: 90FF00A4  stw r7, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 82EB3140: 911F00B4  stw r8, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[8].u32 ) };
	// 82EB3144: 913F00B8  stw r9, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[9].u32 ) };
	// 82EB3148: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB314C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3150: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3154: 4182000C  beq 0x82eb3160
	if ctx.cr[0].eq {
	pc = 0x82EB3160; continue 'dispatch;
	}
	// 82EB3158: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB315C: 48000008  b 0x82eb3164
	pc = 0x82EB3164; continue 'dispatch;
	// 82EB3160: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB3164: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3168: C1AB0AC8  lfs f13, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB316C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB3170: D01F01C4  stfs f0, 0x1c4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB3174: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3178: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB317C: 4182000C  beq 0x82eb3188
	if ctx.cr[0].eq {
	pc = 0x82EB3188; continue 'dispatch;
	}
	// 82EB3180: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3184: 48000008  b 0x82eb318c
	pc = 0x82EB318C; continue 'dispatch;
	// 82EB3188: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB318C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3190: C18B0BFC  lfs f12, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB3194: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB3198: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB319C: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB31A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB31A4: 4182000C  beq 0x82eb31b0
	if ctx.cr[0].eq {
	pc = 0x82EB31B0; continue 'dispatch;
	}
	// 82EB31A8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB31AC: 48000008  b 0x82eb31b4
	pc = 0x82EB31B4; continue 'dispatch;
	// 82EB31B0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB31B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB31B8: C1AB0C84  lfs f13, 0xc84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB31BC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB31C0: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB31C4: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB31C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB31CC: 4182000C  beq 0x82eb31d8
	if ctx.cr[0].eq {
	pc = 0x82EB31D8; continue 'dispatch;
	}
	// 82EB31D0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB31D4: 48000008  b 0x82eb31dc
	pc = 0x82EB31DC; continue 'dispatch;
	// 82EB31D8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB31DC: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EB31E0: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB31E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB31E8: 4182000C  beq 0x82eb31f4
	if ctx.cr[0].eq {
	pc = 0x82EB31F4; continue 'dispatch;
	}
	// 82EB31EC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB31F0: 48000008  b 0x82eb31f8
	pc = 0x82EB31F8; continue 'dispatch;
	// 82EB31F4: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB31F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB31FC: C1ABBDF4  lfs f13, -0x420c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3200: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB3204: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EB3208: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB320C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3210: 4182000C  beq 0x82eb321c
	if ctx.cr[0].eq {
	pc = 0x82EB321C; continue 'dispatch;
	}
	// 82EB3214: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3218: 48000008  b 0x82eb3220
	pc = 0x82EB3220; continue 'dispatch;
	// 82EB321C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB3220: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EB3224: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3228: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB322C: 4182000C  beq 0x82eb3238
	if ctx.cr[0].eq {
	pc = 0x82EB3238; continue 'dispatch;
	}
	// 82EB3230: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3234: 48000008  b 0x82eb323c
	pc = 0x82EB323C; continue 'dispatch;
	// 82EB3238: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 82EB323C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3240: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EB3244: C00B0AA4  lfs f0, 0xaa4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3248: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB324C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB3250: 937F0054  stw r27, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82EB3254: D1BF004C  stfs f13, 0x4c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EB3258: C00BA500  lfs f0, -0x5b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB325C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB3260: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3264: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3268: 4182000C  beq 0x82eb3274
	if ctx.cr[0].eq {
	pc = 0x82EB3274; continue 'dispatch;
	}
	// 82EB326C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3270: 48000008  b 0x82eb3278
	pc = 0x82EB3278; continue 'dispatch;
	// 82EB3274: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB3278: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB327C: D3FF0060  stfs f31, 0x60(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB3280: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB3284: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3288: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB328C: 4182000C  beq 0x82eb3298
	if ctx.cr[0].eq {
	pc = 0x82EB3298; continue 'dispatch;
	}
	// 82EB3290: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3294: 48000008  b 0x82eb329c
	pc = 0x82EB329C; continue 'dispatch;
	// 82EB3298: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB329C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB32A0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB32A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB32A8: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB32AC: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EB32B0: D17F0064  stfs f11, 0x64(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB32B4: 9BBF0068  stb r29, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u8 ) };
	// 82EB32B8: 9BBF0069  stb r29, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[29].u8 ) };
	// 82EB32BC: 9B7F01B6  stb r27, 0x1b6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(438 as u32), ctx.r[27].u8 ) };
	// 82EB32C0: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB32C4: 4B3353B5  bl 0x821e8678
	ctx.lr = 0x82EB32C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EB32C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB32CC: 4182000C  beq 0x82eb32d8
	if ctx.cr[0].eq {
	pc = 0x82EB32D8; continue 'dispatch;
	}
	// 82EB32D0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB32D4: 48000028  b 0x82eb32fc
	pc = 0x82EB32FC; continue 'dispatch;
	// 82EB32D8: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB32DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB32E0: 4182000C  beq 0x82eb32ec
	if ctx.cr[0].eq {
	pc = 0x82EB32EC; continue 'dispatch;
	}
	// 82EB32E4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB32E8: 48000008  b 0x82eb32f0
	pc = 0x82EB32F0; continue 'dispatch;
	// 82EB32EC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EB32F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB32F4: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB32F8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB32FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3300: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB3304: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 82EB3308: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EB330C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3310: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB3314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3318: 4E800421  bctrl
	ctx.lr = 0x82EB331C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB331C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3320: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 82EB3324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3328: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB332C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3330: 4E800421  bctrl
	ctx.lr = 0x82EB3334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3334: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3338: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB333C: 388BDF68  addi r4, r11, -0x2098
	ctx.r[4].s64 = ctx.r[11].s64 + -8344;
	// 82EB3340: 4B3B48E1  bl 0x82267c20
	ctx.lr = 0x82EB3344;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EB3344: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3348: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB334C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB3350: 388BA4F4  addi r4, r11, -0x5b0c
	ctx.r[4].s64 = ctx.r[11].s64 + -23308;
	// 82EB3354: 915F017C  stw r10, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[10].u32 ) };
	// 82EB3358: 4BFD0BC1  bl 0x82e83f18
	ctx.lr = 0x82EB335C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E83F18);
	// 82EB335C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EB3360: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3364: 418200B0  beq 0x82eb3414
	if ctx.cr[0].eq {
	pc = 0x82EB3414; continue 'dispatch;
	}
	// 82EB3368: 4BA5A9A1  bl 0x8290dd08
	ctx.lr = 0x82EB336C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB336C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB3370: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB3374: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EB3378: 4BDF97D9  bl 0x82cacb50
	ctx.lr = 0x82EB337C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB337C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3380: 41820084  beq 0x82eb3404
	if ctx.cr[0].eq {
	pc = 0x82EB3404; continue 'dispatch;
	}
	// 82EB3384: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB338C: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EB3390: 4BDF97C1  bl 0x82cacb50
	ctx.lr = 0x82EB3394;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3394: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3398: 4182006C  beq 0x82eb3404
	if ctx.cr[0].eq {
	pc = 0x82EB3404; continue 'dispatch;
	}
	// 82EB339C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EB33A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33A4: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EB33A8: 4BDF97A9  bl 0x82cacb50
	ctx.lr = 0x82EB33AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB33AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33B0: 41820054  beq 0x82eb3404
	if ctx.cr[0].eq {
	pc = 0x82EB3404; continue 'dispatch;
	}
	// 82EB33B4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB33B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33BC: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EB33C0: 4BDF9791  bl 0x82cacb50
	ctx.lr = 0x82EB33C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB33C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33C8: 41820034  beq 0x82eb33fc
	if ctx.cr[0].eq {
	pc = 0x82EB33FC; continue 'dispatch;
	}
	// 82EB33CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB33D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33D4: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EB33D8: 4BDF9779  bl 0x82cacb50
	ctx.lr = 0x82EB33DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB33DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33E0: 4182001C  beq 0x82eb33fc
	if ctx.cr[0].eq {
	pc = 0x82EB33FC; continue 'dispatch;
	}
	// 82EB33E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB33E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB33EC: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EB33F0: 4BDF9761  bl 0x82cacb50
	ctx.lr = 0x82EB33F4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB33F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB33F8: 40820324  bne 0x82eb371c
	if !ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB33FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB3400: 48000008  b 0x82eb3408
	pc = 0x82EB3408; continue 'dispatch;
	// 82EB3404: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EB3408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EB340C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB3410: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB3414: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3418: 4182006C  beq 0x82eb3484
	if ctx.cr[0].eq {
	pc = 0x82EB3484; continue 'dispatch;
	}
	// 82EB341C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3420: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB3424: 388BA4DC  addi r4, r11, -0x5b24
	ctx.r[4].s64 = ctx.r[11].s64 + -23332;
	// 82EB3428: 4BFD0AF1  bl 0x82e83f18
	ctx.lr = 0x82EB342C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E83F18);
	// 82EB342C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3430: 41820030  beq 0x82eb3460
	if ctx.cr[0].eq {
	pc = 0x82EB3460; continue 'dispatch;
	}
	// 82EB3434: 4BA5A8D5  bl 0x8290dd08
	ctx.lr = 0x82EB3438;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3438: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB343C: 41820024  beq 0x82eb3460
	if ctx.cr[0].eq {
	pc = 0x82EB3460; continue 'dispatch;
	}
	// 82EB3440: 4BFFF9D9  bl 0x82eb2e18
	ctx.lr = 0x82EB3444;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2E18);
	// 82EB3444: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3448: 41820018  beq 0x82eb3460
	if ctx.cr[0].eq {
	pc = 0x82EB3460; continue 'dispatch;
	}
	// 82EB344C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB3450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3458: 4E800421  bctrl
	ctx.lr = 0x82EB345C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB345C: 48000024  b 0x82eb3480
	pc = 0x82EB3480; continue 'dispatch;
	// 82EB3460: 38600104  li r3, 0x104
	ctx.r[3].s64 = 260;
	// 82EB3464: 4B7634C5  bl 0x82616928
	ctx.lr = 0x82EB3468;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EB3468: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB346C: 41820010  beq 0x82eb347c
	if ctx.cr[0].eq {
	pc = 0x82EB347C; continue 'dispatch;
	}
	// 82EB3470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB3474: 4802C4B5  bl 0x82edf928
	ctx.lr = 0x82EB3478;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EDF928);
	// 82EB3478: 48000008  b 0x82eb3480
	pc = 0x82EB3480; continue 'dispatch;
	// 82EB347C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB3480: 907F01B0  stw r3, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB3484: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EB3488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB348C: 4BFD1F1D  bl 0x82e853a8
	ctx.lr = 0x82EB3490;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E853A8);
	// 82EB3490: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3494: 41820288  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3498: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB349C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34A4: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EB34A8: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB34AC: 4B3351CD  bl 0x821e8678
	ctx.lr = 0x82EB34B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EB34B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB34B4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34BC: 907F0158  stw r3, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[3].u32 ) };
	// 82EB34C0: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EB34C4: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB34C8: 4B3351B1  bl 0x821e8678
	ctx.lr = 0x82EB34CC;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EB34CC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB34D0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB34D4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34DC: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82EB34E0: 915F015C  stw r10, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[10].u32 ) };
	// 82EB34E4: 4BFCA1DD  bl 0x82e7d6c0
	ctx.lr = 0x82EB34E8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EB34E8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB34EC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB34F0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB34F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB34F8: 388BCB2C  addi r4, r11, -0x34d4
	ctx.r[4].s64 = ctx.r[11].s64 + -13524;
	// 82EB34FC: 915F0160  stw r10, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[10].u32 ) };
	// 82EB3500: 4BFCA1C1  bl 0x82e7d6c0
	ctx.lr = 0x82EB3504;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EB3504: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3508: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB350C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3510: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB3514: 388BCF7C  addi r4, r11, -0x3084
	ctx.r[4].s64 = ctx.r[11].s64 + -12420;
	// 82EB3518: 915F0164  stw r10, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[10].u32 ) };
	// 82EB351C: 4BFCA1A5  bl 0x82e7d6c0
	ctx.lr = 0x82EB3520;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EB3520: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3524: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB3528: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB352C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB3530: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82EB3534: 915F0168  stw r10, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[10].u32 ) };
	// 82EB3538: 4BFCA189  bl 0x82e7d6c0
	ctx.lr = 0x82EB353C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EB353C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3540: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB3544: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3548: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB354C: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 82EB3550: 915F016C  stw r10, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[10].u32 ) };
	// 82EB3554: 4BFCA16D  bl 0x82e7d6c0
	ctx.lr = 0x82EB3558;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EB3558: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB355C: 907F0170  stw r3, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[3].u32 ) };
	// 82EB3560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3564: 4182000C  beq 0x82eb3570
	if ctx.cr[0].eq {
	pc = 0x82EB3570; continue 'dispatch;
	}
	// 82EB3568: D3CB0008  stfs f30, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB356C: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB3570: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82EB3574: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3578: 4182000C  beq 0x82eb3584
	if ctx.cr[0].eq {
	pc = 0x82EB3584; continue 'dispatch;
	}
	// 82EB357C: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB3580: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB3584: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB3588: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB358C: 4182000C  beq 0x82eb3598
	if ctx.cr[0].eq {
	pc = 0x82EB3598; continue 'dispatch;
	}
	// 82EB3590: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB3594: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB3598: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB359C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB35A0: 4182000C  beq 0x82eb35ac
	if ctx.cr[0].eq {
	pc = 0x82EB35AC; continue 'dispatch;
	}
	// 82EB35A4: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB35A8: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB35AC: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82EB35B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB35B4: 4182000C  beq 0x82eb35c0
	if ctx.cr[0].eq {
	pc = 0x82EB35C0; continue 'dispatch;
	}
	// 82EB35B8: D3CB0008  stfs f30, 8(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB35BC: 9B6B0004  stb r27, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EB35C0: 4B3AD3F9  bl 0x822609b8
	ctx.lr = 0x82EB35C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB35C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB35C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB35CC: 388BA4B0  addi r4, r11, -0x5b50
	ctx.r[4].s64 = ctx.r[11].s64 + -23376;
	// 82EB35D0: 4BFCDC01  bl 0x82e811d0
	ctx.lr = 0x82EB35D4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E811D0);
	// 82EB35D4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB35D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB35DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB35E0: 388BA48C  addi r4, r11, -0x5b74
	ctx.r[4].s64 = ctx.r[11].s64 + -23412;
	// 82EB35E4: 915F0184  stw r10, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[10].u32 ) };
	// 82EB35E8: 4BFCDB81  bl 0x82e81168
	ctx.lr = 0x82EB35EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81168);
	// 82EB35EC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB35F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB35F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB35F8: 388BA464  addi r4, r11, -0x5b9c
	ctx.r[4].s64 = ctx.r[11].s64 + -23452;
	// 82EB35FC: 915F0180  stw r10, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[10].u32 ) };
	// 82EB3600: 4BFCDBD1  bl 0x82e811d0
	ctx.lr = 0x82EB3604;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E811D0);
	// 82EB3604: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3608: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB360C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB3610: 388BA444  addi r4, r11, -0x5bbc
	ctx.r[4].s64 = ctx.r[11].s64 + -23484;
	// 82EB3614: 915F0188  stw r10, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[10].u32 ) };
	// 82EB3618: 4BFCDBB9  bl 0x82e811d0
	ctx.lr = 0x82EB361C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E811D0);
	// 82EB361C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3620: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EB3624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3628: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB362C: 915F018C  stw r10, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[10].u32 ) };
	// 82EB3630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3634: 4E800421  bctrl
	ctx.lr = 0x82EB3638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3638: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB363C: 418200E0  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3640: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3648: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB364C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3650: 4E800421  bctrl
	ctx.lr = 0x82EB3654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3654: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3658: 418200C4  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB365C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3664: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB3668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB366C: 4E800421  bctrl
	ctx.lr = 0x82EB3670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3670: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3674: 418200A8  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB367C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3680: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB3684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3688: 4E800421  bctrl
	ctx.lr = 0x82EB368C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB368C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3690: 4182008C  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3694: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB3698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB369C: 409A0010  bne cr6, 0x82eb36ac
	if !ctx.cr[6].eq {
	pc = 0x82EB36AC; continue 'dispatch;
	}
	// 82EB36A0: 38800032  li r4, 0x32
	ctx.r[4].s64 = 50;
	// 82EB36A4: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB36A8: 4BFDF979  bl 0x82e93020
	ctx.lr = 0x82EB36AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E93020);
	// 82EB36AC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB36B0: 807C0718  lwz r3, 0x718(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB36B4: 388B5E98  addi r4, r11, 0x5e98
	ctx.r[4].s64 = ctx.r[11].s64 + 24216;
	// 82EB36B8: 4B3B4569  bl 0x82267c20
	ctx.lr = 0x82EB36BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EB36BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB36C0: 4182001C  beq 0x82eb36dc
	if ctx.cr[0].eq {
	pc = 0x82EB36DC; continue 'dispatch;
	}
	// 82EB36C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB36C8: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB36CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB36D0: 388B1130  addi r4, r11, 0x1130
	ctx.r[4].s64 = ctx.r[11].s64 + 4400;
	// 82EB36D4: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB36D8: 4BFE4CF1  bl 0x82e983c8
	ctx.lr = 0x82EB36DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E983C8);
	// 82EB36DC: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB36E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB36E4: 4182001C  beq 0x82eb3700
	if ctx.cr[0].eq {
	pc = 0x82EB3700; continue 'dispatch;
	}
	// 82EB36E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB36EC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB36F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB36F4: 4E800421  bctrl
	ctx.lr = 0x82EB36F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB36F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB36FC: 41820020  beq 0x82eb371c
	if ctx.cr[0].eq {
	pc = 0x82EB371C; continue 'dispatch;
	}
	// 82EB3700: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3708: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB370C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3710: 4E800421  bctrl
	ctx.lr = 0x82EB3714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3714: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3718: 48000008  b 0x82eb3720
	pc = 0x82EB3720; continue 'dispatch;
	// 82EB371C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB3720: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EB3724: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EB3728: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EB372C: 4BDF5D24  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
}

pub fn sub_82EB3730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB3730 size=3136
	// 82EB3730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB3734: 4BDF5CD9  bl 0x82ca940c
	ctx.lr = 0x82EB3738;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB3738: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EB373C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EB3740: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB3744: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EB3748: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB374C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EB3750: 409A000C  bne cr6, 0x82eb375c
	if !ctx.cr[6].eq {
	pc = 0x82EB375C; continue 'dispatch;
	}
	// 82EB3754: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB3758: 48000B00  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB375C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3764: 3BCB88AC  addi r30, r11, -0x7754
	ctx.r[30].s64 = ctx.r[11].s64 + -30548;
	// 82EB3768: 483088F9  bl 0x831bc060
	ctx.lr = 0x82EB376C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB376C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3770: 4BDF93E1  bl 0x82cacb50
	ctx.lr = 0x82EB3774;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3774: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB377C: 40820024  bne 0x82eb37a0
	if !ctx.cr[0].eq {
	pc = 0x82EB37A0; continue 'dispatch;
	}
	// 82EB3780: 4BA5A589  bl 0x8290dd08
	ctx.lr = 0x82EB3784;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3784: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3788: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EB378C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB3790: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB3794: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3798: 4E800421  bctrl
	ctx.lr = 0x82EB379C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB379C: 48000ABC  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB37A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB37A4: 3BCBA674  addi r30, r11, -0x598c
	ctx.r[30].s64 = ctx.r[11].s64 + -22924;
	// 82EB37A8: 483088B9  bl 0x831bc060
	ctx.lr = 0x82EB37AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB37AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB37B0: 4BDF93A1  bl 0x82cacb50
	ctx.lr = 0x82EB37B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB37B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB37B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB37BC: 40820048  bne 0x82eb3804
	if !ctx.cr[0].eq {
	pc = 0x82EB3804; continue 'dispatch;
	}
	// 82EB37C0: 4BA5A549  bl 0x8290dd08
	ctx.lr = 0x82EB37C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB37C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB37C8: 4182FF8C  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB37CC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB37D0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB37D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB37D8: 4182000C  beq 0x82eb37e4
	if ctx.cr[0].eq {
	pc = 0x82EB37E4; continue 'dispatch;
	}
	// 82EB37DC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB37E0: 4800000C  b 0x82eb37ec
	pc = 0x82EB37EC; continue 'dispatch;
	// 82EB37E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB37E8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB37EC: 4BDF83C5  bl 0x82cabbb0
	ctx.lr = 0x82EB37F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB37F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB37F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB37F8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB37FC: D01D0034  stfs f0, 0x34(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB3800: 48000A58  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3804: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3808: 3BCBA668  addi r30, r11, -0x5998
	ctx.r[30].s64 = ctx.r[11].s64 + -22936;
	// 82EB380C: 48308855  bl 0x831bc060
	ctx.lr = 0x82EB3810;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3810: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3814: 4BDF933D  bl 0x82cacb50
	ctx.lr = 0x82EB3818;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3818: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB381C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3820: 40820080  bne 0x82eb38a0
	if !ctx.cr[0].eq {
	pc = 0x82EB38A0; continue 'dispatch;
	}
	// 82EB3824: 4BA5A4E5  bl 0x8290dd08
	ctx.lr = 0x82EB3828;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3828: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB382C: 4182FF28  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3830: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82EB3834: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB3838: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB383C: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB3840: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3844: 4182000C  beq 0x82eb3850
	if ctx.cr[0].eq {
	pc = 0x82EB3850; continue 'dispatch;
	}
	// 82EB3848: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB384C: 48000008  b 0x82eb3854
	pc = 0x82EB3854; continue 'dispatch;
	// 82EB3850: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82EB3854: 4BDF835D  bl 0x82cabbb0
	ctx.lr = 0x82EB3858;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB3858: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB385C: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3860: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3864: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3868: 4182000C  beq 0x82eb3874
	if ctx.cr[0].eq {
	pc = 0x82EB3874; continue 'dispatch;
	}
	// 82EB386C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3870: 48000008  b 0x82eb3878
	pc = 0x82EB3878; continue 'dispatch;
	// 82EB3874: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 82EB3878: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB387C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB3880: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB3884: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3888: 816A0030  lwz r11, 0x30(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB388C: EC4D083A  fmadds f2, f13, f0, f1
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64);
	// 82EB3890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB3894: 4E800421  bctrl
	ctx.lr = 0x82EB3898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB3898: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB389C: 480009BC  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB38A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB38A4: 3BCBA65C  addi r30, r11, -0x59a4
	ctx.r[30].s64 = ctx.r[11].s64 + -22948;
	// 82EB38A8: 483087B9  bl 0x831bc060
	ctx.lr = 0x82EB38AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB38AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB38B0: 4BDF92A1  bl 0x82cacb50
	ctx.lr = 0x82EB38B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB38B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB38B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB38BC: 40820048  bne 0x82eb3904
	if !ctx.cr[0].eq {
	pc = 0x82EB3904; continue 'dispatch;
	}
	// 82EB38C0: 4BA5A449  bl 0x8290dd08
	ctx.lr = 0x82EB38C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB38C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB38C8: 4182FE8C  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB38CC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB38D0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB38D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB38D8: 4182000C  beq 0x82eb38e4
	if ctx.cr[0].eq {
	pc = 0x82EB38E4; continue 'dispatch;
	}
	// 82EB38DC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB38E0: 4800000C  b 0x82eb38ec
	pc = 0x82EB38EC; continue 'dispatch;
	// 82EB38E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB38E8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB38EC: 4BDF82C5  bl 0x82cabbb0
	ctx.lr = 0x82EB38F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB38F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB38F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB38F8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB38FC: D01D0038  stfs f0, 0x38(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB3900: 48000958  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3904: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3908: 3BCBA648  addi r30, r11, -0x59b8
	ctx.r[30].s64 = ctx.r[11].s64 + -22968;
	// 82EB390C: 48308755  bl 0x831bc060
	ctx.lr = 0x82EB3910;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3910: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3914: 4BDF923D  bl 0x82cacb50
	ctx.lr = 0x82EB3918;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3918: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB391C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3920: 40820048  bne 0x82eb3968
	if !ctx.cr[0].eq {
	pc = 0x82EB3968; continue 'dispatch;
	}
	// 82EB3924: 4BA5A3E5  bl 0x8290dd08
	ctx.lr = 0x82EB3928;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3928: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB392C: 4182FE28  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3930: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3934: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3938: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB393C: 4182000C  beq 0x82eb3948
	if ctx.cr[0].eq {
	pc = 0x82EB3948; continue 'dispatch;
	}
	// 82EB3940: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3944: 4800000C  b 0x82eb3950
	pc = 0x82EB3950; continue 'dispatch;
	// 82EB3948: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB394C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3950: 4BDF8261  bl 0x82cabbb0
	ctx.lr = 0x82EB3954;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB3954: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3958: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB395C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3960: D01D0040  stfs f0, 0x40(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EB3964: 480008F4  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3968: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB396C: 3BCBA638  addi r30, r11, -0x59c8
	ctx.r[30].s64 = ctx.r[11].s64 + -22984;
	// 82EB3970: 483086F1  bl 0x831bc060
	ctx.lr = 0x82EB3974;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3974: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3978: 4BDF91D9  bl 0x82cacb50
	ctx.lr = 0x82EB397C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB397C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3984: 40820048  bne 0x82eb39cc
	if !ctx.cr[0].eq {
	pc = 0x82EB39CC; continue 'dispatch;
	}
	// 82EB3988: 4BA5A381  bl 0x8290dd08
	ctx.lr = 0x82EB398C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB398C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3990: 4182FDC4  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3994: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3998: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB399C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB39A0: 4182000C  beq 0x82eb39ac
	if ctx.cr[0].eq {
	pc = 0x82EB39AC; continue 'dispatch;
	}
	// 82EB39A4: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB39A8: 4800000C  b 0x82eb39b4
	pc = 0x82EB39B4; continue 'dispatch;
	// 82EB39AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB39B0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB39B4: 4BDF81FD  bl 0x82cabbb0
	ctx.lr = 0x82EB39B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB39B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB39BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB39C0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB39C4: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EB39C8: 48000890  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB39CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB39D0: 3BCBA628  addi r30, r11, -0x59d8
	ctx.r[30].s64 = ctx.r[11].s64 + -23000;
	// 82EB39D4: 4830868D  bl 0x831bc060
	ctx.lr = 0x82EB39D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB39D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB39DC: 4BDF9175  bl 0x82cacb50
	ctx.lr = 0x82EB39E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB39E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB39E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB39E8: 40820048  bne 0x82eb3a30
	if !ctx.cr[0].eq {
	pc = 0x82EB3A30; continue 'dispatch;
	}
	// 82EB39EC: 4BA5A31D  bl 0x8290dd08
	ctx.lr = 0x82EB39F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB39F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB39F4: 4182FD60  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB39F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB39FC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3A00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3A04: 4182000C  beq 0x82eb3a10
	if ctx.cr[0].eq {
	pc = 0x82EB3A10; continue 'dispatch;
	}
	// 82EB3A08: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A0C: 4800000C  b 0x82eb3a18
	pc = 0x82EB3A18; continue 'dispatch;
	// 82EB3A10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3A14: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A18: 4BDF8199  bl 0x82cabbb0
	ctx.lr = 0x82EB3A1C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB3A1C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3A20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3A24: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3A28: D01D0044  stfs f0, 0x44(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EB3A2C: 4800082C  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3A30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3A34: 3BCBA618  addi r30, r11, -0x59e8
	ctx.r[30].s64 = ctx.r[11].s64 + -23016;
	// 82EB3A38: 48308629  bl 0x831bc060
	ctx.lr = 0x82EB3A3C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3A3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3A40: 4BDF9111  bl 0x82cacb50
	ctx.lr = 0x82EB3A44;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3A44: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3A4C: 40820048  bne 0x82eb3a94
	if !ctx.cr[0].eq {
	pc = 0x82EB3A94; continue 'dispatch;
	}
	// 82EB3A50: 4BA5A2B9  bl 0x8290dd08
	ctx.lr = 0x82EB3A54;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3A54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3A58: 4182FCFC  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3A5C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3A60: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3A64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3A68: 4182000C  beq 0x82eb3a74
	if ctx.cr[0].eq {
	pc = 0x82EB3A74; continue 'dispatch;
	}
	// 82EB3A6C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A70: 4800000C  b 0x82eb3a7c
	pc = 0x82EB3A7C; continue 'dispatch;
	// 82EB3A74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3A78: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3A7C: 4BDF8135  bl 0x82cabbb0
	ctx.lr = 0x82EB3A80;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB3A80: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3A84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3A88: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3A8C: D01D004C  stfs f0, 0x4c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EB3A90: 480007C8  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3A94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3A98: 3BCBA608  addi r30, r11, -0x59f8
	ctx.r[30].s64 = ctx.r[11].s64 + -23032;
	// 82EB3A9C: 483085C5  bl 0x831bc060
	ctx.lr = 0x82EB3AA0;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3AA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3AA4: 4BDF90AD  bl 0x82cacb50
	ctx.lr = 0x82EB3AA8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3AA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3AB0: 40820044  bne 0x82eb3af4
	if !ctx.cr[0].eq {
	pc = 0x82EB3AF4; continue 'dispatch;
	}
	// 82EB3AB4: 4BA5A255  bl 0x8290dd08
	ctx.lr = 0x82EB3AB8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3AB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3ABC: 4182FC98  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3AC0: 4BDF80F1  bl 0x82cabbb0
	ctx.lr = 0x82EB3AC4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB3AC4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3AC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3ACC: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB3AD0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB3AD4: 4099000C  ble cr6, 0x82eb3ae0
	if !ctx.cr[6].gt {
	pc = 0x82EB3AE0; continue 'dispatch;
	}
	// 82EB3AD8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB3ADC: 4800000C  b 0x82eb3ae8
	pc = 0x82EB3AE8; continue 'dispatch;
	// 82EB3AE0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB3AE4: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 82EB3AE8: D01D0050  stfs f0, 0x50(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB3AEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3AF0: 48000768  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3AF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3AF8: 3BCBA5F8  addi r30, r11, -0x5a08
	ctx.r[30].s64 = ctx.r[11].s64 + -23048;
	// 82EB3AFC: 48308565  bl 0x831bc060
	ctx.lr = 0x82EB3B00;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3B00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3B04: 4BDF904D  bl 0x82cacb50
	ctx.lr = 0x82EB3B08;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3B08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3B10: 40820024  bne 0x82eb3b34
	if !ctx.cr[0].eq {
	pc = 0x82EB3B34; continue 'dispatch;
	}
	// 82EB3B14: 4BA5A1F5  bl 0x8290dd08
	ctx.lr = 0x82EB3B18;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3B18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3B1C: 4182FC38  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3B20: 4BDF68A1  bl 0x82caa3c0
	ctx.lr = 0x82EB3B24;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CAA3C0);
	// 82EB3B24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB3B28: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3B2C: 917D0054  stw r11, 0x54(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB3B30: 48000728  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3B34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3B38: 3BCBA5EC  addi r30, r11, -0x5a14
	ctx.r[30].s64 = ctx.r[11].s64 + -23060;
	// 82EB3B3C: 48308525  bl 0x831bc060
	ctx.lr = 0x82EB3B40;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3B40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3B44: 4BDF900D  bl 0x82cacb50
	ctx.lr = 0x82EB3B48;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3B48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3B50: 40820048  bne 0x82eb3b98
	if !ctx.cr[0].eq {
	pc = 0x82EB3B98; continue 'dispatch;
	}
	// 82EB3B54: 4BA5A1B5  bl 0x8290dd08
	ctx.lr = 0x82EB3B58;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3B58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3B5C: 4182FBF8  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3B60: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3B64: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3B68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3B6C: 4182000C  beq 0x82eb3b78
	if ctx.cr[0].eq {
	pc = 0x82EB3B78; continue 'dispatch;
	}
	// 82EB3B70: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3B74: 4800000C  b 0x82eb3b80
	pc = 0x82EB3B80; continue 'dispatch;
	// 82EB3B78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3B7C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3B80: 4BDF8031  bl 0x82cabbb0
	ctx.lr = 0x82EB3B84;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB3B84: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3B88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3B8C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3B90: D01D0058  stfs f0, 0x58(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB3B94: 480006C4  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3B98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3B9C: 3BCBA5D0  addi r30, r11, -0x5a30
	ctx.r[30].s64 = ctx.r[11].s64 + -23088;
	// 82EB3BA0: 483084C1  bl 0x831bc060
	ctx.lr = 0x82EB3BA4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3BA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3BA8: 4BDF8FA9  bl 0x82cacb50
	ctx.lr = 0x82EB3BAC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3BAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3BB4: 40820024  bne 0x82eb3bd8
	if !ctx.cr[0].eq {
	pc = 0x82EB3BD8; continue 'dispatch;
	}
	// 82EB3BB8: 4BA5A151  bl 0x8290dd08
	ctx.lr = 0x82EB3BBC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3BBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3BC0: 4182FB94  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3BC4: 4BDF7FED  bl 0x82cabbb0
	ctx.lr = 0x82EB3BC8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB3BC8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3BCC: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB3BD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3BD4: 48000684  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3BD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3BDC: 3BCBA5C0  addi r30, r11, -0x5a40
	ctx.r[30].s64 = ctx.r[11].s64 + -23104;
	// 82EB3BE0: 48308481  bl 0x831bc060
	ctx.lr = 0x82EB3BE4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3BE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3BE8: 4BDF8F69  bl 0x82cacb50
	ctx.lr = 0x82EB3BEC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3BEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3BF4: 40820048  bne 0x82eb3c3c
	if !ctx.cr[0].eq {
	pc = 0x82EB3C3C; continue 'dispatch;
	}
	// 82EB3BF8: 4BA5A111  bl 0x8290dd08
	ctx.lr = 0x82EB3BFC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3BFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3C00: 4182FB54  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3C04: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB3C08: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB3C0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3C10: 4182000C  beq 0x82eb3c1c
	if ctx.cr[0].eq {
	pc = 0x82EB3C1C; continue 'dispatch;
	}
	// 82EB3C14: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3C18: 4800000C  b 0x82eb3c24
	pc = 0x82EB3C24; continue 'dispatch;
	// 82EB3C1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB3C20: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB3C24: 4BDF7F8D  bl 0x82cabbb0
	ctx.lr = 0x82EB3C28;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB3C28: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3C2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3C30: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB3C34: D01D005C  stfs f0, 0x5c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB3C38: 48000620  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3C3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3C40: 3BCBA5B4  addi r30, r11, -0x5a4c
	ctx.r[30].s64 = ctx.r[11].s64 + -23116;
	// 82EB3C44: 4830841D  bl 0x831bc060
	ctx.lr = 0x82EB3C48;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3C4C: 4BDF8F05  bl 0x82cacb50
	ctx.lr = 0x82EB3C50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3C50: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3C58: 40820060  bne 0x82eb3cb8
	if !ctx.cr[0].eq {
	pc = 0x82EB3CB8; continue 'dispatch;
	}
	// 82EB3C5C: 4BA5A0AD  bl 0x8290dd08
	ctx.lr = 0x82EB3C60;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3C60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3C64: 4182FAF0  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3C68: 4BDF7F49  bl 0x82cabbb0
	ctx.lr = 0x82EB3C6C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB3C6C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB3C70: D01D0064  stfs f0, 0x64(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB3C74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3C78: 4BFD1D79  bl 0x82e859f0
	ctx.lr = 0x82EB3C7C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E859F0);
	// 82EB3C7C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB3C80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3C84: 4099FC14  ble cr6, 0x82eb3898
	if !ctx.cr[6].gt {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB3C88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB3C8C: 817D01AC  lwz r11, 0x1ac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB3C90: C01D0064  lfs f0, 0x64(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB3C94: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3C98: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82EB3C9C: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82EB3CA0: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB3CA4: 4BFD1D4D  bl 0x82e859f0
	ctx.lr = 0x82EB3CA8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E859F0);
	// 82EB3CA8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EB3CAC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3CB0: 4198FFDC  blt cr6, 0x82eb3c8c
	if ctx.cr[6].lt {
	pc = 0x82EB3C8C; continue 'dispatch;
	}
	// 82EB3CB4: 4BFFFBE4  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
	// 82EB3CB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3CBC: 3BCBA5A4  addi r30, r11, -0x5a5c
	ctx.r[30].s64 = ctx.r[11].s64 + -23132;
	// 82EB3CC0: 483083A1  bl 0x831bc060
	ctx.lr = 0x82EB3CC4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3CC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3CC8: 4BDF8E89  bl 0x82cacb50
	ctx.lr = 0x82EB3CCC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3CCC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3CD4: 40820030  bne 0x82eb3d04
	if !ctx.cr[0].eq {
	pc = 0x82EB3D04; continue 'dispatch;
	}
	// 82EB3CD8: 4BA5A031  bl 0x8290dd08
	ctx.lr = 0x82EB3CDC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3CDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB3CE0: 4182FA74  beq 0x82eb3754
	if ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3CE4: 4BDF66DD  bl 0x82caa3c0
	ctx.lr = 0x82EB3CE8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CAA3C0);
	// 82EB3CE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB3CEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3CF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB3CF4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB3CF8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82EB3CFC: 997D0068  stb r11, 0x68(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 82EB3D00: 48000558  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3D04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3D08: 3BCBA594  addi r30, r11, -0x5a6c
	ctx.r[30].s64 = ctx.r[11].s64 + -23148;
	// 82EB3D0C: 48308355  bl 0x831bc060
	ctx.lr = 0x82EB3D10;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3D10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3D14: 4BDF8E3D  bl 0x82cacb50
	ctx.lr = 0x82EB3D18;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3D18: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3D20: 4082004C  bne 0x82eb3d6c
	if !ctx.cr[0].eq {
	pc = 0x82EB3D6C; continue 'dispatch;
	}
	// 82EB3D24: 4BA59FE5  bl 0x8290dd08
	ctx.lr = 0x82EB3D28;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3D28: 4BFFEB39  bl 0x82eb2860
	ctx.lr = 0x82EB3D2C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2860);
	// 82EB3D2C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3D30: 40820030  bne 0x82eb3d60
	if !ctx.cr[0].eq {
	pc = 0x82EB3D60; continue 'dispatch;
	}
	// 82EB3D34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3D38: 4B77A751  bl 0x8262e488
	ctx.lr = 0x82EB3D3C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E488);
	// 82EB3D3C: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3D40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3D44: 4099FA10  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3D48: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3D4C: 4B77A73D  bl 0x8262e488
	ctx.lr = 0x82EB3D50;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E488);
	// 82EB3D50: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3D54: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3D58: 4198FFF0  blt cr6, 0x82eb3d48
	if ctx.cr[6].lt {
	pc = 0x82EB3D48; continue 'dispatch;
	}
	// 82EB3D5C: 4BFFF9F8  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3D60: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3D64: 917D009C  stw r11, 0x9c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EB3D68: 480004F0  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3D6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3D70: 3BCBA588  addi r30, r11, -0x5a78
	ctx.r[30].s64 = ctx.r[11].s64 + -23160;
	// 82EB3D74: 483082ED  bl 0x831bc060
	ctx.lr = 0x82EB3D78;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3D78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3D7C: 4BDF8DD5  bl 0x82cacb50
	ctx.lr = 0x82EB3D80;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3D80: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3D88: 4082004C  bne 0x82eb3dd4
	if !ctx.cr[0].eq {
	pc = 0x82EB3DD4; continue 'dispatch;
	}
	// 82EB3D8C: 4BA59F7D  bl 0x8290dd08
	ctx.lr = 0x82EB3D90;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3D90: 4BFFEB91  bl 0x82eb2920
	ctx.lr = 0x82EB3D94;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2920);
	// 82EB3D94: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3D98: 40820030  bne 0x82eb3dc8
	if !ctx.cr[0].eq {
	pc = 0x82EB3DC8; continue 'dispatch;
	}
	// 82EB3D9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3DA0: 4B77A781  bl 0x8262e520
	ctx.lr = 0x82EB3DA4;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E520);
	// 82EB3DA4: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3DA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3DAC: 4099F9A8  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3DB0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3DB4: 4B77A76D  bl 0x8262e520
	ctx.lr = 0x82EB3DB8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E520);
	// 82EB3DB8: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3DBC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3DC0: 4198FFF0  blt cr6, 0x82eb3db0
	if ctx.cr[6].lt {
	pc = 0x82EB3DB0; continue 'dispatch;
	}
	// 82EB3DC4: 4BFFF990  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3DC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3DCC: 917D00A0  stw r11, 0xa0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EB3DD0: 48000488  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3DD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3DD8: 3BCBA578  addi r30, r11, -0x5a88
	ctx.r[30].s64 = ctx.r[11].s64 + -23176;
	// 82EB3DDC: 48308285  bl 0x831bc060
	ctx.lr = 0x82EB3DE0;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3DE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3DE4: 4BDF8D6D  bl 0x82cacb50
	ctx.lr = 0x82EB3DE8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3DE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3DF0: 4082004C  bne 0x82eb3e3c
	if !ctx.cr[0].eq {
	pc = 0x82EB3E3C; continue 'dispatch;
	}
	// 82EB3DF4: 4BA59F15  bl 0x8290dd08
	ctx.lr = 0x82EB3DF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3DF8: 4BFFECA9  bl 0x82eb2aa0
	ctx.lr = 0x82EB3DFC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2AA0);
	// 82EB3DFC: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E00: 40820030  bne 0x82eb3e30
	if !ctx.cr[0].eq {
	pc = 0x82EB3E30; continue 'dispatch;
	}
	// 82EB3E04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3E08: 4BFFE9E1  bl 0x82eb27e8
	ctx.lr = 0x82EB3E0C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB27E8);
	// 82EB3E0C: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E14: 4099F940  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3E18: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3E1C: 4BFFE9CD  bl 0x82eb27e8
	ctx.lr = 0x82EB3E20;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB27E8);
	// 82EB3E20: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E24: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3E28: 4198FFF0  blt cr6, 0x82eb3e18
	if ctx.cr[6].lt {
	pc = 0x82EB3E18; continue 'dispatch;
	}
	// 82EB3E2C: 4BFFF928  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3E30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3E34: 917D00B0  stw r11, 0xb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EB3E38: 48000420  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3E3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3E40: 3BCBA56C  addi r30, r11, -0x5a94
	ctx.r[30].s64 = ctx.r[11].s64 + -23188;
	// 82EB3E44: 4830821D  bl 0x831bc060
	ctx.lr = 0x82EB3E48;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3E48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3E4C: 4BDF8D05  bl 0x82cacb50
	ctx.lr = 0x82EB3E50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3E50: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3E58: 4082004C  bne 0x82eb3ea4
	if !ctx.cr[0].eq {
	pc = 0x82EB3EA4; continue 'dispatch;
	}
	// 82EB3E5C: 4BA59EAD  bl 0x8290dd08
	ctx.lr = 0x82EB3E60;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3E60: 4BFFED01  bl 0x82eb2b60
	ctx.lr = 0x82EB3E64;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2B60);
	// 82EB3E64: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E68: 40820030  bne 0x82eb3e98
	if !ctx.cr[0].eq {
	pc = 0x82EB3E98; continue 'dispatch;
	}
	// 82EB3E6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3E70: 4B77A879  bl 0x8262e6e8
	ctx.lr = 0x82EB3E74;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E6E8);
	// 82EB3E74: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3E7C: 4099F8D8  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3E80: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3E84: 4B77A865  bl 0x8262e6e8
	ctx.lr = 0x82EB3E88;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E6E8);
	// 82EB3E88: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3E8C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3E90: 4198FFF0  blt cr6, 0x82eb3e80
	if ctx.cr[6].lt {
	pc = 0x82EB3E80; continue 'dispatch;
	}
	// 82EB3E94: 4BFFF8C0  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3E98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3E9C: 917D00B4  stw r11, 0xb4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82EB3EA0: 480003B8  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3EA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3EA8: 3BCBA560  addi r30, r11, -0x5aa0
	ctx.r[30].s64 = ctx.r[11].s64 + -23200;
	// 82EB3EAC: 483081B5  bl 0x831bc060
	ctx.lr = 0x82EB3EB0;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3EB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3EB4: 4BDF8C9D  bl 0x82cacb50
	ctx.lr = 0x82EB3EB8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3EB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3EC0: 4082004C  bne 0x82eb3f0c
	if !ctx.cr[0].eq {
	pc = 0x82EB3F0C; continue 'dispatch;
	}
	// 82EB3EC4: 4BA59E45  bl 0x8290dd08
	ctx.lr = 0x82EB3EC8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3EC8: 4BFFEC99  bl 0x82eb2b60
	ctx.lr = 0x82EB3ECC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2B60);
	// 82EB3ECC: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3ED0: 40820030  bne 0x82eb3f00
	if !ctx.cr[0].eq {
	pc = 0x82EB3F00; continue 'dispatch;
	}
	// 82EB3ED4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3ED8: 4B77A811  bl 0x8262e6e8
	ctx.lr = 0x82EB3EDC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E6E8);
	// 82EB3EDC: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3EE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3EE4: 4099F870  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3EE8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3EEC: 4B77A7FD  bl 0x8262e6e8
	ctx.lr = 0x82EB3EF0;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E6E8);
	// 82EB3EF0: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3EF4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3EF8: 4198FFF0  blt cr6, 0x82eb3ee8
	if ctx.cr[6].lt {
	pc = 0x82EB3EE8; continue 'dispatch;
	}
	// 82EB3EFC: 4BFFF858  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3F00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3F04: 917D00B8  stw r11, 0xb8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EB3F08: 48000350  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3F0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3F10: 3BCBA548  addi r30, r11, -0x5ab8
	ctx.r[30].s64 = ctx.r[11].s64 + -23224;
	// 82EB3F14: 4830814D  bl 0x831bc060
	ctx.lr = 0x82EB3F18;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3F18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3F1C: 4BDF8C35  bl 0x82cacb50
	ctx.lr = 0x82EB3F20;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3F20: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3F28: 4082004C  bne 0x82eb3f74
	if !ctx.cr[0].eq {
	pc = 0x82EB3F74; continue 'dispatch;
	}
	// 82EB3F2C: 4BA59DDD  bl 0x8290dd08
	ctx.lr = 0x82EB3F30;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3F30: 4BFFEDB1  bl 0x82eb2ce0
	ctx.lr = 0x82EB3F34;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2CE0);
	// 82EB3F34: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3F38: 40820030  bne 0x82eb3f68
	if !ctx.cr[0].eq {
	pc = 0x82EB3F68; continue 'dispatch;
	}
	// 82EB3F3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3F40: 4B77A711  bl 0x8262e650
	ctx.lr = 0x82EB3F44;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E650);
	// 82EB3F44: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3F48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3F4C: 4099F808  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3F50: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3F54: 4B77A6FD  bl 0x8262e650
	ctx.lr = 0x82EB3F58;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E650);
	// 82EB3F58: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3F5C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3F60: 4198FFF0  blt cr6, 0x82eb3f50
	if ctx.cr[6].lt {
	pc = 0x82EB3F50; continue 'dispatch;
	}
	// 82EB3F64: 4BFFF7F0  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3F68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3F6C: 917D00AC  stw r11, 0xac(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82EB3F70: 480002E8  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3F74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3F78: 3BCBA53C  addi r30, r11, -0x5ac4
	ctx.r[30].s64 = ctx.r[11].s64 + -23236;
	// 82EB3F7C: 483080E5  bl 0x831bc060
	ctx.lr = 0x82EB3F80;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3F80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3F84: 4BDF8BCD  bl 0x82cacb50
	ctx.lr = 0x82EB3F88;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3F88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3F90: 4082004C  bne 0x82eb3fdc
	if !ctx.cr[0].eq {
	pc = 0x82EB3FDC; continue 'dispatch;
	}
	// 82EB3F94: 4BA59D75  bl 0x8290dd08
	ctx.lr = 0x82EB3F98;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB3F98: 4BFFEC89  bl 0x82eb2c20
	ctx.lr = 0x82EB3F9C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2C20);
	// 82EB3F9C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3FA0: 40820030  bne 0x82eb3fd0
	if !ctx.cr[0].eq {
	pc = 0x82EB3FD0; continue 'dispatch;
	}
	// 82EB3FA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB3FA8: 4B77A611  bl 0x8262e5b8
	ctx.lr = 0x82EB3FAC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E5B8);
	// 82EB3FAC: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3FB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB3FB4: 4099F7A0  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB3FB8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB3FBC: 4B77A5FD  bl 0x8262e5b8
	ctx.lr = 0x82EB3FC0;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262E5B8);
	// 82EB3FC0: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB3FC4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB3FC8: 4198FFF0  blt cr6, 0x82eb3fb8
	if ctx.cr[6].lt {
	pc = 0x82EB3FB8; continue 'dispatch;
	}
	// 82EB3FCC: 4BFFF788  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB3FD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB3FD4: 917D00A8  stw r11, 0xa8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EB3FD8: 48000280  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB3FDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB3FE0: 3BCBA534  addi r30, r11, -0x5acc
	ctx.r[30].s64 = ctx.r[11].s64 + -23244;
	// 82EB3FE4: 4830807D  bl 0x831bc060
	ctx.lr = 0x82EB3FE8;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB3FE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB3FEC: 4BDF8B65  bl 0x82cacb50
	ctx.lr = 0x82EB3FF0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB3FF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB3FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB3FF8: 4082004C  bne 0x82eb4044
	if !ctx.cr[0].eq {
	pc = 0x82EB4044; continue 'dispatch;
	}
	// 82EB3FFC: 4BA59D0D  bl 0x8290dd08
	ctx.lr = 0x82EB4000;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB4000: 4BFFE9E1  bl 0x82eb29e0
	ctx.lr = 0x82EB4004;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB29E0);
	// 82EB4004: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4008: 40820030  bne 0x82eb4038
	if !ctx.cr[0].eq {
	pc = 0x82EB4038; continue 'dispatch;
	}
	// 82EB400C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB4010: 4BFFE761  bl 0x82eb2770
	ctx.lr = 0x82EB4014;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2770);
	// 82EB4014: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB4018: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB401C: 4099F738  ble cr6, 0x82eb3754
	if !ctx.cr[6].gt {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB4020: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EB4024: 4BFFE74D  bl 0x82eb2770
	ctx.lr = 0x82EB4028;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2770);
	// 82EB4028: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB402C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB4030: 4198FFF0  blt cr6, 0x82eb4020
	if ctx.cr[6].lt {
	pc = 0x82EB4020; continue 'dispatch;
	}
	// 82EB4034: 4BFFF720  b 0x82eb3754
	pc = 0x82EB3754; continue 'dispatch;
	// 82EB4038: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB403C: 917D00A4  stw r11, 0xa4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EB4040: 48000218  b 0x82eb4258
	pc = 0x82EB4258; continue 'dispatch;
	// 82EB4044: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4048: 3BCBA528  addi r30, r11, -0x5ad8
	ctx.r[30].s64 = ctx.r[11].s64 + -23256;
	// 82EB404C: 48308015  bl 0x831bc060
	ctx.lr = 0x82EB4050;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB4050: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4054: 4BDF8AFD  bl 0x82cacb50
	ctx.lr = 0x82EB4058;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB4058: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB405C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4060: 4082001C  bne 0x82eb407c
	if !ctx.cr[0].eq {
	pc = 0x82EB407C; continue 'dispatch;
	}
	// 82EB4064: 4BA59CA5  bl 0x8290dd08
	ctx.lr = 0x82EB4068;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB4068: 4BDF6359  bl 0x82caa3c0
	ctx.lr = 0x82EB406C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CAA3C0);
	// 82EB406C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EB4070: 387D0074  addi r3, r29, 0x74
	ctx.r[3].s64 = ctx.r[29].s64 + 116;
	// 82EB4074: 4BFDEFAD  bl 0x82e93020
	ctx.lr = 0x82EB4078;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E93020);
	// 82EB4078: 4BFFF820  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
	// 82EB407C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4080: 3BCBA518  addi r30, r11, -0x5ae8
	ctx.r[30].s64 = ctx.r[11].s64 + -23272;
	// 82EB4084: 48307FDD  bl 0x831bc060
	ctx.lr = 0x82EB4088;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB4088: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB408C: 4BDF8AC5  bl 0x82cacb50
	ctx.lr = 0x82EB4090;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB4090: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4098: 40820084  bne 0x82eb411c
	if !ctx.cr[0].eq {
	pc = 0x82EB411C; continue 'dispatch;
	}
	// 82EB409C: 4BA59C6D  bl 0x8290dd08
	ctx.lr = 0x82EB40A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB40A0: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82EB40A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB40A8: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB40AC: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB40B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB40B4: 4182000C  beq 0x82eb40c0
	if ctx.cr[0].eq {
	pc = 0x82EB40C0; continue 'dispatch;
	}
	// 82EB40B8: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB40BC: 48000008  b 0x82eb40c4
	pc = 0x82EB40C4; continue 'dispatch;
	// 82EB40C0: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82EB40C4: 4BDF7AED  bl 0x82cabbb0
	ctx.lr = 0x82EB40C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EB40C8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB40CC: 817F0718  lwz r11, 0x718(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB40D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB40D4: ED8007F2  fmuls f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB40D8: 4182000C  beq 0x82eb40e4
	if ctx.cr[0].eq {
	pc = 0x82EB40E4; continue 'dispatch;
	}
	// 82EB40DC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB40E0: 48000008  b 0x82eb40e8
	pc = 0x82EB40E8; continue 'dispatch;
	// 82EB40E4: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 82EB40E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB40EC: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB40F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB40F4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB40F8: D01D01C4  stfs f0, 0x1c4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB40FC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4100: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EB4104: 41980008  blt cr6, 0x82eb410c
	if ctx.cr[6].lt {
	pc = 0x82EB410C; continue 'dispatch;
	}
	// 82EB4108: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 82EB410C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EB4110: 409AFFF0  bne cr6, 0x82eb4100
	if !ctx.cr[6].eq {
	pc = 0x82EB4100; continue 'dispatch;
	}
	// 82EB4114: D01D01C4  stfs f0, 0x1c4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB4118: 4BFFF780  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
	// 82EB411C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4120: 3BCBA504  addi r30, r11, -0x5afc
	ctx.r[30].s64 = ctx.r[11].s64 + -23292;
	// 82EB4124: 48307F3D  bl 0x831bc060
	ctx.lr = 0x82EB4128;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB4128: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB412C: 4BDF8A25  bl 0x82cacb50
	ctx.lr = 0x82EB4130;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB4130: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4138: 408200AC  bne 0x82eb41e4
	if !ctx.cr[0].eq {
	pc = 0x82EB41E4; continue 'dispatch;
	}
	// 82EB413C: 4BA59BCD  bl 0x8290dd08
	ctx.lr = 0x82EB4140;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EB4140: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB4144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB4148: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EB414C: 4BDF8A05  bl 0x82cacb50
	ctx.lr = 0x82EB4150;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB4150: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4154: 41820084  beq 0x82eb41d8
	if ctx.cr[0].eq {
	pc = 0x82EB41D8; continue 'dispatch;
	}
	// 82EB4158: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB415C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4160: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EB4164: 4BDF89ED  bl 0x82cacb50
	ctx.lr = 0x82EB4168;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB4168: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB416C: 4182006C  beq 0x82eb41d8
	if ctx.cr[0].eq {
	pc = 0x82EB41D8; continue 'dispatch;
	}
	// 82EB4170: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EB4174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4178: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EB417C: 4BDF89D5  bl 0x82cacb50
	ctx.lr = 0x82EB4180;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB4180: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB4184: 41820054  beq 0x82eb41d8
	if ctx.cr[0].eq {
	pc = 0x82EB41D8; continue 'dispatch;
	}
	// 82EB4188: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EB418C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4190: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EB4194: 4BDF89BD  bl 0x82cacb50
	ctx.lr = 0x82EB4198;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB4198: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB419C: 41820034  beq 0x82eb41d0
	if ctx.cr[0].eq {
	pc = 0x82EB41D0; continue 'dispatch;
	}
	// 82EB41A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB41A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB41A8: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EB41AC: 4BDF89A5  bl 0x82cacb50
	ctx.lr = 0x82EB41B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB41B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB41B4: 4182001C  beq 0x82eb41d0
	if ctx.cr[0].eq {
	pc = 0x82EB41D0; continue 'dispatch;
	}
	// 82EB41B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EB41BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB41C0: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EB41C4: 4BDF898D  bl 0x82cacb50
	ctx.lr = 0x82EB41C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB41C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB41CC: 4082F588  bne 0x82eb3754
	if !ctx.cr[0].eq {
	pc = 0x82EB3754; continue 'dispatch;
	}
	// 82EB41D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB41D4: 48000008  b 0x82eb41dc
	pc = 0x82EB41DC; continue 'dispatch;
	// 82EB41D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB41DC: 997D0069  stb r11, 0x69(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82EB41E0: 4BFFF6B8  b 0x82eb3898
	pc = 0x82EB3898; continue 'dispatch;
	// 82EB41E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB41E8: 3BCBA4DC  addi r30, r11, -0x5b24
	ctx.r[30].s64 = ctx.r[11].s64 + -23332;
	// 82EB41EC: 48307E75  bl 0x831bc060
	ctx.lr = 0x82EB41F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB41F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB41F4: 4BDF895D  bl 0x82cacb50
	ctx.lr = 0x82EB41F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB41F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB41FC: 4182F69C  beq 0x82eb3898
	if ctx.cr[0].eq {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB4200: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB4204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4208: 3BCBA4F4  addi r30, r11, -0x5b0c
	ctx.r[30].s64 = ctx.r[11].s64 + -23308;
	// 82EB420C: 48307E55  bl 0x831bc060
	ctx.lr = 0x82EB4210;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB4210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4214: 4BDF893D  bl 0x82cacb50
	ctx.lr = 0x82EB4218;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EB4218: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB421C: 4182F67C  beq 0x82eb3898
	if ctx.cr[0].eq {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB4220: 807D01B0  lwz r3, 0x1b0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB4224: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4228: 41820024  beq 0x82eb424c
	if ctx.cr[0].eq {
	pc = 0x82EB424C; continue 'dispatch;
	}
	// 82EB422C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4230: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB4234: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB4238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB423C: 4E800421  bctrl
	ctx.lr = 0x82EB4240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4240: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4244: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB4248: 419AF650  beq cr6, 0x82eb3898
	if ctx.cr[6].eq {
	pc = 0x82EB3898; continue 'dispatch;
	}
	// 82EB424C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB4250: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB4254: 4B7653E5  bl 0x82619638
	ctx.lr = 0x82EB4258;
	crate::recompiler::externs::call(&mut ctx, base, 0x82619638);
	// 82EB4258: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB425C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EB4260: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EB4264: 4BDF51F8  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
	// 82EB4268: 8063006C  lwz r3, 0x6c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB426C: 4BFDAAD4  b 0x82e8ed40
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8ED40);
	return;
	// 82EB4270: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4274: C00B00D8  lfs f0, 0xd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4278: C1AB0044  lfs f13, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB427C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4280: 41990050  bgt cr6, 0x82eb42d0
	if ctx.cr[6].gt {
	pc = 0x82EB42D0; continue 'dispatch;
	}
	// 82EB4284: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4288: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB428C: 41980044  blt cr6, 0x82eb42d0
	if ctx.cr[6].lt {
	pc = 0x82EB42D0; continue 'dispatch;
	}
	// 82EB4290: 894B00C1  lbz r10, 0xc1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(193 as u32) ) } as u64;
	// 82EB4294: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4298: 4182000C  beq 0x82eb42a4
	if ctx.cr[0].eq {
	pc = 0x82EB42A4; continue 'dispatch;
	}
	// 82EB429C: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB42A0: 48000008  b 0x82eb42a8
	pc = 0x82EB42A8; continue 'dispatch;
	// 82EB42A4: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB42A8: C1AB00DC  lfs f13, 0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB42AC: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB42B0: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB42B4: C00B00D4  lfs f0, 0xd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB42B8: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB42BC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EB42C0: 41990010  bgt cr6, 0x82eb42d0
	if ctx.cr[6].gt {
	pc = 0x82EB42D0; continue 'dispatch;
	}
	// 82EB42C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB42C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB42CC: 4800000C  b 0x82eb42d8
	pc = 0x82EB42D8; continue 'dispatch;
	// 82EB42D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB42D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB42D8: 994B00C1  stb r10, 0xc1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(193 as u32), ctx.r[10].u8 ) };
	// 82EB42DC: 4E800020  blr
	return;
	// 82EB42E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB42E4: C0230044  lfs f1, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB42E8: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82EB42EC: 8063006C  lwz r3, 0x6c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB42F0: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82EB42F4: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB42F8: 4BFDA290  b 0x82e8e588
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8E588);
	return;
}

pub fn sub_82EB4370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB4370 size=20
	// 82EB4370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB437C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB4380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB4530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4530 size=1960
	// 82EB4530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4534: 4BDF4EB5  bl 0x82ca93e8
	ctx.lr = 0x82EB4538;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93E8);
	// 82EB4538: DBA1FF80  stfd f29, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[29].u64 ) };
	// 82EB453C: DBC1FF88  stfd f30, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 82EB4540: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82EB4544: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB454C: 3ADF00E0  addi r22, r31, 0xe0
	ctx.r[22].s64 = ctx.r[31].s64 + 224;
	// 82EB4550: 3B3F00F8  addi r25, r31, 0xf8
	ctx.r[25].s64 = ctx.r[31].s64 + 248;
	// 82EB4554: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4558: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB455C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4560: 409A0028  bne cr6, 0x82eb4588
	if !ctx.cr[6].eq {
	pc = 0x82EB4588; continue 'dispatch;
	}
	// 82EB4564: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4568: C1B60004  lfs f13, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB456C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4570: 409A0018  bne cr6, 0x82eb4588
	if !ctx.cr[6].eq {
	pc = 0x82EB4588; continue 'dispatch;
	}
	// 82EB4574: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4578: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB457C: C1B60008  lfs f13, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4580: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4584: 419A0008  beq cr6, 0x82eb458c
	if ctx.cr[6].eq {
	pc = 0x82EB458C; continue 'dispatch;
	}
	// 82EB4588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB458C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4590: 408205F0  bne 0x82eb4b80
	if !ctx.cr[0].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4594: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EB4598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB459C: 419A05E4  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB45A0: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82EB45A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB45A8: 419A05D8  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB45AC: 4B3AC40D  bl 0x822609b8
	ctx.lr = 0x82EB45B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB45B0: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EB45B4: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82EB45B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB45BC: 4082009C  bne 0x82eb4658
	if !ctx.cr[0].eq {
	pc = 0x82EB4658; continue 'dispatch;
	}
	// 82EB45C0: C1BF0110  lfs f13, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB45C4: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB45C8: C0190000  lfs f0, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB45CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB45D0: C1990004  lfs f12, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB45D4: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB45D8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB45DC: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB45E0: C1990008  lfs f12, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB45E4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB45E8: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB45EC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB45F0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB45F4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB45F8: EFE0002C  fsqrts f31, f0
	ctx.f[31].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB45FC: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82EB4600: 40990058  ble cr6, 0x82eb4658
	if !ctx.cr[6].gt {
	pc = 0x82EB4658; continue 'dispatch;
	}
	// 82EB4604: 4B3AC3B5  bl 0x822609b8
	ctx.lr = 0x82EB4608;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB4608: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB460C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4610: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4614: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82EB4618: 80AA0014  lwz r5, 0x14(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB461C: C3CB004C  lfs f30, 0x4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB4620: 4BFCD0B1  bl 0x82e816d0
	ctx.lr = 0x82EB4624;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E816D0);
	// 82EB4624: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB4628: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82EB462C: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4630: EFDE0828  fsubs f30, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EB4634: C3AB0008  lfs f29, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB4638: 4BFCCCC9  bl 0x82e81300
	ctx.lr = 0x82EB463C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81300);
	// 82EB463C: EDBFE824  fdivs f13, f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[31].f64 / ctx.f[29].f64) as f32) as f64;
	// 82EB4640: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4644: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4648: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB464C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4650: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EB4654: 4198052C  blt cr6, 0x82eb4b80
	if ctx.cr[6].lt {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4658: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EB465C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82EB4660: 4BFDEB29  bl 0x82e93188
	ctx.lr = 0x82EB4664;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E93188);
	// 82EB4664: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB4668: 907F013C  stw r3, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[3].u32 ) };
	// 82EB466C: 419A0514  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4670: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4674: 1D63000C  mulli r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 * 12;
	// 82EB4678: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB467C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EB4680: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4684: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4688: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB468C: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4690: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4694: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4698: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB469C: 83DF013C  lwz r30, 0x13c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB46A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB46A4: 7FD5F378  mr r21, r30
	ctx.r[21].u64 = ctx.r[30].u64;
	// 82EB46A8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB46AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB46B0: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB46B4: 419A0228  beq cr6, 0x82eb48dc
	if ctx.cr[6].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB46B8: 1F9E000C  mulli r28, r30, 0xc
	ctx.r[28].s64 = ctx.r[30].s64 * 12;
	// 82EB46BC: 57DB103A  slwi r27, r30, 2
	// 82EB46C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EB46C4: 419A0044  beq cr6, 0x82eb4708
	if ctx.cr[6].eq {
	pc = 0x82EB4708; continue 'dispatch;
	}
	// 82EB46C8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB46CC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB46D0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EB46D4: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB46D8: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB46DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB46E0: 41820028  beq 0x82eb4708
	if ctx.cr[0].eq {
	pc = 0x82EB4708; continue 'dispatch;
	}
	// 82EB46E4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB46E8: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB46EC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB46F0: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB46F4: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EB46F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB46FC: 4E800421  bctrl
	ctx.lr = 0x82EB4700;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4700: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4704: 41820494  beq 0x82eb4b98
	if ctx.cr[0].eq {
	pc = 0x82EB4B98; continue 'dispatch;
	}
	// 82EB4708: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB470C: 3BBC000C  addi r29, r28, 0xc
	ctx.r[29].s64 = ctx.r[28].s64 + 12;
	// 82EB4710: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4714: 3B5E0001  addi r26, r30, 1
	ctx.r[26].s64 = ctx.r[30].s64 + 1;
	// 82EB4718: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB471C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4720: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4724: 3B1B0004  addi r24, r27, 4
	ctx.r[24].s64 = ctx.r[27].s64 + 4;
	// 82EB4728: C19F0114  lfs f12, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB472C: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4730: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4734: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB4738: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB473C: EDAC4828  fsubs f13, f12, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB4740: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4744: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB4748: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB474C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4750: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4754: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4758: 41990184  bgt cr6, 0x82eb48dc
	if ctx.cr[6].gt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB475C: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EB4760: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4764: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4768: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB476C: 40980008  bge cr6, 0x82eb4774
	if !ctx.cr[6].lt {
	pc = 0x82EB4774; continue 'dispatch;
	}
	// 82EB4770: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4774: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4778: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB477C: 41990160  bgt cr6, 0x82eb48dc
	if ctx.cr[6].gt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB4780: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4788: 815F00A4  lwz r10, 0xa4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB478C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4790: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EB4794: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB4798: 4E800421  bctrl
	ctx.lr = 0x82EB479C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB479C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB47A0: 4182013C  beq 0x82eb48dc
	if ctx.cr[0].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB47A4: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB47A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB47AC: 41820024  beq 0x82eb47d0
	if ctx.cr[0].eq {
	pc = 0x82EB47D0; continue 'dispatch;
	}
	// 82EB47B0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB47B4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB47B8: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB47BC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB47C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB47C4: 4E800421  bctrl
	ctx.lr = 0x82EB47C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB47C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB47CC: 41820110  beq 0x82eb48dc
	if ctx.cr[0].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB47D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB47D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB47D8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB47DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB47E0: 4E800421  bctrl
	ctx.lr = 0x82EB47E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB47E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB47E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB47EC: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB47F0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB47F4: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB47F8: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB47FC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EB4800: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4804: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4808: 7CABE214  add r5, r11, r28
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB480C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4810: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4818: 4E800421  bctrl
	ctx.lr = 0x82EB481C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB481C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4820: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4824: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB4828: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB482C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EB4830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4834: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB4838: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB483C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4840: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4844: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4848: 4E800421  bctrl
	ctx.lr = 0x82EB484C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB484C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4850: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4854: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB4858: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB485C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82EB4860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4864: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4868: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB486C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4870: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4874: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4878: 4E800421  bctrl
	ctx.lr = 0x82EB487C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB487C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4880: 41820014  beq 0x82eb4894
	if ctx.cr[0].eq {
	pc = 0x82EB4894; continue 'dispatch;
	}
	// 82EB4884: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4888: 4182000C  beq 0x82eb4894
	if ctx.cr[0].eq {
	pc = 0x82EB4894; continue 'dispatch;
	}
	// 82EB488C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4890: 4182004C  beq 0x82eb48dc
	if ctx.cr[0].eq {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB4894: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4898: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB489C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB48A0: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB48A4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB48A8: 41990034  bgt cr6, 0x82eb48dc
	if ctx.cr[6].gt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB48AC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB48B0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82EB48B4: 7F55D378  mr r21, r26
	ctx.r[21].u64 = ctx.r[26].u64;
	// 82EB48B8: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48BC: 40980020  bge cr6, 0x82eb48dc
	if !ctx.cr[6].lt {
	pc = 0x82EB48DC; continue 'dispatch;
	}
	// 82EB48C0: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB48C4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82EB48C8: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 82EB48CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB48D0: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82EB48D4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48D8: 409AFDE8  bne cr6, 0x82eb46c0
	if !ctx.cr[6].eq {
	pc = 0x82EB46C0; continue 'dispatch;
	}
	// 82EB48DC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB48E0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EB48E4: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48E8: 409801E0  bge cr6, 0x82eb4ac8
	if !ctx.cr[6].lt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB48EC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB48F0: 39550001  addi r10, r21, 1
	ctx.r[10].s64 = ctx.r[21].s64 + 1;
	// 82EB48F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB48F8: 409A01D0  bne cr6, 0x82eb4ac8
	if !ctx.cr[6].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB48FC: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4900: 1FB5000C  mulli r29, r21, 0xc
	ctx.r[29].s64 = ctx.r[21].s64 * 12;
	// 82EB4904: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4908: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB490C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4910: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82EB4914: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4918: C1440000  lfs f10, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB491C: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB4920: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4924: C1240004  lfs f9, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4928: EDA96828  fsubs f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB492C: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4930: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4934: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB4938: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB493C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4940: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4944: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4948: 40990164  ble cr6, 0x82eb4aac
	if !ctx.cr[6].gt {
	pc = 0x82EB4AAC; continue 'dispatch;
	}
	// 82EB494C: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4950: FD804890  fmr f12, f9
	ctx.f[12].f64 = ctx.f[9].f64;
	// 82EB4954: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4958: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB495C: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4960: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB4964: C1B60004  lfs f13, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4968: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB496C: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 82EB4970: C1560008  lfs f10, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4974: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4978: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB497C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4980: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4984: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4988: 41990140  bgt cr6, 0x82eb4ac8
	if ctx.cr[6].gt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB498C: C01F00E4  lfs f0, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4990: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4994: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4998: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB499C: 40980008  bge cr6, 0x82eb49a4
	if !ctx.cr[6].lt {
	pc = 0x82EB49A4; continue 'dispatch;
	}
	// 82EB49A0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB49A4: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB49A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB49AC: 4199011C  bgt cr6, 0x82eb4ac8
	if ctx.cr[6].gt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB49B0: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB49B4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82EB49B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB49BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB49C0: 4E800421  bctrl
	ctx.lr = 0x82EB49C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB49C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB49C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB49CC: 409A00FC  bne cr6, 0x82eb4ac8
	if !ctx.cr[6].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB49D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB49D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB49D8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EB49DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB49E0: 4E800421  bctrl
	ctx.lr = 0x82EB49E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB49E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB49E8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB49EC: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB49F0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB49F4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB49F8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB49FC: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4A00: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82EB4A04: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4A08: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82EB4A0C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4A10: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4A14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4A18: 4E800421  bctrl
	ctx.lr = 0x82EB4A1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4A1C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4A20: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4A24: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB4A28: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4A2C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EB4A30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4A34: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB4A38: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4A3C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4A40: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4A44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4A48: 4E800421  bctrl
	ctx.lr = 0x82EB4A4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4A4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4A50: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4A54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB4A58: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EB4A5C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82EB4A60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4A64: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4A68: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4A6C: 38A40034  addi r5, r4, 0x34
	ctx.r[5].s64 = ctx.r[4].s64 + 52;
	// 82EB4A70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4A74: 4E800421  bctrl
	ctx.lr = 0x82EB4A78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4A78: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4A7C: 4182004C  beq 0x82eb4ac8
	if ctx.cr[0].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4A80: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4A84: 41820044  beq 0x82eb4ac8
	if ctx.cr[0].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4A88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4A8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB4A90: 409A0038  bne cr6, 0x82eb4ac8
	if !ctx.cr[6].eq {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4A94: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4A98: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4A9C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB4AA0: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4AA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4AA8: 40980020  bge cr6, 0x82eb4ac8
	if !ctx.cr[6].lt {
	pc = 0x82EB4AC8; continue 'dispatch;
	}
	// 82EB4AAC: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4AB0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EB4AB4: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4AB8: C0160004  lfs f0, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4ABC: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4AC0: C0160008  lfs f0, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4AC4: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4AC8: 813F013C  lwz r9, 0x13c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB4ACC: 7F154840  cmplw cr6, r21, r9
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB4AD0: 409A006C  bne cr6, 0x82eb4b3c
	if !ctx.cr[6].eq {
	pc = 0x82EB4B3C; continue 'dispatch;
	}
	// 82EB4AD4: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB4AD8: 39150001  addi r8, r21, 1
	ctx.r[8].s64 = ctx.r[21].s64 + 1;
	// 82EB4ADC: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB4AE0: 40980054  bge cr6, 0x82eb4b34
	if !ctx.cr[6].lt {
	pc = 0x82EB4B34; continue 'dispatch;
	}
	// 82EB4AE4: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4AE8: 1D69000C  mulli r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 * 12;
	// 82EB4AEC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB4AF0: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4AF4: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4AF8: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4AFC: C15F0118  lfs f10, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4B00: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B04: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4B08: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4B0C: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4B10: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4B14: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4B18: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB4B1C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4B20: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4B24: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4B28: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EB4B2C: 40980008  bge cr6, 0x82eb4b34
	if !ctx.cr[6].lt {
	pc = 0x82EB4B34; continue 'dispatch;
	}
	// 82EB4B30: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 82EB4B34: 7F154840  cmplw cr6, r21, r9
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB4B38: 419A0048  beq cr6, 0x82eb4b80
	if ctx.cr[6].eq {
	pc = 0x82EB4B80; continue 'dispatch;
	}
	// 82EB4B3C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4B40: 92BF013C  stw r21, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[21].u32 ) };
	// 82EB4B44: 40820028  bne 0x82eb4b6c
	if !ctx.cr[0].eq {
	pc = 0x82EB4B6C; continue 'dispatch;
	}
	// 82EB4B48: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4B4C: 1D75000C  mulli r11, r21, 0xc
	ctx.r[11].s64 = ctx.r[21].s64 * 12;
	// 82EB4B50: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB4B54: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B58: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4B5C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B60: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4B64: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4B68: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4B6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4B70: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82EB4B74: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82EB4B78: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4B7C: 4B4106BD  bl 0x822c5238
	ctx.lr = 0x82EB4B80;
	crate::recompiler::externs::call(&mut ctx, base, 0x822C5238);
	// 82EB4B80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4B84: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EB4B88: CBA1FF80  lfd f29, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82EB4B8C: CBC1FF88  lfd f30, -0x78(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82EB4B90: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82EB4B94: 4BDF48A4  b 0x82ca9438
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9438);
	return;
	// 82EB4B98: 92BF013C  stw r21, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[21].u32 ) };
	// 82EB4B9C: 4BFFFFAC  b 0x82eb4b48
	pc = 0x82EB4B48; continue 'dispatch;
	// 82EB4BA0: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4BA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4BA8: C0030110  lfs f0, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4BAC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4BB0: C1850004  lfs f12, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4BB4: C1430114  lfs f10, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4BB8: ED4A6028  fsubs f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB4BBC: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB4BC0: C1230118  lfs f9, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4BC4: ED295828  fsubs f9, f9, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4BC8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4BCC: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4BD0: EC09027A  fmadds f0, f9, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4BD4: C12B0C18  lfs f9, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4BD8: ED40002C  fsqrts f10, f0
	ctx.f[10].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB4BDC: FF0A4800  fcmpu cr6, f10, f9
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[9].f64);
	// 82EB4BE0: 419A0040  beq cr6, 0x82eb4c20
	if ctx.cr[6].eq {
	pc = 0x82EB4C20; continue 'dispatch;
	}
	// 82EB4BE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4BE8: C1030110  lfs f8, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4BEC: C0E30114  lfs f7, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EB4BF0: EDAD4028  fsubs f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB4BF4: C1030118  lfs f8, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4BF8: ED8C3828  fsubs f12, f12, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EB4BFC: ED6B4028  fsubs f11, f11, f8
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB4C00: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C04: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EB4C08: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB4C0C: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4C10: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EB4C14: D1840008  stfs f12, 8(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4C18: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EB4C1C: 48000020  b 0x82eb4c3c
	pc = 0x82EB4C3C; continue 'dispatch;
	// 82EB4C20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4C24: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4C28: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C2C: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB4C30: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C34: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4C38: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C3C: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB4C40: 8163015C  lwz r11, 0x15c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) } as u64;
	// 82EB4C44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4C48: 41820010  beq 0x82eb4c58
	if ctx.cr[0].eq {
	pc = 0x82EB4C58; continue 'dispatch;
	}
	// 82EB4C4C: 896B0004  lbz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4C50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4C54: 40820008  bne 0x82eb4c5c
	if !ctx.cr[0].eq {
	pc = 0x82EB4C5C; continue 'dispatch;
	}
	// 82EB4C58: D1240008  stfs f9, 8(r4)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB4C5C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C60: C1A300E0  lfs f13, 0xe0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4C64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4C68: 409A0028  bne cr6, 0x82eb4c90
	if !ctx.cr[6].eq {
	pc = 0x82EB4C90; continue 'dispatch;
	}
	// 82EB4C6C: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C70: C1A300E4  lfs f13, 0xe4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4C74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4C78: 409A0018  bne cr6, 0x82eb4c90
	if !ctx.cr[6].eq {
	pc = 0x82EB4C90; continue 'dispatch;
	}
	// 82EB4C7C: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4C80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB4C84: C1A300E8  lfs f13, 0xe8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4C88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4C8C: 419A0008  beq cr6, 0x82eb4c94
	if ctx.cr[6].eq {
	pc = 0x82EB4C94; continue 'dispatch;
	}
	// 82EB4C90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB4C94: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4C98: 4182000C  beq 0x82eb4ca4
	if ctx.cr[0].eq {
	pc = 0x82EB4CA4; continue 'dispatch;
	}
	// 82EB4C9C: C0030040  lfs f0, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CA0: 48000008  b 0x82eb4ca8
	pc = 0x82EB4CA8; continue 'dispatch;
	// 82EB4CA4: C003003C  lfs f0, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CA8: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82EB4CAC: 4099000C  ble cr6, 0x82eb4cb8
	if !ctx.cr[6].gt {
	pc = 0x82EB4CB8; continue 'dispatch;
	}
	// 82EB4CB0: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CB4: 48000014  b 0x82eb4cc8
	pc = 0x82EB4CC8; continue 'dispatch;
	// 82EB4CB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4CBC: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4CC0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4CC4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4CC8: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4CCC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4CD0: 4E800020  blr
	return;
}

pub fn sub_82EB4CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB4CD8 size=88
	// 82EB4CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4CE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4CE4: 814301B0  lwz r10, 0x1b0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB4CE8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82EB4CEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB4CF0: 409A000C  bne cr6, 0x82eb4cfc
	if !ctx.cr[6].eq {
	pc = 0x82EB4CFC; continue 'dispatch;
	}
	// 82EB4CF4: 4BFFFEAD  bl 0x82eb4ba0
	ctx.lr = 0x82EB4CF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB4BA0);
	// 82EB4CF8: 48000024  b 0x82eb4d1c
	pc = 0x82EB4D1C; continue 'dispatch;
	// 82EB4CFC: 806301B0  lwz r3, 0x1b0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB4D00: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82EB4D04: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EB4D08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4D0C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB4D10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4D14: 4E800421  bctrl
	ctx.lr = 0x82EB4D18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4D18: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4D1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB4D20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4D24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4D28: 4E800020  blr
	return;
}

pub fn sub_82EB4D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4D30 size=112
	// 82EB4D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4D38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4D3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4D40: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4D48: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EB4D4C: C0030110  lfs f0, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D50: D00300F8  stfs f0, 0xf8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EB4D54: C0030114  lfs f0, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D58: D00300FC  stfs f0, 0xfc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EB4D5C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB4D60: C0030118  lfs f0, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D64: D0030100  stfs f0, 0x100(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EB4D68: C0030110  lfs f0, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D6C: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB4D70: C0030114  lfs f0, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D74: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB4D78: C0030118  lfs f0, 0x118(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4D7C: D003010C  stfs f0, 0x10c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB4D80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB4D84: 4E800421  bctrl
	ctx.lr = 0x82EB4D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB4D88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB4D8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB4D90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4D94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4D98: 4E800020  blr
	return;
}

pub fn sub_82EB4DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4DA0 size=80
	// 82EB4DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB4DA8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4DAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB4DB0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB4DB4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EB4DB8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB4DBC: 814B0158  lwz r10, 0x158(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB4DC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB4DC4: C02A0004  lfs f1, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB4DC8: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB4DCC: 4B77A745  bl 0x8262f510
	ctx.lr = 0x82EB4DD0;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262F510);
	// 82EB4DD0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4DD4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB4DD8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB4DDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB4DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB4DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB4DE8: 4E800020  blr
	return;
}

pub fn sub_82EB4DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB4DF0 size=88
	// 82EB4DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4DF4: 4BDF4619  bl 0x82ca940c
	ctx.lr = 0x82EB4DF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB4DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB4E00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB4E04: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB4E08: 4BFFFF99  bl 0x82eb4da0
	ctx.lr = 0x82EB4E0C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB4DA0);
	// 82EB4E0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4E10: 4082000C  bne 0x82eb4e1c
	if !ctx.cr[0].eq {
	pc = 0x82EB4E1C; continue 'dispatch;
	}
	// 82EB4E14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB4E18: 48000028  b 0x82eb4e40
	pc = 0x82EB4E40; continue 'dispatch;
	// 82EB4E1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB4E20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB4E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB4E28: 4BFFCDE1  bl 0x82eb1c08
	ctx.lr = 0x82EB4E2C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB1C08);
	// 82EB4E2C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB4E30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB4E34: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB4E38: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB4E3C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82EB4E40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB4E44: 4BDF4618  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EB4E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB4E48 size=480
	// 82EB4E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB4E4C: 4BDF45C1  bl 0x82ca940c
	ctx.lr = 0x82EB4E50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB4E50: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82EB4E54: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EB4E58: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EB4E5C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB4E60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB4E64: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EB4E68: C01E00E0  lfs f0, 0xe0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4E6C: C1BE00F8  lfs f13, 0xf8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4E70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB4E74: 409A0028  bne cr6, 0x82eb4e9c
	if !ctx.cr[6].eq {
	pc = 0x82EB4E9C; continue 'dispatch;
	}
	// 82EB4E78: C01E00FC  lfs f0, 0xfc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4E7C: C1BE00E4  lfs f13, 0xe4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4E80: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4E84: 409A0018  bne cr6, 0x82eb4e9c
	if !ctx.cr[6].eq {
	pc = 0x82EB4E9C; continue 'dispatch;
	}
	// 82EB4E88: C01E0100  lfs f0, 0x100(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4E8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB4E90: C1BE00E8  lfs f13, 0xe8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4E94: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4E98: 419A0008  beq cr6, 0x82eb4ea0
	if ctx.cr[6].eq {
	pc = 0x82EB4EA0; continue 'dispatch;
	}
	// 82EB4E9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB4EA0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4EA4: 40820168  bne 0x82eb500c
	if !ctx.cr[0].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4EA8: 817E013C  lwz r11, 0x13c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EB4EAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4EB0: 4182015C  beq 0x82eb500c
	if ctx.cr[0].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4EB4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB4EB8: 419A0154  beq cr6, 0x82eb500c
	if ctx.cr[6].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4EBC: 813E0088  lwz r9, 0x88(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EB4EC0: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 * 12;
	// 82EB4EC4: 7FEA4A14  add r31, r10, r9
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EB4EC8: 815E0084  lwz r10, 0x84(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EB4ECC: 556B103A  slwi r11, r11, 2
	// 82EB4ED0: 813E006C  lwz r9, 0x6c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EB4ED4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB4ED8: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4EDC: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4EE0: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4EE4: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EB4EE8: C17FFFF4  lfs f11, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB4EEC: C15FFFF8  lfs f10, -8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4EF0: EFED5828  fsubs f31, f13, f11
	ctx.f[31].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4EF4: C13FFFFC  lfs f9, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB4EF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB4EFC: EFA05028  fsubs f29, f0, f10
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB4F00: EFCC4828  fsubs f30, f12, f9
	ctx.f[30].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB4F04: 419A0038  beq cr6, 0x82eb4f3c
	if ctx.cr[6].eq {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F08: 81490028  lwz r10, 0x28(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB4F0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB4F10: 4098002C  bge cr6, 0x82eb4f3c
	if !ctx.cr[6].lt {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F14: 81490034  lwz r10, 0x34(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB4F18: 556B1838  slwi r11, r11, 3
	// 82EB4F1C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB4F20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB4F24: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB4F28: 419A0014  beq cr6, 0x82eb4f3c
	if ctx.cr[6].eq {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB4F30: 4182000C  beq 0x82eb4f3c
	if ctx.cr[0].eq {
	pc = 0x82EB4F3C; continue 'dispatch;
	}
	// 82EB4F34: 4BFDA6ED  bl 0x82e8f620
	ctx.lr = 0x82EB4F38;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8F620);
	// 82EB4F38: 48000020  b 0x82eb4f58
	pc = 0x82EB4F58; continue 'dispatch;
	// 82EB4F3C: EDAD5828  fsubs f13, f13, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB4F40: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB4F44: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EB4F48: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB4F4C: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB4F50: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB4F54: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB4F58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4F5C: C14B0C18  lfs f10, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB4F60: FF015000  fcmpu cr6, f1, f10
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[10].f64);
	// 82EB4F64: 419A0080  beq cr6, 0x82eb4fe4
	if ctx.cr[6].eq {
	pc = 0x82EB4FE4; continue 'dispatch;
	}
	// 82EB4F68: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4F6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB4F70: FD206850  fneg f9, f13
	ctx.f[9].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4F74: C19E0114  lfs f12, 0x114(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4F78: C1BFFFF8  lfs f13, -8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4F7C: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4F80: C11E0118  lfs f8, 0x118(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4F84: C1BFFFFC  lfs f13, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4F88: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4F8C: C19E0110  lfs f12, 0x110(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB4F90: C11FFFF4  lfs f8, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB4F94: ED8C4028  fsubs f12, f12, f8
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EB4F98: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB4F9C: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 82EB4FA0: ED6B0772  fmuls f11, f11, f29
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EB4FA4: ED6D5FBA  fmadds f11, f13, f30, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB4FA8: ED6C5FFA  fmadds f11, f12, f31, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EB4FAC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4FB0: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 82EB4FB4: 41980030  blt cr6, 0x82eb4fe4
	if ctx.cr[6].lt {
	pc = 0x82EB4FE4; continue 'dispatch;
	}
	// 82EB4FB8: FF0B0800  fcmpu cr6, f11, f1
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[1].f64);
	// 82EB4FBC: 41990028  bgt cr6, 0x82eb4fe4
	if ctx.cr[6].gt {
	pc = 0x82EB4FE4; continue 'dispatch;
	}
	// 82EB4FC0: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EB4FC4: EDAC6FB8  fmsubs f13, f12, f30, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB4FC8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB4FCC: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EB4FD0: 40980008  bge cr6, 0x82eb4fd8
	if !ctx.cr[6].lt {
	pc = 0x82EB4FD8; continue 'dispatch;
	}
	// 82EB4FD4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EB4FD8: C1BE005C  lfs f13, 0x5c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB4FDC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB4FE0: 4198002C  blt cr6, 0x82eb500c
	if ctx.cr[6].lt {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4FE4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB4FE8: 389E0110  addi r4, r30, 0x110
	ctx.r[4].s64 = ctx.r[30].s64 + 272;
	// 82EB4FEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB4FF0: 4BFFCC19  bl 0x82eb1c08
	ctx.lr = 0x82EB4FF4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB1C08);
	// 82EB4FF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB4FF8: 41820014  beq 0x82eb500c
	if ctx.cr[0].eq {
	pc = 0x82EB500C; continue 'dispatch;
	}
	// 82EB4FFC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB5000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB5004: 917E0140  stw r11, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82EB5008: 48000008  b 0x82eb5010
	pc = 0x82EB5010; continue 'dispatch;
	// 82EB500C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB5010: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5014: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EB5018: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EB501C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EB5020: 4BDF443C  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EB5028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5028 size=72
	// 82EB5028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB502C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5030: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5034: 81630158  lwz r11, 0x158(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(344 as u32) ) } as u64;
	// 82EB5038: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB503C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5040: 38630110  addi r3, r3, 0x110
	ctx.r[3].s64 = ctx.r[3].s64 + 272;
	// 82EB5044: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB5048: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB504C: 4B77A4C5  bl 0x8262f510
	ctx.lr = 0x82EB5050;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262F510);
	// 82EB5050: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EB5054: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB5058: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EB505C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5068: 4E800020  blr
	return;
}

pub fn sub_82EB5070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5070 size=216
	// 82EB5070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB507C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5088: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82EB508C: 4BFFD6E5  bl 0x82eb2770
	ctx.lr = 0x82EB5090;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2770);
	// 82EB5090: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB5094: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB5098: 808B0040  lwz r4, 0x40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB509C: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB50A0: 40810054  ble 0x82eb50f4
	if !ctx.cr[0].gt {
	pc = 0x82EB50F4; continue 'dispatch;
	}
	// 82EB50A4: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EB50A8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB50AC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB50B0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB50B4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB50B8: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB50BC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB50C0: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EB50C4: 41820014  beq 0x82eb50d8
	if ctx.cr[0].eq {
	pc = 0x82EB50D8; continue 'dispatch;
	}
	// 82EB50C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB50CC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB50D0: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EB50D4: 419AFFE0  beq cr6, 0x82eb50b4
	if ctx.cr[6].eq {
	pc = 0x82EB50B4; continue 'dispatch;
	}
	// 82EB50D8: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB50DC: 41820030  beq 0x82eb510c
	if ctx.cr[0].eq {
	pc = 0x82EB510C; continue 'dispatch;
	}
	// 82EB50E0: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB50E4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB50E8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB50EC: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB50F0: 4198FFB8  blt cr6, 0x82eb50a8
	if ctx.cr[6].lt {
	pc = 0x82EB50A8; continue 'dispatch;
	}
	// 82EB50F4: 2B040010  cmplwi cr6, r4, 0x10
	ctx.cr[6].compare_u32(ctx.r[4].u32, 16 as u32, &mut ctx.xer);
	// 82EB50F8: 409A0020  bne cr6, 0x82eb5118
	if !ctx.cr[6].eq {
	pc = 0x82EB5118; continue 'dispatch;
	}
	// 82EB50FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB5100: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB5104: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82EB5108: 48000028  b 0x82eb5130
	pc = 0x82EB5130; continue 'dispatch;
	// 82EB510C: 54AA103A  slwi r10, r5, 2
	// 82EB5110: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB5114: 48000018  b 0x82eb512c
	pc = 0x82EB512C; continue 'dispatch;
	// 82EB5118: 548A103A  slwi r10, r4, 2
	// 82EB511C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB5120: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB5124: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB5128: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EB512C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB5130: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB5134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB513C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB5140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5144: 4E800020  blr
	return;
}

pub fn sub_82EB5148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5148 size=216
	// 82EB5148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB514C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5150: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB5154: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5158: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB515C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5160: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82EB5164: 4BFFD685  bl 0x82eb27e8
	ctx.lr = 0x82EB5168;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB27E8);
	// 82EB5168: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB516C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB5170: 808B0040  lwz r4, 0x40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB5174: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB5178: 40810054  ble 0x82eb51cc
	if !ctx.cr[0].gt {
	pc = 0x82EB51CC; continue 'dispatch;
	}
	// 82EB517C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EB5180: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5184: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB5188: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB518C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5190: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5194: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB5198: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EB519C: 41820014  beq 0x82eb51b0
	if ctx.cr[0].eq {
	pc = 0x82EB51B0; continue 'dispatch;
	}
	// 82EB51A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB51A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB51A8: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EB51AC: 419AFFE0  beq cr6, 0x82eb518c
	if ctx.cr[6].eq {
	pc = 0x82EB518C; continue 'dispatch;
	}
	// 82EB51B0: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB51B4: 41820030  beq 0x82eb51e4
	if ctx.cr[0].eq {
	pc = 0x82EB51E4; continue 'dispatch;
	}
	// 82EB51B8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB51BC: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB51C0: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB51C4: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB51C8: 4198FFB8  blt cr6, 0x82eb5180
	if ctx.cr[6].lt {
	pc = 0x82EB5180; continue 'dispatch;
	}
	// 82EB51CC: 2B040010  cmplwi cr6, r4, 0x10
	ctx.cr[6].compare_u32(ctx.r[4].u32, 16 as u32, &mut ctx.xer);
	// 82EB51D0: 409A0020  bne cr6, 0x82eb51f0
	if !ctx.cr[6].eq {
	pc = 0x82EB51F0; continue 'dispatch;
	}
	// 82EB51D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB51D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB51DC: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82EB51E0: 48000028  b 0x82eb5208
	pc = 0x82EB5208; continue 'dispatch;
	// 82EB51E4: 54AA103A  slwi r10, r5, 2
	// 82EB51E8: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB51EC: 48000018  b 0x82eb5204
	pc = 0x82EB5204; continue 'dispatch;
	// 82EB51F0: 548A103A  slwi r10, r4, 2
	// 82EB51F4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EB51F8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB51FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB5200: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82EB5204: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB5208: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB520C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5214: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB5218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB521C: 4E800020  blr
	return;
}

pub fn sub_82EB5220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5220 size=136
	// 82EB5220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5228: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB522C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5230: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB5234: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5238: 392BAFB4  addi r9, r11, -0x504c
	ctx.r[9].s64 = ctx.r[11].s64 + -20556;
	// 82EB523C: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82EB5240: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB5244: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EB5248: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB524C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5250: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5254: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EB5258: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB525C: 4082FFF0  bne 0x82eb524c
	if !ctx.cr[0].eq {
	pc = 0x82EB524C; continue 'dispatch;
	}
	// 82EB5260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5264: 90BF0104  stw r5, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[5].u32 ) };
	// 82EB5268: 4BFFFE09  bl 0x82eb5070
	ctx.lr = 0x82EB526C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5070);
	// 82EB526C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5270: 4082000C  bne 0x82eb527c
	if !ctx.cr[0].eq {
	pc = 0x82EB527C; continue 'dispatch;
	}
	// 82EB5274: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB5278: 48000010  b 0x82eb5288
	pc = 0x82EB5288; continue 'dispatch;
	// 82EB527C: 4BFFD4F5  bl 0x82eb2770
	ctx.lr = 0x82EB5280;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB2770);
	// 82EB5280: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB5284: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB5288: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82EB528C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB529C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB52A0: 4E800020  blr
	return;
}

pub fn sub_82EB52A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB52A8 size=136
	// 82EB52A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB52AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB52B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB52B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB52B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB52BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB52C0: 392BAFB4  addi r9, r11, -0x504c
	ctx.r[9].s64 = ctx.r[11].s64 + -20556;
	// 82EB52C4: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82EB52C8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EB52CC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EB52D0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB52D4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB52D8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB52DC: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EB52E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB52E4: 4082FFF0  bne 0x82eb52d4
	if !ctx.cr[0].eq {
	pc = 0x82EB52D4; continue 'dispatch;
	}
	// 82EB52E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB52EC: 90BF0104  stw r5, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[5].u32 ) };
	// 82EB52F0: 4BFFFE59  bl 0x82eb5148
	ctx.lr = 0x82EB52F4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5148);
	// 82EB52F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB52F8: 4082000C  bne 0x82eb5304
	if !ctx.cr[0].eq {
	pc = 0x82EB5304; continue 'dispatch;
	}
	// 82EB52FC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB5300: 48000010  b 0x82eb5310
	pc = 0x82EB5310; continue 'dispatch;
	// 82EB5304: 4BFFD4E5  bl 0x82eb27e8
	ctx.lr = 0x82EB5308;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB27E8);
	// 82EB5308: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB530C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB5310: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82EB5314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5318: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB531C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5328: 4E800020  blr
	return;
}

pub fn sub_82EB5330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5330 size=152
	// 82EB5330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB533C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5344: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EB5348: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB534C: 394AA7C0  addi r10, r10, -0x5840
	ctx.r[10].s64 = ctx.r[10].s64 + -22592;
	// 82EB5350: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB5354: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EB5358: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82EB535C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB5360: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EB5364: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5368: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB536C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB5370: 409AFFF4  bne cr6, 0x82eb5364
	if !ctx.cr[6].eq {
	pc = 0x82EB5364; continue 'dispatch;
	}
	// 82EB5374: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82EB5378: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB537C: 556B003E  slwi r11, r11, 0
	// 82EB5380: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82EB5384: 4B7615A5  bl 0x82616928
	ctx.lr = 0x82EB5388;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EB5388: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB538C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82EB5390: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5394: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB5398: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB539C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EB53A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB53A4: 4082FFEC  bne 0x82eb5390
	if !ctx.cr[0].eq {
	pc = 0x82EB5390; continue 'dispatch;
	}
	// 82EB53A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB53AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB53B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB53B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB53B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB53BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB53C0: 4E800020  blr
	return;
}

pub fn sub_82EB53C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB53C8 size=88
	// 82EB53C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB53CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB53D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB53D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB53D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB53DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB53E0: 396BA7C0  addi r11, r11, -0x5840
	ctx.r[11].s64 = ctx.r[11].s64 + -22592;
	// 82EB53E4: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82EB53E8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB53EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB53F0: 816ADAB4  lwz r11, -0x254c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB53F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB53F8: 4E800421  bctrl
	ctx.lr = 0x82EB53FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB53FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB5400: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB5404: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB5408: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB540C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5414: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5418: 4E800020  blr
	return;
}

pub fn sub_82EB5420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5420 size=136
	// 82EB5420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5428: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB542C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5430: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EB5434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5438: 48306C29  bl 0x831bc060
	ctx.lr = 0x82EB543C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB543C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5440: 4182001C  beq 0x82eb545c
	if ctx.cr[0].eq {
	pc = 0x82EB545C; continue 'dispatch;
	}
	// 82EB5444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5448: 48306C19  bl 0x831bc060
	ctx.lr = 0x82EB544C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EB544C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5450: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82EB5454: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB5458: 419A0008  beq cr6, 0x82eb5460
	if ctx.cr[6].eq {
	pc = 0x82EB5460; continue 'dispatch;
	}
	// 82EB545C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB5460: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EB5464: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB546C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5470: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5474: 4E800020  blr
	return;
	// 82EB5478: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB547C: 386BE058  addi r3, r11, -0x1fa8
	ctx.r[3].s64 = ctx.r[11].s64 + -8104;
	// 82EB5480: 4E800020  blr
	return;
}

pub fn sub_82EB54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB54A8 size=144
	// 82EB54A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB54AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB54B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB54B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB54B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB54BC: 4BFFFE75  bl 0x82eb5330
	ctx.lr = 0x82EB54C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EB54C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB54C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB54C8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB54CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB54D0: 396BA818  addi r11, r11, -0x57e8
	ctx.r[11].s64 = ctx.r[11].s64 + -22504;
	// 82EB54D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB54D8: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EB54DC: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EB54E0: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EB54E4: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EB54E8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB54EC: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB54F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB54F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB54F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB54FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5500: 4E800020  blr
	return;
}

pub fn sub_82EB5538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5538 size=120
	// 82EB5538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB553C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5544: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB554C: 4BFFFDE5  bl 0x82eb5330
	ctx.lr = 0x82EB5550;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EB5550: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB5554: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB5558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB555C: 396BA86C  addi r11, r11, -0x5794
	ctx.r[11].s64 = ctx.r[11].s64 + -22420;
	// 82EB5560: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5564: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB5568: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB556C: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EB5570: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EB5574: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EB5578: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EB557C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5588: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB558C: 4E800020  blr
	return;
	// 82EB5590: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB5594: 386BD244  addi r3, r11, -0x2dbc
	ctx.r[3].s64 = ctx.r[11].s64 + -11708;
	// 82EB5598: 4E800020  blr
	return;
}

pub fn sub_82EB55B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB55B0 size=152
	// 82EB55B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB55B4: 4BDF3E59  bl 0x82ca940c
	ctx.lr = 0x82EB55B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB55B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB55BC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB55C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB55C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB55C8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB55CC: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82EB55D0: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EB55D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB55D8: 4B3330A1  bl 0x821e8678
	ctx.lr = 0x82EB55DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EB55DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB55E0: 41820014  beq 0x82eb55f4
	if ctx.cr[0].eq {
	pc = 0x82EB55F4; continue 'dispatch;
	}
	// 82EB55E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB55E8: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB55EC: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB55F0: 4800002C  b 0x82eb561c
	pc = 0x82EB561C; continue 'dispatch;
	// 82EB55F4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB55F8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB55FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5600: 4182000C  beq 0x82eb560c
	if ctx.cr[0].eq {
	pc = 0x82EB560C; continue 'dispatch;
	}
	// 82EB5604: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5608: 4800000C  b 0x82eb5614
	pc = 0x82EB5614; continue 'dispatch;
	// 82EB560C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5610: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5614: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5618: C00B0B24  lfs f0, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB561C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5620: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5624: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB5628: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB562C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5630: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5634: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5638: 4E800421  bctrl
	ctx.lr = 0x82EB563C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB563C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB5640: 4BDF3E1C  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EB5648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5648 size=176
	// 82EB5648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB564C: 4BDF3DBD  bl 0x82ca9408
	ctx.lr = 0x82EB5650;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EB5650: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5654: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB565C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5660: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB5664: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82EB5668: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EB566C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB5670: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EB5674: 4B333005  bl 0x821e8678
	ctx.lr = 0x82EB5678;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EB5678: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB567C: 41820014  beq 0x82eb5690
	if ctx.cr[0].eq {
	pc = 0x82EB5690; continue 'dispatch;
	}
	// 82EB5680: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5684: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5688: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB568C: 4800002C  b 0x82eb56b8
	pc = 0x82EB56B8; continue 'dispatch;
	// 82EB5690: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5694: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB5698: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB569C: 4182000C  beq 0x82eb56a8
	if ctx.cr[0].eq {
	pc = 0x82EB56A8; continue 'dispatch;
	}
	// 82EB56A0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB56A4: 4800000C  b 0x82eb56b0
	pc = 0x82EB56B0; continue 'dispatch;
	// 82EB56A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB56AC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB56B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB56B4: C00B0B24  lfs f0, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB56B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB56BC: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB56C0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB56C4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB56C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB56CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB56D0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB56D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB56D8: 4E800421  bctrl
	ctx.lr = 0x82EB56DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB56DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB56E0: 4BDF3D78  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EB56F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB56F8 size=88
	// 82EB56F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB56FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5700: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB5704: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB570C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5710: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5714: 4800B675  bl 0x82ec0d88
	ctx.lr = 0x82EB5718;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC0D88);
	// 82EB5718: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB571C: 41820018  beq 0x82eb5734
	if ctx.cr[0].eq {
	pc = 0x82EB5734; continue 'dispatch;
	}
	// 82EB5720: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB5724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5728: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB572C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5730: 4E800421  bctrl
	ctx.lr = 0x82EB5734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB5734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5738: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB573C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5744: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB5748: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB574C: 4E800020  blr
	return;
}

pub fn sub_82EB5750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5750 size=504
	// 82EB5750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5758: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB575C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5764: 4BFFFBCD  bl 0x82eb5330
	ctx.lr = 0x82EB5768;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EB5768: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB576C: 396BA8BC  addi r11, r11, -0x5744
	ctx.r[11].s64 = ctx.r[11].s64 + -22340;
	// 82EB5770: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB5774: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5778: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB577C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5780: 4182000C  beq 0x82eb578c
	if ctx.cr[0].eq {
	pc = 0x82EB578C; continue 'dispatch;
	}
	// 82EB5784: C18B000C  lfs f12, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5788: 4800000C  b 0x82eb5794
	pc = 0x82EB5794; continue 'dispatch;
	// 82EB578C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5790: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5794: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB5798: C00BDF3C  lfs f0, -0x20c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB579C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB57A0: C1ABBE10  lfs f13, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB57A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB57A8: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB57AC: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB57B0: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB57B4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB57B8: 4B3846F9  bl 0x82239eb0
	ctx.lr = 0x82EB57BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82239EB0);
	// 82EB57BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB57C0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB57C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB57C8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB57CC: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EB57D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB57D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB57D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB57DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB57E0: 4E800020  blr
	return;
}

pub fn sub_82EB5948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5948 size=624
	// 82EB5948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB594C: 4BDF3AB9  bl 0x82ca9404
	ctx.lr = 0x82EB5950;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EB5950: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82EB5954: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5958: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB595C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EB5960: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EB5964: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5968: 9BBF0034  stb r29, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u8 ) };
	// 82EB596C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5970: 4182023C  beq 0x82eb5bac
	if ctx.cr[0].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5974: 81630294  lwz r11, 0x294(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(660 as u32) ) } as u64;
	// 82EB5978: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EB597C: 409A0230  bne cr6, 0x82eb5bac
	if !ctx.cr[6].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5980: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB5984: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5988: 40820018  bne 0x82eb59a0
	if !ctx.cr[0].eq {
	pc = 0x82EB59A0; continue 'dispatch;
	}
	// 82EB598C: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB5990: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB5994: 388B5818  addi r4, r11, 0x5818
	ctx.r[4].s64 = ctx.r[11].s64 + 22552;
	// 82EB5998: 48017009  bl 0x82ecc9a0
	ctx.lr = 0x82EB599C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ECC9A0);
	// 82EB599C: 9BBF00A0  stb r29, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[29].u8 ) };
	// 82EB59A0: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB59A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB59A8: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB59AC: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB59B0: 419A003C  beq cr6, 0x82eb59ec
	if ctx.cr[6].eq {
	pc = 0x82EB59EC; continue 'dispatch;
	}
	// 82EB59B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB59B8: 419A0034  beq cr6, 0x82eb59ec
	if ctx.cr[6].eq {
	pc = 0x82EB59EC; continue 'dispatch;
	}
	// 82EB59BC: 4801DE95  bl 0x82ed3850
	ctx.lr = 0x82EB59C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB59C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB59C4: 41820028  beq 0x82eb59ec
	if ctx.cr[0].eq {
	pc = 0x82EB59EC; continue 'dispatch;
	}
	// 82EB59C8: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB59CC: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB59D0: 41820010  beq 0x82eb59e0
	if ctx.cr[0].eq {
	pc = 0x82EB59E0; continue 'dispatch;
	}
	// 82EB59D4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB59D8: 4801D559  bl 0x82ed2f30
	ctx.lr = 0x82EB59DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB59DC: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB59E0: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB59E4: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB59E8: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EB59EC: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB59F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB59F4: 41820024  beq 0x82eb5a18
	if ctx.cr[0].eq {
	pc = 0x82EB5A18; continue 'dispatch;
	}
	// 82EB59F8: 4801DEB1  bl 0x82ed38a8
	ctx.lr = 0x82EB59FC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38A8);
	// 82EB59FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5A00: 41820018  beq 0x82eb5a18
	if ctx.cr[0].eq {
	pc = 0x82EB5A18; continue 'dispatch;
	}
	// 82EB5A04: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB5A08: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5A0C: 4801D525  bl 0x82ed2f30
	ctx.lr = 0x82EB5A10;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB5A10: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB5A14: 9BBF00A1  stb r29, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[29].u8 ) };
	// 82EB5A18: C17B0000  lfs f11, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5A1C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB5A20: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A24: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB5A28: C15F0084  lfs f10, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB5A2C: C1BB0004  lfs f13, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5A30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A34: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB5A38: C19B0008  lfs f12, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5A3C: C15F0088  lfs f10, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB5A40: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB5A44: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5A48: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5A4C: ED8C033A  fmadds f12, f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5A50: 409A0010  bne cr6, 0x82eb5a60
	if !ctx.cr[6].eq {
	pc = 0x82EB5A60; continue 'dispatch;
	}
	// 82EB5A54: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB5A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A5C: 419A0058  beq cr6, 0x82eb5ab4
	if ctx.cr[6].eq {
	pc = 0x82EB5AB4; continue 'dispatch;
	}
	// 82EB5A60: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5A64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB5A68: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB5A6C: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A74: 4182000C  beq 0x82eb5a80
	if ctx.cr[0].eq {
	pc = 0x82EB5A80; continue 'dispatch;
	}
	// 82EB5A78: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5A7C: 48000008  b 0x82eb5a84
	pc = 0x82EB5A84; continue 'dispatch;
	// 82EB5A80: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EB5A84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A88: 41820008  beq 0x82eb5a90
	if ctx.cr[0].eq {
	pc = 0x82EB5A90; continue 'dispatch;
	}
	// 82EB5A8C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A90: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB5A94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5A98: C00B0B60  lfs f0, 0xb60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A9C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5AA0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EB5AA4: 40980010  bge cr6, 0x82eb5ab4
	if !ctx.cr[6].lt {
	pc = 0x82EB5AB4; continue 'dispatch;
	}
	// 82EB5AA8: 897F00A1  lbz r11, 0xa1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(161 as u32) ) } as u64;
	// 82EB5AAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5AB0: 418200FC  beq 0x82eb5bac
	if ctx.cr[0].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5AB4: D17F0080  stfs f11, 0x80(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB5AB8: 3B9F005C  addi r28, r31, 0x5c
	ctx.r[28].s64 = ctx.r[31].s64 + 92;
	// 82EB5ABC: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5AC0: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB5AC4: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5AC8: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB5ACC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5AD0: 9BDF00A1  stb r30, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[30].u8 ) };
	// 82EB5AD4: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EB5AD8: 4801C3C9  bl 0x82ed1ea0
	ctx.lr = 0x82EB5ADC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1EA0);
	// 82EB5ADC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB5AE0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82EB5AE4: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB5AE8: 40990008  ble cr6, 0x82eb5af0
	if !ctx.cr[6].gt {
	pc = 0x82EB5AF0; continue 'dispatch;
	}
	// 82EB5AEC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EB5AF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB5AF4: 80FF0060  lwz r7, 0x60(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB5AF8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EB5AFC: C03F002C  lfs f1, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB5B00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB5B04: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B08: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB5B0C: 4801C58D  bl 0x82ed2098
	ctx.lr = 0x82EB5B10;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2098);
	// 82EB5B10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5B14: 41820098  beq 0x82eb5bac
	if ctx.cr[0].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5B18: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5B20: 419A008C  beq cr6, 0x82eb5bac
	if ctx.cr[6].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5B24: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB5B28: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5B2C: 4182000C  beq 0x82eb5b38
	if ctx.cr[0].eq {
	pc = 0x82EB5B38; continue 'dispatch;
	}
	// 82EB5B30: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B34: 4801D3FD  bl 0x82ed2f30
	ctx.lr = 0x82EB5B38;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB5B38: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B3C: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB5B40: 4801C461  bl 0x82ed1fa0
	ctx.lr = 0x82EB5B44;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FA0);
	// 82EB5B44: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5B4C: 40990044  ble cr6, 0x82eb5b90
	if !ctx.cr[6].gt {
	pc = 0x82EB5B90; continue 'dispatch;
	}
	// 82EB5B50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5B54: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB5B58: C3EB0C4C  lfs f31, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB5B5C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB5B60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB5B64: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB5B68: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B6C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB5B70: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB5B74: 4801D1D5  bl 0x82ed2d48
	ctx.lr = 0x82EB5B78;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB5B78: 907F0064  stw r3, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EB5B7C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB5B80: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5B84: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB5B88: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB5B8C: 4198FFD0  blt cr6, 0x82eb5b5c
	if ctx.cr[6].lt {
	pc = 0x82EB5B5C; continue 'dispatch;
	}
	// 82EB5B90: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B94: 4801C42D  bl 0x82ed1fc0
	ctx.lr = 0x82EB5B98;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FC0);
	// 82EB5B98: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB5B9C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82EB5BA0: 4098000C  bge cr6, 0x82eb5bac
	if !ctx.cr[6].lt {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5BA4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB5BA8: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB5BAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5BB0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EB5BB4: 4BDF38A0  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EB5BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5BB8 size=352
	// 82EB5BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5BBC: 4BDF3845  bl 0x82ca9400
	ctx.lr = 0x82EB5BC0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EB5BC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5BC4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EB5BC8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EB5BCC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82EB5BD0: 419A00A4  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BD4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EB5BD8: 419A009C  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BDC: 83FA01BC  lwz r31, 0x1bc(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB5BE0: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5BE4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB5BE8: 419A008C  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BEC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB5BF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB5BF4: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5BF8: 4182007C  beq 0x82eb5c74
	if ctx.cr[0].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB5C00: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5C04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB5C08: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EB5C0C: 4801DCCD  bl 0x82ed38d8
	ctx.lr = 0x82EB5C10;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB5C10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5C14: 4182000C  beq 0x82eb5c20
	if ctx.cr[0].eq {
	pc = 0x82EB5C20; continue 'dispatch;
	}
	// 82EB5C18: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5C1C: 48000008  b 0x82eb5c24
	pc = 0x82EB5C24; continue 'dispatch;
	// 82EB5C20: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB5C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5C28: 419A0030  beq cr6, 0x82eb5c58
	if ctx.cr[6].eq {
	pc = 0x82EB5C58; continue 'dispatch;
	}
	// 82EB5C2C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EB5C30: 419A0028  beq cr6, 0x82eb5c58
	if ctx.cr[6].eq {
	pc = 0x82EB5C58; continue 'dispatch;
	}
	// 82EB5C34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB5C38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB5C3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB5C40: 4801FD21  bl 0x82ed5960
	ctx.lr = 0x82EB5C44;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5960);
	// 82EB5C44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5C48: 41820010  beq 0x82eb5c58
	if ctx.cr[0].eq {
	pc = 0x82EB5C58; continue 'dispatch;
	}
	// 82EB5C4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB5C50: 4801EB41  bl 0x82ed4790
	ctx.lr = 0x82EB5C54;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4790);
	// 82EB5C54: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82EB5C58: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5C5C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB5C60: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82EB5C64: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB5C68: 419A000C  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5C6C: 37FF0014  addic. r31, r31, 0x14
	ctx.xer.ca = (ctx.r[31].u32 > (!(20 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EB5C70: 4082FF8C  bne 0x82eb5bfc
	if !ctx.cr[0].eq {
	pc = 0x82EB5BFC; continue 'dispatch;
	}
	// 82EB5C74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5C78: 4BDF37D8  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
}

pub fn sub_82EB5D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5D18 size=12
	// 82EB5D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5D1C: 4BDF36F1  bl 0x82ca940c
	ctx.lr = 0x82EB5D20;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB5D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB5D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5D98 size=312
	// 82EB5D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5D9C: 4BDF3661  bl 0x82ca93fc
	ctx.lr = 0x82EB5DA0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93FC);
	// 82EB5DA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5DA4: 81450018  lwz r10, 0x18(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5DA8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EB5DAC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB5DB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5DB4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB5DB8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EB5DBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB5DC0: 419A0024  beq cr6, 0x82eb5de4
	if ctx.cr[6].eq {
	pc = 0x82EB5DE4; continue 'dispatch;
	}
	// 82EB5DC4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB5DC8: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5DCC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB5DD0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5DD4: 913D0018  stw r9, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB5DD8: 4182000C  beq 0x82eb5de4
	if ctx.cr[0].eq {
	pc = 0x82EB5DE4; continue 'dispatch;
	}
	// 82EB5DDC: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82EB5DE0: 4BFFFFE4  b 0x82eb5dc4
	pc = 0x82EB5DC4; continue 'dispatch;
	// 82EB5DE4: 54DA043E  clrlwi r26, r6, 0x10
	ctx.r[26].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 82EB5DE8: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5DEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5DF0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5DF4: 83EB0198  lwz r31, 0x198(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB5DF8: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB5DFC: 933E0008  stw r25, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82EB5E00: 4801DA31  bl 0x82ed3830
	ctx.lr = 0x82EB5E04;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3830);
	// 82EB5E04: 546B007E  clrlwi r11, r3, 1
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB5E08: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	// 82EB5E0C: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 82EB5E10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB5E14: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5E18: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5E1C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB5E20: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5E24: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB5E28: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5E2C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB5E30: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB5E34: B33F0012  sth r25, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[25].u16 ) };
	// 82EB5E38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5E3C: 41820040  beq 0x82eb5e7c
	if ctx.cr[0].eq {
	pc = 0x82EB5E7C; continue 'dispatch;
	}
	// 82EB5E40: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5E44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5E48: 41820034  beq 0x82eb5e7c
	if ctx.cr[0].eq {
	pc = 0x82EB5E7C; continue 'dispatch;
	}
	// 82EB5E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5E50: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5E54: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5E58: 4801FB09  bl 0x82ed5960
	ctx.lr = 0x82EB5E5C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5960);
	// 82EB5E5C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82EB5E60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB5E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5E68: 4801D8E9  bl 0x82ed3750
	ctx.lr = 0x82EB5E6C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3750);
	// 82EB5E6C: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5E70: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EB5E74: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5E78: 48000008  b 0x82eb5e80
	pc = 0x82EB5E80; continue 'dispatch;
	// 82EB5E7C: B33F0012  sth r25, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[25].u16 ) };
	// 82EB5E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5E84: 4801F2FD  bl 0x82ed5180
	ctx.lr = 0x82EB5E88;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5180);
	// 82EB5E88: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5E8C: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82EB5E90: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82EB5E94: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5E98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB5E9C: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5EA0: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5EA4: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB5EA8: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5EAC: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB5EB0: 5529103A  slwi r9, r9, 2
	// 82EB5EB4: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB5EB8: 914B0198  stw r10, 0x198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(408 as u32), ctx.r[10].u32 ) };
	// 82EB5EBC: 83BD0018  lwz r29, 0x18(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5EC0: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5EC4: 4082FF24  bne 0x82eb5de8
	if !ctx.cr[0].eq {
	pc = 0x82EB5DE8; continue 'dispatch;
	}
	// 82EB5EC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5ECC: 4BDF3580  b 0x82ca944c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA944C);
	return;
}

pub fn sub_82EB5ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5ED0 size=304
	// 82EB5ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5ED4: 4BDF3529  bl 0x82ca93fc
	ctx.lr = 0x82EB5ED8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93FC);
	// 82EB5ED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5EDC: 81450018  lwz r10, 0x18(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5EE0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EB5EE4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB5EE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5EEC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB5EF0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EB5EF4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB5EF8: 419A0024  beq cr6, 0x82eb5f1c
	if ctx.cr[6].eq {
	pc = 0x82EB5F1C; continue 'dispatch;
	}
	// 82EB5EFC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB5F00: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5F04: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB5F08: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5F0C: 913D0018  stw r9, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB5F10: 4182000C  beq 0x82eb5f1c
	if ctx.cr[0].eq {
	pc = 0x82EB5F1C; continue 'dispatch;
	}
	// 82EB5F14: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82EB5F18: 4BFFFFE4  b 0x82eb5efc
	pc = 0x82EB5EFC; continue 'dispatch;
	// 82EB5F1C: 54DA043E  clrlwi r26, r6, 0x10
	ctx.r[26].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 82EB5F20: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5F24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5F28: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5F2C: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB5F30: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB5F34: 933E0008  stw r25, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82EB5F38: 4801D8F9  bl 0x82ed3830
	ctx.lr = 0x82EB5F3C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3830);
	// 82EB5F3C: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	// 82EB5F40: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 82EB5F44: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB5F48: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5F4C: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5F50: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB5F54: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5F58: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB5F5C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5F60: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB5F64: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB5F68: B33F0012  sth r25, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[25].u16 ) };
	// 82EB5F6C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5F70: 4182003C  beq 0x82eb5fac
	if ctx.cr[0].eq {
	pc = 0x82EB5FAC; continue 'dispatch;
	}
	// 82EB5F74: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5F78: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5F7C: 41820030  beq 0x82eb5fac
	if ctx.cr[0].eq {
	pc = 0x82EB5FAC; continue 'dispatch;
	}
	// 82EB5F80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5F84: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5F88: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5F8C: 4801F9D5  bl 0x82ed5960
	ctx.lr = 0x82EB5F90;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5960);
	// 82EB5F90: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82EB5F94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB5F98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5F9C: 4801D7B5  bl 0x82ed3750
	ctx.lr = 0x82EB5FA0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3750);
	// 82EB5FA0: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FA4: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EB5FA8: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5FAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5FB0: 4801F1D1  bl 0x82ed5180
	ctx.lr = 0x82EB5FB4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5180);
	// 82EB5FB4: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FB8: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82EB5FBC: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82EB5FC0: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB5FC8: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5FCC: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5FD0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB5FD4: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FD8: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB5FDC: 5529103A  slwi r9, r9, 2
	// 82EB5FE0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB5FE4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB5FE8: 83BD0018  lwz r29, 0x18(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5FEC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5FF0: 4082FF30  bne 0x82eb5f20
	if !ctx.cr[0].eq {
	pc = 0x82EB5F20; continue 'dispatch;
	}
	// 82EB5FF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5FF8: 4BDF3454  b 0x82ca944c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA944C);
	return;
}

pub fn sub_82EB6000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB6000 size=88
	// 82EB6000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB6004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB6008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB600C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB6010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB6018: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB601C: 4BFFF3AD  bl 0x82eb53c8
	ctx.lr = 0x82EB6020;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB53C8);
	// 82EB6020: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6024: 41820018  beq 0x82eb603c
	if ctx.cr[0].eq {
	pc = 0x82EB603C; continue 'dispatch;
	}
	// 82EB6028: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB602C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6030: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB6034: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6038: 4E800421  bctrl
	ctx.lr = 0x82EB603C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB603C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6040: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB6044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB6048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB604C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB6050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB6054: 4E800020  blr
	return;
}

pub fn sub_82EB6058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB6058 size=328
	// 82EB6058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB605C: 4BDF33AD  bl 0x82ca9408
	ctx.lr = 0x82EB6060;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EB6060: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6064: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB6068: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB606C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EB6070: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6074: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB6078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB607C: 4E800421  bctrl
	ctx.lr = 0x82EB6080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB6080: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EB6084: 4182010C  beq 0x82eb6190
	if ctx.cr[0].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB608C: 4801D7C5  bl 0x82ed3850
	ctx.lr = 0x82EB6090;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB6090: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6094: 418200FC  beq 0x82eb6190
	if ctx.cr[0].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6098: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB609C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB60A0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB60A4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EB60A8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB60AC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB60B0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB60B4: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB60B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB60BC: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EB60C0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB60C4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB60C8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB60CC: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82EB60D0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB60D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB60D8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB60DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB60E0: 4200FFF8  bdnz 0x82eb60d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB60D8; continue 'dispatch;
	}
	// 82EB60E4: 817C009C  lwz r11, 0x9c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EB60E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB60EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB60F0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB60F4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB60F8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EB60FC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB6100: 9BC100D8  stb r30, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[30].u8 ) };
	// 82EB6104: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EB6108: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB610C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB6110: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EB6114: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB6118: 4801F419  bl 0x82ed5530
	ctx.lr = 0x82EB611C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5530);
	// 82EB611C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB6120: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82EB6124: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB6128: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB612C: 554BDFFF  rlwinm. r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6130: 41820060  beq 0x82eb6190
	if ctx.cr[0].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6134: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB6138: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 82EB613C: 419A0054  beq cr6, 0x82eb6190
	if ctx.cr[6].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6140: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB6144: 4801D795  bl 0x82ed38d8
	ctx.lr = 0x82EB6148;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB6148: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB614C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB6150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6154: 388A75C8  addi r4, r10, 0x75c8
	ctx.r[4].s64 = ctx.r[10].s64 + 30152;
	// 82EB6158: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB615C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB6160: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6164: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB6168: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB616C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6170: 9BDF0058  stb r30, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB6174: 4BFD356D  bl 0x82e896e0
	ctx.lr = 0x82EB6178;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EB6178: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB617C: 4182000C  beq 0x82eb6188
	if ctx.cr[0].eq {
	pc = 0x82EB6188; continue 'dispatch;
	}
	// 82EB6180: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB6184: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB6188: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB618C: 48000008  b 0x82eb6194
	pc = 0x82EB6194; continue 'dispatch;
	// 82EB6190: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB6194: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82EB6198: 4BDF32C0  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EB61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB61A0 size=368
	// 82EB61A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB61A4: 4BDF3265  bl 0x82ca9408
	ctx.lr = 0x82EB61A8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EB61A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB61AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB61B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB61B4: 809D017C  lwz r4, 0x17c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB61B8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB61BC: 41820010  beq 0x82eb61cc
	if ctx.cr[0].eq {
	pc = 0x82EB61CC; continue 'dispatch;
	}
	// 82EB61C0: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB61C4: 4801CD6D  bl 0x82ed2f30
	ctx.lr = 0x82EB61C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB61C8: 93FD017C  stw r31, 0x17c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(380 as u32), ctx.r[31].u32 ) };
	// 82EB61CC: 817D0168  lwz r11, 0x168(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB61D0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82EB61D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB61D8: 40990064  ble cr6, 0x82eb623c
	if !ctx.cr[6].gt {
	pc = 0x82EB623C; continue 'dispatch;
	}
	// 82EB61DC: 3BDD00A8  addi r30, r29, 0xa8
	ctx.r[30].s64 = ctx.r[29].s64 + 168;
	// 82EB61E0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB61E4: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB61E8: 4182001C  beq 0x82eb6204
	if ctx.cr[0].eq {
	pc = 0x82EB6204; continue 'dispatch;
	}
	// 82EB61EC: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB61F0: 4801CD41  bl 0x82ed2f30
	ctx.lr = 0x82EB61F4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB61F4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82EB61F8: 9BFE0004  stb r31, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EB61FC: 93FE0048  stw r31, 0x48(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 82EB6200: 93FEFFFC  stw r31, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[31].u32 ) };
	// 82EB6204: 809E0060  lwz r4, 0x60(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB6208: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB620C: 4182001C  beq 0x82eb6228
	if ctx.cr[0].eq {
	pc = 0x82EB6228; continue 'dispatch;
	}
	// 82EB6210: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB6214: 4801CD1D  bl 0x82ed2f30
	ctx.lr = 0x82EB6218;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB6218: 93FE0060  stw r31, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82EB621C: 9BFE0064  stb r31, 0x64(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[31].u8 ) };
	// 82EB6220: 93FE00A8  stw r31, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 82EB6224: 93FE005C  stw r31, 0x5c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82EB6228: 817D0168  lwz r11, 0x168(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB622C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB6230: 3BDE0060  addi r30, r30, 0x60
	ctx.r[30].s64 = ctx.r[30].s64 + 96;
	// 82EB6234: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6238: 4198FFA8  blt cr6, 0x82eb61e0
	if ctx.cr[6].lt {
	pc = 0x82EB61E0; continue 'dispatch;
	}
	// 82EB623C: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6240: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6244: 812B01B4  lwz r9, 0x1b4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB6248: 810B019C  lwz r8, 0x19c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB624C: 93EB01A4  stw r31, 0x1a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), ctx.r[31].u32 ) };
	// 82EB6250: 93EB01A8  stw r31, 0x1a8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(424 as u32), ctx.r[31].u32 ) };
	// 82EB6254: 93EB0190  stw r31, 0x190(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(400 as u32), ctx.r[31].u32 ) };
	// 82EB6258: 93EB0194  stw r31, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[31].u32 ) };
	// 82EB625C: 910B0198  stw r8, 0x198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(408 as u32), ctx.r[8].u32 ) };
	// 82EB6260: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB6264: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB6268: 912B01B8  stw r9, 0x1b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), ctx.r[9].u32 ) };
	// 82EB626C: 912B01BC  stw r9, 0x1bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(444 as u32), ctx.r[9].u32 ) };
	// 82EB6270: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB6274: 4BDF31E4  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
	// 82EB6278: 8163019C  lwz r11, 0x19c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB627C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB6280: 38EB0014  addi r7, r11, 0x14
	ctx.r[7].s64 = ctx.r[11].s64 + 20;
	// 82EB6284: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6288: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 82EB628C: 554A103A  slwi r10, r10, 2
	// 82EB6290: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB6294: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 82EB6298: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB629C: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82EB62A0: C00A0004  lfs f0, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB62A4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB62A8: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB62AC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB62B0: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB62B4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB62B8: A0CA0010  lhz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB62BC: B0CB0010  sth r6, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u16 ) };
	// 82EB62C0: A14A0012  lhz r10, 0x12(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB62C4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB62C8: B14B0012  sth r10, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[10].u16 ) };
	// 82EB62CC: 41820024  beq 0x82eb62f0
	if ctx.cr[0].eq {
	pc = 0x82EB62F0; continue 'dispatch;
	}
	// 82EB62D0: 7D493850  subf r10, r9, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82EB62D4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB62D8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB62DC: 7CEA492E  stwx r7, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 82EB62E0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB62E4: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB62E8: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EB62EC: 4198FFE8  blt cr6, 0x82eb62d4
	if ctx.cr[6].lt {
	pc = 0x82EB62D4; continue 'dispatch;
	}
	// 82EB62F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB62F4: 914301A8  stw r10, 0x1a8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), ctx.r[10].u32 ) };
	// 82EB62F8: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB62FC: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 82EB6300: 554A103A  slwi r10, r10, 2
	// 82EB6304: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB6308: 91630198  stw r11, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB630C: 4E800020  blr
	return;
}

pub fn sub_82EB6310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB6310 size=144
	// 82EB6310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB6314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB6318: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB631C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB6320: 90A301AC  stw r5, 0x1ac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(428 as u32), ctx.r[5].u32 ) };
	// 82EB6324: 48000050  b 0x82eb6374
	pc = 0x82EB6374; continue 'dispatch;
	// 82EB6328: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB632C: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB6330: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EB6334: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB6338: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB633C: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6340: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB6344: 5529103A  slwi r9, r9, 2
	// 82EB6348: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB634C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB6350: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EB6354: 409A0038  bne cr6, 0x82eb638c
	if !ctx.cr[6].eq {
	pc = 0x82EB638C; continue 'dispatch;
	}
	// 82EB6358: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB635C: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 * 12;
	// 82EB6360: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82EB6364: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB6368: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB636C: 91630194  stw r11, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EB6370: 91430198  stw r10, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[10].u32 ) };
	// 82EB6374: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB6378: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB637C: 4098FFAC  bge cr6, 0x82eb6328
	if !ctx.cr[6].lt {
	pc = 0x82EB6328; continue 'dispatch;
	}
	// 82EB6380: 4BFFFEF9  bl 0x82eb6278
	ctx.lr = 0x82EB6384;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB6278);
	// 82EB6384: 90A301A4  stw r5, 0x1a4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), ctx.r[5].u32 ) };
	// 82EB6388: 90A30194  stw r5, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[5].u32 ) };
	// 82EB638C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB6390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB6394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB6398: 4E800020  blr
	return;
}

pub fn sub_82EB63A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB63A0 size=344
	// 82EB63A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB63A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB63A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB63AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB63B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB63B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB63B8: 817F01A8  lwz r11, 0x1a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EB63BC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EB63C0: 419A0120  beq cr6, 0x82eb64e0
	if ctx.cr[6].eq {
	pc = 0x82EB64E0; continue 'dispatch;
	}
	// 82EB63C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB63C8: 409A005C  bne cr6, 0x82eb6424
	if !ctx.cr[6].eq {
	pc = 0x82EB6424; continue 'dispatch;
	}
	// 82EB63CC: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB63D0: A1440010  lhz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB63D4: B14B0010  sth r10, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u16 ) };
	// 82EB63D8: A1440012  lhz r10, 0x12(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB63DC: B14B0012  sth r10, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[10].u16 ) };
	// 82EB63E0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB63E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB63E8: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB63EC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB63F0: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB63F4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB63F8: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB63FC: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6400: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6404: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6408: 418200B4  beq 0x82eb64bc
	if ctx.cr[0].eq {
	pc = 0x82EB64BC; continue 'dispatch;
	}
	// 82EB640C: A1440012  lhz r10, 0x12(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6410: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82EB6414: 38840014  addi r4, r4, 0x14
	ctx.r[4].s64 = ctx.r[4].s64 + 20;
	// 82EB6418: 5545103E  rotlwi r5, r10, 2
	ctx.r[5].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82EB641C: 4BDF3065  bl 0x82ca9480
	ctx.lr = 0x82EB6420;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9480);
	// 82EB6420: 4800009C  b 0x82eb64bc
	pc = 0x82EB64BC; continue 'dispatch;
	// 82EB6424: 83DF0198  lwz r30, 0x198(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB6428: A1640010  lhz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB642C: B17E0010  sth r11, 0x10(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82EB6430: A1640012  lhz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6434: B17E0012  sth r11, 0x12(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB6438: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB643C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6440: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6444: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB6448: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB644C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB6450: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6454: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6458: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB645C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6460: 41820018  beq 0x82eb6478
	if ctx.cr[0].eq {
	pc = 0x82EB6478; continue 'dispatch;
	}
	// 82EB6464: A1640012  lhz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6468: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 82EB646C: 38840014  addi r4, r4, 0x14
	ctx.r[4].s64 = ctx.r[4].s64 + 20;
	// 82EB6470: 5565103E  rotlwi r5, r11, 2
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82EB6474: 4BDF300D  bl 0x82ca9480
	ctx.lr = 0x82EB6478;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9480);
	// 82EB6478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB647C: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB6480: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EB6484: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EB6488: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EB648C: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB6490: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB6494: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB6498: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EB649C: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB64A0: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 * 12;
	// 82EB64A4: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EB64A8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82EB64AC: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB64B0: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB64B4: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 82EB64B8: 913F0190  stw r9, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[9].u32 ) };
	// 82EB64BC: 815F01A8  lwz r10, 0x1a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EB64C0: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB64C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB64C8: 915F01A8  stw r10, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[10].u32 ) };
	// 82EB64CC: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB64D0: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 82EB64D4: 554A103A  slwi r10, r10, 2
	// 82EB64D8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB64DC: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB64E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB64E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB64E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB64EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB64F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB64F4: 4E800020  blr
	return;
}

pub fn sub_82EB64F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB64F8 size=176
	// 82EB64F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB64FC: 4BDF2F11  bl 0x82ca940c
	ctx.lr = 0x82EB6500;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB6500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB6508: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB650C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB6510: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EB6514: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EB6518: 4B760411  bl 0x82616928
	ctx.lr = 0x82EB651C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EB651C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EB6520: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB6524: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB6528: 4BDF3489  bl 0x82ca99b0
	ctx.lr = 0x82EB652C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA99B0);
	// 82EB652C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6530: 93DF01A0  stw r30, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 82EB6534: 4B7603F5  bl 0x82616928
	ctx.lr = 0x82EB6538;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EB6538: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EB653C: 80BF01A0  lwz r5, 0x1a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82EB6540: 907F019C  stw r3, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[3].u32 ) };
	// 82EB6544: 4BDF346D  bl 0x82ca99b0
	ctx.lr = 0x82EB6548;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA99B0);
	// 82EB6548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB654C: 93BF01C0  stw r29, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[29].u32 ) };
	// 82EB6550: 4B7603D9  bl 0x82616928
	ctx.lr = 0x82EB6554;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EB6554: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EB6558: 80BF01C0  lwz r5, 0x1c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EB655C: 907F01B4  stw r3, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[3].u32 ) };
	// 82EB6560: 4BDF3451  bl 0x82ca99b0
	ctx.lr = 0x82EB6564;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA99B0);
	// 82EB6564: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB656C: 813F01B4  lwz r9, 0x1b4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB6570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6574: 811F019C  lwz r8, 0x19c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB6578: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82EB657C: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 82EB6580: 911F0198  stw r8, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[8].u32 ) };
	// 82EB6584: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 82EB6588: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EB658C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB6590: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB6594: 913F01B8  stw r9, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[9].u32 ) };
	// 82EB6598: 913F01BC  stw r9, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[9].u32 ) };
	// 82EB659C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB65A0: 4BDF2EBC  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EB65A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB65A8 size=2424
	// 82EB65A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB65AC: 4BDF2E25  bl 0x82ca93d0
	ctx.lr = 0x82EB65B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93D0);
	// 82EB65B0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB65B4: 4BDF7725  bl 0x82cadcd8
	ctx.lr = 0x82EB65B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCD8);
	// 82EB65B8: 9421FD20  stwu r1, -0x2e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-736 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB65BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB65C0: 90E10314  stw r7, 0x314(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(788 as u32), ctx.r[7].u32 ) };
	// 82EB65C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB65C8: 9101031C  stw r8, 0x31c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(796 as u32), ctx.r[8].u32 ) };
	// 82EB65CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB65D0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EB65D4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82EB65D8: 4801D2D1  bl 0x82ed38a8
	ctx.lr = 0x82EB65DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38A8);
	// 82EB65DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB65E0: 40820874  bne 0x82eb6e54
	if !ctx.cr[0].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB65E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB65E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB65EC: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 82EB65F0: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB65F4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB65F8: C3CB0C18  lfs f30, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB65FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6600: 93BF0074  stw r29, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82EB6604: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EB6608: 93BF0078  stw r29, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82EB660C: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6610: 816B9E3C  lwz r11, -0x61c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB6614: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6618: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB661C: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6620: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6624: 554A103A  slwi r10, r10, 2
	// 82EB6628: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB662C: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6630: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6634: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82EB6638: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB663C: 556A103A  slwi r10, r11, 2
	// 82EB6640: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6644: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6648: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EB664C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6650: 556A103A  slwi r10, r11, 2
	// 82EB6654: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6658: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB665C: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6660: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6664: 556A103A  slwi r10, r11, 2
	// 82EB6668: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB666C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6670: D3CB0014  stfs f30, 0x14(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB6674: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EB6678: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB667C: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB6680: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB6684: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6688: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82EB668C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6690: C1780004  lfs f11, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB6694: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB6698: C1580008  lfs f10, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB669C: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB66A0: C138000C  lfs f9, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB66A4: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB66A8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB66AC: 556A103A  slwi r10, r11, 2
	// 82EB66B0: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB66B4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB66B8: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB66BC: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB66C0: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB66C4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB66C8: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB66CC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB66D0: 556A103A  slwi r10, r11, 2
	// 82EB66D4: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB66D8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB66DC: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB66E0: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB66E4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB66E8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB66EC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB66F0: 556A103A  slwi r10, r11, 2
	// 82EB66F4: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB66F8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB66FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB6700: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EB6704: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6708: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB670C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EB6710: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB6714: 3A6B9128  addi r19, r11, -0x6ed8
	ctx.r[19].s64 = ctx.r[11].s64 + -28376;
	// 82EB6718: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB671C: 3B2B9128  addi r25, r11, -0x6ed8
	ctx.r[25].s64 = ctx.r[11].s64 + -28376;
	// 82EB6720: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB6724: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EB6728: C38A0BEC  lfs f28, 0xbec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EB672C: 3A4B9F1C  addi r18, r11, -0x60e4
	ctx.r[18].s64 = ctx.r[11].s64 + -24804;
	// 82EB6730: C3A90C98  lfs f29, 0xc98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3224 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB6734: 3DC08330  lis r14, -0x7cd0
	ctx.r[14].s64 = -2094006272;
	// 82EB6738: 3A80FFFF  li r20, -1
	ctx.r[20].s64 = -1;
	// 82EB673C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6740: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6744: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EB6748: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 82EB674C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6750: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB6754: 816A9E58  lwz r11, -0x61a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25000 as u32) ) } as u64;
	// 82EB6758: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 82EB675C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6760: 916A9E58  stw r11, -0x61a8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25000 as u32), ctx.r[11].u32 ) };
	// 82EB6764: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EB6768: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB676C: 40990044  ble cr6, 0x82eb67b0
	if !ctx.cr[6].gt {
	pc = 0x82EB67B0; continue 'dispatch;
	}
	// 82EB6770: 5527003E  slwi r7, r9, 0
	// 82EB6774: 813A9E40  lwz r9, -0x61c0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6778: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB677C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EB6780: 419A0020  beq cr6, 0x82eb67a0
	if ctx.cr[6].eq {
	pc = 0x82EB67A0; continue 'dispatch;
	}
	// 82EB6784: 54C6003E  slwi r6, r6, 0
	// 82EB6788: C1A6000C  lfs f13, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB678C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB6790: 40980010  bge cr6, 0x82eb67a0
	if !ctx.cr[6].lt {
	pc = 0x82EB67A0; continue 'dispatch;
	}
	// 82EB6794: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EB6798: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB679C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EB67A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB67A4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB67A8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EB67AC: 4198FFCC  blt cr6, 0x82eb6778
	if ctx.cr[6].lt {
	pc = 0x82EB6778; continue 'dispatch;
	}
	// 82EB67B0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB67B4: 418206A0  beq 0x82eb6e54
	if ctx.cr[0].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB67B8: 554B103A  slwi r11, r10, 2
	// 82EB67BC: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB67C0: 7EAB502E  lwzx r21, r11, r10
	ctx.r[21].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB67C4: 7FAB512E  stwx r29, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 82EB67C8: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB67CC: 7E0B5214  add r16, r11, r10
	ctx.r[16].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB67D0: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67D4: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB67D8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB67DC: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB67E0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB67E4: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67E8: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67F0: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82EB67F4: 556B007F  clrlwi. r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB67F8: 41820670  beq 0x82eb6e68
	if ctx.cr[0].eq {
	pc = 0x82EB6E68; continue 'dispatch;
	}
	// 82EB67FC: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82EB6800: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EB6804: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 82EB6808: 93A1008C  stw r29, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 82EB680C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82EB6810: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82EB6814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6818: 4801DA29  bl 0x82ed4240
	ctx.lr = 0x82EB681C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4240);
	// 82EB681C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6820: 7FAFEB78  mr r15, r29
	ctx.r[15].u64 = ctx.r[29].u64;
	// 82EB6824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6828: 419A05AC  beq cr6, 0x82eb6dd4
	if ctx.cr[6].eq {
	pc = 0x82EB6DD4; continue 'dispatch;
	}
	// 82EB682C: 7FB1EB78  mr r17, r29
	ctx.r[17].u64 = ctx.r[29].u64;
	// 82EB6830: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB6834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB6838: 7EF1582E  lwzx r23, r17, r11
	ctx.r[23].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB683C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB6840: 7ED1582E  lwzx r22, r17, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6844: D3C10088  stfs f30, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB6848: 8161031C  lwz r11, 0x31c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(796 as u32) ) } as u64;
	// 82EB684C: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EB6850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6854: 92DE000C  stw r22, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[22].u32 ) };
	// 82EB6858: 409A0188  bne cr6, 0x82eb69e0
	if !ctx.cr[6].eq {
	pc = 0x82EB69E0; continue 'dispatch;
	}
	// 82EB685C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6860: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 82EB6864: 556B0FFF  rlwinm. r11, r11, 1, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6868: 41820178  beq 0x82eb69e0
	if ctx.cr[0].eq {
	pc = 0x82EB69E0; continue 'dispatch;
	}
	// 82EB686C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6870: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB6874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6878: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB687C: 4801E095  bl 0x82ed4910
	ctx.lr = 0x82EB6880;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4910);
	// 82EB6880: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6884: 41820538  beq 0x82eb6dbc
	if ctx.cr[0].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB688C: 4801DF05  bl 0x82ed4790
	ctx.lr = 0x82EB6890;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4790);
	// 82EB6890: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EB6894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6898: 4BFE39B1  bl 0x82e9a248
	ctx.lr = 0x82EB689C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A248);
	// 82EB689C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB68A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB68A4: 4BFE3A25  bl 0x82e9a2c8
	ctx.lr = 0x82EB68A8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A2C8);
	// 82EB68A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB68AC: 92810084  stw r20, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[20].u32 ) };
	// 82EB68B0: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82EB68B4: 9281005C  stw r20, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[20].u32 ) };
	// 82EB68B8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB68BC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB68C0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB68C4: 92410080  stw r18, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[18].u32 ) };
	// 82EB68C8: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 82EB68CC: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB68D0: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB68D4: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB68D8: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 82EB68DC: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB68E0: 926100A0  stw r19, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[19].u32 ) };
	// 82EB68E4: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB68E8: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82EB68EC: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB68F0: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EB68F4: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB68F8: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EB68FC: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6900: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EB6904: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6908: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB690C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB6910: 4200FFF8  bdnz 0x82eb6908
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6908; continue 'dispatch;
	}
	// 82EB6914: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EB6918: 9BA100F8  stb r29, 0xf8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[29].u8 ) };
	// 82EB691C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EB6920: 4B2F7D89  bl 0x821ae6a8
	ctx.lr = 0x82EB6924;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB6924: 92610160  stw r19, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[19].u32 ) };
	// 82EB6928: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB692C: 39410170  addi r10, r1, 0x170
	ctx.r[10].s64 = ctx.r[1].s64 + 368;
	// 82EB6930: D0010164  stfs f0, 0x164(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82EB6934: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB6938: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB693C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB6940: D0010168  stfs f0, 0x168(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82EB6944: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6948: D001016C  stfs f0, 0x16c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82EB694C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6950: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB6954: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB6958: 4200FFF8  bdnz 0x82eb6950
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6950; continue 'dispatch;
	}
	// 82EB695C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EB6960: 9BA101B8  stb r29, 0x1b8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[29].u8 ) };
	// 82EB6964: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82EB6968: 4B2F7D41  bl 0x821ae6a8
	ctx.lr = 0x82EB696C;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB696C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6970: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6974: 39010088  addi r8, r1, 0x88
	ctx.r[8].s64 = ctx.r[1].s64 + 136;
	// 82EB6978: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB697C: 38C10160  addi r6, r1, 0x160
	ctx.r[6].s64 = ctx.r[1].s64 + 352;
	// 82EB6980: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82EB6984: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB6988: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB698C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6994: 4E800421  bctrl
	ctx.lr = 0x82EB6998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB6998: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB699C: 4082002C  bne 0x82eb69c8
	if !ctx.cr[0].eq {
	pc = 0x82EB69C8; continue 'dispatch;
	}
	// 82EB69A0: 897F007E  lbz r11, 0x7e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(126 as u32) ) } as u64;
	// 82EB69A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB69A8: 41820020  beq 0x82eb69c8
	if ctx.cr[0].eq {
	pc = 0x82EB69C8; continue 'dispatch;
	}
	// 82EB69AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB69B0: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82EB69B4: 91610160  stw r11, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82EB69B8: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EB69BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB69C0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB69C4: 480003F8  b 0x82eb6dbc
	pc = 0x82EB6DBC; continue 'dispatch;
	// 82EB69C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB69CC: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82EB69D0: 91610160  stw r11, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82EB69D4: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EB69D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB69DC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB69E0: C3F50014  lfs f31, 0x14(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB69E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB69E8: 41820010  beq 0x82eb69f8
	if ctx.cr[0].eq {
	pc = 0x82EB69F8; continue 'dispatch;
	}
	// 82EB69EC: C0010088  lfs f0, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB69F0: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB69F4: 48000188  b 0x82eb6b7c
	pc = 0x82EB6B7C; continue 'dispatch;
	// 82EB69F8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB69FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6A00: 419A015C  beq cr6, 0x82eb6b5c
	if ctx.cr[6].eq {
	pc = 0x82EB6B5C; continue 'dispatch;
	}
	// 82EB6A04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A08: D3C10078  stfs f30, 0x78(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EB6A0C: 4BFE383D  bl 0x82e9a248
	ctx.lr = 0x82EB6A10;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A248);
	// 82EB6A10: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB6A14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A18: 4BFE38B1  bl 0x82e9a2c8
	ctx.lr = 0x82EB6A1C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A2C8);
	// 82EB6A1C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB6A20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A24: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EB6A28: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 82EB6A2C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6A30: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	// 82EB6A34: 4801CDFD  bl 0x82ed3830
	ctx.lr = 0x82EB6A38;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3830);
	// 82EB6A38: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6A3C: 392101D0  addi r9, r1, 0x1d0
	ctx.r[9].s64 = ctx.r[1].s64 + 464;
	// 82EB6A40: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EB6A44: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6A48: 926101C0  stw r19, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[19].u32 ) };
	// 82EB6A4C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB6A50: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6A54: D00101C4  stfs f0, 0x1c4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB6A58: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6A5C: D00101C8  stfs f0, 0x1c8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 82EB6A60: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6A64: D00101CC  stfs f0, 0x1cc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 82EB6A68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB6A6C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB6A70: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB6A74: 4200FFF8  bdnz 0x82eb6a6c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6A6C; continue 'dispatch;
	}
	// 82EB6A78: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EB6A7C: 9BA10218  stb r29, 0x218(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), ctx.r[29].u8 ) };
	// 82EB6A80: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 82EB6A84: 4B2F7C25  bl 0x821ae6a8
	ctx.lr = 0x82EB6A88;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB6A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A8C: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 82EB6A90: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB6A94: 92810064  stw r20, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u32 ) };
	// 82EB6A98: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6A9C: 4801CD95  bl 0x82ed3830
	ctx.lr = 0x82EB6AA0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3830);
	// 82EB6AA0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6AA4: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 82EB6AA8: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EB6AAC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6AB0: 92610100  stw r19, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[19].u32 ) };
	// 82EB6AB4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB6AB8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6ABC: D0010104  stfs f0, 0x104(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB6AC0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6AC4: D0010108  stfs f0, 0x108(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB6AC8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6ACC: D001010C  stfs f0, 0x10c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB6AD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB6AD4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB6AD8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB6ADC: 4200FFF8  bdnz 0x82eb6ad4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6AD4; continue 'dispatch;
	}
	// 82EB6AE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB6AE4: 9BA10158  stb r29, 0x158(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[29].u8 ) };
	// 82EB6AE8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82EB6AEC: 4B2F7BBD  bl 0x821ae6a8
	ctx.lr = 0x82EB6AF0;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB6AF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6AF4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB6AF8: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 82EB6AFC: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 82EB6B00: 38A101C0  addi r5, r1, 0x1c0
	ctx.r[5].s64 = ctx.r[1].s64 + 448;
	// 82EB6B04: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6B08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6B0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB6B10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6B14: 4E800421  bctrl
	ctx.lr = 0x82EB6B18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB6B18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6B1C: 40820024  bne 0x82eb6b40
	if !ctx.cr[0].eq {
	pc = 0x82EB6B40; continue 'dispatch;
	}
	// 82EB6B20: 897F007F  lbz r11, 0x7f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(127 as u32) ) } as u64;
	// 82EB6B24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6B28: 41820018  beq 0x82eb6b40
	if ctx.cr[0].eq {
	pc = 0x82EB6B40; continue 'dispatch;
	}
	// 82EB6B2C: 93210100  stw r25, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[25].u32 ) };
	// 82EB6B30: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 82EB6B34: 932101C0  stw r25, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[25].u32 ) };
	// 82EB6B38: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82EB6B3C: 48000280  b 0x82eb6dbc
	pc = 0x82EB6DBC; continue 'dispatch;
	// 82EB6B40: C0010078  lfs f0, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6B44: 93210100  stw r25, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[25].u32 ) };
	// 82EB6B48: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB6B4C: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 82EB6B50: 932101C0  stw r25, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[25].u32 ) };
	// 82EB6B54: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82EB6B58: 48000024  b 0x82eb6b7c
	pc = 0x82EB6B7C; continue 'dispatch;
	// 82EB6B5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6B60: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82EB6B64: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB6B68: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 82EB6B6C: C8010098  lfd f0, 0x98(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82EB6B70: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EB6B74: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EB6B78: EFE0FF7A  fmadds f31, f0, f29, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EB6B7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6B80: 4BFE37C9  bl 0x82e9a348
	ctx.lr = 0x82EB6B84;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A348);
	// 82EB6B84: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6B88: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6B8C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB6B90: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6B94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB6B98: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6B9C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB6BA0: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6BA8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BAC: 5565007E  clrlwi r5, r11, 1
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB6BB0: 40990060  ble cr6, 0x82eb6c10
	if !ctx.cr[6].gt {
	pc = 0x82EB6C10; continue 'dispatch;
	}
	// 82EB6BB4: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6BB8: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB6BBC: 40820054  bne 0x82eb6c10
	if !ctx.cr[0].eq {
	pc = 0x82EB6C10; continue 'dispatch;
	}
	// 82EB6BC0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB6BC8: 419A0034  beq cr6, 0x82eb6bfc
	if ctx.cr[6].eq {
	pc = 0x82EB6BFC; continue 'dispatch;
	}
	// 82EB6BCC: 554A003E  slwi r10, r10, 0
	// 82EB6BD0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BD4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BD8: 554A007E  clrlwi r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB6BDC: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB6BE0: 409A001C  bne cr6, 0x82eb6bfc
	if !ctx.cr[6].eq {
	pc = 0x82EB6BFC; continue 'dispatch;
	}
	// 82EB6BE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BE8: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EB6BEC: C00A0014  lfs f0, 0x14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6BF0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB6BF4: 41990008  bgt cr6, 0x82eb6bfc
	if ctx.cr[6].gt {
	pc = 0x82EB6BFC; continue 'dispatch;
	}
	// 82EB6BF8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB6BFC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6C00: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB6C04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB6C08: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6C0C: 4198FFAC  blt cr6, 0x82eb6bb8
	if ctx.cr[6].lt {
	pc = 0x82EB6BB8; continue 'dispatch;
	}
	// 82EB6C10: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6C14: 408201A8  bne 0x82eb6dbc
	if !ctx.cr[0].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6C18: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6C1C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EB6C20: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6C28: 40990060  ble cr6, 0x82eb6c88
	if !ctx.cr[6].gt {
	pc = 0x82EB6C88; continue 'dispatch;
	}
	// 82EB6C2C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6C30: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6C34: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB6C38: 40820050  bne 0x82eb6c88
	if !ctx.cr[0].eq {
	pc = 0x82EB6C88; continue 'dispatch;
	}
	// 82EB6C3C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6C40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB6C44: 419A0030  beq cr6, 0x82eb6c74
	if ctx.cr[6].eq {
	pc = 0x82EB6C74; continue 'dispatch;
	}
	// 82EB6C48: 554A003E  slwi r10, r10, 0
	// 82EB6C4C: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6C50: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6C54: 5463007E  clrlwi r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB6C58: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB6C5C: 409A0018  bne cr6, 0x82eb6c74
	if !ctx.cr[6].eq {
	pc = 0x82EB6C74; continue 'dispatch;
	}
	// 82EB6C60: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6C64: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EB6C68: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB6C6C: 41990008  bgt cr6, 0x82eb6c74
	if ctx.cr[6].gt {
	pc = 0x82EB6C74; continue 'dispatch;
	}
	// 82EB6C70: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB6C74: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6C78: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB6C7C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB6C80: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6C84: 4198FFB0  blt cr6, 0x82eb6c34
	if ctx.cr[6].lt {
	pc = 0x82EB6C34; continue 'dispatch;
	}
	// 82EB6C88: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6C8C: 40820130  bne 0x82eb6dbc
	if !ctx.cr[0].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6C90: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB6C94: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB6C98: 1D0B001C  mulli r8, r11, 0x1c
	ctx.r[8].s64 = ctx.r[11].s64 * 28;
	// 82EB6C9C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6CA0: 816B9E3C  lwz r11, -0x61c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB6CA4: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB6CA8: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EB6CAC: 810EDF34  lwz r8, -0x20cc(r14)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB6CB0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB6CB4: 419A01A0  beq cr6, 0x82eb6e54
	if ctx.cr[6].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB6CB8: D3EB0014  stfs f31, 0x14(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB6CBC: 92AB0018  stw r21, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[21].u32 ) };
	// 82EB6CC0: 92CB0004  stw r22, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 82EB6CC4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EB6CC8: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EB6CCC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6CD0: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB6CD4: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB6CD8: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6CDC: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82EB6CE0: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6CE4: C1780004  lfs f11, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB6CE8: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB6CEC: C1580008  lfs f10, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB6CF0: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB6CF4: C138000C  lfs f9, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB6CF8: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB6CFC: C10B0014  lfs f8, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB6D00: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB6D04: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82EB6D08: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB6D0C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB6D10: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB6D14: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB6D18: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB6D1C: EDA0402A  fadds f13, f0, f8
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EB6D20: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6D24: 419A0008  beq cr6, 0x82eb6d2c
	if ctx.cr[6].eq {
	pc = 0x82EB6D2C; continue 'dispatch;
	}
	// 82EB6D28: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EB6D2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D30: 409A008C  bne cr6, 0x82eb6dbc
	if !ctx.cr[6].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6D34: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D38: 419A0010  beq cr6, 0x82eb6d48
	if ctx.cr[6].eq {
	pc = 0x82EB6D48; continue 'dispatch;
	}
	// 82EB6D3C: 91700000  stw r11, 0(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6D40: 7FB0EB78  mr r16, r29
	ctx.r[16].u64 = ctx.r[29].u64;
	// 82EB6D44: 48000078  b 0x82eb6dbc
	pc = 0x82EB6DBC; continue 'dispatch;
	// 82EB6D48: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6D4C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EB6D50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D54: 40990038  ble cr6, 0x82eb6d8c
	if !ctx.cr[6].gt {
	pc = 0x82EB6D8C; continue 'dispatch;
	}
	// 82EB6D58: 813A9E40  lwz r9, -0x61c0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6D5C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6D60: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D64: 419A001C  beq cr6, 0x82eb6d80
	if ctx.cr[6].eq {
	pc = 0x82EB6D80; continue 'dispatch;
	}
	// 82EB6D68: 811F0074  lwz r8, 0x74(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6D6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB6D70: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB6D74: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB6D78: 4198FFE4  blt cr6, 0x82eb6d5c
	if ctx.cr[6].lt {
	pc = 0x82EB6D5C; continue 'dispatch;
	}
	// 82EB6D7C: 48000010  b 0x82eb6d8c
	pc = 0x82EB6D8C; continue 'dispatch;
	// 82EB6D80: 811A9E40  lwz r8, -0x61c0(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6D84: 5549103A  slwi r9, r10, 2
	// 82EB6D88: 7D69412E  stwx r11, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 82EB6D8C: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6D90: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB6D94: 41980028  blt cr6, 0x82eb6dbc
	if ctx.cr[6].lt {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6D98: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB6D9C: 5548103A  slwi r8, r10, 2
	// 82EB6DA0: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82EB6DA4: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6DA8: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EB6DAC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6DB0: 816EDF34  lwz r11, -0x20cc(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB6DB4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6DB8: 419A009C  beq cr6, 0x82eb6e54
	if ctx.cr[6].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB6DBC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6DC0: 39EF0001  addi r15, r15, 1
	ctx.r[15].s64 = ctx.r[15].s64 + 1;
	// 82EB6DC4: 3A310004  addi r17, r17, 4
	ctx.r[17].s64 = ctx.r[17].s64 + 4;
	// 82EB6DC8: 7F0F5840  cmplw cr6, r15, r11
	ctx.cr[6].compare_u32(ctx.r[15].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6DCC: 4198FA64  blt cr6, 0x82eb6830
	if ctx.cr[6].lt {
	pc = 0x82EB6830; continue 'dispatch;
	}
	// 82EB6DD0: 83610090  lwz r27, 0x90(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB6DD4: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6DD8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB6DDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB6DE0: 40990040  ble cr6, 0x82eb6e20
	if !ctx.cr[6].gt {
	pc = 0x82EB6E20; continue 'dispatch;
	}
	// 82EB6DE4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6DE8: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6DEC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6DF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB6DF4: 419A001C  beq cr6, 0x82eb6e10
	if ctx.cr[6].eq {
	pc = 0x82EB6E10; continue 'dispatch;
	}
	// 82EB6DF8: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6DFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6E00: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB6E04: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB6E08: 4198FFE4  blt cr6, 0x82eb6dec
	if ctx.cr[6].lt {
	pc = 0x82EB6DEC; continue 'dispatch;
	}
	// 82EB6E0C: 48000014  b 0x82eb6e20
	pc = 0x82EB6E20; continue 'dispatch;
	// 82EB6E10: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6E14: 5569103A  slwi r9, r11, 2
	// 82EB6E18: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6E1C: 7EA9512E  stwx r21, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[21].u32) };
	// 82EB6E20: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6E24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6E28: 4198F914  blt cr6, 0x82eb673c
	if ctx.cr[6].lt {
	pc = 0x82EB673C; continue 'dispatch;
	}
	// 82EB6E2C: 556A103A  slwi r10, r11, 2
	// 82EB6E30: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6E34: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6E38: 7EAA592E  stwx r21, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[21].u32) };
	// 82EB6E3C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6E40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6E44: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB6E48: 814EDF34  lwz r10, -0x20cc(r14)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB6E4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6E50: 409AF8EC  bne cr6, 0x82eb673c
	if !ctx.cr[6].eq {
	pc = 0x82EB673C; continue 'dispatch;
	}
	// 82EB6E54: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EB6E58: 382102E0  addi r1, r1, 0x2e0
	ctx.r[1].s64 = ctx.r[1].s64 + 736;
	// 82EB6E5C: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB6E60: 4BDF6EC5  bl 0x82cadd24
	ctx.lr = 0x82EB6E64;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADD24);
	// 82EB6E64: 4BDF25BC  b 0x82ca9420
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9420);
	return;
	// 82EB6E68: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB6E6C: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 82EB6E70: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB6E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6E78: 419A0020  beq cr6, 0x82eb6e98
	if ctx.cr[6].eq {
	pc = 0x82EB6E98; continue 'dispatch;
	}
	// 82EB6E7C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB6E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6E84: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EB6E88: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6E8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6E90: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6E94: 4801D9B5  bl 0x82ed4848
	ctx.lr = 0x82EB6E98;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4848);
	// 82EB6E98: 839C0018  lwz r28, 0x18(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB6E9C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EB6EA0: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6EA4: 4082FFCC  bne 0x82eb6e70
	if !ctx.cr[0].eq {
	pc = 0x82EB6E70; continue 'dispatch;
	}
	// 82EB6EA8: 83A10314  lwz r29, 0x314(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(788 as u32) ) } as u64;
	// 82EB6EAC: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 82EB6EB0: 409A0018  bne cr6, 0x82eb6ec8
	if !ctx.cr[6].eq {
	pc = 0x82EB6EC8; continue 'dispatch;
	}
	// 82EB6EB4: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 82EB6EB8: 80C1031C  lwz r6, 0x31c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(796 as u32) ) } as u64;
	// 82EB6EBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB6EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6EC4: 4BFFF00D  bl 0x82eb5ed0
	ctx.lr = 0x82EB6EC8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5ED0);
	// 82EB6EC8: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 82EB6ECC: 409A0048  bne cr6, 0x82eb6f14
	if !ctx.cr[6].eq {
	pc = 0x82EB6F14; continue 'dispatch;
	}
	// 82EB6ED0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6ED4: 395B0004  addi r10, r27, 4
	ctx.r[10].s64 = ctx.r[27].s64 + 4;
	// 82EB6ED8: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 * 24;
	// 82EB6EDC: 816B01A0  lwz r11, 0x1a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 82EB6EE0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6EE4: 4198001C  blt cr6, 0x82eb6f00
	if ctx.cr[6].lt {
	pc = 0x82EB6F00; continue 'dispatch;
	}
	// 82EB6EE8: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82EB6EEC: 80810090  lwz r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB6EF0: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB6EF4: 4BFD4DE5  bl 0x82e8bcd8
	ctx.lr = 0x82EB6EF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8BCD8);
	// 82EB6EF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6EFC: 4BFFFF5C  b 0x82eb6e58
	pc = 0x82EB6E58; continue 'dispatch;
	// 82EB6F00: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 82EB6F04: 80C1031C  lwz r6, 0x31c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(796 as u32) ) } as u64;
	// 82EB6F08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB6F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6F10: 4BFFEE89  bl 0x82eb5d98
	ctx.lr = 0x82EB6F14;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5D98);
	// 82EB6F14: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82EB6F18: 4BFFFFD4  b 0x82eb6eec
	pc = 0x82EB6EEC; continue 'dispatch;
}

pub fn sub_82EB6F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB6F20 size=3168
	// 82EB6F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB6F24: 4BDF24AD  bl 0x82ca93d0
	ctx.lr = 0x82EB6F28;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93D0);
	// 82EB6F28: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB6F2C: 4BDF6D9D  bl 0x82cadcc8
	ctx.lr = 0x82EB6F30;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCC8);
	// 82EB6F30: 9421FCE0  stwu r1, -0x320(r1)
	ea = ctx.r[1].u32.wrapping_add(-800 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6F34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB6F38: 90E10354  stw r7, 0x354(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(852 as u32), ctx.r[7].u32 ) };
	// 82EB6F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB6F40: 9101035C  stw r8, 0x35c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(860 as u32), ctx.r[8].u32 ) };
	// 82EB6F44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6F48: 91210364  stw r9, 0x364(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(868 as u32), ctx.r[9].u32 ) };
	// 82EB6F4C: 7CAE2B78  mr r14, r5
	ctx.r[14].u64 = ctx.r[5].u64;
	// 82EB6F50: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 82EB6F54: 4801C955  bl 0x82ed38a8
	ctx.lr = 0x82EB6F58;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38A8);
	// 82EB6F58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB6F5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6F60: 41820030  beq 0x82eb6f90
	if ctx.cr[0].eq {
	pc = 0x82EB6F90; continue 'dispatch;
	}
	// 82EB6F64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB6F68: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6F6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB6F70: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB6F74: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6F78: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB6F7C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6F80: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB6F84: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6F88: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB6F8C: 48000A58  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
	// 82EB6F90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6F94: 3D008335  lis r8, -0x7ccb
	ctx.r[8].s64 = -2093678592;
	// 82EB6F98: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB6F9C: 3CE08335  lis r7, -0x7ccb
	ctx.r[7].s64 = -2093678592;
	// 82EB6FA0: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 82EB6FA4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6FA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6FAC: 816B9E48  lwz r11, -0x61b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25016 as u32) ) } as u64;
	// 82EB6FB0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6FB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB6FB8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6FBC: C3CB0C18  lfs f30, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB6FC0: 409A002C  bne cr6, 0x82eb6fec
	if !ctx.cr[6].eq {
	pc = 0x82EB6FEC; continue 'dispatch;
	}
	// 82EB6FC4: 81699E4C  lwz r11, -0x61b4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25012 as u32) ) } as u64;
	// 82EB6FC8: 7F0B7040  cmplw cr6, r11, r14
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[14].u32, &mut ctx.xer);
	// 82EB6FCC: 409A0020  bne cr6, 0x82eb6fec
	if !ctx.cr[6].eq {
	pc = 0x82EB6FEC; continue 'dispatch;
	}
	// 82EB6FD0: 81689E50  lwz r11, -0x61b0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25008 as u32) ) } as u64;
	// 82EB6FD4: 7F0BA040  cmplw cr6, r11, r20
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[20].u32, &mut ctx.xer);
	// 82EB6FD8: 409A0014  bne cr6, 0x82eb6fec
	if !ctx.cr[6].eq {
	pc = 0x82EB6FEC; continue 'dispatch;
	}
	// 82EB6FDC: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB6FE0: 81679E54  lwz r11, -0x61ac(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-25004 as u32) ) } as u64;
	// 82EB6FE4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB6FE8: 419A0110  beq cr6, 0x82eb70f8
	if ctx.cr[6].eq {
	pc = 0x82EB70F8; continue 'dispatch;
	}
	// 82EB6FEC: 93BF0074  stw r29, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82EB6FF0: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EB6FF4: 93BF0078  stw r29, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82EB6FF8: 816A9E3C  lwz r11, -0x61c4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB6FFC: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7000: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB7004: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB7008: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB700C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7010: 554A103A  slwi r10, r10, 2
	// 82EB7014: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB7018: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB701C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7020: 91CB0000  stw r14, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	// 82EB7024: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7028: 556A103A  slwi r10, r11, 2
	// 82EB702C: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7030: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7034: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EB7038: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB703C: 556A103A  slwi r10, r11, 2
	// 82EB7040: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7044: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7048: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB704C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7050: 556A103A  slwi r10, r11, 2
	// 82EB7054: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7058: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB705C: D3CB0014  stfs f30, 0x14(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB7060: 91DE0004  stw r14, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[14].u32 ) };
	// 82EB7064: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7068: C1AE0004  lfs f13, 4(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB706C: C18E0008  lfs f12, 8(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB7070: C00E000C  lfs f0, 0xc(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7074: 929E0004  stw r20, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 82EB7078: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB707C: C1740004  lfs f11, 4(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB7080: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB7084: C1540008  lfs f10, 8(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB7088: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB708C: C134000C  lfs f9, 0xc(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB7090: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB7094: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7098: 556A103A  slwi r10, r11, 2
	// 82EB709C: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB70A0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB70A4: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB70A8: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB70AC: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB70B0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB70B4: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB70B8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB70BC: 556A103A  slwi r10, r11, 2
	// 82EB70C0: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB70C4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB70C8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB70CC: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB70D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB70D4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB70D8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB70DC: 556A103A  slwi r10, r11, 2
	// 82EB70E0: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB70E4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB70E8: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EB70EC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB70F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB70F4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EB70F8: 839F0194  lwz r28, 0x194(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB70FC: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82EB7100: 4B3A98B9  bl 0x822609b8
	ctx.lr = 0x82EB7104;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB7104: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB7108: 4BFCA411  bl 0x82e81518
	ctx.lr = 0x82EB710C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81518);
	// 82EB710C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB7110: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82EB7114: 3AEBDAC0  addi r23, r11, -0x2540
	ctx.r[23].s64 = ctx.r[11].s64 + -9536;
	// 82EB7118: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB711C: 92E100A0  stw r23, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[23].u32 ) };
	// 82EB7120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7124: 419A0018  beq cr6, 0x82eb713c
	if ctx.cr[6].eq {
	pc = 0x82EB713C; continue 'dispatch;
	}
	// 82EB7128: 556B003E  slwi r11, r11, 0
	// 82EB712C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7130: 4E800421  bctrl
	ctx.lr = 0x82EB7134;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB7134: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82EB7138: 48000008  b 0x82eb7140
	pc = 0x82EB7140; continue 'dispatch;
	// 82EB713C: FF80F090  fmr f28, f30
	ctx.f[28].f64 = ctx.f[30].f64;
	// 82EB7140: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB7144: 815F0444  lwz r10, 0x444(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) } as u64;
	// 82EB7148: C1BF044C  lfs f13, 0x44c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB714C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82EB7150: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB7154: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB7158: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82EB715C: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7160: F9410098  std r10, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u64 ) };
	// 82EB7164: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB7168: C9A10098  lfd f13, 0x98(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82EB716C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EB7170: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EB7174: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB7178: C3490BFC  lfs f26, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EB717C: C3080BEC  lfs f24, 0xbec(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3052 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EB7180: 3AA0FFFF  li r21, -1
	ctx.r[21].s64 = -1;
	// 82EB7184: C3270C98  lfs f25, 0xc98(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3224 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EB7188: C36A0C14  lfs f27, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EB718C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EB7190: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB7194: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EB7198: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EB719C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB71A0: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB71A4: 3A4B9128  addi r18, r11, -0x6ed8
	ctx.r[18].s64 = ctx.r[11].s64 + -28376;
	// 82EB71A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB71AC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB71B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB71B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB71B8: 3A2B9F1C  addi r17, r11, -0x60e4
	ctx.r[17].s64 = ctx.r[11].s64 + -24804;
	// 82EB71BC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB71C0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EB71C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB71C8: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EB71CC: 816A9E58  lwz r11, -0x61a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25000 as u32) ) } as u64;
	// 82EB71D0: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82EB71D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB71D8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EB71DC: 916A9E58  stw r11, -0x61a8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25000 as u32), ctx.r[11].u32 ) };
	// 82EB71E0: 409900B4  ble cr6, 0x82eb7294
	if !ctx.cr[6].gt {
	pc = 0x82EB7294; continue 'dispatch;
	}
	// 82EB71E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB71E8: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB71EC: 4BFD4AED  bl 0x82e8bcd8
	ctx.lr = 0x82EB71F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8BCD8);
	// 82EB71F0: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB71F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB71F8: 419A0014  beq cr6, 0x82eb720c
	if ctx.cr[6].eq {
	pc = 0x82EB720C; continue 'dispatch;
	}
	// 82EB71FC: 556B003E  slwi r11, r11, 0
	// 82EB7200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7204: 4E800421  bctrl
	ctx.lr = 0x82EB7208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB7208: 48000008  b 0x82eb7210
	pc = 0x82EB7210; continue 'dispatch;
	// 82EB720C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EB7210: EC01E028  fsubs f0, f1, f28
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EB7214: EFBD0028  fsubs f29, f29, f0
	ctx.f[29].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB7218: FF1DF000  fcmpu cr6, f29, f30
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[30].f64);
	// 82EB721C: 409907D8  ble cr6, 0x82eb79f4
	if !ctx.cr[6].gt {
	pc = 0x82EB79F4; continue 'dispatch;
	}
	// 82EB7220: 7B6A0020  clrldi r10, r27, 0x20
	ctx.r[10].u64 = ctx.r[27].u64 & 0x00000000FFFFFFFFu64;
	// 82EB7224: C1BF044C  lfs f13, 0x44c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB7228: EDBB6828  fsubs f13, f27, f13
	ctx.f[13].f64 = (((ctx.f[27].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB722C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EB7230: 817F0448  lwz r11, 0x448(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82EB7234: F94100A8  std r10, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[10].u64 ) };
	// 82EB7238: EDADD82A  fadds f13, f13, f27
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[27].f64) as f32) as f64;
	// 82EB723C: EDAD06B2  fmuls f13, f13, f26
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[26].f64) as f32) as f64);
	// 82EB7240: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EB7244: C9A100A8  lfd f13, 0xa8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82EB7248: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EB724C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EB7250: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB7254: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EB7258: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EB725C: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 82EB7260: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB7264: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7268: 41990010  bgt cr6, 0x82eb7278
	if ctx.cr[6].gt {
	pc = 0x82EB7278; continue 'dispatch;
	}
	// 82EB726C: 817F0444  lwz r11, 0x444(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) } as u64;
	// 82EB7270: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7274: 4098000C  bge cr6, 0x82eb7280
	if !ctx.cr[6].lt {
	pc = 0x82EB7280; continue 'dispatch;
	}
	// 82EB7278: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82EB727C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82EB7280: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EB7284: FF800890  fmr f28, f1
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82EB7288: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82EB728C: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82EB7290: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EB7294: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7298: FC00C090  fmr f0, f24
	ctx.f[0].f64 = ctx.f[24].f64;
	// 82EB729C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB72A0: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB72A4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB72A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB72AC: 40990044  ble cr6, 0x82eb72f0
	if !ctx.cr[6].gt {
	pc = 0x82EB72F0; continue 'dispatch;
	}
	// 82EB72B0: 5547003E  slwi r7, r10, 0
	// 82EB72B4: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB72B8: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB72BC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EB72C0: 419A0020  beq cr6, 0x82eb72e0
	if ctx.cr[6].eq {
	pc = 0x82EB72E0; continue 'dispatch;
	}
	// 82EB72C4: 54C6003E  slwi r6, r6, 0
	// 82EB72C8: C1A6000C  lfs f13, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB72CC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB72D0: 40980010  bge cr6, 0x82eb72e0
	if !ctx.cr[6].lt {
	pc = 0x82EB72E0; continue 'dispatch;
	}
	// 82EB72D4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EB72D8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB72DC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB72E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB72E4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB72E8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EB72EC: 4198FFCC  blt cr6, 0x82eb72b8
	if ctx.cr[6].lt {
	pc = 0x82EB72B8; continue 'dispatch;
	}
	// 82EB72F0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB72F4: 41820748  beq 0x82eb7a3c
	if ctx.cr[0].eq {
	pc = 0x82EB7A3C; continue 'dispatch;
	}
	// 82EB72F8: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB72FC: 552B103A  slwi r11, r9, 2
	// 82EB7300: 7F0B502E  lwzx r24, r11, r10
	ctx.r[24].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB7304: 7FAB512E  stwx r29, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 82EB7308: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB730C: 7E0B5214  add r16, r11, r10
	ctx.r[16].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB7310: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7314: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7318: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB731C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7320: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB7324: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7328: 81540000  lwz r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB732C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7330: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82EB7334: 556B007F  clrlwi. r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7338: 4182073C  beq 0x82eb7a74
	if ctx.cr[0].eq {
	pc = 0x82EB7A74; continue 'dispatch;
	}
	// 82EB733C: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 82EB7340: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82EB7344: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82EB7348: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82EB734C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82EB7350: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82EB7354: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7358: 4801CEE9  bl 0x82ed4240
	ctx.lr = 0x82EB735C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4240);
	// 82EB735C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB7360: 7FAFEB78  mr r15, r29
	ctx.r[15].u64 = ctx.r[29].u64;
	// 82EB7364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7368: 419A05C4  beq cr6, 0x82eb792c
	if ctx.cr[6].eq {
	pc = 0x82EB792C; continue 'dispatch;
	}
	// 82EB736C: 7FB3EB78  mr r19, r29
	ctx.r[19].u64 = ctx.r[29].u64;
	// 82EB7370: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB7374: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB7378: 7EF3582E  lwzx r23, r19, r11
	ctx.r[23].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB737C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB7380: 7ED3582E  lwzx r22, r19, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7384: D3C10080  stfs f30, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB7388: 8161035C  lwz r11, 0x35c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EB738C: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EB7390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7394: 92DE000C  stw r22, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[22].u32 ) };
	// 82EB7398: 409A0188  bne cr6, 0x82eb7520
	if !ctx.cr[6].eq {
	pc = 0x82EB7520; continue 'dispatch;
	}
	// 82EB739C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB73A0: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 82EB73A4: 556B0FFF  rlwinm. r11, r11, 1, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB73A8: 41820178  beq 0x82eb7520
	if ctx.cr[0].eq {
	pc = 0x82EB7520; continue 'dispatch;
	}
	// 82EB73AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB73B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB73B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73B8: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB73BC: 4801D555  bl 0x82ed4910
	ctx.lr = 0x82EB73C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4910);
	// 82EB73C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB73C4: 41820548  beq 0x82eb790c
	if ctx.cr[0].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB73C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73CC: 4801D3C5  bl 0x82ed4790
	ctx.lr = 0x82EB73D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4790);
	// 82EB73D0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EB73D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73D8: 4BFE2E71  bl 0x82e9a248
	ctx.lr = 0x82EB73DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A248);
	// 82EB73DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB73E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73E4: 4BFE2EE5  bl 0x82e9a2c8
	ctx.lr = 0x82EB73E8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A2C8);
	// 82EB73E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB73EC: 92A10094  stw r21, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[21].u32 ) };
	// 82EB73F0: 39410190  addi r10, r1, 0x190
	ctx.r[10].s64 = ctx.r[1].s64 + 400;
	// 82EB73F4: 92A1007C  stw r21, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[21].u32 ) };
	// 82EB73F8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB73FC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7400: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB7404: 92210090  stw r17, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[17].u32 ) };
	// 82EB7408: 92210078  stw r17, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[17].u32 ) };
	// 82EB740C: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB7410: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7414: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB7418: 91010094  stw r8, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 82EB741C: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7420: 92410180  stw r18, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[18].u32 ) };
	// 82EB7424: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB7428: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 82EB742C: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7430: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB7434: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7438: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB743C: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7440: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82EB7444: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7448: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB744C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7450: 4200FFF8  bdnz 0x82eb7448
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7448; continue 'dispatch;
	}
	// 82EB7454: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EB7458: 9BA101D8  stb r29, 0x1d8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[29].u8 ) };
	// 82EB745C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EB7460: 4B2F7249  bl 0x821ae6a8
	ctx.lr = 0x82EB7464;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB7464: 924100C0  stw r18, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[18].u32 ) };
	// 82EB7468: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB746C: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82EB7470: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EB7474: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB7478: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB747C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB7480: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EB7484: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7488: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EB748C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7490: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7494: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7498: 4200FFF8  bdnz 0x82eb7490
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7490; continue 'dispatch;
	}
	// 82EB749C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82EB74A0: 9BA10118  stb r29, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[29].u8 ) };
	// 82EB74A4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EB74A8: 4B2F7201  bl 0x821ae6a8
	ctx.lr = 0x82EB74AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB74AC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB74B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB74B4: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82EB74B8: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB74BC: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82EB74C0: 38A10180  addi r5, r1, 0x180
	ctx.r[5].s64 = ctx.r[1].s64 + 384;
	// 82EB74C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB74C8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB74CC: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB74D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB74D4: 4E800421  bctrl
	ctx.lr = 0x82EB74D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB74D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB74DC: 4082002C  bne 0x82eb7508
	if !ctx.cr[0].eq {
	pc = 0x82EB7508; continue 'dispatch;
	}
	// 82EB74E0: 897F007E  lbz r11, 0x7e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(126 as u32) ) } as u64;
	// 82EB74E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB74E8: 41820020  beq 0x82eb7508
	if ctx.cr[0].eq {
	pc = 0x82EB7508; continue 'dispatch;
	}
	// 82EB74EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB74F0: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB74F4: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EB74F8: 91610180  stw r11, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82EB74FC: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB7500: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EB7504: 48000408  b 0x82eb790c
	pc = 0x82EB790C; continue 'dispatch;
	// 82EB7508: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB750C: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB7510: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EB7514: 91610180  stw r11, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82EB7518: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB751C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EB7520: C3F80014  lfs f31, 0x14(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB7524: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7528: 41820010  beq 0x82eb7538
	if ctx.cr[0].eq {
	pc = 0x82EB7538; continue 'dispatch;
	}
	// 82EB752C: C0010080  lfs f0, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7530: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB7534: 48000190  b 0x82eb76c4
	pc = 0x82EB76C4; continue 'dispatch;
	// 82EB7538: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB753C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7540: 419A0164  beq cr6, 0x82eb76a4
	if ctx.cr[6].eq {
	pc = 0x82EB76A4; continue 'dispatch;
	}
	// 82EB7544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7548: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EB754C: 4BFE2CFD  bl 0x82e9a248
	ctx.lr = 0x82EB7550;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A248);
	// 82EB7550: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB7554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7558: 4BFE2D71  bl 0x82e9a2c8
	ctx.lr = 0x82EB755C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A2C8);
	// 82EB755C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB7560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7564: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EB7568: 92210070  stw r17, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[17].u32 ) };
	// 82EB756C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7570: 92A10074  stw r21, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[21].u32 ) };
	// 82EB7574: 4801C2BD  bl 0x82ed3830
	ctx.lr = 0x82EB7578;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3830);
	// 82EB7578: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB757C: 392101F0  addi r9, r1, 0x1f0
	ctx.r[9].s64 = ctx.r[1].s64 + 496;
	// 82EB7580: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EB7584: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB7588: 924101E0  stw r18, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[18].u32 ) };
	// 82EB758C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB7590: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7594: D00101E4  stfs f0, 0x1e4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82EB7598: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB759C: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82EB75A0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB75A4: D00101EC  stfs f0, 0x1ec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 82EB75A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB75AC: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB75B0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB75B4: 4200FFF8  bdnz 0x82eb75ac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB75AC; continue 'dispatch;
	}
	// 82EB75B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EB75BC: 9BA10238  stb r29, 0x238(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), ctx.r[29].u8 ) };
	// 82EB75C0: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 82EB75C4: 4B2F70E5  bl 0x821ae6a8
	ctx.lr = 0x82EB75C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB75C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB75CC: 92210088  stw r17, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[17].u32 ) };
	// 82EB75D0: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB75D4: 92A1008C  stw r21, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[21].u32 ) };
	// 82EB75D8: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB75DC: 4801C255  bl 0x82ed3830
	ctx.lr = 0x82EB75E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3830);
	// 82EB75E0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB75E4: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 82EB75E8: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 82EB75EC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB75F0: 92410120  stw r18, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[18].u32 ) };
	// 82EB75F4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB75F8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB75FC: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EB7600: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7604: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EB7608: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB760C: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EB7610: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB7614: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB7618: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB761C: 4200FFF8  bdnz 0x82eb7614
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7614; continue 'dispatch;
	}
	// 82EB7620: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82EB7624: 9BA10178  stb r29, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[29].u8 ) };
	// 82EB7628: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82EB762C: 4B2F707D  bl 0x821ae6a8
	ctx.lr = 0x82EB7630;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EB7630: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7634: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB7638: 38E10098  addi r7, r1, 0x98
	ctx.r[7].s64 = ctx.r[1].s64 + 152;
	// 82EB763C: 38C10120  addi r6, r1, 0x120
	ctx.r[6].s64 = ctx.r[1].s64 + 288;
	// 82EB7640: 38A101E0  addi r5, r1, 0x1e0
	ctx.r[5].s64 = ctx.r[1].s64 + 480;
	// 82EB7644: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB7648: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB764C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7654: 4E800421  bctrl
	ctx.lr = 0x82EB7658;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB7658: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB765C: 40820028  bne 0x82eb7684
	if !ctx.cr[0].eq {
	pc = 0x82EB7684; continue 'dispatch;
	}
	// 82EB7660: 897F007F  lbz r11, 0x7f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(127 as u32) ) } as u64;
	// 82EB7664: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7668: 4182001C  beq 0x82eb7684
	if ctx.cr[0].eq {
	pc = 0x82EB7684; continue 'dispatch;
	}
	// 82EB766C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7670: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82EB7674: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EB7678: 916101E0  stw r11, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EB767C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB7680: 4800028C  b 0x82eb790c
	pc = 0x82EB790C; continue 'dispatch;
	// 82EB7684: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7688: C0010098  lfs f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB768C: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB7690: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82EB7694: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EB7698: 916101E0  stw r11, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EB769C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB76A0: 48000024  b 0x82eb76c4
	pc = 0x82EB76C4; continue 'dispatch;
	// 82EB76A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB76A8: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82EB76AC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB76B0: F96100B0  std r11, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u64 ) };
	// 82EB76B4: C80100B0  lfd f0, 0xb0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82EB76B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EB76BC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EB76C0: EFE0FE7A  fmadds f31, f0, f25, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EB76C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB76C8: 4BFE2C81  bl 0x82e9a348
	ctx.lr = 0x82EB76CC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9A348);
	// 82EB76CC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB76D0: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB76D4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB76D8: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB76DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB76E0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB76E4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB76E8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB76EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB76F0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB76F4: 5565007E  clrlwi r5, r11, 1
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB76F8: 40990060  ble cr6, 0x82eb7758
	if !ctx.cr[6].gt {
	pc = 0x82EB7758; continue 'dispatch;
	}
	// 82EB76FC: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7700: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB7704: 40820054  bne 0x82eb7758
	if !ctx.cr[0].eq {
	pc = 0x82EB7758; continue 'dispatch;
	}
	// 82EB7708: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB770C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB7710: 419A0034  beq cr6, 0x82eb7744
	if ctx.cr[6].eq {
	pc = 0x82EB7744; continue 'dispatch;
	}
	// 82EB7714: 554A003E  slwi r10, r10, 0
	// 82EB7718: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB771C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7720: 554A007E  clrlwi r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB7724: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB7728: 409A001C  bne cr6, 0x82eb7744
	if !ctx.cr[6].eq {
	pc = 0x82EB7744; continue 'dispatch;
	}
	// 82EB772C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7730: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EB7734: C00A0014  lfs f0, 0x14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7738: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB773C: 41990008  bgt cr6, 0x82eb7744
	if ctx.cr[6].gt {
	pc = 0x82EB7744; continue 'dispatch;
	}
	// 82EB7740: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB7744: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7748: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB774C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB7750: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB7754: 4198FFAC  blt cr6, 0x82eb7700
	if ctx.cr[6].lt {
	pc = 0x82EB7700; continue 'dispatch;
	}
	// 82EB7758: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB775C: 408201B0  bne 0x82eb790c
	if !ctx.cr[0].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB7760: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB7764: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EB7768: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB776C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7770: 40990060  ble cr6, 0x82eb77d0
	if !ctx.cr[6].gt {
	pc = 0x82EB77D0; continue 'dispatch;
	}
	// 82EB7774: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7778: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB777C: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB7780: 40820050  bne 0x82eb77d0
	if !ctx.cr[0].eq {
	pc = 0x82EB77D0; continue 'dispatch;
	}
	// 82EB7784: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7788: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB778C: 419A0030  beq cr6, 0x82eb77bc
	if ctx.cr[6].eq {
	pc = 0x82EB77BC; continue 'dispatch;
	}
	// 82EB7790: 554A003E  slwi r10, r10, 0
	// 82EB7794: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7798: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB779C: 5463007E  clrlwi r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB77A0: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB77A4: 409A0018  bne cr6, 0x82eb77bc
	if !ctx.cr[6].eq {
	pc = 0x82EB77BC; continue 'dispatch;
	}
	// 82EB77A8: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB77AC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EB77B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB77B4: 41990008  bgt cr6, 0x82eb77bc
	if ctx.cr[6].gt {
	pc = 0x82EB77BC; continue 'dispatch;
	}
	// 82EB77B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EB77BC: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB77C0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB77C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB77C8: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB77CC: 4198FFB0  blt cr6, 0x82eb777c
	if ctx.cr[6].lt {
	pc = 0x82EB777C; continue 'dispatch;
	}
	// 82EB77D0: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB77D4: 40820138  bne 0x82eb790c
	if !ctx.cr[0].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB77D8: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB77DC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB77E0: 1D0B001C  mulli r8, r11, 0x1c
	ctx.r[8].s64 = ctx.r[11].s64 * 28;
	// 82EB77E4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB77E8: 816B9E3C  lwz r11, -0x61c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB77EC: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB77F0: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EB77F4: 3D008330  lis r8, -0x7cd0
	ctx.r[8].s64 = -2094006272;
	// 82EB77F8: 8108DF34  lwz r8, -0x20cc(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB77FC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB7800: 419A0354  beq cr6, 0x82eb7b54
	if ctx.cr[6].eq {
	pc = 0x82EB7B54; continue 'dispatch;
	}
	// 82EB7804: D3EB0014  stfs f31, 0x14(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB7808: 930B0018  stw r24, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 82EB780C: 92CB0004  stw r22, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 82EB7810: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EB7814: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EB7818: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB781C: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB7820: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB7824: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7828: 929E0004  stw r20, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 82EB782C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7830: C1740004  lfs f11, 4(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB7834: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB7838: C1540008  lfs f10, 8(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB783C: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB7840: C134000C  lfs f9, 0xc(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB7844: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB7848: C10B0014  lfs f8, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB784C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7850: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82EB7854: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB7858: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB785C: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB7860: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB7864: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB7868: EDA0402A  fadds f13, f0, f8
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EB786C: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7870: 419A0008  beq cr6, 0x82eb7878
	if ctx.cr[6].eq {
	pc = 0x82EB7878; continue 'dispatch;
	}
	// 82EB7874: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82EB7878: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EB787C: 409A0090  bne cr6, 0x82eb790c
	if !ctx.cr[6].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB7880: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82EB7884: 419A0010  beq cr6, 0x82eb7894
	if ctx.cr[6].eq {
	pc = 0x82EB7894; continue 'dispatch;
	}
	// 82EB7888: 91700000  stw r11, 0(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB788C: 7FB0EB78  mr r16, r29
	ctx.r[16].u64 = ctx.r[29].u64;
	// 82EB7890: 4800007C  b 0x82eb790c
	pc = 0x82EB790C; continue 'dispatch;
	// 82EB7894: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7898: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EB789C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB78A0: 40990038  ble cr6, 0x82eb78d8
	if !ctx.cr[6].gt {
	pc = 0x82EB78D8; continue 'dispatch;
	}
	// 82EB78A4: 81399E40  lwz r9, -0x61c0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB78A8: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB78AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EB78B0: 419A001C  beq cr6, 0x82eb78cc
	if ctx.cr[6].eq {
	pc = 0x82EB78CC; continue 'dispatch;
	}
	// 82EB78B4: 811F0074  lwz r8, 0x74(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB78B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB78BC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB78C0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB78C4: 4198FFE4  blt cr6, 0x82eb78a8
	if ctx.cr[6].lt {
	pc = 0x82EB78A8; continue 'dispatch;
	}
	// 82EB78C8: 48000010  b 0x82eb78d8
	pc = 0x82EB78D8; continue 'dispatch;
	// 82EB78CC: 81199E40  lwz r8, -0x61c0(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB78D0: 5549103A  slwi r9, r10, 2
	// 82EB78D4: 7D69412E  stwx r11, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	// 82EB78D8: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB78DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB78E0: 4198002C  blt cr6, 0x82eb790c
	if ctx.cr[6].lt {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB78E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB78E8: 5548103A  slwi r8, r10, 2
	// 82EB78EC: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82EB78F0: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB78F4: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EB78F8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB78FC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7900: 816BDF34  lwz r11, -0x20cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB7904: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7908: 419A024C  beq cr6, 0x82eb7b54
	if ctx.cr[6].eq {
	pc = 0x82EB7B54; continue 'dispatch;
	}
	// 82EB790C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB7910: 39EF0001  addi r15, r15, 1
	ctx.r[15].s64 = ctx.r[15].s64 + 1;
	// 82EB7914: 3A730004  addi r19, r19, 4
	ctx.r[19].s64 = ctx.r[19].s64 + 4;
	// 82EB7918: 7F0F5840  cmplw cr6, r15, r11
	ctx.cr[6].compare_u32(ctx.r[15].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB791C: 4198FA54  blt cr6, 0x82eb7370
	if ctx.cr[6].lt {
	pc = 0x82EB7370; continue 'dispatch;
	}
	// 82EB7920: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB7924: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB7928: 82E100A0  lwz r23, 0xa0(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB792C: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB7930: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7934: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB7938: 40990040  ble cr6, 0x82eb7978
	if !ctx.cr[6].gt {
	pc = 0x82EB7978; continue 'dispatch;
	}
	// 82EB793C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7940: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB7944: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7948: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB794C: 419A001C  beq cr6, 0x82eb7968
	if ctx.cr[6].eq {
	pc = 0x82EB7968; continue 'dispatch;
	}
	// 82EB7950: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB7954: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7958: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB795C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB7960: 4198FFE4  blt cr6, 0x82eb7944
	if ctx.cr[6].lt {
	pc = 0x82EB7944; continue 'dispatch;
	}
	// 82EB7964: 48000014  b 0x82eb7978
	pc = 0x82EB7978; continue 'dispatch;
	// 82EB7968: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB796C: 5569103A  slwi r9, r11, 2
	// 82EB7970: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB7974: 7F09512E  stwx r24, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[24].u32) };
	// 82EB7978: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB797C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB7980: 4198F83C  blt cr6, 0x82eb71bc
	if ctx.cr[6].lt {
	pc = 0x82EB71BC; continue 'dispatch;
	}
	// 82EB7984: 556A103A  slwi r10, r11, 2
	// 82EB7988: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB798C: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB7990: 7F0A592E  stwx r24, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[24].u32) };
	// 82EB7994: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82EB7998: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB799C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB79A0: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB79A4: 814ADF34  lwz r10, -0x20cc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB79A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB79AC: 409AF810  bne cr6, 0x82eb71bc
	if !ctx.cr[6].eq {
	pc = 0x82EB71BC; continue 'dispatch;
	}
	// 82EB79B0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB79B4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB79B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB79BC: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB79C0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB79C4: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB79C8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB79CC: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB79D0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB79D4: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB79D8: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB79DC: 4BFD42FD  bl 0x82e8bcd8
	ctx.lr = 0x82EB79E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8BCD8);
	// 82EB79E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB79E4: 38210320  addi r1, r1, 0x320
	ctx.r[1].s64 = ctx.r[1].s64 + 800;
	// 82EB79E8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB79EC: 4BDF6329  bl 0x82cadd14
	ctx.lr = 0x82EB79F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADD14);
	// 82EB79F0: 4BDF1A30  b 0x82ca9420
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9420);
	return;
	// 82EB79F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB79F8: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB79FC: 4B3A8FBD  bl 0x822609b8
	ctx.lr = 0x82EB7A00;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB7A00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB7A04: 4BFC9C05  bl 0x82e81608
	ctx.lr = 0x82EB7A08;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81608);
	// 82EB7A08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7A0C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A10: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82EB7A14: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB7A18: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7A1C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7A20: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A24: 91CB9E4C  stw r14, -0x61b4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25012 as u32), ctx.r[14].u32 ) };
	// 82EB7A28: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7A2C: 928B9E50  stw r20, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[20].u32 ) };
	// 82EB7A30: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB7A34: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7A38: 4BFFFFAC  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
	// 82EB7A3C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7A40: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB7A48: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7A4C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A50: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7A54: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A58: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB7A5C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7A60: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB7A64: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB7A68: 4BFD4271  bl 0x82e8bcd8
	ctx.lr = 0x82EB7A6C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8BCD8);
	// 82EB7A6C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82EB7A70: 4BFFFF74  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
	// 82EB7A74: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7A78: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A7C: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB7A80: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82EB7A84: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7A88: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A8C: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7A90: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A94: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB7A98: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A9C: 916A9E50  stw r11, -0x61b0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25008 as u32), ctx.r[11].u32 ) };
	// 82EB7AA0: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB7AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7AA8: 419A0020  beq cr6, 0x82eb7ac8
	if ctx.cr[6].eq {
	pc = 0x82EB7AC8; continue 'dispatch;
	}
	// 82EB7AAC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7AB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7AB4: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EB7AB8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB7ABC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7AC0: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB7AC4: 4801CD85  bl 0x82ed4848
	ctx.lr = 0x82EB7AC8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4848);
	// 82EB7AC8: 839C0018  lwz r28, 0x18(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB7ACC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EB7AD0: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7AD4: 4082FFCC  bne 0x82eb7aa0
	if !ctx.cr[0].eq {
	pc = 0x82EB7AA0; continue 'dispatch;
	}
	// 82EB7AD8: 83A10354  lwz r29, 0x354(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(852 as u32) ) } as u64;
	// 82EB7ADC: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 82EB7AE0: 409A0018  bne cr6, 0x82eb7af8
	if !ctx.cr[6].eq {
	pc = 0x82EB7AF8; continue 'dispatch;
	}
	// 82EB7AE4: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EB7AE8: 80C1035C  lwz r6, 0x35c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EB7AEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB7AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB7AF4: 4BFFE3DD  bl 0x82eb5ed0
	ctx.lr = 0x82EB7AF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5ED0);
	// 82EB7AF8: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 82EB7AFC: 409A0048  bne cr6, 0x82eb7b44
	if !ctx.cr[6].eq {
	pc = 0x82EB7B44; continue 'dispatch;
	}
	// 82EB7B00: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7B04: 395B0004  addi r10, r27, 4
	ctx.r[10].s64 = ctx.r[27].s64 + 4;
	// 82EB7B08: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 * 24;
	// 82EB7B0C: 816B01A0  lwz r11, 0x1a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 82EB7B10: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7B14: 4198001C  blt cr6, 0x82eb7b30
	if ctx.cr[6].lt {
	pc = 0x82EB7B30; continue 'dispatch;
	}
	// 82EB7B18: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82EB7B1C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB7B20: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB7B24: 4BFD41B5  bl 0x82e8bcd8
	ctx.lr = 0x82EB7B28;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8BCD8);
	// 82EB7B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7B2C: 4BFFFEB8  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
	// 82EB7B30: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EB7B34: 80C1035C  lwz r6, 0x35c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EB7B38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB7B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB7B40: 4BFFE259  bl 0x82eb5d98
	ctx.lr = 0x82EB7B44;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5D98);
	// 82EB7B44: 81610364  lwz r11, 0x364(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EB7B48: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82EB7B4C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82EB7B50: 4BFFFFCC  b 0x82eb7b1c
	pc = 0x82EB7B1C; continue 'dispatch;
	// 82EB7B54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7B58: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7B5C: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7B60: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7B64: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7B68: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7B6C: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB7B70: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7B74: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB7B78: 4BFFFFA0  b 0x82eb7b18
	pc = 0x82EB7B18; continue 'dispatch;
}

pub fn sub_82EB7B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB7B80 size=16
	// 82EB7B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB7B84: 4BDF1875  bl 0x82ca93f8
	ctx.lr = 0x82EB7B88;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93F8);
	// 82EB7B88: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82EB7B8C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EB7F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB7F80 size=968
	// 82EB7F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB7F84: 4BDF1485  bl 0x82ca9408
	ctx.lr = 0x82EB7F88;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EB7F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB7F8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB7F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB7F94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB7F98: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82EB7F9C: 397F0334  addi r11, r31, 0x334
	ctx.r[11].s64 = ctx.r[31].s64 + 820;
	// 82EB7FA0: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7FA4: 395F027C  addi r10, r31, 0x27c
	ctx.r[10].s64 = ctx.r[31].s64 + 636;
	// 82EB7FA8: 393F03A4  addi r9, r31, 0x3a4
	ctx.r[9].s64 = ctx.r[31].s64 + 932;
	// 82EB7FAC: 93DF0390  stw r30, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[30].u32 ) };
	// 82EB7FB0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB7FB4: 911F03A0  stw r8, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[8].u32 ) };
	// 82EB7FB8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB7FBC: 9BDF0396  stb r30, 0x396(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(918 as u32), ctx.r[30].u8 ) };
	// 82EB7FC0: 9BDF0397  stb r30, 0x397(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(919 as u32), ctx.r[30].u8 ) };
	// 82EB7FC4: 9BDF0395  stb r30, 0x395(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(917 as u32), ctx.r[30].u8 ) };
	// 82EB7FC8: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	// 82EB7FCC: 9BDF0400  stb r30, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	// 82EB7FD0: C1A80C1C  lfs f13, 0xc1c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB7FD4: 9BDF0435  stb r30, 0x435(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1077 as u32), ctx.r[30].u8 ) };
	// 82EB7FD8: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7FDC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB7FE0: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7FE4: 9BCB0058  stb r30, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB7FE8: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7FEC: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB7FF0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7FF4: 9BCA0058  stb r30, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB7FF8: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7FFC: D0090008  stfs f0, 8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB8000: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB8004: 9BC90058  stb r30, 0x58(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB8008: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB800C: D1BF0424  stfs f13, 0x424(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	// 82EB8010: D1BF0438  stfs f13, 0x438(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), tmp.u32 ) };
	// 82EB8014: 9BDF0394  stb r30, 0x394(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[30].u8 ) };
	// 82EB8018: 9BDF019D  stb r30, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[30].u8 ) };
	// 82EB801C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8020: 40990034  ble cr6, 0x82eb8054
	if !ctx.cr[6].gt {
	pc = 0x82EB8054; continue 'dispatch;
	}
	// 82EB8024: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB8028: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EB802C: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8030: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8034: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8038: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB803C: 4E800421  bctrl
	ctx.lr = 0x82EB8040;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8040: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB8044: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB8048: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EB804C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8050: 4198FFD8  blt cr6, 0x82eb8028
	if ctx.cr[6].lt {
	pc = 0x82EB8028; continue 'dispatch;
	}
	// 82EB8054: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EB8058: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB805C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8060: 40990034  ble cr6, 0x82eb8094
	if !ctx.cr[6].gt {
	pc = 0x82EB8094; continue 'dispatch;
	}
	// 82EB8064: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8068: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB806C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8070: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8074: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB807C: 4E800421  bctrl
	ctx.lr = 0x82EB8080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8080: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EB8084: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8088: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB808C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8090: 4198FFD8  blt cr6, 0x82eb8068
	if ctx.cr[6].lt {
	pc = 0x82EB8068; continue 'dispatch;
	}
	// 82EB8094: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EB8098: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB809C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB80A0: 40990034  ble cr6, 0x82eb80d4
	if !ctx.cr[6].gt {
	pc = 0x82EB80D4; continue 'dispatch;
	}
	// 82EB80A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB80A8: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EB80AC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB80B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB80B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB80B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB80BC: 4E800421  bctrl
	ctx.lr = 0x82EB80C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB80C0: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EB80C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB80C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB80CC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB80D0: 4198FFD8  blt cr6, 0x82eb80a8
	if ctx.cr[6].lt {
	pc = 0x82EB80A8; continue 'dispatch;
	}
	// 82EB80D4: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EB80D8: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB80DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB80E0: 40990034  ble cr6, 0x82eb8114
	if !ctx.cr[6].gt {
	pc = 0x82EB8114; continue 'dispatch;
	}
	// 82EB80E4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB80E8: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EB80EC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB80F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB80F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB80F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB80FC: 4E800421  bctrl
	ctx.lr = 0x82EB8100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8100: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EB8104: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8108: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB810C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8110: 4198FFD8  blt cr6, 0x82eb80e8
	if ctx.cr[6].lt {
	pc = 0x82EB80E8; continue 'dispatch;
	}
	// 82EB8114: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EB8118: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB811C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8120: 40990034  ble cr6, 0x82eb8154
	if !ctx.cr[6].gt {
	pc = 0x82EB8154; continue 'dispatch;
	}
	// 82EB8124: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8128: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EB812C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8130: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8134: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB813C: 4E800421  bctrl
	ctx.lr = 0x82EB8140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8140: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EB8144: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8148: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB814C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8150: 4198FFD8  blt cr6, 0x82eb8128
	if ctx.cr[6].lt {
	pc = 0x82EB8128; continue 'dispatch;
	}
	// 82EB8154: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EB8158: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB815C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8160: 40990034  ble cr6, 0x82eb8194
	if !ctx.cr[6].gt {
	pc = 0x82EB8194; continue 'dispatch;
	}
	// 82EB8164: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8168: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EB816C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8174: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB817C: 4E800421  bctrl
	ctx.lr = 0x82EB8180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8180: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EB8184: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8188: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB818C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8190: 4198FFD8  blt cr6, 0x82eb8168
	if ctx.cr[6].lt {
	pc = 0x82EB8168; continue 'dispatch;
	}
	// 82EB8194: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EB8198: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB819C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB81A0: 40990034  ble cr6, 0x82eb81d4
	if !ctx.cr[6].gt {
	pc = 0x82EB81D4; continue 'dispatch;
	}
	// 82EB81A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB81A8: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EB81AC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB81B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB81B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB81B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB81BC: 4E800421  bctrl
	ctx.lr = 0x82EB81C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB81C0: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EB81C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB81C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB81CC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB81D0: 4198FFD8  blt cr6, 0x82eb81a8
	if ctx.cr[6].lt {
	pc = 0x82EB81A8; continue 'dispatch;
	}
	// 82EB81D4: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EB81D8: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB81DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB81E0: 40990034  ble cr6, 0x82eb8214
	if !ctx.cr[6].gt {
	pc = 0x82EB8214; continue 'dispatch;
	}
	// 82EB81E4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB81E8: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EB81EC: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB81F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB81F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB81F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB81FC: 4E800421  bctrl
	ctx.lr = 0x82EB8200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8200: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EB8204: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8208: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB820C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8210: 4198FFD8  blt cr6, 0x82eb81e8
	if ctx.cr[6].lt {
	pc = 0x82EB81E8; continue 'dispatch;
	}
	// 82EB8214: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EB8218: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB821C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8220: 40990034  ble cr6, 0x82eb8254
	if !ctx.cr[6].gt {
	pc = 0x82EB8254; continue 'dispatch;
	}
	// 82EB8224: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8228: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EB822C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB8230: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8234: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB823C: 4E800421  bctrl
	ctx.lr = 0x82EB8240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8240: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EB8244: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8248: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB824C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8250: 4198FFD8  blt cr6, 0x82eb8228
	if ctx.cr[6].lt {
	pc = 0x82EB8228; continue 'dispatch;
	}
	// 82EB8254: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EB8258: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB825C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8260: 40990034  ble cr6, 0x82eb8294
	if !ctx.cr[6].gt {
	pc = 0x82EB8294; continue 'dispatch;
	}
	// 82EB8264: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB8268: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EB826C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB8270: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8274: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8278: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB827C: 4E800421  bctrl
	ctx.lr = 0x82EB8280;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8280: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EB8284: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8288: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB828C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8290: 4198FFD8  blt cr6, 0x82eb8268
	if ctx.cr[6].lt {
	pc = 0x82EB8268; continue 'dispatch;
	}
	// 82EB8294: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EB8298: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB829C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB82A0: 40990034  ble cr6, 0x82eb82d4
	if !ctx.cr[6].gt {
	pc = 0x82EB82D4; continue 'dispatch;
	}
	// 82EB82A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB82A8: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EB82AC: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB82B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB82B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB82B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB82BC: 4E800421  bctrl
	ctx.lr = 0x82EB82C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB82C0: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EB82C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB82C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB82CC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB82D0: 4198FFD8  blt cr6, 0x82eb82a8
	if ctx.cr[6].lt {
	pc = 0x82EB82A8; continue 'dispatch;
	}
	// 82EB82D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB82D8: 4BFFDEC9  bl 0x82eb61a0
	ctx.lr = 0x82EB82DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB61A0);
	// 82EB82DC: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB82E0: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EB82E4: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EB82E8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB82EC: 41820024  beq 0x82eb8310
	if ctx.cr[0].eq {
	pc = 0x82EB8310; continue 'dispatch;
	}
	// 82EB82F0: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB82F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB82F8: 41820018  beq 0x82eb8310
	if ctx.cr[0].eq {
	pc = 0x82EB8310; continue 'dispatch;
	}
	// 82EB82FC: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB8300: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8304: 4182000C  beq 0x82eb8310
	if ctx.cr[0].eq {
	pc = 0x82EB8310; continue 'dispatch;
	}
	// 82EB8308: 4801AC29  bl 0x82ed2f30
	ctx.lr = 0x82EB830C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB830C: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB8310: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB8314: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8318: 41820024  beq 0x82eb833c
	if ctx.cr[0].eq {
	pc = 0x82EB833C; continue 'dispatch;
	}
	// 82EB831C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8320: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8324: 41820018  beq 0x82eb833c
	if ctx.cr[0].eq {
	pc = 0x82EB833C; continue 'dispatch;
	}
	// 82EB8328: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB832C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8330: 4182000C  beq 0x82eb833c
	if ctx.cr[0].eq {
	pc = 0x82EB833C; continue 'dispatch;
	}
	// 82EB8334: 4801ABFD  bl 0x82ed2f30
	ctx.lr = 0x82EB8338;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB8338: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB833C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB8340: 4BDF1118  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EB8348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB8348 size=2008
	// 82EB8348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB834C: 4BDF10A9  bl 0x82ca93f4
	ctx.lr = 0x82EB8350;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93F4);
	// 82EB8350: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82EB8354: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB8358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB835C: 839F0054  lwz r28, 0x54(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8360: 817C01A4  lwz r11, 0x1a4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EB8364: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB8368: 408200F4  bne 0x82eb845c
	if !ctx.cr[0].eq {
	pc = 0x82EB845C; continue 'dispatch;
	}
	// 82EB836C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8370: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB8374: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB8378: 419A006C  beq cr6, 0x82eb83e4
	if ctx.cr[6].eq {
	pc = 0x82EB83E4; continue 'dispatch;
	}
	// 82EB837C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8380: 816301A8  lwz r11, 0x1a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EB8384: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 82EB8388: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB838C: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8390: 40820038  bne 0x82eb83c8
	if !ctx.cr[0].eq {
	pc = 0x82EB83C8; continue 'dispatch;
	}
	// 82EB8394: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8398: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB839C: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB83A0: 419A0770  beq cr6, 0x82eb8b10
	if ctx.cr[6].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB83A4: 4BFFDFFD  bl 0x82eb63a0
	ctx.lr = 0x82EB83A8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB63A0);
	// 82EB83A8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB83AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB83B0: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB83B4: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB83B8: 5529103A  slwi r9, r9, 2
	// 82EB83BC: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB83C0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB83C4: 4BFFFFB8  b 0x82eb837c
	pc = 0x82EB837C; continue 'dispatch;
	// 82EB83C8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB83CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB83D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB83D4: 914B01A4  stw r10, 0x1a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), ctx.r[10].u32 ) };
	// 82EB83D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB83DC: 912B01AC  stw r9, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[9].u32 ) };
	// 82EB83E0: 48000730  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB83E4: 817C01B8  lwz r11, 0x1b8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB83E8: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB83EC: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82EB83F0: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB83F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB83F8: 409A0028  bne cr6, 0x82eb8420
	if !ctx.cr[6].eq {
	pc = 0x82EB8420; continue 'dispatch;
	}
	// 82EB83FC: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8400: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8404: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8408: 409A0018  bne cr6, 0x82eb8420
	if !ctx.cr[6].eq {
	pc = 0x82EB8420; continue 'dispatch;
	}
	// 82EB840C: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8410: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB8414: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8418: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB841C: 419A0008  beq cr6, 0x82eb8424
	if ctx.cr[6].eq {
	pc = 0x82EB8424; continue 'dispatch;
	}
	// 82EB8420: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82EB8424: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB8428: 418206E8  beq 0x82eb8b10
	if ctx.cr[0].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB842C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB8430: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8434: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB8438: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB843C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB8440: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8444: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB8448: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB844C: 814B01B8  lwz r10, 0x1b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB8450: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EB8454: 914B01B8  stw r10, 0x1b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), ctx.r[10].u32 ) };
	// 82EB8458: 480006B8  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB845C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB8460: 409A06B0  bne cr6, 0x82eb8b10
	if !ctx.cr[6].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8464: 817C01BC  lwz r11, 0x1bc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB8468: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EB846C: 815C01B8  lwz r10, 0x1b8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB8470: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82EB8474: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82EB8478: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB847C: 419A0030  beq cr6, 0x82eb84ac
	if ctx.cr[6].eq {
	pc = 0x82EB84AC; continue 'dispatch;
	}
	// 82EB8480: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EB8484: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82EB8488: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EB848C: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 82EB8490: 41990680  bgt cr6, 0x82eb8b10
	if ctx.cr[6].gt {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8494: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82EB8498: 4098000C  bge cr6, 0x82eb84a4
	if !ctx.cr[6].lt {
	pc = 0x82EB84A4; continue 'dispatch;
	}
	// 82EB849C: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 82EB84A0: 48000010  b 0x82eb84b0
	pc = 0x82EB84B0; continue 'dispatch;
	// 82EB84A4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EB84A8: 40980008  bge cr6, 0x82eb84b0
	if !ctx.cr[6].lt {
	pc = 0x82EB84B0; continue 'dispatch;
	}
	// 82EB84AC: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 82EB84B0: 817C01AC  lwz r11, 0x1ac(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB84B4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB84B8: 40820324  bne 0x82eb87dc
	if !ctx.cr[0].eq {
	pc = 0x82EB87DC; continue 'dispatch;
	}
	// 82EB84BC: 817C0194  lwz r11, 0x194(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB84C0: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82EB84C4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB84C8: 38CB0010  addi r6, r11, 0x10
	ctx.r[6].s64 = ctx.r[11].s64 + 16;
	// 82EB84CC: 83C60008  lwz r30, 8(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB84D0: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB84D4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB84D8: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 82EB84DC: 556B103A  slwi r11, r11, 2
	// 82EB84E0: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB84E4: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB84E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB84EC: 409A0028  bne cr6, 0x82eb8514
	if !ctx.cr[6].eq {
	pc = 0x82EB8514; continue 'dispatch;
	}
	// 82EB84F0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB84F4: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB84F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB84FC: 409A0018  bne cr6, 0x82eb8514
	if !ctx.cr[6].eq {
	pc = 0x82EB8514; continue 'dispatch;
	}
	// 82EB8500: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8504: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82EB8508: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB850C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8510: 419A0008  beq cr6, 0x82eb8518
	if ctx.cr[6].eq {
	pc = 0x82EB8518; continue 'dispatch;
	}
	// 82EB8514: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82EB8518: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB851C: 4182001C  beq 0x82eb8538
	if ctx.cr[0].eq {
	pc = 0x82EB8538; continue 'dispatch;
	}
	// 82EB8520: 92FC01A4  stw r23, 0x1a4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(420 as u32), ctx.r[23].u32 ) };
	// 82EB8524: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8528: 4BFFDDE9  bl 0x82eb6310
	ctx.lr = 0x82EB852C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB6310);
	// 82EB852C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8530: 4BFFFE19  bl 0x82eb8348
	ctx.lr = 0x82EB8534;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB8348);
	// 82EB8534: 480005DC  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB8538: A15E0010  lhz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB853C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8540: 40820080  bne 0x82eb85c0
	if !ctx.cr[0].eq {
	pc = 0x82EB85C0; continue 'dispatch;
	}
	// 82EB8544: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8548: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB854C: 40820074  bne 0x82eb85c0
	if !ctx.cr[0].eq {
	pc = 0x82EB85C0; continue 'dispatch;
	}
	// 82EB8550: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB8554: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EB8558: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EB855C: 4BFFD745  bl 0x82eb5ca0
	ctx.lr = 0x82EB8560;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5CA0);
	// 82EB8560: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8564: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8568: 419A002C  beq cr6, 0x82eb8594
	if ctx.cr[6].eq {
	pc = 0x82EB8594; continue 'dispatch;
	}
	// 82EB856C: A1670012  lhz r11, 0x12(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8570: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8574: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 82EB8578: 556B103A  slwi r11, r11, 2
	// 82EB857C: 7CEB3A14  add r7, r11, r7
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82EB8580: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82EB8584: 4BFFD71D  bl 0x82eb5ca0
	ctx.lr = 0x82EB8588;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5CA0);
	// 82EB8588: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB858C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8590: 409AFFDC  bne cr6, 0x82eb856c
	if !ctx.cr[6].eq {
	pc = 0x82EB856C; continue 'dispatch;
	}
	// 82EB8594: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8598: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB859C: 1D2A000C  mulli r9, r10, 0xc
	ctx.r[9].s64 = ctx.r[10].s64 * 12;
	// 82EB85A0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB85A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EB85A8: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB85AC: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB85B0: 912B0198  stw r9, 0x198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(408 as u32), ctx.r[9].u32 ) };
	// 82EB85B4: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB85B8: 4BFFDD59  bl 0x82eb6310
	ctx.lr = 0x82EB85BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB6310);
	// 82EB85BC: 48000554  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB85C0: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB85C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB85C8: 419800A8  blt cr6, 0x82eb8670
	if ctx.cr[6].lt {
	pc = 0x82EB8670; continue 'dispatch;
	}
	// 82EB85CC: 419A00A4  beq cr6, 0x82eb8670
	if ctx.cr[6].eq {
	pc = 0x82EB8670; continue 'dispatch;
	}
	// 82EB85D0: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB85D4: 480199CD  bl 0x82ed1fa0
	ctx.lr = 0x82EB85D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FA0);
	// 82EB85D8: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB85DC: 3B7E0014  addi r27, r30, 0x14
	ctx.r[27].s64 = ctx.r[30].s64 + 20;
	// 82EB85E0: 835F0054  lwz r26, 0x54(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB85E4: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82EB85E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB85EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB85F0: C3EB0C14  lfs f31, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB85F4: 41820034  beq 0x82eb8628
	if ctx.cr[0].eq {
	pc = 0x82EB8628; continue 'dispatch;
	}
	// 82EB85F8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB85FC: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8600: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB8604: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8608: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB860C: 4801A73D  bl 0x82ed2d48
	ctx.lr = 0x82EB8610;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB8610: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB8614: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8618: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB861C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EB8620: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8624: 4198FFD4  blt cr6, 0x82eb85f8
	if ctx.cr[6].lt {
	pc = 0x82EB85F8; continue 'dispatch;
	}
	// 82EB8628: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB862C: 3B9D0014  addi r28, r29, 0x14
	ctx.r[28].s64 = ctx.r[29].s64 + 20;
	// 82EB8630: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EB8634: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8638: 41820190  beq 0x82eb87c8
	if ctx.cr[0].eq {
	pc = 0x82EB87C8; continue 'dispatch;
	}
	// 82EB863C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8640: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8644: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB8648: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB864C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8650: 4801A6F9  bl 0x82ed2d48
	ctx.lr = 0x82EB8654;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB8654: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB8658: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB865C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB8660: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EB8664: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8668: 4198FFD4  blt cr6, 0x82eb863c
	if ctx.cr[6].lt {
	pc = 0x82EB863C; continue 'dispatch;
	}
	// 82EB866C: 4800015C  b 0x82eb87c8
	pc = 0x82EB87C8; continue 'dispatch;
	// 82EB8670: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8674: 4801992D  bl 0x82ed1fa0
	ctx.lr = 0x82EB8678;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FA0);
	// 82EB8678: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB867C: 3B7E0014  addi r27, r30, 0x14
	ctx.r[27].s64 = ctx.r[30].s64 + 20;
	// 82EB8680: 835F0054  lwz r26, 0x54(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8684: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82EB8688: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB868C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8690: C3EB0C14  lfs f31, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB8694: 41820034  beq 0x82eb86c8
	if ctx.cr[0].eq {
	pc = 0x82EB86C8; continue 'dispatch;
	}
	// 82EB8698: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB869C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB86A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB86A4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB86A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB86AC: 4801A69D  bl 0x82ed2d48
	ctx.lr = 0x82EB86B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB86B0: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB86B4: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB86B8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB86BC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EB86C0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB86C4: 4198FFD4  blt cr6, 0x82eb8698
	if ctx.cr[6].lt {
	pc = 0x82EB8698; continue 'dispatch;
	}
	// 82EB86C8: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB86CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB86D0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB86D4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB86D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB86DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB86E0: 556B103A  slwi r11, r11, 2
	// 82EB86E4: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB86E8: 4801A661  bl 0x82ed2d48
	ctx.lr = 0x82EB86EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB86EC: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB86F0: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB86F4: A15E0010  lhz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB86F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB86FC: 409800CC  bge cr6, 0x82eb87c8
	if !ctx.cr[6].lt {
	pc = 0x82EB87C8; continue 'dispatch;
	}
	// 82EB8700: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8704: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8708: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB870C: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82EB8710: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EB8714: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82EB8718: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82EB871C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8720: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82EB8724: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB8728: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EB872C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB8730: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB8734: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8738: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB873C: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB8740: C02B4DDC  lfs f1, 0x4ddc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19932 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB8744: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8748: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB874C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8750: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB8754: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB8758: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB875C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EB8760: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8764: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB8768: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB876C: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB8770: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EB8774: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8778: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB877C: A0DE0010  lhz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8780: 48019919  bl 0x82ed2098
	ctx.lr = 0x82EB8784;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2098);
	// 82EB8784: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB8788: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EB878C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8790: 419A0038  beq cr6, 0x82eb87c8
	if ctx.cr[6].eq {
	pc = 0x82EB87C8; continue 'dispatch;
	}
	// 82EB8794: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82EB8798: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB879C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB87A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB87A4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB87A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB87AC: 4801A59D  bl 0x82ed2d48
	ctx.lr = 0x82EB87B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB87B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB87B4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB87B8: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB87BC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB87C0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB87C4: 4198FFD4  blt cr6, 0x82eb8798
	if ctx.cr[6].lt {
	pc = 0x82EB8798; continue 'dispatch;
	}
	// 82EB87C8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB87CC: 480197F5  bl 0x82ed1fc0
	ctx.lr = 0x82EB87D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FC0);
	// 82EB87D0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB87D4: 930B01AC  stw r24, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[24].u32 ) };
	// 82EB87D8: 48000338  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB87DC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB87E0: 409A0050  bne cr6, 0x82eb8830
	if !ctx.cr[6].eq {
	pc = 0x82EB8830; continue 'dispatch;
	}
	// 82EB87E4: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB87E8: 4801B069  bl 0x82ed3850
	ctx.lr = 0x82EB87EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB87EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB87F0: 41820014  beq 0x82eb8804
	if ctx.cr[0].eq {
	pc = 0x82EB8804; continue 'dispatch;
	}
	// 82EB87F4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB87F8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EB87FC: 914B01AC  stw r10, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[10].u32 ) };
	// 82EB8800: 48000310  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB8804: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB8808: 4801B0A1  bl 0x82ed38a8
	ctx.lr = 0x82EB880C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38A8);
	// 82EB880C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8810: 41820300  beq 0x82eb8b10
	if ctx.cr[0].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8814: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8818: 92EB01AC  stw r23, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[23].u32 ) };
	// 82EB881C: 809C01B0  lwz r4, 0x1b0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB8820: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8824: 4801A70D  bl 0x82ed2f30
	ctx.lr = 0x82EB8828;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB8828: 92FC01B0  stw r23, 0x1b0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(432 as u32), ctx.r[23].u32 ) };
	// 82EB882C: 480002E4  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
	// 82EB8830: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB8834: 409A02DC  bne cr6, 0x82eb8b10
	if !ctx.cr[6].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8838: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB883C: 4801B015  bl 0x82ed3850
	ctx.lr = 0x82EB8840;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB8840: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8844: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8848: 4182FF8C  beq 0x82eb87d4
	if ctx.cr[0].eq {
	pc = 0x82EB87D4; continue 'dispatch;
	}
	// 82EB884C: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8850: 836B01B0  lwz r27, 0x1b0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB8854: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82EB8858: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB885C: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82EB8860: 7FAA582E  lwzx r29, r10, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8864: A13D0012  lhz r9, 0x12(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8868: A15D0010  lhz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB886C: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8870: 5529103A  slwi r9, r9, 2
	// 82EB8874: 7F89EA14  add r28, r9, r29
	ctx.r[28].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 82EB8878: A13C0010  lhz r9, 0x10(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB887C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB8880: 409800DC  bge cr6, 0x82eb895c
	if !ctx.cr[6].lt {
	pc = 0x82EB895C; continue 'dispatch;
	}
	// 82EB8884: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8888: 4801B051  bl 0x82ed38d8
	ctx.lr = 0x82EB888C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB888C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8890: 4801D009  bl 0x82ed5898
	ctx.lr = 0x82EB8894;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5898);
	// 82EB8894: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB8898: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB889C: 409A0014  bne cr6, 0x82eb88b0
	if !ctx.cr[6].eq {
	pc = 0x82EB88B0; continue 'dispatch;
	}
	// 82EB88A0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB88A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB88A8: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB88AC: 48000268  b 0x82eb8b14
	pc = 0x82EB8B14; continue 'dispatch;
	// 82EB88B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB88B4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB88B8: 4801B021  bl 0x82ed38d8
	ctx.lr = 0x82EB88BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB88BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB88C0: 4082000C  bne 0x82eb88cc
	if !ctx.cr[0].eq {
	pc = 0x82EB88CC; continue 'dispatch;
	}
	// 82EB88C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB88C8: 4800024C  b 0x82eb8b14
	pc = 0x82EB8B14; continue 'dispatch;
	// 82EB88CC: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB88D0: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EB88D4: 419AFFF0  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB88D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB88DC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB88E0: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB88E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB88E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB88EC: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB88F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB88F4: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB88F8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB88FC: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8900: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB8904: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82EB8908: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB890C: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82EB8910: 554B003E  slwi r11, r10, 0
	// 82EB8914: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB8918: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB891C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB8920: A11D0010  lhz r8, 0x10(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8924: 4BFFDC85  bl 0x82eb65a8
	ctx.lr = 0x82EB8928;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB65A8);
	// 82EB8928: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB892C: 419AFF98  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB8930: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8934: 408101C0  ble 0x82eb8af4
	if !ctx.cr[0].gt {
	pc = 0x82EB8AF4; continue 'dispatch;
	}
	// 82EB8938: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB893C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8940: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8944: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8948: 5529103A  slwi r9, r9, 2
	// 82EB894C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB8950: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB8954: 4082FFE4  bne 0x82eb8938
	if !ctx.cr[0].eq {
	pc = 0x82EB8938; continue 'dispatch;
	}
	// 82EB8958: 4800019C  b 0x82eb8af4
	pc = 0x82EB8AF4; continue 'dispatch;
	// 82EB895C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8960: 409A00DC  bne cr6, 0x82eb8a3c
	if !ctx.cr[6].eq {
	pc = 0x82EB8A3C; continue 'dispatch;
	}
	// 82EB8964: 4801AF75  bl 0x82ed38d8
	ctx.lr = 0x82EB8968;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB8968: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB896C: 4182FF34  beq 0x82eb88a0
	if ctx.cr[0].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8970: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8974: 4801CF25  bl 0x82ed5898
	ctx.lr = 0x82EB8978;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5898);
	// 82EB8978: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB897C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB8980: 419AFF20  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8984: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8988: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB898C: 4801AF4D  bl 0x82ed38d8
	ctx.lr = 0x82EB8990;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB8990: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8994: 4182FF0C  beq 0x82eb88a0
	if ctx.cr[0].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8998: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB899C: 4801CEFD  bl 0x82ed5898
	ctx.lr = 0x82EB89A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5898);
	// 82EB89A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB89A4: 2F06FFFF  cmpwi cr6, r6, -1
	ctx.cr[6].compare_i32(ctx.r[6].s32, -1, &mut ctx.xer);
	// 82EB89A8: 419AFEF8  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB89AC: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EB89B0: 419AFEF0  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB89B4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB89B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB89BC: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB89C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB89C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB89C8: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB89CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB89D0: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB89D4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB89D8: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB89DC: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB89E0: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82EB89E4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB89E8: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82EB89EC: 554B003E  slwi r11, r10, 0
	// 82EB89F0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB89F4: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB89F8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB89FC: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8A00: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82EB8A04: 4BFFDBA5  bl 0x82eb65a8
	ctx.lr = 0x82EB8A08;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB65A8);
	// 82EB8A08: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB8A0C: 419AFE94  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8A10: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8A14: 408100E0  ble 0x82eb8af4
	if !ctx.cr[0].gt {
	pc = 0x82EB8AF4; continue 'dispatch;
	}
	// 82EB8A18: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8A1C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8A20: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8A24: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8A28: 5529103A  slwi r9, r9, 2
	// 82EB8A2C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB8A30: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB8A34: 4082FFE4  bne 0x82eb8a18
	if !ctx.cr[0].eq {
	pc = 0x82EB8A18; continue 'dispatch;
	}
	// 82EB8A38: 480000BC  b 0x82eb8af4
	pc = 0x82EB8AF4; continue 'dispatch;
	// 82EB8A3C: 4801AE9D  bl 0x82ed38d8
	ctx.lr = 0x82EB8A40;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB8A40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8A44: 4182FE5C  beq 0x82eb88a0
	if ctx.cr[0].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8A48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8A4C: 4801CE4D  bl 0x82ed5898
	ctx.lr = 0x82EB8A50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5898);
	// 82EB8A50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB8A54: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB8A58: 419AFE48  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8A5C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8A60: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8A64: 4801AE75  bl 0x82ed38d8
	ctx.lr = 0x82EB8A68;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB8A68: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8A6C: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EB8A70: 419AFE54  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB8A74: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8A78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB8A7C: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB8A80: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB8A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8A88: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8A8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB8A90: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB8A94: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8A98: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8A9C: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB8AA0: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82EB8AA4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB8AA8: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82EB8AAC: 554B003E  slwi r11, r10, 0
	// 82EB8AB0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB8AB4: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB8AB8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB8ABC: A11C0010  lhz r8, 0x10(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8AC0: 4BFFDAE9  bl 0x82eb65a8
	ctx.lr = 0x82EB8AC4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB65A8);
	// 82EB8AC4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB8AC8: 419AFDFC  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB8ACC: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8AD0: 40810024  ble 0x82eb8af4
	if !ctx.cr[0].gt {
	pc = 0x82EB8AF4; continue 'dispatch;
	}
	// 82EB8AD4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8AD8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8ADC: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8AE0: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8AE4: 5529103A  slwi r9, r9, 2
	// 82EB8AE8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB8AEC: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB8AF0: 4082FFE4  bne 0x82eb8ad4
	if !ctx.cr[0].eq {
	pc = 0x82EB8AD4; continue 'dispatch;
	}
	// 82EB8AF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB8AF8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8AFC: 4801A435  bl 0x82ed2f30
	ctx.lr = 0x82EB8B00;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB8B00: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8B04: 92EB01B0  stw r23, 0x1b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(432 as u32), ctx.r[23].u32 ) };
	// 82EB8B08: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8B0C: 92EB01AC  stw r23, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[23].u32 ) };
	// 82EB8B10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB8B14: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82EB8B18: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EB8B1C: 4BDF0928  b 0x82ca9444
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9444);
	return;
}

pub fn sub_82EB8B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB8B20 size=1720
	// 82EB8B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB8B24: 4BDF08BD  bl 0x82ca93e0
	ctx.lr = 0x82EB8B28;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93E0);
	// 82EB8B28: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 82EB8B2C: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82EB8B30: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82EB8B34: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB8B38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB8B3C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EB8B40: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 82EB8B44: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 82EB8B48: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EB8B4C: 827F0058  lwz r19, 0x58(r31)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB8B50: 2C130000  cmpwi r19, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB8B54: 40820114  bne 0x82eb8c68
	if !ctx.cr[0].eq {
	pc = 0x82EB8C68; continue 'dispatch;
	}
	// 82EB8B58: 3BB20004  addi r29, r18, 4
	ctx.r[29].s64 = ctx.r[18].s64 + 4;
	// 82EB8B5C: C0180000  lfs f0, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8B60: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8B64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8B68: 409A0028  bne cr6, 0x82eb8b90
	if !ctx.cr[6].eq {
	pc = 0x82EB8B90; continue 'dispatch;
	}
	// 82EB8B6C: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8B70: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8B74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8B78: 409A0018  bne cr6, 0x82eb8b90
	if !ctx.cr[6].eq {
	pc = 0x82EB8B90; continue 'dispatch;
	}
	// 82EB8B7C: C0180008  lfs f0, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8B80: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 82EB8B84: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8B88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8B8C: 419A0008  beq cr6, 0x82eb8b94
	if ctx.cr[6].eq {
	pc = 0x82EB8B94; continue 'dispatch;
	}
	// 82EB8B90: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 82EB8B94: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8B98: 4182000C  beq 0x82eb8ba4
	if ctx.cr[0].eq {
	pc = 0x82EB8BA4; continue 'dispatch;
	}
	// 82EB8B9C: 92DF0058  stw r22, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 82EB8BA0: 4800061C  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
	// 82EB8BA4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8BA8: 81630294  lwz r11, 0x294(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(660 as u32) ) } as u64;
	// 82EB8BAC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EB8BB0: 409A060C  bne cr6, 0x82eb91bc
	if !ctx.cr[6].eq {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8BB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB8BB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB8BBC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EB8BC0: 48019C71  bl 0x82ed2830
	ctx.lr = 0x82EB8BC4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2830);
	// 82EB8BC4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB8BC8: 40820010  bne 0x82eb8bd8
	if !ctx.cr[0].eq {
	pc = 0x82EB8BD8; continue 'dispatch;
	}
	// 82EB8BCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB8BD0: 929F0198  stw r20, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[20].u32 ) };
	// 82EB8BD4: 480005EC  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
	// 82EB8BD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB8BDC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8BE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8BE4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8BE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB8BEC: C3EBBE10  lfs f31, -0x41f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB8BF0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8BF4: 4801A155  bl 0x82ed2d48
	ctx.lr = 0x82EB8BF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB8BF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB8BFC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8C00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB8C04: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 82EB8C08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB8C0C: 92DF00F0  stw r22, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[22].u32 ) };
	// 82EB8C10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB8C14: 9ADF00AC  stb r22, 0xac(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[22].u8 ) };
	// 82EB8C18: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EB8C1C: 48019C15  bl 0x82ed2830
	ctx.lr = 0x82EB8C20;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2830);
	// 82EB8C20: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB8C24: 40820014  bne 0x82eb8c38
	if !ctx.cr[0].eq {
	pc = 0x82EB8C38; continue 'dispatch;
	}
	// 82EB8C28: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB8C2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB8C30: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB8C34: 4800058C  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
	// 82EB8C38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8C3C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8C40: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8C44: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB8C4C: 4801A0FD  bl 0x82ed2d48
	ctx.lr = 0x82EB8C50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB8C50: 907F0108  stw r3, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 82EB8C54: 93DF0104  stw r30, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 82EB8C58: 92DF0150  stw r22, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[22].u32 ) };
	// 82EB8C5C: 9ADF010C  stb r22, 0x10c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[22].u8 ) };
	// 82EB8C60: 92DF0050  stw r22, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 82EB8C64: 929F0058  stw r20, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[20].u32 ) };
	// 82EB8C68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8C6C: 3AA00003  li r21, 3
	ctx.r[21].s64 = 3;
	// 82EB8C70: 2F130001  cmpwi cr6, r19, 1
	ctx.cr[6].compare_i32(ctx.r[19].s32, 1, &mut ctx.xer);
	// 82EB8C74: C3AB0C4C  lfs f29, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB8C78: 409A0210  bne cr6, 0x82eb8e88
	if !ctx.cr[6].eq {
	pc = 0x82EB8E88; continue 'dispatch;
	}
	// 82EB8C7C: 3B320004  addi r25, r18, 4
	ctx.r[25].s64 = ctx.r[18].s64 + 4;
	// 82EB8C80: C1B80008  lfs f13, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8C84: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8C88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8C8C: C1980000  lfs f12, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB8C90: 83BF0050  lwz r29, 0x50(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB8C94: 3AFF005C  addi r23, r31, 0x5c
	ctx.r[23].s64 = ctx.r[31].s64 + 92;
	// 82EB8C98: C1590008  lfs f10, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB8C9C: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB8CA0: C1790004  lfs f11, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB8CA4: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB8CA8: C1790000  lfs f11, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB8CAC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB8CB0: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB8CB4: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB8CB8: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8CBC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB8CC0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB8CC4: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB8CC8: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82EB8CCC: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB8CD0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EB8CD4: 811F0060  lwz r8, 0x60(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB8CD8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB8CDC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8CE0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EB8CE4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8CE8: 92D70000  stw r22, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 82EB8CEC: 9AC10057  stb r22, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[22].u8 ) };
	// 82EB8CF0: 4801A499  bl 0x82ed3188
	ctx.lr = 0x82EB8CF4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3188);
	// 82EB8CF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB8CF8: 419A016C  beq cr6, 0x82eb8e64
	if ctx.cr[6].eq {
	pc = 0x82EB8E64; continue 'dispatch;
	}
	// 82EB8CFC: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 82EB8D00: 1D7D0060  mulli r11, r29, 0x60
	ctx.r[11].s64 = ctx.r[29].s64 * 96;
	// 82EB8D04: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82EB8D08: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB8D0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB8D10: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EB8D14: 3B7E00F0  addi r27, r30, 0xf0
	ctx.r[27].s64 = ctx.r[30].s64 + 240;
	// 82EB8D18: 3B5E00B0  addi r26, r30, 0xb0
	ctx.r[26].s64 = ctx.r[30].s64 + 176;
	// 82EB8D1C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 82EB8D20: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB8D24: 92DE00F0  stw r22, 0xf0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), ctx.r[22].u32 ) };
	// 82EB8D28: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8D2C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EB8D30: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D34: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EB8D38: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EB8D3C: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EB8D40: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EB8D44: FFC06818  frsp f30, f13
	ctx.f[30].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EB8D48: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8D4C: 4801934D  bl 0x82ed2098
	ctx.lr = 0x82EB8D50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2098);
	// 82EB8D50: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D54: 4801924D  bl 0x82ed1fa0
	ctx.lr = 0x82EB8D58;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FA0);
	// 82EB8D58: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EB8D5C: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EB8D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8D64: 40990034  ble cr6, 0x82eb8d98
	if !ctx.cr[6].gt {
	pc = 0x82EB8D98; continue 'dispatch;
	}
	// 82EB8D68: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8D6C: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8D70: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8D74: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D78: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82EB8D7C: 48019FCD  bl 0x82ed2d48
	ctx.lr = 0x82EB8D80;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB8D80: 907E00A8  stw r3, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[3].u32 ) };
	// 82EB8D84: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8D88: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8D8C: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EB8D90: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8D94: 4198FFD4  blt cr6, 0x82eb8d68
	if ctx.cr[6].lt {
	pc = 0x82EB8D68; continue 'dispatch;
	}
	// 82EB8D98: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D9C: 48019225  bl 0x82ed1fc0
	ctx.lr = 0x82EB8DA0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FC0);
	// 82EB8DA0: 3B7E0150  addi r27, r30, 0x150
	ctx.r[27].s64 = ctx.r[30].s64 + 336;
	// 82EB8DA4: 92DE00A4  stw r22, 0xa4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[22].u32 ) };
	// 82EB8DA8: 3B5E0110  addi r26, r30, 0x110
	ctx.r[26].s64 = ctx.r[30].s64 + 272;
	// 82EB8DAC: 9ADE00AC  stb r22, 0xac(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[22].u8 ) };
	// 82EB8DB0: 92DE0150  stw r22, 0x150(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(336 as u32), ctx.r[22].u32 ) };
	// 82EB8DB4: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8DB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB8DBC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8DC0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EB8DC4: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8DC8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB8DCC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EB8DD0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EB8DD4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EB8DD8: 480192C1  bl 0x82ed2098
	ctx.lr = 0x82EB8DDC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2098);
	// 82EB8DDC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8DE0: 480191C1  bl 0x82ed1fa0
	ctx.lr = 0x82EB8DE4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FA0);
	// 82EB8DE4: 817E0150  lwz r11, 0x150(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 82EB8DE8: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EB8DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8DF0: 40990034  ble cr6, 0x82eb8e24
	if !ctx.cr[6].gt {
	pc = 0x82EB8E24; continue 'dispatch;
	}
	// 82EB8DF4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8DF8: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8DFC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8E00: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8E04: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82EB8E08: 48019F41  bl 0x82ed2d48
	ctx.lr = 0x82EB8E0C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB8E0C: 907E0108  stw r3, 0x108(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 82EB8E10: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E14: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8E18: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EB8E1C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8E20: 4198FFD4  blt cr6, 0x82eb8df4
	if ctx.cr[6].lt {
	pc = 0x82EB8DF4; continue 'dispatch;
	}
	// 82EB8E24: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8E28: 48019199  bl 0x82ed1fc0
	ctx.lr = 0x82EB8E2C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FC0);
	// 82EB8E2C: 92DE0104  stw r22, 0x104(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(260 as u32), ctx.r[22].u32 ) };
	// 82EB8E30: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EB8E34: 9ADE010C  stb r22, 0x10c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(268 as u32), ctx.r[22].u8 ) };
	// 82EB8E38: 80B70000  lwz r5, 0(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E3C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8E40: 480190C9  bl 0x82ed1f08
	ctx.lr = 0x82EB8E44;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1F08);
	// 82EB8E44: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E48: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 82EB8E4C: 40990008  ble cr6, 0x82eb8e54
	if !ctx.cr[6].gt {
	pc = 0x82EB8E54; continue 'dispatch;
	}
	// 82EB8E50: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82EB8E54: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82EB8E58: 40990018  ble cr6, 0x82eb8e70
	if !ctx.cr[6].gt {
	pc = 0x82EB8E70; continue 'dispatch;
	}
	// 82EB8E5C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB8E60: 4BFFFE68  b 0x82eb8cc8
	pc = 0x82EB8CC8; continue 'dispatch;
	// 82EB8E64: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E68: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82EB8E6C: 4BFFFFD0  b 0x82eb8e3c
	pc = 0x82EB8E3C; continue 'dispatch;
	// 82EB8E70: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB8E74: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EB8E78: 93BF0168  stw r29, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[29].u32 ) };
	// 82EB8E7C: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EB8E80: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82EB8E84: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 82EB8E88: 2F130002  cmpwi cr6, r19, 2
	ctx.cr[6].compare_i32(ctx.r[19].s32, 2, &mut ctx.xer);
	// 82EB8E8C: 409A0084  bne cr6, 0x82eb8f10
	if !ctx.cr[6].eq {
	pc = 0x82EB8F10; continue 'dispatch;
	}
	// 82EB8E90: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB8E94: 3BBF016C  addi r29, r31, 0x16c
	ctx.r[29].s64 = ctx.r[31].s64 + 364;
	// 82EB8E98: 815F0168  lwz r10, 0x168(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB8E9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB8EA0: 41990020  bgt cr6, 0x82eb8ec0
	if ctx.cr[6].gt {
	pc = 0x82EB8EC0; continue 'dispatch;
	}
	// 82EB8EA4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB8EA8: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82EB8EAC: 38DF0170  addi r6, r31, 0x170
	ctx.r[6].s64 = ctx.r[31].s64 + 368;
	// 82EB8EB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB8EB4: 389F00A4  addi r4, r31, 0xa4
	ctx.r[4].s64 = ctx.r[31].s64 + 164;
	// 82EB8EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8EBC: 4BFFECC5  bl 0x82eb7b80
	ctx.lr = 0x82EB8EC0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB7B80);
	// 82EB8EC0: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EB8EC4: 3BDF0174  addi r30, r31, 0x174
	ctx.r[30].s64 = ctx.r[31].s64 + 372;
	// 82EB8EC8: 815F0168  lwz r10, 0x168(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB8ECC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB8ED0: 41990020  bgt cr6, 0x82eb8ef0
	if ctx.cr[6].gt {
	pc = 0x82EB8EF0; continue 'dispatch;
	}
	// 82EB8ED4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB8ED8: 38F20004  addi r7, r18, 4
	ctx.r[7].s64 = ctx.r[18].s64 + 4;
	// 82EB8EDC: 38DF0178  addi r6, r31, 0x178
	ctx.r[6].s64 = ctx.r[31].s64 + 376;
	// 82EB8EE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB8EE4: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 82EB8EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8EEC: 4BFFEC95  bl 0x82eb7b80
	ctx.lr = 0x82EB8EF0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB7B80);
	// 82EB8EF0: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB8EF4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8EF8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8EFC: 409902C0  ble cr6, 0x82eb91bc
	if !ctx.cr[6].gt {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8F00: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8F04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8F08: 409902B4  ble cr6, 0x82eb91bc
	if !ctx.cr[6].gt {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8F0C: 92BF0058  stw r21, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 82EB8F10: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 82EB8F14: 2F130003  cmpwi cr6, r19, 3
	ctx.cr[6].compare_i32(ctx.r[19].s32, 3, &mut ctx.xer);
	// 82EB8F18: 409A006C  bne cr6, 0x82eb8f84
	if !ctx.cr[6].eq {
	pc = 0x82EB8F84; continue 'dispatch;
	}
	// 82EB8F1C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8F20: 92DF017C  stw r22, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[22].u32 ) };
	// 82EB8F24: 4801907D  bl 0x82ed1fa0
	ctx.lr = 0x82EB8F28;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FA0);
	// 82EB8F28: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB8F2C: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 82EB8F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8F34: 40990044  ble cr6, 0x82eb8f78
	if !ctx.cr[6].gt {
	pc = 0x82EB8F78; continue 'dispatch;
	}
	// 82EB8F38: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82EB8F3C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB8F40: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8F44: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8F48: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8F4C: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82EB8F50: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8F54: 48019DF5  bl 0x82ed2d48
	ctx.lr = 0x82EB8F58;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB8F58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8F5C: 907F017C  stw r3, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[3].u32 ) };
	// 82EB8F60: 41820048  beq 0x82eb8fa8
	if ctx.cr[0].eq {
	pc = 0x82EB8FA8; continue 'dispatch;
	}
	// 82EB8F64: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB8F68: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB8F6C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EB8F70: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8F74: 4198FFC8  blt cr6, 0x82eb8f3c
	if ctx.cr[6].lt {
	pc = 0x82EB8F3C; continue 'dispatch;
	}
	// 82EB8F78: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8F7C: 48019045  bl 0x82ed1fc0
	ctx.lr = 0x82EB8F80;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FC0);
	// 82EB8F80: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB8F84: 2F130004  cmpwi cr6, r19, 4
	ctx.cr[6].compare_i32(ctx.r[19].s32, 4, &mut ctx.xer);
	// 82EB8F88: 409A0050  bne cr6, 0x82eb8fd8
	if !ctx.cr[6].eq {
	pc = 0x82EB8FD8; continue 'dispatch;
	}
	// 82EB8F8C: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8F90: 4801A8C1  bl 0x82ed3850
	ctx.lr = 0x82EB8F94;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB8F94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8F98: 41820018  beq 0x82eb8fb0
	if ctx.cr[0].eq {
	pc = 0x82EB8FB0; continue 'dispatch;
	}
	// 82EB8F9C: 3A600007  li r19, 7
	ctx.r[19].s64 = 7;
	// 82EB8FA0: 927F0058  stw r19, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[19].u32 ) };
	// 82EB8FA4: 4800003C  b 0x82eb8fe0
	pc = 0x82EB8FE0; continue 'dispatch;
	// 82EB8FA8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB8FAC: 4BFFFC80  b 0x82eb8c2c
	pc = 0x82EB8C2C; continue 'dispatch;
	// 82EB8FB0: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8FB4: 4801A8F5  bl 0x82ed38a8
	ctx.lr = 0x82EB8FB8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38A8);
	// 82EB8FB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8FBC: 41820200  beq 0x82eb91bc
	if ctx.cr[0].eq {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8FC0: 809F017C  lwz r4, 0x17c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8FC4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8FC8: 48019F69  bl 0x82ed2f30
	ctx.lr = 0x82EB8FCC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB8FCC: 92DF017C  stw r22, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[22].u32 ) };
	// 82EB8FD0: 92BF0058  stw r21, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 82EB8FD4: 480001E8  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
	// 82EB8FD8: 2F130007  cmpwi cr6, r19, 7
	ctx.cr[6].compare_i32(ctx.r[19].s32, 7, &mut ctx.xer);
	// 82EB8FDC: 409A01CC  bne cr6, 0x82eb91a8
	if !ctx.cr[6].eq {
	pc = 0x82EB91A8; continue 'dispatch;
	}
	// 82EB8FE0: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8FE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8FE8: 418201D8  beq 0x82eb91c0
	if ctx.cr[0].eq {
	pc = 0x82EB91C0; continue 'dispatch;
	}
	// 82EB8FEC: 4801A865  bl 0x82ed3850
	ctx.lr = 0x82EB8FF0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB8FF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8FF4: 4082000C  bne 0x82eb9000
	if !ctx.cr[0].eq {
	pc = 0x82EB9000; continue 'dispatch;
	}
	// 82EB8FF8: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB8FFC: 480001C0  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
	// 82EB9000: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB9004: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9008: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB900C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB9010: 808B0100  lwz r4, 0x100(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) } as u64;
	// 82EB9014: 4801A8C5  bl 0x82ed38d8
	ctx.lr = 0x82EB9018;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB9018: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB901C: 40820010  bne 0x82eb902c
	if !ctx.cr[0].eq {
	pc = 0x82EB902C; continue 'dispatch;
	}
	// 82EB9020: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9024: 939F0198  stw r28, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[28].u32 ) };
	// 82EB9028: 48000198  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
	// 82EB902C: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB9030: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9034: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 * 96;
	// 82EB9038: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB903C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9040: 808B0160  lwz r4, 0x160(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB9044: 4801A895  bl 0x82ed38d8
	ctx.lr = 0x82EB9048;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB9048: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB904C: 4182FFD4  beq 0x82eb9020
	if ctx.cr[0].eq {
	pc = 0x82EB9020; continue 'dispatch;
	}
	// 82EB9050: 809F017C  lwz r4, 0x17c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9054: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EB9058: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB905C: 811F0168  lwz r8, 0x168(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB9060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9064: 80C40004  lwz r6, 4(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9068: 4BFFD541  bl 0x82eb65a8
	ctx.lr = 0x82EB906C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB65A8);
	// 82EB906C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB9070: 809F017C  lwz r4, 0x17c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9074: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9078: 48019EB9  bl 0x82ed2f30
	ctx.lr = 0x82EB907C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB907C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB9080: 92DF017C  stw r22, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[22].u32 ) };
	// 82EB9084: 409A0038  bne cr6, 0x82eb90bc
	if !ctx.cr[6].eq {
	pc = 0x82EB90BC; continue 'dispatch;
	}
	// 82EB9088: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB908C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9090: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB9094: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EB9098: 48018E21  bl 0x82ed1eb8
	ctx.lr = 0x82EB909C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1EB8);
	// 82EB909C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB90A0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB90A4: 40990010  ble cr6, 0x82eb90b4
	if !ctx.cr[6].gt {
	pc = 0x82EB90B4; continue 'dispatch;
	}
	// 82EB90A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB90AC: 92BF0198  stw r21, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[21].u32 ) };
	// 82EB90B0: 48000110  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
	// 82EB90B4: 929F0058  stw r20, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[20].u32 ) };
	// 82EB90B8: 48000104  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
	// 82EB90BC: 813F0168  lwz r9, 0x168(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB90C0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB90C4: 408100AC  ble 0x82eb9170
	if !ctx.cr[0].gt {
	pc = 0x82EB9170; continue 'dispatch;
	}
	// 82EB90C8: 1D690060  mulli r11, r9, 0x60
	ctx.r[11].s64 = ctx.r[9].s64 * 96;
	// 82EB90CC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB90D0: 394B015C  addi r10, r11, 0x15c
	ctx.r[10].s64 = ctx.r[11].s64 + 348;
	// 82EB90D4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB90D8: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 82EB90DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB90E0: 38EB0014  addi r7, r11, 0x14
	ctx.r[7].s64 = ctx.r[11].s64 + 20;
	// 82EB90E4: B12B0010  sth r9, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u16 ) };
	// 82EB90E8: C00AFFF8  lfs f0, -8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB90EC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB90F0: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB90F4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB90F8: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB90FC: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9100: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9104: B2CB0012  sth r22, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[22].u16 ) };
	// 82EB9108: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82EB910C: 80CAFFF4  lwz r6, -0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EB9110: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EB9114: 40990034  ble cr6, 0x82eb9148
	if !ctx.cr[6].gt {
	pc = 0x82EB9148; continue 'dispatch;
	}
	// 82EB9118: 38CAFFB4  addi r6, r10, -0x4c
	ctx.r[6].s64 = ctx.r[10].s64 + -76;
	// 82EB911C: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB9120: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB9124: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB9128: 90A70000  stw r5, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82EB912C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EB9130: A0AB0012  lhz r5, 0x12(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB9134: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB9138: B0AB0012  sth r5, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[5].u16 ) };
	// 82EB913C: 80AAFFF4  lwz r5, -0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EB9140: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB9144: 4198FFD8  blt cr6, 0x82eb911c
	if ctx.cr[6].lt {
	pc = 0x82EB911C; continue 'dispatch;
	}
	// 82EB9148: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB914C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB9150: 394AFFA0  addi r10, r10, -0x60
	ctx.r[10].s64 = ctx.r[10].s64 + -96;
	// 82EB9154: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB9158: A0E80012  lhz r7, 0x12(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB915C: 38E70005  addi r7, r7, 5
	ctx.r[7].s64 = ctx.r[7].s64 + 5;
	// 82EB9160: 54E7103A  slwi r7, r7, 2
	// 82EB9164: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82EB9168: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EB916C: 4181FF68  bgt 0x82eb90d4
	if ctx.cr[0].gt {
	pc = 0x82EB90D4; continue 'dispatch;
	}
	// 82EB9170: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9174: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82EB9178: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB917C: B2CB0010  sth r22, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[22].u16 ) };
	// 82EB9180: C01F0154  lfs f0, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9184: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9188: C01F0158  lfs f0, 0x158(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB918C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9190: C01F015C  lfs f0, 0x15c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9194: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9198: 813F0160  lwz r9, 0x160(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB919C: B2CB0012  sth r22, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[22].u16 ) };
	// 82EB91A0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB91A4: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EB91A8: 2F130008  cmpwi cr6, r19, 8
	ctx.cr[6].compare_i32(ctx.r[19].s32, 8, &mut ctx.xer);
	// 82EB91AC: 409A0010  bne cr6, 0x82eb91bc
	if !ctx.cr[6].eq {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB91B0: 38920004  addi r4, r18, 4
	ctx.r[4].s64 = ctx.r[18].s64 + 4;
	// 82EB91B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB91B8: 4BFFF191  bl 0x82eb8348
	ctx.lr = 0x82EB91BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB8348);
	// 82EB91BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB91C0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82EB91C4: CBA1FF70  lfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82EB91C8: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82EB91CC: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82EB91D0: 4BDF0260  b 0x82ca9430
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9430);
	return;
}

pub fn sub_82EB91D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB91D8 size=184
	// 82EB91D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB91DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB91E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB91E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB91E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB91EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB91F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB91F4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB91F8: 4099007C  ble cr6, 0x82eb9274
	if !ctx.cr[6].gt {
	pc = 0x82EB9274; continue 'dispatch;
	}
	// 82EB91FC: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82EB9200: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82EB9204: 5483103A  slwi r3, r4, 2
	// 82EB9208: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EB920C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB9210: 40990008  ble cr6, 0x82eb9218
	if !ctx.cr[6].gt {
	pc = 0x82EB9218; continue 'dispatch;
	}
	// 82EB9214: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EB9218: 4B75D711  bl 0x82616928
	ctx.lr = 0x82EB921C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EB921C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9220: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB9224: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB9228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB922C: 40990028  ble cr6, 0x82eb9254
	if !ctx.cr[6].gt {
	pc = 0x82EB9254; continue 'dispatch;
	}
	// 82EB9230: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9234: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9238: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB923C: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB9240: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82EB9244: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB9248: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB924C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB9250: 4198FFE4  blt cr6, 0x82eb9234
	if ctx.cr[6].lt {
	pc = 0x82EB9234; continue 'dispatch;
	}
	// 82EB9254: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9258: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB925C: 41820014  beq 0x82eb9270
	if ctx.cr[0].eq {
	pc = 0x82EB9270; continue 'dispatch;
	}
	// 82EB9260: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB9264: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB9268: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB926C: 4E800421  bctrl
	ctx.lr = 0x82EB9270;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB9270: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EB9274: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB9278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB927C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB9280: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB9284: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB9288: 4E800020  blr
	return;
}

pub fn sub_82EB9290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB9290 size=240
	// 82EB9290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9294: 4BDF0179  bl 0x82ca940c
	ctx.lr = 0x82EB9298;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB9298: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB929C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB92A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EB92A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB92A8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB92AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB92B0: 409A00A8  bne cr6, 0x82eb9358
	if !ctx.cr[6].eq {
	pc = 0x82EB9358; continue 'dispatch;
	}
	// 82EB92B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB92B8: 409A000C  bne cr6, 0x82eb92c4
	if !ctx.cr[6].eq {
	pc = 0x82EB92C4; continue 'dispatch;
	}
	// 82EB92BC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB92C0: 48000008  b 0x82eb92c8
	pc = 0x82EB92C8; continue 'dispatch;
	// 82EB92C4: 556B083C  slwi r11, r11, 1
	// 82EB92C8: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EB92CC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB92D0: 556B003E  slwi r11, r11, 0
	// 82EB92D4: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EB92D8: 5563103A  slwi r3, r11, 2
	// 82EB92DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB92E0: 40990008  ble cr6, 0x82eb92e8
	if !ctx.cr[6].gt {
	pc = 0x82EB92E8; continue 'dispatch;
	}
	// 82EB92E4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EB92E8: 4B75D641  bl 0x82616928
	ctx.lr = 0x82EB92EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EB92EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB92F0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB92F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB92F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB92FC: 40990008  ble cr6, 0x82eb9304
	if !ctx.cr[6].gt {
	pc = 0x82EB9304; continue 'dispatch;
	}
	// 82EB9300: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EB9304: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9308: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB930C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB9310: 40990028  ble cr6, 0x82eb9338
	if !ctx.cr[6].gt {
	pc = 0x82EB9338; continue 'dispatch;
	}
	// 82EB9314: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9318: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB931C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB9320: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB9324: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82EB9328: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB932C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9330: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB9334: 4198FFE4  blt cr6, 0x82eb9318
	if ctx.cr[6].lt {
	pc = 0x82EB9318; continue 'dispatch;
	}
	// 82EB9338: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB933C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9340: 41820014  beq 0x82eb9354
	if ctx.cr[0].eq {
	pc = 0x82EB9354; continue 'dispatch;
	}
	// 82EB9344: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB9348: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB934C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB9350: 4E800421  bctrl
	ctx.lr = 0x82EB9354;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB9354: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82EB9358: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB935C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB9360: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9364: 556B103A  slwi r11, r11, 2
	// 82EB9368: 7D49592E  stwx r10, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82EB936C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9370: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB9374: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EB9378: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB937C: 4BDF00E0  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EB9380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB9380 size=96
	// 82EB9380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB9388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB938C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB9394: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB9398: 396BA8F0  addi r11, r11, -0x5710
	ctx.r[11].s64 = ctx.r[11].s64 + -22288;
	// 82EB939C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB93A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB93A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB93A8: 41820014  beq 0x82eb93bc
	if ctx.cr[0].eq {
	pc = 0x82EB93BC; continue 'dispatch;
	}
	// 82EB93AC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB93B0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB93B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB93B8: 4E800421  bctrl
	ctx.lr = 0x82EB93BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB93BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB93C0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB93C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB93C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB93CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB93D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB93D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB93D8: 4E800020  blr
	return;
}

pub fn sub_82EB93E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB93E0 size=88
	// 82EB93E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB93E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB93E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB93EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB93F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB93F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB93F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB93FC: 4BFFFF85  bl 0x82eb9380
	ctx.lr = 0x82EB9400;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EB9400: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9404: 41820018  beq 0x82eb941c
	if ctx.cr[0].eq {
	pc = 0x82EB941C; continue 'dispatch;
	}
	// 82EB9408: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB940C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9410: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB9414: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB9418: 4E800421  bctrl
	ctx.lr = 0x82EB941C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB941C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB9424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB9428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB942C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB9430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB9434: 4E800020  blr
	return;
}

pub fn sub_82EB9438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB9438 size=1720
	// 82EB9438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB943C: 4BDEFFB9  bl 0x82ca93f4
	ctx.lr = 0x82EB9440;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93F4);
	// 82EB9440: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82EB9444: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB944C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82EB9450: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB9454: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB9458: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB945C: 837F0058  lwz r27, 0x58(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB9460: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB9464: 409A004C  bne cr6, 0x82eb94b0
	if !ctx.cr[6].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB9468: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB946C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9470: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB9474: 419A003C  beq cr6, 0x82eb94b0
	if ctx.cr[6].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB9478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB947C: 419A0034  beq cr6, 0x82eb94b0
	if ctx.cr[6].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB9480: 4801A3D1  bl 0x82ed3850
	ctx.lr = 0x82EB9484;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB9484: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9488: 41820028  beq 0x82eb94b0
	if ctx.cr[0].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB948C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9490: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9494: 41820010  beq 0x82eb94a4
	if ctx.cr[0].eq {
	pc = 0x82EB94A4; continue 'dispatch;
	}
	// 82EB9498: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB949C: 48019A95  bl 0x82ed2f30
	ctx.lr = 0x82EB94A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB94A0: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EB94A4: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB94A8: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82EB94AC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EB94B0: 3B5E0004  addi r26, r30, 4
	ctx.r[26].s64 = ctx.r[30].s64 + 4;
	// 82EB94B4: C0190000  lfs f0, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB94B8: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82EB94BC: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB94C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB94C4: 409A0028  bne cr6, 0x82eb94ec
	if !ctx.cr[6].eq {
	pc = 0x82EB94EC; continue 'dispatch;
	}
	// 82EB94C8: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB94CC: C1BA0004  lfs f13, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB94D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB94D4: 409A0018  bne cr6, 0x82eb94ec
	if !ctx.cr[6].eq {
	pc = 0x82EB94EC; continue 'dispatch;
	}
	// 82EB94D8: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB94DC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82EB94E0: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB94E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB94E8: 419A0008  beq cr6, 0x82eb94f0
	if ctx.cr[6].eq {
	pc = 0x82EB94F0; continue 'dispatch;
	}
	// 82EB94EC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EB94F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB94F4: 4182000C  beq 0x82eb9500
	if ctx.cr[0].eq {
	pc = 0x82EB9500; continue 'dispatch;
	}
	// 82EB94F8: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB94FC: 480005E0  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
	// 82EB9500: 3AE00004  li r23, 4
	ctx.r[23].s64 = 4;
	// 82EB9504: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EB9508: 409A000C  bne cr6, 0x82eb9514
	if !ctx.cr[6].eq {
	pc = 0x82EB9514; continue 'dispatch;
	}
	// 82EB950C: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82EB9510: 92FF0058  stw r23, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82EB9514: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 82EB9518: 409A0080  bne cr6, 0x82eb9598
	if !ctx.cr[6].eq {
	pc = 0x82EB9598; continue 'dispatch;
	}
	// 82EB951C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9520: 48018A81  bl 0x82ed1fa0
	ctx.lr = 0x82EB9524;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FA0);
	// 82EB9524: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB9528: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EB952C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB9530: 4099005C  ble cr6, 0x82eb958c
	if !ctx.cr[6].gt {
	pc = 0x82EB958C; continue 'dispatch;
	}
	// 82EB9534: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB9538: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EB953C: C3EB0C4C  lfs f31, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB9540: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB9544: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB9548: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB954C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9550: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB9554: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EB9558: 480197F1  bl 0x82ed2d48
	ctx.lr = 0x82EB955C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2D48);
	// 82EB955C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9560: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EB9564: 40820014  bne 0x82eb9578
	if !ctx.cr[0].eq {
	pc = 0x82EB9578; continue 'dispatch;
	}
	// 82EB9568: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB956C: 48018A55  bl 0x82ed1fc0
	ctx.lr = 0x82EB9570;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FC0);
	// 82EB9570: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB9574: 939F005C  stw r28, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82EB9578: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB957C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB9580: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EB9584: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB9588: 4198FFB8  blt cr6, 0x82eb9540
	if ctx.cr[6].lt {
	pc = 0x82EB9540; continue 'dispatch;
	}
	// 82EB958C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9590: 48018A31  bl 0x82ed1fc0
	ctx.lr = 0x82EB9594;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED1FC0);
	// 82EB9594: 92FF0058  stw r23, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82EB9598: 3BA00007  li r29, 7
	ctx.r[29].s64 = 7;
	// 82EB959C: 2F1B0004  cmpwi cr6, r27, 4
	ctx.cr[6].compare_i32(ctx.r[27].s32, 4, &mut ctx.xer);
	// 82EB95A0: 409A00A8  bne cr6, 0x82eb9648
	if !ctx.cr[6].eq {
	pc = 0x82EB9648; continue 'dispatch;
	}
	// 82EB95A4: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB95A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB95AC: 41820530  beq 0x82eb9adc
	if ctx.cr[0].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB95B0: 4801A2A1  bl 0x82ed3850
	ctx.lr = 0x82EB95B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB95B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB95B8: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB95BC: 41820020  beq 0x82eb95dc
	if ctx.cr[0].eq {
	pc = 0x82EB95DC; continue 'dispatch;
	}
	// 82EB95C0: 3B600005  li r27, 5
	ctx.r[27].s64 = 5;
	// 82EB95C4: 809F0094  lwz r4, 0x94(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB95C8: 937F0058  stw r27, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82EB95CC: 4801A175  bl 0x82ed3740
	ctx.lr = 0x82EB95D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3740);
	// 82EB95D0: 9B9F007D  stb r28, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[28].u8 ) };
	// 82EB95D4: 939F0198  stw r28, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[28].u32 ) };
	// 82EB95D8: 48000080  b 0x82eb9658
	pc = 0x82EB9658; continue 'dispatch;
	// 82EB95DC: 4801A2CD  bl 0x82ed38a8
	ctx.lr = 0x82EB95E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38A8);
	// 82EB95E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB95E4: 4182002C  beq 0x82eb9610
	if ctx.cr[0].eq {
	pc = 0x82EB9610; continue 'dispatch;
	}
	// 82EB95E8: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB95EC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB95F0: 409A0010  bne cr6, 0x82eb9600
	if !ctx.cr[6].eq {
	pc = 0x82EB9600; continue 'dispatch;
	}
	// 82EB95F4: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB95F8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB95FC: 48019935  bl 0x82ed2f30
	ctx.lr = 0x82EB9600;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB9600: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82EB9604: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EB9608: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB960C: 480004D0  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
	// 82EB9610: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9614: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9618: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82EB961C: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB9620: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB9624: 409A04B8  bne cr6, 0x82eb9adc
	if !ctx.cr[6].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB9628: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB962C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9630: 4182000C  beq 0x82eb963c
	if ctx.cr[0].eq {
	pc = 0x82EB963C; continue 'dispatch;
	}
	// 82EB9634: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9638: 480198F9  bl 0x82ed2f30
	ctx.lr = 0x82EB963C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EB963C: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EB9640: 939F005C  stw r28, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82EB9644: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB9648: 2F1B0005  cmpwi cr6, r27, 5
	ctx.cr[6].compare_i32(ctx.r[27].s32, 5, &mut ctx.xer);
	// 82EB964C: 419A000C  beq cr6, 0x82eb9658
	if ctx.cr[6].eq {
	pc = 0x82EB9658; continue 'dispatch;
	}
	// 82EB9650: 2F1B0006  cmpwi cr6, r27, 6
	ctx.cr[6].compare_i32(ctx.r[27].s32, 6, &mut ctx.xer);
	// 82EB9654: 409A0180  bne cr6, 0x82eb97d4
	if !ctx.cr[6].eq {
	pc = 0x82EB97D4; continue 'dispatch;
	}
	// 82EB9658: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB965C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9660: 4082000C  bne 0x82eb966c
	if !ctx.cr[0].eq {
	pc = 0x82EB966C; continue 'dispatch;
	}
	// 82EB9664: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9668: 48000478  b 0x82eb9ae0
	pc = 0x82EB9AE0; continue 'dispatch;
	// 82EB966C: 4801A1E5  bl 0x82ed3850
	ctx.lr = 0x82EB9670;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB9670: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9674: 41820464  beq 0x82eb9ad8
	if ctx.cr[0].eq {
	pc = 0x82EB9AD8; continue 'dispatch;
	}
	// 82EB9678: 897F007D  lbz r11, 0x7d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(125 as u32) ) } as u64;
	// 82EB967C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB9680: 409A0018  bne cr6, 0x82eb9698
	if !ctx.cr[6].eq {
	pc = 0x82EB9698; continue 'dispatch;
	}
	// 82EB9684: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB9688: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB968C: 419AFFD8  beq cr6, 0x82eb9664
	if ctx.cr[6].eq {
	pc = 0x82EB9664; continue 'dispatch;
	}
	// 82EB9690: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB9694: 419AFFD0  beq cr6, 0x82eb9664
	if ctx.cr[6].eq {
	pc = 0x82EB9664; continue 'dispatch;
	}
	// 82EB9698: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB969C: 9B1F007D  stb r24, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[24].u8 ) };
	// 82EB96A0: 3BDF0090  addi r30, r31, 0x90
	ctx.r[30].s64 = ctx.r[31].s64 + 144;
	// 82EB96A4: 2F1B0005  cmpwi cr6, r27, 5
	ctx.cr[6].compare_i32(ctx.r[27].s32, 5, &mut ctx.xer);
	// 82EB96A8: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EB96AC: 409A0008  bne cr6, 0x82eb96b4
	if !ctx.cr[6].eq {
	pc = 0x82EB96B4; continue 'dispatch;
	}
	// 82EB96B0: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EB96B4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB96B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB96BC: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82EB96C0: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EB96C4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB96C8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EB96CC: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB96D0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82EB96D4: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB96D8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB96DC: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB96E0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB96E4: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB96E8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EB96EC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82EB96F0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EB96F4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EB96F8: 4200FFF8  bdnz 0x82eb96f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB96F0; continue 'dispatch;
	}
	// 82EB96FC: 807F0278  lwz r3, 0x278(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EB9700: 391F008C  addi r8, r31, 0x8c
	ctx.r[8].s64 = ctx.r[31].s64 + 140;
	// 82EB9704: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 82EB9708: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB970C: 80FF0094  lwz r7, 0x94(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB9710: 38BF02D8  addi r5, r31, 0x2d8
	ctx.r[5].s64 = ctx.r[31].s64 + 728;
	// 82EB9714: 80DF0068  lwz r6, 0x68(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9718: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB971C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB9720: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9724: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB9728: 4E800421  bctrl
	ctx.lr = 0x82EB972C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB972C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB9730: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB9734: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB9738: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB973C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB9740: 419A000C  beq cr6, 0x82eb974c
	if ctx.cr[6].eq {
	pc = 0x82EB974C; continue 'dispatch;
	}
	// 82EB9744: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82EB9748: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB974C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9750: 40820024  bne 0x82eb9774
	if !ctx.cr[0].eq {
	pc = 0x82EB9774; continue 'dispatch;
	}
	// 82EB9754: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9758: 83FF0194  lwz r31, 0x194(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB975C: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9760: 4B3A7259  bl 0x822609b8
	ctx.lr = 0x82EB9764;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB9764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB9768: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB976C: 4BFC84CD  bl 0x82e81c38
	ctx.lr = 0x82EB9770;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81C38);
	// 82EB9770: 4800036C  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
	// 82EB9774: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB9778: 409A0028  bne cr6, 0x82eb97a0
	if !ctx.cr[6].eq {
	pc = 0x82EB97A0; continue 'dispatch;
	}
	// 82EB977C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9780: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB9784: 931F0198  stw r24, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[24].u32 ) };
	// 82EB9788: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB978C: 4B3A722D  bl 0x822609b8
	ctx.lr = 0x82EB9790;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB9790: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB9794: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB9798: 4BFC82D9  bl 0x82e81a70
	ctx.lr = 0x82EB979C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81A70);
	// 82EB979C: 4BFFFEC8  b 0x82eb9664
	pc = 0x82EB9664; continue 'dispatch;
	// 82EB97A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB97A4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB97A8: 409A001C  bne cr6, 0x82eb97c4
	if !ctx.cr[6].eq {
	pc = 0x82EB97C4; continue 'dispatch;
	}
	// 82EB97AC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB97B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB97B4: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB97B8: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB97BC: 83EA0014  lwz r31, 0x14(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB97C0: 4BFFFFCC  b 0x82eb978c
	pc = 0x82EB978C; continue 'dispatch;
	// 82EB97C4: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB97C8: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EB97CC: 9B9F007C  stb r28, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[28].u8 ) };
	// 82EB97D0: 939F0198  stw r28, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[28].u32 ) };
	// 82EB97D4: 2F1B0007  cmpwi cr6, r27, 7
	ctx.cr[6].compare_i32(ctx.r[27].s32, 7, &mut ctx.xer);
	// 82EB97D8: 409A0304  bne cr6, 0x82eb9adc
	if !ctx.cr[6].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB97DC: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB97E0: 4801A071  bl 0x82ed3850
	ctx.lr = 0x82EB97E4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EB97E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB97E8: 418202F0  beq 0x82eb9ad8
	if ctx.cr[0].eq {
	pc = 0x82EB9AD8; continue 'dispatch;
	}
	// 82EB97EC: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB97F0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB97F4: 409A0010  bne cr6, 0x82eb9804
	if !ctx.cr[6].eq {
	pc = 0x82EB9804; continue 'dispatch;
	}
	// 82EB97F8: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB97FC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82EB9800: 419AFE64  beq cr6, 0x82eb9664
	if ctx.cr[6].eq {
	pc = 0x82EB9664; continue 'dispatch;
	}
	// 82EB9804: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB9808: 9B1F007C  stb r24, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[24].u8 ) };
	// 82EB980C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB9810: 419A002C  beq cr6, 0x82eb983c
	if ctx.cr[6].eq {
	pc = 0x82EB983C; continue 'dispatch;
	}
	// 82EB9814: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9818: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB981C: 4B3A719D  bl 0x822609b8
	ctx.lr = 0x82EB9820;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB9820: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB9824: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB9828: 4BFB68A9  bl 0x82e700d0
	ctx.lr = 0x82EB982C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E700D0);
	// 82EB982C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9830: 4082000C  bne 0x82eb983c
	if !ctx.cr[0].eq {
	pc = 0x82EB983C; continue 'dispatch;
	}
	// 82EB9834: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EB9838: 480002A4  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
	// 82EB983C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9840: 4BFFC961  bl 0x82eb61a0
	ctx.lr = 0x82EB9844;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB61A0);
	// 82EB9844: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB9848: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB984C: 9B1F006C  stb r24, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[24].u8 ) };
	// 82EB9850: 4801A089  bl 0x82ed38d8
	ctx.lr = 0x82EB9854;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB9854: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9858: 40820010  bne 0x82eb9868
	if !ctx.cr[0].eq {
	pc = 0x82EB9868; continue 'dispatch;
	}
	// 82EB985C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9860: 931F0198  stw r24, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[24].u32 ) };
	// 82EB9864: 4800027C  b 0x82eb9ae0
	pc = 0x82EB9AE0; continue 'dispatch;
	// 82EB9868: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB986C: 809F0090  lwz r4, 0x90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB9870: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9874: 4801A065  bl 0x82ed38d8
	ctx.lr = 0x82EB9878;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EB9878: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB987C: 40820014  bne 0x82eb9890
	if !ctx.cr[0].eq {
	pc = 0x82EB9890; continue 'dispatch;
	}
	// 82EB9880: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB9884: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9888: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB988C: 48000254  b 0x82eb9ae0
	pc = 0x82EB9AE0; continue 'dispatch;
	// 82EB9890: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9894: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9898: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB989C: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB98A0: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82EB98A4: 814B019C  lwz r10, 0x19c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB98A8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB98AC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EB98B0: B38A0012  sth r28, 0x12(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[28].u16 ) };
	// 82EB98B4: C0190000  lfs f0, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB98B8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB98BC: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB98C0: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB98C4: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB98C8: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB98CC: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB98D0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB98D4: 93090000  stw r24, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB98D8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB98DC: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB98E0: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB98E4: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB98E8: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB98EC: 5529103A  slwi r9, r9, 2
	// 82EB98F0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB98F4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EB98F8: B38A0012  sth r28, 0x12(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[28].u16 ) };
	// 82EB98FC: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9900: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9904: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EB9908: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB990C: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9910: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9914: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9918: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB991C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB9920: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EB9924: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9928: 41820010  beq 0x82eb9938
	if ctx.cr[0].eq {
	pc = 0x82EB9938; continue 'dispatch;
	}
	// 82EB992C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9930: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9934: 4BFE3335  bl 0x82e9cc68
	ctx.lr = 0x82EB9938;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E9CC68);
	// 82EB9938: 897F0440  lbz r11, 0x440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1088 as u32) ) } as u64;
	// 82EB993C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB9940: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9944: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB9948: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB994C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB9950: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB9954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9958: 41820048  beq 0x82eb99a0
	if ctx.cr[0].eq {
	pc = 0x82EB99A0; continue 'dispatch;
	}
	// 82EB995C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EB9960: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EB9964: 4BFFD5BD  bl 0x82eb6f20
	ctx.lr = 0x82EB9968;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB6F20);
	// 82EB9968: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB996C: 83BF0194  lwz r29, 0x194(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB9970: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB9974: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9978: 4B3A7041  bl 0x822609b8
	ctx.lr = 0x82EB997C;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB997C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB9980: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB9984: 4BFC8365  bl 0x82e81ce8
	ctx.lr = 0x82EB9988;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81CE8);
	// 82EB9988: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82EB998C: 419A0150  beq cr6, 0x82eb9adc
	if ctx.cr[6].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB9990: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 82EB9994: 419A0038  beq cr6, 0x82eb99cc
	if ctx.cr[6].eq {
	pc = 0x82EB99CC; continue 'dispatch;
	}
	// 82EB9998: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82EB999C: 4BFFFEE8  b 0x82eb9884
	pc = 0x82EB9884; continue 'dispatch;
	// 82EB99A0: 4BFFCC09  bl 0x82eb65a8
	ctx.lr = 0x82EB99A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB65A8);
	// 82EB99A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB99A8: 83BF0194  lwz r29, 0x194(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB99AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB99B0: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB99B4: 4B3A7005  bl 0x822609b8
	ctx.lr = 0x82EB99B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EB99B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB99BC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB99C0: 4BFC8329  bl 0x82e81ce8
	ctx.lr = 0x82EB99C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81CE8);
	// 82EB99C4: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB99C8: 419AFFD0  beq cr6, 0x82eb9998
	if ctx.cr[6].eq {
	pc = 0x82EB9998; continue 'dispatch;
	}
	// 82EB99CC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99D0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82EB99D4: 930B01A4  stw r24, 0x1a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), ctx.r[24].u32 ) };
	// 82EB99D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99DC: 938B01AC  stw r28, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[28].u32 ) };
	// 82EB99E0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99E4: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB99E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB99EC: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB99F0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99F4: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB99F8: 812B019C  lwz r9, 0x19c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB99FC: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82EB9A00: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB9A04: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EB9A08: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB9A0C: 813F0054  lwz r9, 0x54(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9A10: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB9A14: 81290198  lwz r9, 0x198(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB9A18: 48000018  b 0x82eb9a30
	pc = 0x82EB9A30; continue 'dispatch;
	// 82EB9A1C: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB9A20: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EB9A24: 38E70005  addi r7, r7, 5
	ctx.r[7].s64 = ctx.r[7].s64 + 5;
	// 82EB9A28: 54E7103A  slwi r7, r7, 2
	// 82EB9A2C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82EB9A30: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB9A34: 409AFFE8  bne cr6, 0x82eb9a1c
	if !ctx.cr[6].eq {
	pc = 0x82EB9A1C; continue 'dispatch;
	}
	// 82EB9A38: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EB9A3C: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EB9A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9A44: 4BFFE905  bl 0x82eb8348
	ctx.lr = 0x82EB9A48;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB8348);
	// 82EB9A48: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9A4C: C01A0000  lfs f0, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A50: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB9A54: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9A58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB9A5C: 409A0028  bne cr6, 0x82eb9a84
	if !ctx.cr[6].eq {
	pc = 0x82EB9A84; continue 'dispatch;
	}
	// 82EB9A60: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A64: C1BA0004  lfs f13, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9A68: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9A6C: 409A0018  bne cr6, 0x82eb9a84
	if !ctx.cr[6].eq {
	pc = 0x82EB9A84; continue 'dispatch;
	}
	// 82EB9A70: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A74: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82EB9A78: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9A7C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9A80: 419A0008  beq cr6, 0x82eb9a88
	if ctx.cr[6].eq {
	pc = 0x82EB9A88; continue 'dispatch;
	}
	// 82EB9A84: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82EB9A88: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB9A8C: 41820030  beq 0x82eb9abc
	if ctx.cr[0].eq {
	pc = 0x82EB9ABC; continue 'dispatch;
	}
	// 82EB9A90: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB9A94: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A98: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9A9C: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9AA0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9AA4: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9AA8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9AAC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9AB0: 814B01B8  lwz r10, 0x1b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB9AB4: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EB9AB8: 914B01B8  stw r10, 0x1b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), ctx.r[10].u32 ) };
	// 82EB9ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9AC0: 80BF0068  lwz r5, 0x68(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9AC4: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9AC8: 9B1F006C  stb r24, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[24].u8 ) };
	// 82EB9ACC: 4BFFC0ED  bl 0x82eb5bb8
	ctx.lr = 0x82EB9AD0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5BB8);
	// 82EB9AD0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82EB9AD4: 4BFFFB34  b 0x82eb9608
	pc = 0x82EB9608; continue 'dispatch;
	// 82EB9AD8: 92FF0058  stw r23, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82EB9ADC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB9AE0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EB9AE4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EB9AE8: 4BDEF95C  b 0x82ca9444
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9444);
	return;
}

pub fn sub_82EB9AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB9AF0 size=272
	// 82EB9AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9AF4: 4BDEF915  bl 0x82ca9408
	ctx.lr = 0x82EB9AF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EB9AF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9AFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB9B00: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB9B04: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB9B08: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB9B0C: 897F018C  lbz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB9B10: 9BBF006C  stb r29, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u8 ) };
	// 82EB9B14: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9B18: 4182007C  beq 0x82eb9b94
	if ctx.cr[0].eq {
	pc = 0x82EB9B94; continue 'dispatch;
	}
	// 82EB9B1C: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9B20: C1BF0180  lfs f13, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9B24: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9B28: 409A0028  bne cr6, 0x82eb9b50
	if !ctx.cr[6].eq {
	pc = 0x82EB9B50; continue 'dispatch;
	}
	// 82EB9B2C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9B30: C1BF0184  lfs f13, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9B34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9B38: 409A0018  bne cr6, 0x82eb9b50
	if !ctx.cr[6].eq {
	pc = 0x82EB9B50; continue 'dispatch;
	}
	// 82EB9B3C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9B40: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB9B44: C1BF0188  lfs f13, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9B48: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9B4C: 419A0008  beq cr6, 0x82eb9b54
	if ctx.cr[6].eq {
	pc = 0x82EB9B54; continue 'dispatch;
	}
	// 82EB9B50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB9B54: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9B58: 40820018  bne 0x82eb9b70
	if !ctx.cr[0].eq {
	pc = 0x82EB9B70; continue 'dispatch;
	}
	// 82EB9B5C: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9B60: 40820010  bne 0x82eb9b70
	if !ctx.cr[0].eq {
	pc = 0x82EB9B70; continue 'dispatch;
	}
	// 82EB9B64: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB9B68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9B6C: 4182004C  beq 0x82eb9bb8
	if ctx.cr[0].eq {
	pc = 0x82EB9BB8; continue 'dispatch;
	}
	// 82EB9B70: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB9B74: 9BBF0040  stb r29, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 82EB9B78: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB9B7C: 409A0020  bne cr6, 0x82eb9b9c
	if !ctx.cr[6].eq {
	pc = 0x82EB9B9C; continue 'dispatch;
	}
	// 82EB9B80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB9B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9B88: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 82EB9B8C: 4BFFC615  bl 0x82eb61a0
	ctx.lr = 0x82EB9B90;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB61A0);
	// 82EB9B90: 4800000C  b 0x82eb9b9c
	pc = 0x82EB9B9C; continue 'dispatch;
	// 82EB9B94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB9B98: 997F018C  stb r11, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u8 ) };
	// 82EB9B9C: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EB9BA0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9BA4: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EB9BA8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9BAC: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB9BB0: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9BB4: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB9BB8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB9BBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB9BC0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB9BC4: 409A0018  bne cr6, 0x82eb9bdc
	if !ctx.cr[6].eq {
	pc = 0x82EB9BDC; continue 'dispatch;
	}
	// 82EB9BC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB9BCC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB9BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9BD4: 4BFFF865  bl 0x82eb9438
	ctx.lr = 0x82EB9BD8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9438);
	// 82EB9BD8: 4800001C  b 0x82eb9bf4
	pc = 0x82EB9BF4; continue 'dispatch;
	// 82EB9BDC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB9BE0: 409A0014  bne cr6, 0x82eb9bf4
	if !ctx.cr[6].eq {
	pc = 0x82EB9BF4; continue 'dispatch;
	}
	// 82EB9BE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB9BE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB9BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9BF0: 4BFFEF31  bl 0x82eb8b20
	ctx.lr = 0x82EB9BF4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB8B20);
	// 82EB9BF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB9BF8: 4BDEF860  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EB9C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB9C00 size=1120
	// 82EB9C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9C04: 4BDEF809  bl 0x82ca940c
	ctx.lr = 0x82EB9C08;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EB9C08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB9C10: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82EB9C14: 4BFCBCED  bl 0x82e85900
	ctx.lr = 0x82EB9C18;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85900);
	// 82EB9C18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB9C1C: 395F00A4  addi r10, r31, 0xa4
	ctx.r[10].s64 = ctx.r[31].s64 + 164;
	// 82EB9C20: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82EB9C24: 393F0104  addi r9, r31, 0x104
	ctx.r[9].s64 = ctx.r[31].s64 + 260;
	// 82EB9C28: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 82EB9C2C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9C30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB9C34: 3CA08204  lis r5, -0x7dfc
	ctx.r[5].s64 = -2113667072;
	// 82EB9C38: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EB9C3C: 390BA8F8  addi r8, r11, -0x5708
	ctx.r[8].s64 = ctx.r[11].s64 + -22280;
	// 82EB9C40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9C44: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82EB9C48: 38E7A8F0  addi r7, r7, -0x5710
	ctx.r[7].s64 = ctx.r[7].s64 + -22288;
	// 82EB9C4C: 38C6A8F0  addi r6, r6, -0x5710
	ctx.r[6].s64 = ctx.r[6].s64 + -22288;
	// 82EB9C50: 38A5A8F0  addi r5, r5, -0x5710
	ctx.r[5].s64 = ctx.r[5].s64 + -22288;
	// 82EB9C54: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB9C58: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EB9C5C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB9C60: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB9C64: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB9C68: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB9C6C: 3908A8F0  addi r8, r8, -0x5710
	ctx.r[8].s64 = ctx.r[8].s64 + -22288;
	// 82EB9C70: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB9C74: D00A0050  stfs f0, 0x50(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB9C78: D00A0054  stfs f0, 0x54(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB9C7C: D00A0058  stfs f0, 0x58(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB9C80: 395F027C  addi r10, r31, 0x27c
	ctx.r[10].s64 = ctx.r[31].s64 + 636;
	// 82EB9C84: D0090050  stfs f0, 0x50(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB9C88: D0090054  stfs f0, 0x54(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB9C8C: D0090058  stfs f0, 0x58(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB9C90: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9C94: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EB9C98: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB9C9C: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB9CA0: 90FF01A0  stw r7, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[7].u32 ) };
	// 82EB9CA4: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82EB9CA8: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 82EB9CAC: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 82EB9CB0: 90DF01B4  stw r6, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[6].u32 ) };
	// 82EB9CB4: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB9CB8: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB9CBC: 917F01C0  stw r11, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82EB9CC0: 90BF01C8  stw r5, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[5].u32 ) };
	// 82EB9CC4: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 82EB9CC8: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 82EB9CCC: 917F01D4  stw r11, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82EB9CD0: 911F01DC  stw r8, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[8].u32 ) };
	// 82EB9CD4: 3909A8F0  addi r8, r9, -0x5710
	ctx.r[8].s64 = ctx.r[9].s64 + -22288;
	// 82EB9CD8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9CDC: 917F01E0  stw r11, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EB9CE0: 917F01E4  stw r11, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82EB9CE4: 38E9A8F0  addi r7, r9, -0x5710
	ctx.r[7].s64 = ctx.r[9].s64 + -22288;
	// 82EB9CE8: 917F01E8  stw r11, 0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[11].u32 ) };
	// 82EB9CEC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9CF0: 917F01F4  stw r11, 0x1f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[11].u32 ) };
	// 82EB9CF4: 911F01F0  stw r8, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[8].u32 ) };
	// 82EB9CF8: 38C9A8F0  addi r6, r9, -0x5710
	ctx.r[6].s64 = ctx.r[9].s64 + -22288;
	// 82EB9CFC: 917F01F8  stw r11, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 82EB9D00: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D04: 917F01FC  stw r11, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[11].u32 ) };
	// 82EB9D08: 90FF0204  stw r7, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[7].u32 ) };
	// 82EB9D0C: 38A9A8F0  addi r5, r9, -0x5710
	ctx.r[5].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D10: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 82EB9D14: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D18: 917F020C  stw r11, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u32 ) };
	// 82EB9D1C: 917F0210  stw r11, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[11].u32 ) };
	// 82EB9D20: 3889A8F0  addi r4, r9, -0x5710
	ctx.r[4].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D24: 90DF0218  stw r6, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[6].u32 ) };
	// 82EB9D28: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D2C: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 82EB9D30: 917F0220  stw r11, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 82EB9D34: 3869A8F0  addi r3, r9, -0x5710
	ctx.r[3].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D38: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 82EB9D3C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D40: 90BF022C  stw r5, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[5].u32 ) };
	// 82EB9D44: 3BC9A8F0  addi r30, r9, -0x5710
	ctx.r[30].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D48: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EB9D4C: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EB9D50: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 82EB9D54: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 82EB9D58: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 82EB9D5C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EB9D60: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 82EB9D64: 909F0240  stw r4, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[4].u32 ) };
	// 82EB9D68: 917F0244  stw r11, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	// 82EB9D6C: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 82EB9D70: 917F024C  stw r11, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u32 ) };
	// 82EB9D74: 907F0254  stw r3, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[3].u32 ) };
	// 82EB9D78: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 82EB9D7C: 917F025C  stw r11, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 82EB9D80: 917F0260  stw r11, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 82EB9D84: 93DF0268  stw r30, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[30].u32 ) };
	// 82EB9D88: 917F026C  stw r11, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 82EB9D8C: 917F0270  stw r11, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 82EB9D90: 917F0274  stw r11, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	// 82EB9D94: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9D98: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9D9C: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9DA0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9DA4: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82EB9DA8: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9DAC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EB9DB0: 4200FFF8  bdnz 0x82eb9da8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9DA8; continue 'dispatch;
	}
	// 82EB9DB4: 38FF02D8  addi r7, r31, 0x2d8
	ctx.r[7].s64 = ctx.r[31].s64 + 728;
	// 82EB9DB8: 996A0058  stb r11, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9DBC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EB9DC0: 39470010  addi r10, r7, 0x10
	ctx.r[10].s64 = ctx.r[7].s64 + 16;
	// 82EB9DC4: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9DC8: D0070004  stfs f0, 4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9DCC: D0070008  stfs f0, 8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9DD0: D007000C  stfs f0, 0xc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9DD4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82EB9DD8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9DDC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB9DE0: 4200FFF8  bdnz 0x82eb9dd8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9DD8; continue 'dispatch;
	}
	// 82EB9DE4: 391F0334  addi r8, r31, 0x334
	ctx.r[8].s64 = ctx.r[31].s64 + 820;
	// 82EB9DE8: 99670058  stb r11, 0x58(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9DEC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB9DF0: 38E80010  addi r7, r8, 0x10
	ctx.r[7].s64 = ctx.r[8].s64 + 16;
	// 82EB9DF4: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9DF8: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9DFC: D0080008  stfs f0, 8(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9E00: D008000C  stfs f0, 0xc(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9E04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EB9E08: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9E0C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EB9E10: 4200FFF8  bdnz 0x82eb9e08
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9E08; continue 'dispatch;
	}
	// 82EB9E14: 395F03A4  addi r10, r31, 0x3a4
	ctx.r[10].s64 = ctx.r[31].s64 + 932;
	// 82EB9E18: 99680058  stb r11, 0x58(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9E1C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EB9E20: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9E24: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9E28: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9E2C: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 82EB9E30: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9E34: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82EB9E38: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9E3C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB9E40: 4200FFF8  bdnz 0x82eb9e38
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9E38; continue 'dispatch;
	}
	// 82EB9E44: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9E48: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82EB9E4C: 996A0058  stb r11, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9E54: 39298704  addi r9, r9, -0x78fc
	ctx.r[9].s64 = ctx.r[9].s64 + -30972;
	// 82EB9E58: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EB9E5C: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EB9E60: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82EB9E64: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82EB9E68: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB9E6C: D01F0428  stfs f0, 0x428(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), tmp.u32 ) };
	// 82EB9E70: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	// 82EB9E74: 917F041C  stw r11, 0x41c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1052 as u32), ctx.r[11].u32 ) };
	// 82EB9E78: D01F042C  stfs f0, 0x42c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), tmp.u32 ) };
	// 82EB9E7C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82EB9E80: D01F0430  stfs f0, 0x430(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 82EB9E84: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB9E88: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 82EB9E8C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82EB9E90: 38A00400  li r5, 0x400
	ctx.r[5].s64 = 1024;
	// 82EB9E94: 386001F4  li r3, 0x1f4
	ctx.r[3].s64 = 500;
	// 82EB9E98: C1A90C14  lfs f13, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9E9C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EB9EA0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9EA4: 917F0418  stw r11, 0x418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), ctx.r[11].u32 ) };
	// 82EB9EA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB9EAC: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB9EB0: 814B9E38  lwz r10, -0x61c8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25032 as u32) ) } as u64;
	// 82EB9EB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB9EB8: 914B9E38  stw r10, -0x61c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25032 as u32), ctx.r[10].u32 ) };
	// 82EB9EBC: D1BF044C  stfs f13, 0x44c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1100 as u32), tmp.u32 ) };
	// 82EB9EC0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB9EC4: 909F0444  stw r4, 0x444(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1092 as u32), ctx.r[4].u32 ) };
	// 82EB9EC8: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82EB9ECC: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EB9ED0: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82EB9ED4: 997F0034  stb r11, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82EB9ED8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB9EDC: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82EB9EE0: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82EB9EE4: 93DF0198  stw r30, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[30].u32 ) };
	// 82EB9EE8: 93DF0164  stw r30, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[30].u32 ) };
	// 82EB9EEC: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9EF0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB9EF4: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB9EF8: 93DF017C  stw r30, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[30].u32 ) };
	// 82EB9EFC: 388BF090  addi r4, r11, -0xf70
	ctx.r[4].s64 = ctx.r[11].s64 + -3952;
	// 82EB9F00: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB9F04: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB9F08: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 82EB9F0C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB9F10: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82EB9F14: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EB9F18: 90FF0030  stw r7, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[7].u32 ) };
	// 82EB9F1C: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB9F20: 993F019C  stb r9, 0x19c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[9].u8 ) };
	// 82EB9F24: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB9F28: 9BDF019D  stb r30, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[30].u8 ) };
	// 82EB9F2C: 90DF0194  stw r6, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[6].u32 ) };
	// 82EB9F30: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82EB9F34: 90BF0098  stw r5, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	// 82EB9F38: 93DF009C  stw r30, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 82EB9F3C: 9BDF007E  stb r30, 0x7e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(126 as u32), ctx.r[30].u8 ) };
	// 82EB9F40: 993F007F  stb r9, 0x7f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(127 as u32), ctx.r[9].u8 ) };
	// 82EB9F44: 9BDF00A0  stb r30, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[30].u8 ) };
	// 82EB9F48: 9BDF00A1  stb r30, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[30].u8 ) };
	// 82EB9F4C: 9BDF0440  stb r30, 0x440(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1088 as u32), ctx.r[30].u8 ) };
	// 82EB9F50: 907F0448  stw r3, 0x448(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1096 as u32), ctx.r[3].u32 ) };
	// 82EB9F54: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB9F58: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB9F5C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EB9F60: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB9F64: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 82EB9F68: 9BDF00AC  stb r30, 0xac(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u8 ) };
	// 82EB9F6C: 93DF00F0  stw r30, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	// 82EB9F70: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 82EB9F74: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 82EB9F78: 9BDF010C  stb r30, 0x10c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u8 ) };
	// 82EB9F7C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EB9F80: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82EB9F84: 93DF0160  stw r30, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[30].u32 ) };
	// 82EB9F88: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82EB9F8C: 93DF0168  stw r30, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[30].u32 ) };
	// 82EB9F90: 807D0718  lwz r3, 0x718(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB9F94: 4B3ADC8D  bl 0x82267c20
	ctx.lr = 0x82EB9F98;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EB9F98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB9F9C: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82EB9FA0: 807D0718  lwz r3, 0x718(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB9FA4: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82EB9FA8: 4B3ADC79  bl 0x82267c20
	ctx.lr = 0x82EB9FAC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EB9FAC: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 82EB9FB0: 9BDF018C  stb r30, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[30].u8 ) };
	// 82EB9FB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9FB8: 93DF01B0  stw r30, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[30].u32 ) };
	// 82EB9FBC: 93DF01C4  stw r30, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[30].u32 ) };
	// 82EB9FC0: 93DF01D8  stw r30, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[30].u32 ) };
	// 82EB9FC4: 93DF01EC  stw r30, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[30].u32 ) };
	// 82EB9FC8: 93DF0200  stw r30, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[30].u32 ) };
	// 82EB9FCC: 93DF0214  stw r30, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[30].u32 ) };
	// 82EB9FD0: 93DF0228  stw r30, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[30].u32 ) };
	// 82EB9FD4: 93DF0264  stw r30, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[30].u32 ) };
	// 82EB9FD8: 93DF0250  stw r30, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[30].u32 ) };
	// 82EB9FDC: 93DF023C  stw r30, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[30].u32 ) };
	// 82EB9FE0: 93DF0278  stw r30, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[30].u32 ) };
	// 82EB9FE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB9FE8: 4BDEF474  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EBA060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBA060 size=1496
	// 82EBA060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBA064: 4BDEF3A5  bl 0x82ca9408
	ctx.lr = 0x82EBA068;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EBA068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBA06C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBA074: 396BA8F8  addi r11, r11, -0x5708
	ctx.r[11].s64 = ctx.r[11].s64 + -22280;
	// 82EBA078: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBA07C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EBA080: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82EBA084: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA088: 816A9E38  lwz r11, -0x61c8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25032 as u32) ) } as u64;
	// 82EBA08C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA090: 916A9E38  stw r11, -0x61c8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25032 as u32), ctx.r[11].u32 ) };
	// 82EBA094: 40820070  bne 0x82eba104
	if !ctx.cr[0].eq {
	pc = 0x82EBA104; continue 'dispatch;
	}
	// 82EBA098: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82EBA09C: 807D9E3C  lwz r3, -0x61c4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EBA0A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBA0A4: 419A0018  beq cr6, 0x82eba0bc
	if ctx.cr[6].eq {
	pc = 0x82EBA0BC; continue 'dispatch;
	}
	// 82EBA0A8: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA0AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA0B0: 4E800421  bctrl
	ctx.lr = 0x82EBA0B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA0B4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EBA0B8: 917D9E3C  stw r11, -0x61c4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-25028 as u32), ctx.r[11].u32 ) };
	// 82EBA0BC: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82EBA0C0: 807D9E40  lwz r3, -0x61c0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EBA0C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBA0C8: 419A0018  beq cr6, 0x82eba0e0
	if ctx.cr[6].eq {
	pc = 0x82EBA0E0; continue 'dispatch;
	}
	// 82EBA0CC: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA0D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA0D4: 4E800421  bctrl
	ctx.lr = 0x82EBA0D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA0D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EBA0DC: 917D9E40  stw r11, -0x61c0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-25024 as u32), ctx.r[11].u32 ) };
	// 82EBA0E0: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82EBA0E4: 807D9E44  lwz r3, -0x61bc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EBA0E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBA0EC: 419A0018  beq cr6, 0x82eba104
	if ctx.cr[6].eq {
	pc = 0x82EBA104; continue 'dispatch;
	}
	// 82EBA0F0: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA0F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA0F8: 4E800421  bctrl
	ctx.lr = 0x82EBA0FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA0FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EBA100: 917D9E44  stw r11, -0x61bc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-25020 as u32), ctx.r[11].u32 ) };
	// 82EBA104: 83BF0054  lwz r29, 0x54(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBA108: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA10C: 41820020  beq 0x82eba12c
	if ctx.cr[0].eq {
	pc = 0x82EBA12C; continue 'dispatch;
	}
	// 82EBA110: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBA114: 4BFFBC05  bl 0x82eb5d18
	ctx.lr = 0x82EBA118;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5D18);
	// 82EBA118: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA11C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBA120: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA124: 4E800421  bctrl
	ctx.lr = 0x82EBA128;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA128: 939F0054  stw r28, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EBA12C: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EBA130: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA134: 41820014  beq 0x82eba148
	if ctx.cr[0].eq {
	pc = 0x82EBA148; continue 'dispatch;
	}
	// 82EBA138: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA13C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA140: 4E800421  bctrl
	ctx.lr = 0x82EBA144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA144: 939F0094  stw r28, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	// 82EBA148: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EBA14C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA150: 41820014  beq 0x82eba164
	if ctx.cr[0].eq {
	pc = 0x82EBA164; continue 'dispatch;
	}
	// 82EBA154: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA15C: 4E800421  bctrl
	ctx.lr = 0x82EBA160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA160: 939F0060  stw r28, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EBA164: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA168: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA16C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA170: 4099004C  ble cr6, 0x82eba1bc
	if !ctx.cr[6].gt {
	pc = 0x82EBA1BC; continue 'dispatch;
	}
	// 82EBA174: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA178: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBA17C: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBA180: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA184: 419A0024  beq cr6, 0x82eba1a8
	if ctx.cr[6].eq {
	pc = 0x82EBA1A8; continue 'dispatch;
	}
	// 82EBA188: 5543003E  slwi r3, r10, 0
	// 82EBA18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA190: 41820018  beq 0x82eba1a8
	if ctx.cr[0].eq {
	pc = 0x82EBA1A8; continue 'dispatch;
	}
	// 82EBA194: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA198: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA19C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA1A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA1A4: 4E800421  bctrl
	ctx.lr = 0x82EBA1A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA1A8: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA1AC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA1B0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA1B4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA1B8: 4198FFC0  blt cr6, 0x82eba178
	if ctx.cr[6].lt {
	pc = 0x82EBA178; continue 'dispatch;
	}
	// 82EBA1BC: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA1C0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA1C8: 4099004C  ble cr6, 0x82eba214
	if !ctx.cr[6].gt {
	pc = 0x82EBA214; continue 'dispatch;
	}
	// 82EBA1CC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA1D0: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBA1D4: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA1D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA1DC: 419A0024  beq cr6, 0x82eba200
	if ctx.cr[6].eq {
	pc = 0x82EBA200; continue 'dispatch;
	}
	// 82EBA1E0: 5543003E  slwi r3, r10, 0
	// 82EBA1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA1E8: 41820018  beq 0x82eba200
	if ctx.cr[0].eq {
	pc = 0x82EBA200; continue 'dispatch;
	}
	// 82EBA1EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA1F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA1F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA1F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA1FC: 4E800421  bctrl
	ctx.lr = 0x82EBA200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA200: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA204: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA208: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA20C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA210: 4198FFC0  blt cr6, 0x82eba1d0
	if ctx.cr[6].lt {
	pc = 0x82EBA1D0; continue 'dispatch;
	}
	// 82EBA214: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBA218: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA220: 4099004C  ble cr6, 0x82eba26c
	if !ctx.cr[6].gt {
	pc = 0x82EBA26C; continue 'dispatch;
	}
	// 82EBA224: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA228: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBA22C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA230: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA234: 419A0024  beq cr6, 0x82eba258
	if ctx.cr[6].eq {
	pc = 0x82EBA258; continue 'dispatch;
	}
	// 82EBA238: 5543003E  slwi r3, r10, 0
	// 82EBA23C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA240: 41820018  beq 0x82eba258
	if ctx.cr[0].eq {
	pc = 0x82EBA258; continue 'dispatch;
	}
	// 82EBA244: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA248: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA24C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA254: 4E800421  bctrl
	ctx.lr = 0x82EBA258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA258: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBA25C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA260: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA264: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA268: 4198FFC0  blt cr6, 0x82eba228
	if ctx.cr[6].lt {
	pc = 0x82EBA228; continue 'dispatch;
	}
	// 82EBA26C: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBA270: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA278: 4099004C  ble cr6, 0x82eba2c4
	if !ctx.cr[6].gt {
	pc = 0x82EBA2C4; continue 'dispatch;
	}
	// 82EBA27C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA280: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBA284: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA288: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA28C: 419A0024  beq cr6, 0x82eba2b0
	if ctx.cr[6].eq {
	pc = 0x82EBA2B0; continue 'dispatch;
	}
	// 82EBA290: 5543003E  slwi r3, r10, 0
	// 82EBA294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA298: 41820018  beq 0x82eba2b0
	if ctx.cr[0].eq {
	pc = 0x82EBA2B0; continue 'dispatch;
	}
	// 82EBA29C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA2A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA2A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA2A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA2AC: 4E800421  bctrl
	ctx.lr = 0x82EBA2B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA2B0: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBA2B4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA2B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA2BC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA2C0: 4198FFC0  blt cr6, 0x82eba280
	if ctx.cr[6].lt {
	pc = 0x82EBA280; continue 'dispatch;
	}
	// 82EBA2C4: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBA2C8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA2D0: 4099004C  ble cr6, 0x82eba31c
	if !ctx.cr[6].gt {
	pc = 0x82EBA31C; continue 'dispatch;
	}
	// 82EBA2D4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA2D8: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBA2DC: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA2E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA2E4: 419A0024  beq cr6, 0x82eba308
	if ctx.cr[6].eq {
	pc = 0x82EBA308; continue 'dispatch;
	}
	// 82EBA2E8: 5543003E  slwi r3, r10, 0
	// 82EBA2EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA2F0: 41820018  beq 0x82eba308
	if ctx.cr[0].eq {
	pc = 0x82EBA308; continue 'dispatch;
	}
	// 82EBA2F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA2F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA2FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA300: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA304: 4E800421  bctrl
	ctx.lr = 0x82EBA308;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA308: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBA30C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA310: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA314: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA318: 4198FFC0  blt cr6, 0x82eba2d8
	if ctx.cr[6].lt {
	pc = 0x82EBA2D8; continue 'dispatch;
	}
	// 82EBA31C: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBA320: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA328: 4099004C  ble cr6, 0x82eba374
	if !ctx.cr[6].gt {
	pc = 0x82EBA374; continue 'dispatch;
	}
	// 82EBA32C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA330: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBA334: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA33C: 419A0024  beq cr6, 0x82eba360
	if ctx.cr[6].eq {
	pc = 0x82EBA360; continue 'dispatch;
	}
	// 82EBA340: 5543003E  slwi r3, r10, 0
	// 82EBA344: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA348: 41820018  beq 0x82eba360
	if ctx.cr[0].eq {
	pc = 0x82EBA360; continue 'dispatch;
	}
	// 82EBA34C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA350: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA354: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA358: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA35C: 4E800421  bctrl
	ctx.lr = 0x82EBA360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA360: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBA364: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA368: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA36C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA370: 4198FFC0  blt cr6, 0x82eba330
	if ctx.cr[6].lt {
	pc = 0x82EBA330; continue 'dispatch;
	}
	// 82EBA374: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBA378: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA380: 4099004C  ble cr6, 0x82eba3cc
	if !ctx.cr[6].gt {
	pc = 0x82EBA3CC; continue 'dispatch;
	}
	// 82EBA384: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA388: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBA38C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA394: 419A0024  beq cr6, 0x82eba3b8
	if ctx.cr[6].eq {
	pc = 0x82EBA3B8; continue 'dispatch;
	}
	// 82EBA398: 5543003E  slwi r3, r10, 0
	// 82EBA39C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3A0: 41820018  beq 0x82eba3b8
	if ctx.cr[0].eq {
	pc = 0x82EBA3B8; continue 'dispatch;
	}
	// 82EBA3A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA3A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA3AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA3B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA3B4: 4E800421  bctrl
	ctx.lr = 0x82EBA3B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA3B8: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBA3BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA3C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA3C4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA3C8: 4198FFC0  blt cr6, 0x82eba388
	if ctx.cr[6].lt {
	pc = 0x82EBA388; continue 'dispatch;
	}
	// 82EBA3CC: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBA3D0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3D8: 4099004C  ble cr6, 0x82eba424
	if !ctx.cr[6].gt {
	pc = 0x82EBA424; continue 'dispatch;
	}
	// 82EBA3DC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA3E0: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBA3E4: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA3E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3EC: 419A0024  beq cr6, 0x82eba410
	if ctx.cr[6].eq {
	pc = 0x82EBA410; continue 'dispatch;
	}
	// 82EBA3F0: 5543003E  slwi r3, r10, 0
	// 82EBA3F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3F8: 41820018  beq 0x82eba410
	if ctx.cr[0].eq {
	pc = 0x82EBA410; continue 'dispatch;
	}
	// 82EBA3FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA400: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA404: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA40C: 4E800421  bctrl
	ctx.lr = 0x82EBA410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA410: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBA414: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA418: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA41C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA420: 4198FFC0  blt cr6, 0x82eba3e0
	if ctx.cr[6].lt {
	pc = 0x82EBA3E0; continue 'dispatch;
	}
	// 82EBA424: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBA428: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA42C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA430: 4099004C  ble cr6, 0x82eba47c
	if !ctx.cr[6].gt {
	pc = 0x82EBA47C; continue 'dispatch;
	}
	// 82EBA434: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA438: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBA43C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA440: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA444: 419A0024  beq cr6, 0x82eba468
	if ctx.cr[6].eq {
	pc = 0x82EBA468; continue 'dispatch;
	}
	// 82EBA448: 5543003E  slwi r3, r10, 0
	// 82EBA44C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA450: 41820018  beq 0x82eba468
	if ctx.cr[0].eq {
	pc = 0x82EBA468; continue 'dispatch;
	}
	// 82EBA454: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA458: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA45C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA464: 4E800421  bctrl
	ctx.lr = 0x82EBA468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA468: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBA46C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA470: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA474: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA478: 4198FFC0  blt cr6, 0x82eba438
	if ctx.cr[6].lt {
	pc = 0x82EBA438; continue 'dispatch;
	}
	// 82EBA47C: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBA480: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA488: 4099004C  ble cr6, 0x82eba4d4
	if !ctx.cr[6].gt {
	pc = 0x82EBA4D4; continue 'dispatch;
	}
	// 82EBA48C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA490: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBA494: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA498: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA49C: 419A0024  beq cr6, 0x82eba4c0
	if ctx.cr[6].eq {
	pc = 0x82EBA4C0; continue 'dispatch;
	}
	// 82EBA4A0: 5543003E  slwi r3, r10, 0
	// 82EBA4A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA4A8: 41820018  beq 0x82eba4c0
	if ctx.cr[0].eq {
	pc = 0x82EBA4C0; continue 'dispatch;
	}
	// 82EBA4AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA4B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA4B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA4B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA4BC: 4E800421  bctrl
	ctx.lr = 0x82EBA4C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA4C0: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBA4C4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA4C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA4CC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA4D0: 4198FFC0  blt cr6, 0x82eba490
	if ctx.cr[6].lt {
	pc = 0x82EBA490; continue 'dispatch;
	}
	// 82EBA4D4: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBA4D8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA4DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA4E0: 4099004C  ble cr6, 0x82eba52c
	if !ctx.cr[6].gt {
	pc = 0x82EBA52C; continue 'dispatch;
	}
	// 82EBA4E4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EBA4E8: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBA4EC: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA4F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA4F4: 419A0024  beq cr6, 0x82eba518
	if ctx.cr[6].eq {
	pc = 0x82EBA518; continue 'dispatch;
	}
	// 82EBA4F8: 5543003E  slwi r3, r10, 0
	// 82EBA4FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA500: 41820018  beq 0x82eba518
	if ctx.cr[0].eq {
	pc = 0x82EBA518; continue 'dispatch;
	}
	// 82EBA504: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA508: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA50C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA514: 4E800421  bctrl
	ctx.lr = 0x82EBA518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA518: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBA51C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA520: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA524: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA528: 4198FFC0  blt cr6, 0x82eba4e8
	if ctx.cr[6].lt {
	pc = 0x82EBA4E8; continue 'dispatch;
	}
	// 82EBA52C: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EBA530: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA534: 41820024  beq 0x82eba558
	if ctx.cr[0].eq {
	pc = 0x82EBA558; continue 'dispatch;
	}
	// 82EBA538: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA53C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA540: 41820018  beq 0x82eba558
	if ctx.cr[0].eq {
	pc = 0x82EBA558; continue 'dispatch;
	}
	// 82EBA544: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EBA548: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EBA54C: 388B5818  addi r4, r11, 0x5818
	ctx.r[4].s64 = ctx.r[11].s64 + 22552;
	// 82EBA550: 480125B1  bl 0x82eccb00
	ctx.lr = 0x82EBA554;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ECCB00);
	// 82EBA554: 9B9F00A0  stb r28, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[28].u8 ) };
	// 82EBA558: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EBA55C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA560: 41820020  beq 0x82eba580
	if ctx.cr[0].eq {
	pc = 0x82EBA580; continue 'dispatch;
	}
	// 82EBA564: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA568: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA56C: 41820014  beq 0x82eba580
	if ctx.cr[0].eq {
	pc = 0x82EBA580; continue 'dispatch;
	}
	// 82EBA570: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EBA574: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA578: 41820008  beq 0x82eba580
	if ctx.cr[0].eq {
	pc = 0x82EBA580; continue 'dispatch;
	}
	// 82EBA57C: 480189B5  bl 0x82ed2f30
	ctx.lr = 0x82EBA580;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EBA580: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EBA584: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82EBA588: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA58C: 41820020  beq 0x82eba5ac
	if ctx.cr[0].eq {
	pc = 0x82EBA5AC; continue 'dispatch;
	}
	// 82EBA590: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA598: 41820014  beq 0x82eba5ac
	if ctx.cr[0].eq {
	pc = 0x82EBA5AC; continue 'dispatch;
	}
	// 82EBA59C: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EBA5A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA5A4: 41820008  beq 0x82eba5ac
	if ctx.cr[0].eq {
	pc = 0x82EBA5AC; continue 'dispatch;
	}
	// 82EBA5A8: 48018989  bl 0x82ed2f30
	ctx.lr = 0x82EBA5AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED2F30);
	// 82EBA5AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBA5B0: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EBA5B4: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 82EBA5B8: 387F0268  addi r3, r31, 0x268
	ctx.r[3].s64 = ctx.r[31].s64 + 616;
	// 82EBA5BC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EBA5C0: 917F0418  stw r11, 0x418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), ctx.r[11].u32 ) };
	// 82EBA5C4: 917F03A4  stw r11, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[11].u32 ) };
	// 82EBA5C8: 917F0334  stw r11, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[11].u32 ) };
	// 82EBA5CC: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	// 82EBA5D0: 917F027C  stw r11, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[11].u32 ) };
	// 82EBA5D4: 4BFFEDAD  bl 0x82eb9380
	ctx.lr = 0x82EBA5D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA5D8: 387F0254  addi r3, r31, 0x254
	ctx.r[3].s64 = ctx.r[31].s64 + 596;
	// 82EBA5DC: 4BFFEDA5  bl 0x82eb9380
	ctx.lr = 0x82EBA5E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA5E0: 387F0240  addi r3, r31, 0x240
	ctx.r[3].s64 = ctx.r[31].s64 + 576;
	// 82EBA5E4: 4BFFED9D  bl 0x82eb9380
	ctx.lr = 0x82EBA5E8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA5E8: 387F022C  addi r3, r31, 0x22c
	ctx.r[3].s64 = ctx.r[31].s64 + 556;
	// 82EBA5EC: 4BFFED95  bl 0x82eb9380
	ctx.lr = 0x82EBA5F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA5F0: 387F0218  addi r3, r31, 0x218
	ctx.r[3].s64 = ctx.r[31].s64 + 536;
	// 82EBA5F4: 4BFFED8D  bl 0x82eb9380
	ctx.lr = 0x82EBA5F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA5F8: 387F0204  addi r3, r31, 0x204
	ctx.r[3].s64 = ctx.r[31].s64 + 516;
	// 82EBA5FC: 4BFFED85  bl 0x82eb9380
	ctx.lr = 0x82EBA600;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA600: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 82EBA604: 4BFFED7D  bl 0x82eb9380
	ctx.lr = 0x82EBA608;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA608: 387F01DC  addi r3, r31, 0x1dc
	ctx.r[3].s64 = ctx.r[31].s64 + 476;
	// 82EBA60C: 4BFFED75  bl 0x82eb9380
	ctx.lr = 0x82EBA610;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA610: 387F01C8  addi r3, r31, 0x1c8
	ctx.r[3].s64 = ctx.r[31].s64 + 456;
	// 82EBA614: 4BFFED6D  bl 0x82eb9380
	ctx.lr = 0x82EBA618;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA618: 387F01B4  addi r3, r31, 0x1b4
	ctx.r[3].s64 = ctx.r[31].s64 + 436;
	// 82EBA61C: 4BFFED65  bl 0x82eb9380
	ctx.lr = 0x82EBA620;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA620: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EBA624: 4BFFED5D  bl 0x82eb9380
	ctx.lr = 0x82EBA628;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9380);
	// 82EBA628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBA62C: 4BFCB24D  bl 0x82e85878
	ctx.lr = 0x82EBA630;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85878);
	// 82EBA630: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBA634: 4BDEEE24  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EBA638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBA638 size=3392
	// 82EBA638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBA63C: 4BDEEDC1  bl 0x82ca93fc
	ctx.lr = 0x82EBA640;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93FC);
	// 82EBA640: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBA644: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EBA648: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBA64C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EBA650: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBA654: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EBA658: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBA65C: C14A0C14  lfs f10, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBA660: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA664: 4182000C  beq 0x82eba670
	if ctx.cr[0].eq {
	pc = 0x82EBA670; continue 'dispatch;
	}
	// 82EBA668: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBA66C: 48000008  b 0x82eba674
	pc = 0x82EBA674; continue 'dispatch;
	// 82EBA670: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EBA674: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA678: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBA67C: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBA680: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA684: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBA688: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBA68C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBA690: 41980008  blt cr6, 0x82eba698
	if ctx.cr[6].lt {
	pc = 0x82EBA698; continue 'dispatch;
	}
	// 82EBA694: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82EBA698: FF0C6000  fcmpu cr6, f12, f12
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[12].f64);
	// 82EBA69C: 409AFFF0  bne cr6, 0x82eba68c
	if !ctx.cr[6].eq {
	pc = 0x82EBA68C; continue 'dispatch;
	}
	// 82EBA6A0: D19F0024  stfs f12, 0x24(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBA6A4: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBA6A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA6AC: 4182000C  beq 0x82eba6b8
	if ctx.cr[0].eq {
	pc = 0x82EBA6B8; continue 'dispatch;
	}
	// 82EBA6B0: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBA6B4: 48000008  b 0x82eba6bc
	pc = 0x82EBA6BC; continue 'dispatch;
	// 82EBA6B8: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 82EBA6BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA6C0: C01F002C  lfs f0, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBA6C4: C1AB0AEC  lfs f13, 0xaec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBA6C8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBA6CC: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EBA6D0: 41980008  blt cr6, 0x82eba6d8
	if ctx.cr[6].lt {
	pc = 0x82EBA6D8; continue 'dispatch;
	}
	// 82EBA6D4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBA6D8: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBA6DC: 409AFFF0  bne cr6, 0x82eba6cc
	if !ctx.cr[6].eq {
	pc = 0x82EBA6CC; continue 'dispatch;
	}
	// 82EBA6E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA6E4: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EBA6E8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EBA6EC: D15F043C  stfs f10, 0x43c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1084 as u32), tmp.u32 ) };
	// 82EBA6F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBA6F4: C1AB0BF8  lfs f13, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBA6F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBA6FC: D1BF0420  stfs f13, 0x420(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1056 as u32), tmp.u32 ) };
	// 82EBA700: 9B3F019D  stb r25, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[25].u8 ) };
	// 82EBA704: 997F019C  stb r11, 0x19c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u8 ) };
	// 82EBA708: 4BFCACA1  bl 0x82e853a8
	ctx.lr = 0x82EBA70C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E853A8);
	// 82EBA70C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA710: 4082000C  bne 0x82eba71c
	if !ctx.cr[0].eq {
	pc = 0x82EBA71C; continue 'dispatch;
	}
	// 82EBA714: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBA718: 48000C54  b 0x82ebb36c
	pc = 0x82EBB36C; continue 'dispatch;
	// 82EBA71C: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EBA720: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EBA724: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 82EBA728: 615CFFFF  ori r28, r10, 0xffff
	ctx.r[28].u64 = ctx.r[10].u64 | 65535;
	// 82EBA72C: 5563103A  slwi r3, r11, 2
	// 82EBA730: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EBA734: 40990008  ble cr6, 0x82eba73c
	if !ctx.cr[6].gt {
	pc = 0x82EBA73C; continue 'dispatch;
	}
	// 82EBA738: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBA73C: 4B75C1ED  bl 0x82616928
	ctx.lr = 0x82EBA740;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBA740: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EBA744: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBA748: 907F0060  stw r3, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EBA74C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA750: 40990024  ble cr6, 0x82eba774
	if !ctx.cr[6].gt {
	pc = 0x82EBA774; continue 'dispatch;
	}
	// 82EBA754: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82EBA758: 813F0060  lwz r9, 0x60(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EBA75C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBA760: 7F29512E  stwx r25, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[25].u32) };
	// 82EBA764: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EBA768: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EBA76C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EBA770: 4198FFE8  blt cr6, 0x82eba758
	if ctx.cr[6].lt {
	pc = 0x82EBA758; continue 'dispatch;
	}
	// 82EBA774: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EBA778: 4B75C1B1  bl 0x82616928
	ctx.lr = 0x82EBA77C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBA77C: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EBA780: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82EBA784: 907F0094  stw r3, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EBA788: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA78C: 817E9E3C  lwz r11, -0x61c4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EBA790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA794: 409A006C  bne cr6, 0x82eba800
	if !ctx.cr[6].eq {
	pc = 0x82EBA800; continue 'dispatch;
	}
	// 82EBA798: 3FA08330  lis r29, -0x7cd0
	ctx.r[29].s64 = -2094006272;
	// 82EBA79C: 3D400924  lis r10, 0x924
	ctx.r[10].s64 = 153354240;
	// 82EBA7A0: 614A9249  ori r10, r10, 0x9249
	ctx.r[10].u64 = ctx.r[10].u64 | 37449;
	// 82EBA7A4: 817DDF34  lwz r11, -0x20cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EBA7A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EBA7AC: 1C6B001C  mulli r3, r11, 0x1c
	ctx.r[3].s64 = ctx.r[11].s64 * 28;
	// 82EBA7B0: 40990008  ble cr6, 0x82eba7b8
	if !ctx.cr[6].gt {
	pc = 0x82EBA7B8; continue 'dispatch;
	}
	// 82EBA7B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBA7B8: 4B75C171  bl 0x82616928
	ctx.lr = 0x82EBA7BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBA7BC: 817DDF34  lwz r11, -0x20cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EBA7C0: 907E9E3C  stw r3, -0x61c4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-25028 as u32), ctx.r[3].u32 ) };
	// 82EBA7C4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EBA7C8: 5563103A  slwi r3, r11, 2
	// 82EBA7CC: 40990008  ble cr6, 0x82eba7d4
	if !ctx.cr[6].gt {
	pc = 0x82EBA7D4; continue 'dispatch;
	}
	// 82EBA7D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBA7D4: 4B75C155  bl 0x82616928
	ctx.lr = 0x82EBA7D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBA7D8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBA7DC: 817DDF34  lwz r11, -0x20cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EBA7E0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EBA7E4: 906A9E40  stw r3, -0x61c0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25024 as u32), ctx.r[3].u32 ) };
	// 82EBA7E8: 5563103A  slwi r3, r11, 2
	// 82EBA7EC: 40990008  ble cr6, 0x82eba7f4
	if !ctx.cr[6].gt {
	pc = 0x82EBA7F4; continue 'dispatch;
	}
	// 82EBA7F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBA7F4: 4B75C135  bl 0x82616928
	ctx.lr = 0x82EBA7F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBA7F8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBA7FC: 906B9E44  stw r3, -0x61bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25020 as u32), ctx.r[3].u32 ) };
	// 82EBA800: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBA804: 386001C4  li r3, 0x1c4
	ctx.r[3].s64 = 452;
	// 82EBA808: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EBA80C: 409A0020  bne cr6, 0x82eba82c
	if !ctx.cr[6].eq {
	pc = 0x82EBA82C; continue 'dispatch;
	}
	// 82EBA810: 4B75C119  bl 0x82616928
	ctx.lr = 0x82EBA814;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBA814: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA818: 41820040  beq 0x82eba858
	if ctx.cr[0].eq {
	pc = 0x82EBA858; continue 'dispatch;
	}
	// 82EBA81C: 3CC00005  lis r6, 5
	ctx.r[6].s64 = 327680;
	// 82EBA820: 38A02800  li r5, 0x2800
	ctx.r[5].s64 = 10240;
	// 82EBA824: 38803800  li r4, 0x3800
	ctx.r[4].s64 = 14336;
	// 82EBA828: 48000028  b 0x82eba850
	pc = 0x82EBA850; continue 'dispatch;
	// 82EBA82C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EBA830: 1FCB0018  mulli r30, r11, 0x18
	ctx.r[30].s64 = ctx.r[11].s64 * 24;
	// 82EBA834: 1FAB0014  mulli r29, r11, 0x14
	ctx.r[29].s64 = ctx.r[11].s64 * 20;
	// 82EBA838: 4B75C0F1  bl 0x82616928
	ctx.lr = 0x82EBA83C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBA83C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA840: 41820018  beq 0x82eba858
	if ctx.cr[0].eq {
	pc = 0x82EBA858; continue 'dispatch;
	}
	// 82EBA844: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EBA848: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBA84C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA850: 4BFFBCA9  bl 0x82eb64f8
	ctx.lr = 0x82EBA854;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB64F8);
	// 82EBA854: 48000008  b 0x82eba85c
	pc = 0x82EBA85C; continue 'dispatch;
	// 82EBA858: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBA85C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA860: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EBA864: 3BCBA9B8  addi r30, r11, -0x5648
	ctx.r[30].s64 = ctx.r[11].s64 + -22088;
	// 82EBA868: 4B3A6151  bl 0x822609b8
	ctx.lr = 0x82EBA86C;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EBA86C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBA870: 4BFC68F9  bl 0x82e81168
	ctx.lr = 0x82EBA874;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81168);
	// 82EBA874: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA878: 907F0194  stw r3, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[3].u32 ) };
	// 82EBA87C: 3BCBA994  addi r30, r11, -0x566c
	ctx.r[30].s64 = ctx.r[11].s64 + -22124;
	// 82EBA880: 4B3A6139  bl 0x822609b8
	ctx.lr = 0x82EBA884;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EBA884: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBA888: 4BFC68E1  bl 0x82e81168
	ctx.lr = 0x82EBA88C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81168);
	// 82EBA88C: 817F01B0  lwz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EBA890: 3B7F01B0  addi r27, r31, 0x1b0
	ctx.r[27].s64 = ctx.r[31].s64 + 432;
	// 82EBA894: 907F0414  stw r3, 0x414(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1044 as u32), ctx.r[3].u32 ) };
	// 82EBA898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA89C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA8A0: 3B4BA98C  addi r26, r11, -0x5674
	ctx.r[26].s64 = ctx.r[11].s64 + -22132;
	// 82EBA8A4: 409A00F0  bne cr6, 0x82eba994
	if !ctx.cr[6].eq {
	pc = 0x82EBA994; continue 'dispatch;
	}
	// 82EBA8A8: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA8AC: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBA8B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA8B4: 40990078  ble cr6, 0x82eba92c
	if !ctx.cr[6].gt {
	pc = 0x82EBA92C; continue 'dispatch;
	}
	// 82EBA8B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBA8BC: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBA8C0: 3B8BE058  addi r28, r11, -0x1fa8
	ctx.r[28].s64 = ctx.r[11].s64 + -8104;
	// 82EBA8C4: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBA8C8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA8CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA8D0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBA8D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA8D8: 4E800421  bctrl
	ctx.lr = 0x82EBA8DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA8DC: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBA8E0: 419A0034  beq cr6, 0x82eba914
	if ctx.cr[6].eq {
	pc = 0x82EBA914; continue 'dispatch;
	}
	// 82EBA8E4: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBA8E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA8EC: 4082FFF0  bne 0x82eba8dc
	if !ctx.cr[0].eq {
	pc = 0x82EBA8DC; continue 'dispatch;
	}
	// 82EBA8F0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBA8F4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA8F8: 40820024  bne 0x82eba91c
	if !ctx.cr[0].eq {
	pc = 0x82EBA91C; continue 'dispatch;
	}
	// 82EBA8FC: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA900: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA904: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA908: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA90C: 4198FFB8  blt cr6, 0x82eba8c4
	if ctx.cr[6].lt {
	pc = 0x82EBA8C4; continue 'dispatch;
	}
	// 82EBA910: 4800001C  b 0x82eba92c
	pc = 0x82EBA92C; continue 'dispatch;
	// 82EBA914: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBA918: 4BFFFFDC  b 0x82eba8f4
	pc = 0x82EBA8F4; continue 'dispatch;
	// 82EBA91C: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBA920: 57AA103A  slwi r10, r29, 2
	// 82EBA924: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBA928: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA92C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA934: 409A0060  bne cr6, 0x82eba994
	if !ctx.cr[6].eq {
	pc = 0x82EBA994; continue 'dispatch;
	}
	// 82EBA938: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBA93C: 4B75BFED  bl 0x82616928
	ctx.lr = 0x82EBA940;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBA940: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBA944: 41820028  beq 0x82eba96c
	if ctx.cr[0].eq {
	pc = 0x82EBA96C; continue 'dispatch;
	}
	// 82EBA948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBA94C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBA950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBA954: 4BFFA9DD  bl 0x82eb5330
	ctx.lr = 0x82EBA958;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBA958: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBA960: 396BA7D0  addi r11, r11, -0x5830
	ctx.r[11].s64 = ctx.r[11].s64 + -22576;
	// 82EBA964: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA968: 48000008  b 0x82eba970
	pc = 0x82EBA970; continue 'dispatch;
	// 82EBA96C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBA970: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBA974: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBA978: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA97C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBA980: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA984: 4E800421  bctrl
	ctx.lr = 0x82EBA988;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA988: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBA98C: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EBA990: 4BFFE901  bl 0x82eb9290
	ctx.lr = 0x82EBA994;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBA994: 817F01C4  lwz r11, 0x1c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EBA998: 3B7F01C4  addi r27, r31, 0x1c4
	ctx.r[27].s64 = ctx.r[31].s64 + 452;
	// 82EBA99C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA9A0: 409A00F0  bne cr6, 0x82ebaa90
	if !ctx.cr[6].eq {
	pc = 0x82EBAA90; continue 'dispatch;
	}
	// 82EBA9A4: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA9A8: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBA9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA9B0: 40990078  ble cr6, 0x82ebaa28
	if !ctx.cr[6].gt {
	pc = 0x82EBAA28; continue 'dispatch;
	}
	// 82EBA9B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBA9B8: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBA9BC: 3B8BDD1C  addi r28, r11, -0x22e4
	ctx.r[28].s64 = ctx.r[11].s64 + -8932;
	// 82EBA9C0: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBA9C4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA9C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA9CC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBA9D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA9D4: 4E800421  bctrl
	ctx.lr = 0x82EBA9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA9D8: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBA9DC: 419A0034  beq cr6, 0x82ebaa10
	if ctx.cr[6].eq {
	pc = 0x82EBAA10; continue 'dispatch;
	}
	// 82EBA9E0: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBA9E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA9E8: 4082FFF0  bne 0x82eba9d8
	if !ctx.cr[0].eq {
	pc = 0x82EBA9D8; continue 'dispatch;
	}
	// 82EBA9EC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBA9F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA9F4: 40820024  bne 0x82ebaa18
	if !ctx.cr[0].eq {
	pc = 0x82EBAA18; continue 'dispatch;
	}
	// 82EBA9F8: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA9FC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAA00: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAA04: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAA08: 4198FFB8  blt cr6, 0x82eba9c0
	if ctx.cr[6].lt {
	pc = 0x82EBA9C0; continue 'dispatch;
	}
	// 82EBAA0C: 4800001C  b 0x82ebaa28
	pc = 0x82EBAA28; continue 'dispatch;
	// 82EBAA10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAA14: 4BFFFFDC  b 0x82eba9f0
	pc = 0x82EBA9F0; continue 'dispatch;
	// 82EBAA18: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBAA1C: 57AA103A  slwi r10, r29, 2
	// 82EBAA20: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAA24: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAA28: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAA30: 409A0060  bne cr6, 0x82ebaa90
	if !ctx.cr[6].eq {
	pc = 0x82EBAA90; continue 'dispatch;
	}
	// 82EBAA34: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EBAA38: 4B75BEF1  bl 0x82616928
	ctx.lr = 0x82EBAA3C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBAA3C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAA40: 41820028  beq 0x82ebaa68
	if ctx.cr[0].eq {
	pc = 0x82EBAA68; continue 'dispatch;
	}
	// 82EBAA44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAA48: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAA4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAA50: 4BFFA8E1  bl 0x82eb5330
	ctx.lr = 0x82EBAA54;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBAA54: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAA5C: 396BA7E8  addi r11, r11, -0x5818
	ctx.r[11].s64 = ctx.r[11].s64 + -22552;
	// 82EBAA60: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAA64: 48000008  b 0x82ebaa6c
	pc = 0x82EBAA6C; continue 'dispatch;
	// 82EBAA68: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAA6C: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAA70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAA74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAA78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAA7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAA80: 4E800421  bctrl
	ctx.lr = 0x82EBAA84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAA84: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAA88: 387F01B4  addi r3, r31, 0x1b4
	ctx.r[3].s64 = ctx.r[31].s64 + 436;
	// 82EBAA8C: 4BFFE805  bl 0x82eb9290
	ctx.lr = 0x82EBAA90;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBAA90: 817F01D8  lwz r11, 0x1d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EBAA94: 3B7F01D8  addi r27, r31, 0x1d8
	ctx.r[27].s64 = ctx.r[31].s64 + 472;
	// 82EBAA98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAA9C: 409A00F0  bne cr6, 0x82ebab8c
	if !ctx.cr[6].eq {
	pc = 0x82EBAB8C; continue 'dispatch;
	}
	// 82EBAAA0: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBAAA4: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAAA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAAAC: 40990078  ble cr6, 0x82ebab24
	if !ctx.cr[6].gt {
	pc = 0x82EBAB24; continue 'dispatch;
	}
	// 82EBAAB0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAAB4: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAAB8: 3B8BDAF4  addi r28, r11, -0x250c
	ctx.r[28].s64 = ctx.r[11].s64 + -9484;
	// 82EBAABC: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBAAC0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBAAC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAAC8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBAACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAAD0: 4E800421  bctrl
	ctx.lr = 0x82EBAAD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAAD4: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBAAD8: 419A0034  beq cr6, 0x82ebab0c
	if ctx.cr[6].eq {
	pc = 0x82EBAB0C; continue 'dispatch;
	}
	// 82EBAADC: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBAAE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAAE4: 4082FFF0  bne 0x82ebaad4
	if !ctx.cr[0].eq {
	pc = 0x82EBAAD4; continue 'dispatch;
	}
	// 82EBAAE8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBAAEC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBAAF0: 40820024  bne 0x82ebab14
	if !ctx.cr[0].eq {
	pc = 0x82EBAB14; continue 'dispatch;
	}
	// 82EBAAF4: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBAAF8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAAFC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAB00: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAB04: 4198FFB8  blt cr6, 0x82ebaabc
	if ctx.cr[6].lt {
	pc = 0x82EBAABC; continue 'dispatch;
	}
	// 82EBAB08: 4800001C  b 0x82ebab24
	pc = 0x82EBAB24; continue 'dispatch;
	// 82EBAB0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAB10: 4BFFFFDC  b 0x82ebaaec
	pc = 0x82EBAAEC; continue 'dispatch;
	// 82EBAB14: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBAB18: 57AA103A  slwi r10, r29, 2
	// 82EBAB1C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAB20: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAB24: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAB28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAB2C: 409A0060  bne cr6, 0x82ebab8c
	if !ctx.cr[6].eq {
	pc = 0x82EBAB8C; continue 'dispatch;
	}
	// 82EBAB30: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EBAB34: 4B75BDF5  bl 0x82616928
	ctx.lr = 0x82EBAB38;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBAB38: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAB3C: 41820028  beq 0x82ebab64
	if ctx.cr[0].eq {
	pc = 0x82EBAB64; continue 'dispatch;
	}
	// 82EBAB40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAB44: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAB48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAB4C: 4BFFA7E5  bl 0x82eb5330
	ctx.lr = 0x82EBAB50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBAB50: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAB54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAB58: 396BA800  addi r11, r11, -0x5800
	ctx.r[11].s64 = ctx.r[11].s64 + -22528;
	// 82EBAB5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAB60: 48000008  b 0x82ebab68
	pc = 0x82EBAB68; continue 'dispatch;
	// 82EBAB64: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAB68: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAB6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAB70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAB74: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAB78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAB7C: 4E800421  bctrl
	ctx.lr = 0x82EBAB80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAB80: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAB84: 387F01C8  addi r3, r31, 0x1c8
	ctx.r[3].s64 = ctx.r[31].s64 + 456;
	// 82EBAB88: 4BFFE709  bl 0x82eb9290
	ctx.lr = 0x82EBAB8C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBAB8C: 817F01EC  lwz r11, 0x1ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EBAB90: 3B7F01EC  addi r27, r31, 0x1ec
	ctx.r[27].s64 = ctx.r[31].s64 + 492;
	// 82EBAB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAB98: 409A00DC  bne cr6, 0x82ebac74
	if !ctx.cr[6].eq {
	pc = 0x82EBAC74; continue 'dispatch;
	}
	// 82EBAB9C: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBABA0: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBABA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBABA8: 40990078  ble cr6, 0x82ebac20
	if !ctx.cr[6].gt {
	pc = 0x82EBAC20; continue 'dispatch;
	}
	// 82EBABAC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBABB0: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBABB4: 3B8BD9E0  addi r28, r11, -0x2620
	ctx.r[28].s64 = ctx.r[11].s64 + -9760;
	// 82EBABB8: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBABBC: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBABC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBABC4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBABC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBABCC: 4E800421  bctrl
	ctx.lr = 0x82EBABD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBABD0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBABD4: 419A0034  beq cr6, 0x82ebac08
	if ctx.cr[6].eq {
	pc = 0x82EBAC08; continue 'dispatch;
	}
	// 82EBABD8: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBABDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBABE0: 4082FFF0  bne 0x82ebabd0
	if !ctx.cr[0].eq {
	pc = 0x82EBABD0; continue 'dispatch;
	}
	// 82EBABE4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBABE8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBABEC: 40820024  bne 0x82ebac10
	if !ctx.cr[0].eq {
	pc = 0x82EBAC10; continue 'dispatch;
	}
	// 82EBABF0: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBABF4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBABF8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBABFC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAC00: 4198FFB8  blt cr6, 0x82ebabb8
	if ctx.cr[6].lt {
	pc = 0x82EBABB8; continue 'dispatch;
	}
	// 82EBAC04: 4800001C  b 0x82ebac20
	pc = 0x82EBAC20; continue 'dispatch;
	// 82EBAC08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAC0C: 4BFFFFDC  b 0x82ebabe8
	pc = 0x82EBABE8; continue 'dispatch;
	// 82EBAC10: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBAC14: 57AA103A  slwi r10, r29, 2
	// 82EBAC18: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAC1C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAC20: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAC24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC28: 409A004C  bne cr6, 0x82ebac74
	if !ctx.cr[6].eq {
	pc = 0x82EBAC74; continue 'dispatch;
	}
	// 82EBAC2C: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 82EBAC30: 4B75BCF9  bl 0x82616928
	ctx.lr = 0x82EBAC34;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBAC34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC38: 41820014  beq 0x82ebac4c
	if ctx.cr[0].eq {
	pc = 0x82EBAC4C; continue 'dispatch;
	}
	// 82EBAC3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAC40: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAC44: 4BFFA865  bl 0x82eb54a8
	ctx.lr = 0x82EBAC48;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB54A8);
	// 82EBAC48: 48000008  b 0x82ebac50
	pc = 0x82EBAC50; continue 'dispatch;
	// 82EBAC4C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAC50: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAC54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAC58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAC5C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAC64: 4E800421  bctrl
	ctx.lr = 0x82EBAC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAC68: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAC6C: 387F01DC  addi r3, r31, 0x1dc
	ctx.r[3].s64 = ctx.r[31].s64 + 476;
	// 82EBAC70: 4BFFE621  bl 0x82eb9290
	ctx.lr = 0x82EBAC74;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBAC74: 817F0200  lwz r11, 0x200(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EBAC78: 3B7F0200  addi r27, r31, 0x200
	ctx.r[27].s64 = ctx.r[31].s64 + 512;
	// 82EBAC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC80: 409A00F0  bne cr6, 0x82ebad70
	if !ctx.cr[6].eq {
	pc = 0x82EBAD70; continue 'dispatch;
	}
	// 82EBAC84: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBAC88: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC90: 40990078  ble cr6, 0x82ebad08
	if !ctx.cr[6].gt {
	pc = 0x82EBAD08; continue 'dispatch;
	}
	// 82EBAC94: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAC98: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAC9C: 3B8BD8CC  addi r28, r11, -0x2734
	ctx.r[28].s64 = ctx.r[11].s64 + -10036;
	// 82EBACA0: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBACA4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBACA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBACAC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBACB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBACB4: 4E800421  bctrl
	ctx.lr = 0x82EBACB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBACB8: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBACBC: 419A0034  beq cr6, 0x82ebacf0
	if ctx.cr[6].eq {
	pc = 0x82EBACF0; continue 'dispatch;
	}
	// 82EBACC0: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBACC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBACC8: 4082FFF0  bne 0x82ebacb8
	if !ctx.cr[0].eq {
	pc = 0x82EBACB8; continue 'dispatch;
	}
	// 82EBACCC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBACD0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBACD4: 40820024  bne 0x82ebacf8
	if !ctx.cr[0].eq {
	pc = 0x82EBACF8; continue 'dispatch;
	}
	// 82EBACD8: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBACDC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBACE0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBACE4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBACE8: 4198FFB8  blt cr6, 0x82ebaca0
	if ctx.cr[6].lt {
	pc = 0x82EBACA0; continue 'dispatch;
	}
	// 82EBACEC: 4800001C  b 0x82ebad08
	pc = 0x82EBAD08; continue 'dispatch;
	// 82EBACF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBACF4: 4BFFFFDC  b 0x82ebacd0
	pc = 0x82EBACD0; continue 'dispatch;
	// 82EBACF8: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBACFC: 57AA103A  slwi r10, r29, 2
	// 82EBAD00: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAD04: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAD08: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAD0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAD10: 409A0060  bne cr6, 0x82ebad70
	if !ctx.cr[6].eq {
	pc = 0x82EBAD70; continue 'dispatch;
	}
	// 82EBAD14: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EBAD18: 4B75BC11  bl 0x82616928
	ctx.lr = 0x82EBAD1C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBAD1C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAD20: 41820028  beq 0x82ebad48
	if ctx.cr[0].eq {
	pc = 0x82EBAD48; continue 'dispatch;
	}
	// 82EBAD24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAD28: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAD2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAD30: 4BFFA601  bl 0x82eb5330
	ctx.lr = 0x82EBAD34;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBAD34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAD38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAD3C: 396BA84C  addi r11, r11, -0x57b4
	ctx.r[11].s64 = ctx.r[11].s64 + -22452;
	// 82EBAD40: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAD44: 48000008  b 0x82ebad4c
	pc = 0x82EBAD4C; continue 'dispatch;
	// 82EBAD48: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAD4C: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAD50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAD54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAD58: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAD5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAD60: 4E800421  bctrl
	ctx.lr = 0x82EBAD64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAD64: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAD68: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 82EBAD6C: 4BFFE525  bl 0x82eb9290
	ctx.lr = 0x82EBAD70;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBAD70: 817F0214  lwz r11, 0x214(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EBAD74: 3B7F0214  addi r27, r31, 0x214
	ctx.r[27].s64 = ctx.r[31].s64 + 532;
	// 82EBAD78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAD7C: 409A00F0  bne cr6, 0x82ebae6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAE6C; continue 'dispatch;
	}
	// 82EBAD80: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBAD84: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAD8C: 40990078  ble cr6, 0x82ebae04
	if !ctx.cr[6].gt {
	pc = 0x82EBAE04; continue 'dispatch;
	}
	// 82EBAD90: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAD94: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAD98: 3B8BD6A4  addi r28, r11, -0x295c
	ctx.r[28].s64 = ctx.r[11].s64 + -10588;
	// 82EBAD9C: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBADA0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBADA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBADA8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBADAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBADB0: 4E800421  bctrl
	ctx.lr = 0x82EBADB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBADB4: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBADB8: 419A0034  beq cr6, 0x82ebadec
	if ctx.cr[6].eq {
	pc = 0x82EBADEC; continue 'dispatch;
	}
	// 82EBADBC: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBADC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBADC4: 4082FFF0  bne 0x82ebadb4
	if !ctx.cr[0].eq {
	pc = 0x82EBADB4; continue 'dispatch;
	}
	// 82EBADC8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBADCC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBADD0: 40820024  bne 0x82ebadf4
	if !ctx.cr[0].eq {
	pc = 0x82EBADF4; continue 'dispatch;
	}
	// 82EBADD4: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBADD8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBADDC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBADE0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBADE4: 4198FFB8  blt cr6, 0x82ebad9c
	if ctx.cr[6].lt {
	pc = 0x82EBAD9C; continue 'dispatch;
	}
	// 82EBADE8: 4800001C  b 0x82ebae04
	pc = 0x82EBAE04; continue 'dispatch;
	// 82EBADEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBADF0: 4BFFFFDC  b 0x82ebadcc
	pc = 0x82EBADCC; continue 'dispatch;
	// 82EBADF4: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBADF8: 57AA103A  slwi r10, r29, 2
	// 82EBADFC: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAE00: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAE04: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAE08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAE0C: 409A0060  bne cr6, 0x82ebae6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAE6C; continue 'dispatch;
	}
	// 82EBAE10: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EBAE14: 4B75BB15  bl 0x82616928
	ctx.lr = 0x82EBAE18;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBAE18: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAE1C: 41820028  beq 0x82ebae44
	if ctx.cr[0].eq {
	pc = 0x82EBAE44; continue 'dispatch;
	}
	// 82EBAE20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAE24: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAE28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAE2C: 4BFFA505  bl 0x82eb5330
	ctx.lr = 0x82EBAE30;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBAE30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAE34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAE38: 396BA834  addi r11, r11, -0x57cc
	ctx.r[11].s64 = ctx.r[11].s64 + -22476;
	// 82EBAE3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAE40: 48000008  b 0x82ebae48
	pc = 0x82EBAE48; continue 'dispatch;
	// 82EBAE44: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAE48: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAE4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAE50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAE54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAE58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAE5C: 4E800421  bctrl
	ctx.lr = 0x82EBAE60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAE60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAE64: 387F0204  addi r3, r31, 0x204
	ctx.r[3].s64 = ctx.r[31].s64 + 516;
	// 82EBAE68: 4BFFE429  bl 0x82eb9290
	ctx.lr = 0x82EBAE6C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBAE6C: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EBAE70: 3B7F0228  addi r27, r31, 0x228
	ctx.r[27].s64 = ctx.r[31].s64 + 552;
	// 82EBAE74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAE78: 409A00F4  bne cr6, 0x82ebaf6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAF6C; continue 'dispatch;
	}
	// 82EBAE7C: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBAE80: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAE88: 40990078  ble cr6, 0x82ebaf00
	if !ctx.cr[6].gt {
	pc = 0x82EBAF00; continue 'dispatch;
	}
	// 82EBAE8C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAE90: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAE94: 3B8BD590  addi r28, r11, -0x2a70
	ctx.r[28].s64 = ctx.r[11].s64 + -10864;
	// 82EBAE98: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBAE9C: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAEA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAEA4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBAEA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAEAC: 4E800421  bctrl
	ctx.lr = 0x82EBAEB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAEB0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBAEB4: 419A0034  beq cr6, 0x82ebaee8
	if ctx.cr[6].eq {
	pc = 0x82EBAEE8; continue 'dispatch;
	}
	// 82EBAEB8: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBAEBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAEC0: 4082FFF0  bne 0x82ebaeb0
	if !ctx.cr[0].eq {
	pc = 0x82EBAEB0; continue 'dispatch;
	}
	// 82EBAEC4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBAEC8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBAECC: 40820024  bne 0x82ebaef0
	if !ctx.cr[0].eq {
	pc = 0x82EBAEF0; continue 'dispatch;
	}
	// 82EBAED0: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBAED4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAED8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAEDC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAEE0: 4198FFB8  blt cr6, 0x82ebae98
	if ctx.cr[6].lt {
	pc = 0x82EBAE98; continue 'dispatch;
	}
	// 82EBAEE4: 4800001C  b 0x82ebaf00
	pc = 0x82EBAF00; continue 'dispatch;
	// 82EBAEE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAEEC: 4BFFFFDC  b 0x82ebaec8
	pc = 0x82EBAEC8; continue 'dispatch;
	// 82EBAEF0: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBAEF4: 57AA103A  slwi r10, r29, 2
	// 82EBAEF8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAEFC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAF00: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAF08: 409A0064  bne cr6, 0x82ebaf6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAF6C; continue 'dispatch;
	}
	// 82EBAF0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EBAF10: 4B75BA19  bl 0x82616928
	ctx.lr = 0x82EBAF14;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBAF14: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAF18: 4182002C  beq 0x82ebaf44
	if ctx.cr[0].eq {
	pc = 0x82EBAF44; continue 'dispatch;
	}
	// 82EBAF1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAF20: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAF24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAF28: 4BFFA409  bl 0x82eb5330
	ctx.lr = 0x82EBAF2C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBAF2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAF30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAF34: 933E000C  stw r25, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 82EBAF38: 396BA890  addi r11, r11, -0x5770
	ctx.r[11].s64 = ctx.r[11].s64 + -22384;
	// 82EBAF3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAF40: 48000008  b 0x82ebaf48
	pc = 0x82EBAF48; continue 'dispatch;
	// 82EBAF44: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBAF48: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAF4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAF50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAF54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAF58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAF5C: 4E800421  bctrl
	ctx.lr = 0x82EBAF60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAF60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAF64: 387F0218  addi r3, r31, 0x218
	ctx.r[3].s64 = ctx.r[31].s64 + 536;
	// 82EBAF68: 4BFFE329  bl 0x82eb9290
	ctx.lr = 0x82EBAF6C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBAF6C: 817F0264  lwz r11, 0x264(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBAF70: 3B7F0264  addi r27, r31, 0x264
	ctx.r[27].s64 = ctx.r[31].s64 + 612;
	// 82EBAF74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAF78: 409A00DC  bne cr6, 0x82ebb054
	if !ctx.cr[6].eq {
	pc = 0x82EBB054; continue 'dispatch;
	}
	// 82EBAF7C: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBAF80: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAF84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAF88: 40990078  ble cr6, 0x82ebb000
	if !ctx.cr[6].gt {
	pc = 0x82EBB000; continue 'dispatch;
	}
	// 82EBAF8C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAF90: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAF94: 3B8BCDF0  addi r28, r11, -0x3210
	ctx.r[28].s64 = ctx.r[11].s64 + -12816;
	// 82EBAF98: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBAF9C: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAFA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAFA4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBAFA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAFAC: 4E800421  bctrl
	ctx.lr = 0x82EBAFB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAFB0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBAFB4: 419A0034  beq cr6, 0x82ebafe8
	if ctx.cr[6].eq {
	pc = 0x82EBAFE8; continue 'dispatch;
	}
	// 82EBAFB8: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBAFBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAFC0: 4082FFF0  bne 0x82ebafb0
	if !ctx.cr[0].eq {
	pc = 0x82EBAFB0; continue 'dispatch;
	}
	// 82EBAFC4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBAFC8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBAFCC: 40820024  bne 0x82ebaff0
	if !ctx.cr[0].eq {
	pc = 0x82EBAFF0; continue 'dispatch;
	}
	// 82EBAFD0: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBAFD4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAFD8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAFDC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAFE0: 4198FFB8  blt cr6, 0x82ebaf98
	if ctx.cr[6].lt {
	pc = 0x82EBAF98; continue 'dispatch;
	}
	// 82EBAFE4: 4800001C  b 0x82ebb000
	pc = 0x82EBB000; continue 'dispatch;
	// 82EBAFE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAFEC: 4BFFFFDC  b 0x82ebafc8
	pc = 0x82EBAFC8; continue 'dispatch;
	// 82EBAFF0: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBAFF4: 57AA103A  slwi r10, r29, 2
	// 82EBAFF8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAFFC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB000: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB008: 409A004C  bne cr6, 0x82ebb054
	if !ctx.cr[6].eq {
	pc = 0x82EBB054; continue 'dispatch;
	}
	// 82EBB00C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82EBB010: 4B75B919  bl 0x82616928
	ctx.lr = 0x82EBB014;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBB014: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB018: 41820014  beq 0x82ebb02c
	if ctx.cr[0].eq {
	pc = 0x82EBB02C; continue 'dispatch;
	}
	// 82EBB01C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB020: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB024: 4BFFA72D  bl 0x82eb5750
	ctx.lr = 0x82EBB028;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5750);
	// 82EBB028: 48000008  b 0x82ebb030
	pc = 0x82EBB030; continue 'dispatch;
	// 82EBB02C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBB030: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB034: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB038: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB03C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB040: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB044: 4E800421  bctrl
	ctx.lr = 0x82EBB048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB048: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB04C: 387F0254  addi r3, r31, 0x254
	ctx.r[3].s64 = ctx.r[31].s64 + 596;
	// 82EBB050: 4BFFE241  bl 0x82eb9290
	ctx.lr = 0x82EBB054;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBB054: 817F0250  lwz r11, 0x250(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBB058: 3B7F0250  addi r27, r31, 0x250
	ctx.r[27].s64 = ctx.r[31].s64 + 592;
	// 82EBB05C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB060: 409A00DC  bne cr6, 0x82ebb13c
	if !ctx.cr[6].eq {
	pc = 0x82EBB13C; continue 'dispatch;
	}
	// 82EBB064: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBB068: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBB06C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB070: 40990078  ble cr6, 0x82ebb0e8
	if !ctx.cr[6].gt {
	pc = 0x82EBB0E8; continue 'dispatch;
	}
	// 82EBB074: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EBB078: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBB07C: 3B8B89BC  addi r28, r11, -0x7644
	ctx.r[28].s64 = ctx.r[11].s64 + -30276;
	// 82EBB080: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBB084: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBB088: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB08C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBB090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB094: 4E800421  bctrl
	ctx.lr = 0x82EBB098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB098: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBB09C: 419A0034  beq cr6, 0x82ebb0d0
	if ctx.cr[6].eq {
	pc = 0x82EBB0D0; continue 'dispatch;
	}
	// 82EBB0A0: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBB0A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB0A8: 4082FFF0  bne 0x82ebb098
	if !ctx.cr[0].eq {
	pc = 0x82EBB098; continue 'dispatch;
	}
	// 82EBB0AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBB0B0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBB0B4: 40820024  bne 0x82ebb0d8
	if !ctx.cr[0].eq {
	pc = 0x82EBB0D8; continue 'dispatch;
	}
	// 82EBB0B8: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBB0BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBB0C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBB0C4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBB0C8: 4198FFB8  blt cr6, 0x82ebb080
	if ctx.cr[6].lt {
	pc = 0x82EBB080; continue 'dispatch;
	}
	// 82EBB0CC: 4800001C  b 0x82ebb0e8
	pc = 0x82EBB0E8; continue 'dispatch;
	// 82EBB0D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBB0D4: 4BFFFFDC  b 0x82ebb0b0
	pc = 0x82EBB0B0; continue 'dispatch;
	// 82EBB0D8: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBB0DC: 57AA103A  slwi r10, r29, 2
	// 82EBB0E0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB0E4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB0E8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB0EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB0F0: 409A004C  bne cr6, 0x82ebb13c
	if !ctx.cr[6].eq {
	pc = 0x82EBB13C; continue 'dispatch;
	}
	// 82EBB0F4: 3860011C  li r3, 0x11c
	ctx.r[3].s64 = 284;
	// 82EBB0F8: 4B75B831  bl 0x82616928
	ctx.lr = 0x82EBB0FC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBB0FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB100: 41820014  beq 0x82ebb114
	if ctx.cr[0].eq {
	pc = 0x82EBB114; continue 'dispatch;
	}
	// 82EBB104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB108: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB10C: 4801FD75  bl 0x82edae80
	ctx.lr = 0x82EBB110;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EDAE80);
	// 82EBB110: 48000008  b 0x82ebb118
	pc = 0x82EBB118; continue 'dispatch;
	// 82EBB114: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBB118: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB11C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB120: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB124: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB128: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB12C: 4E800421  bctrl
	ctx.lr = 0x82EBB130;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB130: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB134: 387F0240  addi r3, r31, 0x240
	ctx.r[3].s64 = ctx.r[31].s64 + 576;
	// 82EBB138: 4BFFE159  bl 0x82eb9290
	ctx.lr = 0x82EBB13C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBB13C: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EBB140: 3B7F023C  addi r27, r31, 0x23c
	ctx.r[27].s64 = ctx.r[31].s64 + 572;
	// 82EBB144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB148: 409A00DC  bne cr6, 0x82ebb224
	if !ctx.cr[6].eq {
	pc = 0x82EBB224; continue 'dispatch;
	}
	// 82EBB14C: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBB150: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBB154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB158: 40990078  ble cr6, 0x82ebb1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBB1D0; continue 'dispatch;
	}
	// 82EBB15C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBB160: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBB164: 3B8BD244  addi r28, r11, -0x2dbc
	ctx.r[28].s64 = ctx.r[11].s64 + -11708;
	// 82EBB168: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBB16C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBB170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB174: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBB178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB17C: 4E800421  bctrl
	ctx.lr = 0x82EBB180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB180: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBB184: 419A0034  beq cr6, 0x82ebb1b8
	if ctx.cr[6].eq {
	pc = 0x82EBB1B8; continue 'dispatch;
	}
	// 82EBB188: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBB18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB190: 4082FFF0  bne 0x82ebb180
	if !ctx.cr[0].eq {
	pc = 0x82EBB180; continue 'dispatch;
	}
	// 82EBB194: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBB198: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBB19C: 40820024  bne 0x82ebb1c0
	if !ctx.cr[0].eq {
	pc = 0x82EBB1C0; continue 'dispatch;
	}
	// 82EBB1A0: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBB1A4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBB1A8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBB1AC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBB1B0: 4198FFB8  blt cr6, 0x82ebb168
	if ctx.cr[6].lt {
	pc = 0x82EBB168; continue 'dispatch;
	}
	// 82EBB1B4: 4800001C  b 0x82ebb1d0
	pc = 0x82EBB1D0; continue 'dispatch;
	// 82EBB1B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBB1BC: 4BFFFFDC  b 0x82ebb198
	pc = 0x82EBB198; continue 'dispatch;
	// 82EBB1C0: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBB1C4: 57AA103A  slwi r10, r29, 2
	// 82EBB1C8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB1CC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB1D0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB1D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB1D8: 409A004C  bne cr6, 0x82ebb224
	if !ctx.cr[6].eq {
	pc = 0x82EBB224; continue 'dispatch;
	}
	// 82EBB1DC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EBB1E0: 4B75B749  bl 0x82616928
	ctx.lr = 0x82EBB1E4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBB1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB1E8: 41820014  beq 0x82ebb1fc
	if ctx.cr[0].eq {
	pc = 0x82EBB1FC; continue 'dispatch;
	}
	// 82EBB1EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB1F0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB1F4: 4BFFA345  bl 0x82eb5538
	ctx.lr = 0x82EBB1F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5538);
	// 82EBB1F8: 48000008  b 0x82ebb200
	pc = 0x82EBB200; continue 'dispatch;
	// 82EBB1FC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBB200: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB204: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB20C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB214: 4E800421  bctrl
	ctx.lr = 0x82EBB218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB218: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB21C: 387F022C  addi r3, r31, 0x22c
	ctx.r[3].s64 = ctx.r[31].s64 + 556;
	// 82EBB220: 4BFFE071  bl 0x82eb9290
	ctx.lr = 0x82EBB224;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBB224: 817F0278  lwz r11, 0x278(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EBB228: 3B7F0278  addi r27, r31, 0x278
	ctx.r[27].s64 = ctx.r[31].s64 + 632;
	// 82EBB22C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB230: 409A00F0  bne cr6, 0x82ebb320
	if !ctx.cr[6].eq {
	pc = 0x82EBB320; continue 'dispatch;
	}
	// 82EBB234: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBB238: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBB23C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB240: 40990078  ble cr6, 0x82ebb2b8
	if !ctx.cr[6].gt {
	pc = 0x82EBB2B8; continue 'dispatch;
	}
	// 82EBB244: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBB248: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBB24C: 3B8BCBC8  addi r28, r11, -0x3438
	ctx.r[28].s64 = ctx.r[11].s64 + -13368;
	// 82EBB250: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBB254: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB25C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBB260: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB264: 4E800421  bctrl
	ctx.lr = 0x82EBB268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB268: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBB26C: 419A0034  beq cr6, 0x82ebb2a0
	if ctx.cr[6].eq {
	pc = 0x82EBB2A0; continue 'dispatch;
	}
	// 82EBB270: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBB274: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB278: 4082FFF0  bne 0x82ebb268
	if !ctx.cr[0].eq {
	pc = 0x82EBB268; continue 'dispatch;
	}
	// 82EBB27C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBB280: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBB284: 40820024  bne 0x82ebb2a8
	if !ctx.cr[0].eq {
	pc = 0x82EBB2A8; continue 'dispatch;
	}
	// 82EBB288: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBB28C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBB290: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBB294: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBB298: 4198FFB8  blt cr6, 0x82ebb250
	if ctx.cr[6].lt {
	pc = 0x82EBB250; continue 'dispatch;
	}
	// 82EBB29C: 4800001C  b 0x82ebb2b8
	pc = 0x82EBB2B8; continue 'dispatch;
	// 82EBB2A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBB2A4: 4BFFFFDC  b 0x82ebb280
	pc = 0x82EBB280; continue 'dispatch;
	// 82EBB2A8: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBB2AC: 57AA103A  slwi r10, r29, 2
	// 82EBB2B0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB2B4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB2B8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB2C0: 409A0060  bne cr6, 0x82ebb320
	if !ctx.cr[6].eq {
	pc = 0x82EBB320; continue 'dispatch;
	}
	// 82EBB2C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBB2C8: 4B75B661  bl 0x82616928
	ctx.lr = 0x82EBB2CC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBB2CC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBB2D0: 41820028  beq 0x82ebb2f8
	if ctx.cr[0].eq {
	pc = 0x82EBB2F8; continue 'dispatch;
	}
	// 82EBB2D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB2D8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB2DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBB2E0: 4BFFA051  bl 0x82eb5330
	ctx.lr = 0x82EBB2E4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBB2E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBB2E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBB2EC: 396BA8D8  addi r11, r11, -0x5728
	ctx.r[11].s64 = ctx.r[11].s64 + -22312;
	// 82EBB2F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB2F4: 48000008  b 0x82ebb2fc
	pc = 0x82EBB2FC; continue 'dispatch;
	// 82EBB2F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBB2FC: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB300: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB304: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB308: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB30C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB310: 4E800421  bctrl
	ctx.lr = 0x82EBB314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB314: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB318: 387F0268  addi r3, r31, 0x268
	ctx.r[3].s64 = ctx.r[31].s64 + 616;
	// 82EBB31C: 4BFFDF75  bl 0x82eb9290
	ctx.lr = 0x82EBB320;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9290);
	// 82EBB320: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB324: 389F0418  addi r4, r31, 0x418
	ctx.r[4].s64 = ctx.r[31].s64 + 1048;
	// 82EBB328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB32C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EBB330: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB334: 4E800421  bctrl
	ctx.lr = 0x82EBB338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB338: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB33C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB340: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBB344: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB348: 4E800421  bctrl
	ctx.lr = 0x82EBB34C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB34C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBB350: 3BCBA974  addi r30, r11, -0x568c
	ctx.r[30].s64 = ctx.r[11].s64 + -22156;
	// 82EBB354: 4B3A5665  bl 0x822609b8
	ctx.lr = 0x82EBB358;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EBB358: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBB35C: 4BFC5EDD  bl 0x82e81238
	ctx.lr = 0x82EBB360;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81238);
	// 82EBB360: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBB364: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBB368: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82EBB36C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EBB370: 4BDEE0DC  b 0x82ca944c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA944C);
	return;
}

pub fn sub_82EBB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB378 size=120
	// 82EBB378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB384: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB388: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB38C: 816AA374  lwz r11, -0x5c8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23692 as u32) ) } as u64;
	// 82EBB390: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB394: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB398: 3BE99F70  addi r31, r9, -0x6090
	ctx.r[31].s64 = ctx.r[9].s64 + -24720;
	// 82EBB39C: 40820038  bne 0x82ebb3d4
	if !ctx.cr[0].eq {
	pc = 0x82EBB3D4; continue 'dispatch;
	}
	// 82EBB3A0: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB3A4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB3A8: 8909DF40  lbz r8, -0x20c0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8384 as u32) ) } as u64;
	// 82EBB3AC: 916AA374  stw r11, -0x5c8c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-23692 as u32), ctx.r[11].u32 ) };
	// 82EBB3B0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB3B4: 4182000C  beq 0x82ebb3c0
	if ctx.cr[0].eq {
	pc = 0x82EBB3C0; continue 'dispatch;
	}
	// 82EBB3B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB3BC: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB3C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB3C4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB3C8: 386A8BA8  addi r3, r10, -0x7458
	ctx.r[3].s64 = ctx.r[10].s64 + -29784;
	// 82EBB3CC: 9969DF40  stb r11, -0x20c0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8384 as u32), ctx.r[11].u8 ) };
	// 82EBB3D0: 4BDEEB51  bl 0x82ca9f20
	ctx.lr = 0x82EBB3D4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB3D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB3DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB3E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB3E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB3E8: 4E800020  blr
	return;
}

pub fn sub_82EBB3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB3F0 size=120
	// 82EBB3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB3F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB3FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB400: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB404: 816AA77C  lwz r11, -0x5884(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-22660 as u32) ) } as u64;
	// 82EBB408: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB40C: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB410: 3BE9A378  addi r31, r9, -0x5c88
	ctx.r[31].s64 = ctx.r[9].s64 + -23688;
	// 82EBB414: 40820038  bne 0x82ebb44c
	if !ctx.cr[0].eq {
	pc = 0x82EBB44C; continue 'dispatch;
	}
	// 82EBB418: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB41C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB420: 8909DF41  lbz r8, -0x20bf(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8383 as u32) ) } as u64;
	// 82EBB424: 916AA77C  stw r11, -0x5884(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-22660 as u32), ctx.r[11].u32 ) };
	// 82EBB428: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB42C: 4182000C  beq 0x82ebb438
	if ctx.cr[0].eq {
	pc = 0x82EBB438; continue 'dispatch;
	}
	// 82EBB430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB434: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB43C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB440: 386A8B90  addi r3, r10, -0x7470
	ctx.r[3].s64 = ctx.r[10].s64 + -29808;
	// 82EBB444: 9969DF41  stb r11, -0x20bf(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8383 as u32), ctx.r[11].u8 ) };
	// 82EBB448: 4BDEEAD9  bl 0x82ca9f20
	ctx.lr = 0x82EBB44C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB450: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB45C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB460: 4E800020  blr
	return;
}

pub fn sub_82EBB468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB468 size=120
	// 82EBB468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB470: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB474: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB478: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB47C: 816AAB84  lwz r11, -0x547c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21628 as u32) ) } as u64;
	// 82EBB480: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB484: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB488: 3BE9A780  addi r31, r9, -0x5880
	ctx.r[31].s64 = ctx.r[9].s64 + -22656;
	// 82EBB48C: 40820038  bne 0x82ebb4c4
	if !ctx.cr[0].eq {
	pc = 0x82EBB4C4; continue 'dispatch;
	}
	// 82EBB490: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB494: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB498: 8909DF42  lbz r8, -0x20be(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8382 as u32) ) } as u64;
	// 82EBB49C: 916AAB84  stw r11, -0x547c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21628 as u32), ctx.r[11].u32 ) };
	// 82EBB4A0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB4A4: 4182000C  beq 0x82ebb4b0
	if ctx.cr[0].eq {
	pc = 0x82EBB4B0; continue 'dispatch;
	}
	// 82EBB4A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB4AC: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB4B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB4B4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB4B8: 386A8B78  addi r3, r10, -0x7488
	ctx.r[3].s64 = ctx.r[10].s64 + -29832;
	// 82EBB4BC: 9969DF42  stb r11, -0x20be(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8382 as u32), ctx.r[11].u8 ) };
	// 82EBB4C0: 4BDEEA61  bl 0x82ca9f20
	ctx.lr = 0x82EBB4C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB4C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB4CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB4D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB4D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB4D8: 4E800020  blr
	return;
}

pub fn sub_82EBB4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB4E0 size=120
	// 82EBB4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB4E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB4EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB4F0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB4F4: 816AAF8C  lwz r11, -0x5074(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20596 as u32) ) } as u64;
	// 82EBB4F8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB4FC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB500: 3BE9AB88  addi r31, r9, -0x5478
	ctx.r[31].s64 = ctx.r[9].s64 + -21624;
	// 82EBB504: 40820038  bne 0x82ebb53c
	if !ctx.cr[0].eq {
	pc = 0x82EBB53C; continue 'dispatch;
	}
	// 82EBB508: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB50C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB510: 8909DF44  lbz r8, -0x20bc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8380 as u32) ) } as u64;
	// 82EBB514: 916AAF8C  stw r11, -0x5074(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20596 as u32), ctx.r[11].u32 ) };
	// 82EBB518: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB51C: 4182000C  beq 0x82ebb528
	if ctx.cr[0].eq {
	pc = 0x82EBB528; continue 'dispatch;
	}
	// 82EBB520: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB524: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB52C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB530: 386A8B60  addi r3, r10, -0x74a0
	ctx.r[3].s64 = ctx.r[10].s64 + -29856;
	// 82EBB534: 9969DF44  stb r11, -0x20bc(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8380 as u32), ctx.r[11].u8 ) };
	// 82EBB538: 4BDEE9E9  bl 0x82ca9f20
	ctx.lr = 0x82EBB53C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB540: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB544: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB548: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB54C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB550: 4E800020  blr
	return;
}

pub fn sub_82EBB558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB558 size=120
	// 82EBB558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB560: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB564: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB568: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB56C: 816AB394  lwz r11, -0x4c6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19564 as u32) ) } as u64;
	// 82EBB570: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB574: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB578: 3BE9AF90  addi r31, r9, -0x5070
	ctx.r[31].s64 = ctx.r[9].s64 + -20592;
	// 82EBB57C: 40820038  bne 0x82ebb5b4
	if !ctx.cr[0].eq {
	pc = 0x82EBB5B4; continue 'dispatch;
	}
	// 82EBB580: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB584: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB588: 8909DF46  lbz r8, -0x20ba(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8378 as u32) ) } as u64;
	// 82EBB58C: 916AB394  stw r11, -0x4c6c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19564 as u32), ctx.r[11].u32 ) };
	// 82EBB590: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB594: 4182000C  beq 0x82ebb5a0
	if ctx.cr[0].eq {
	pc = 0x82EBB5A0; continue 'dispatch;
	}
	// 82EBB598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB59C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB5A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB5A4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB5A8: 386A8B48  addi r3, r10, -0x74b8
	ctx.r[3].s64 = ctx.r[10].s64 + -29880;
	// 82EBB5AC: 9969DF46  stb r11, -0x20ba(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8378 as u32), ctx.r[11].u8 ) };
	// 82EBB5B0: 4BDEE971  bl 0x82ca9f20
	ctx.lr = 0x82EBB5B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB5B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB5BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB5C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB5C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB5C8: 4E800020  blr
	return;
}

pub fn sub_82EBB5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB5D0 size=120
	// 82EBB5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB5D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB5D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB5DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB5E0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB5E4: 816AB79C  lwz r11, -0x4864(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18532 as u32) ) } as u64;
	// 82EBB5E8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB5EC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB5F0: 3BE9B398  addi r31, r9, -0x4c68
	ctx.r[31].s64 = ctx.r[9].s64 + -19560;
	// 82EBB5F4: 40820038  bne 0x82ebb62c
	if !ctx.cr[0].eq {
	pc = 0x82EBB62C; continue 'dispatch;
	}
	// 82EBB5F8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB5FC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB600: 8909DF45  lbz r8, -0x20bb(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8379 as u32) ) } as u64;
	// 82EBB604: 916AB79C  stw r11, -0x4864(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18532 as u32), ctx.r[11].u32 ) };
	// 82EBB608: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB60C: 4182000C  beq 0x82ebb618
	if ctx.cr[0].eq {
	pc = 0x82EBB618; continue 'dispatch;
	}
	// 82EBB610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB614: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB61C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB620: 386A8B30  addi r3, r10, -0x74d0
	ctx.r[3].s64 = ctx.r[10].s64 + -29904;
	// 82EBB624: 9969DF45  stb r11, -0x20bb(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8379 as u32), ctx.r[11].u8 ) };
	// 82EBB628: 4BDEE8F9  bl 0x82ca9f20
	ctx.lr = 0x82EBB62C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB63C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB640: 4E800020  blr
	return;
}

pub fn sub_82EBB648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB648 size=120
	// 82EBB648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB654: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB658: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB65C: 816ABBA4  lwz r11, -0x445c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17500 as u32) ) } as u64;
	// 82EBB660: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB664: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB668: 3BE9B7A0  addi r31, r9, -0x4860
	ctx.r[31].s64 = ctx.r[9].s64 + -18528;
	// 82EBB66C: 40820038  bne 0x82ebb6a4
	if !ctx.cr[0].eq {
	pc = 0x82EBB6A4; continue 'dispatch;
	}
	// 82EBB670: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB674: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB678: 8909DF47  lbz r8, -0x20b9(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8377 as u32) ) } as u64;
	// 82EBB67C: 916ABBA4  stw r11, -0x445c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17500 as u32), ctx.r[11].u32 ) };
	// 82EBB680: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB684: 4182000C  beq 0x82ebb690
	if ctx.cr[0].eq {
	pc = 0x82EBB690; continue 'dispatch;
	}
	// 82EBB688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB68C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB694: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB698: 386A8B18  addi r3, r10, -0x74e8
	ctx.r[3].s64 = ctx.r[10].s64 + -29928;
	// 82EBB69C: 9969DF47  stb r11, -0x20b9(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8377 as u32), ctx.r[11].u8 ) };
	// 82EBB6A0: 4BDEE881  bl 0x82ca9f20
	ctx.lr = 0x82EBB6A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB6A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB6A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB6AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB6B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB6B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB6B8: 4E800020  blr
	return;
}

pub fn sub_82EBB6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB6C0 size=120
	// 82EBB6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB6C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB6CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB6D0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB6D4: 816ABFAC  lwz r11, -0x4054(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16468 as u32) ) } as u64;
	// 82EBB6D8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB6DC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB6E0: 3BE9BBA8  addi r31, r9, -0x4458
	ctx.r[31].s64 = ctx.r[9].s64 + -17496;
	// 82EBB6E4: 40820038  bne 0x82ebb71c
	if !ctx.cr[0].eq {
	pc = 0x82EBB71C; continue 'dispatch;
	}
	// 82EBB6E8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB6EC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB6F0: 8909DF43  lbz r8, -0x20bd(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8381 as u32) ) } as u64;
	// 82EBB6F4: 916ABFAC  stw r11, -0x4054(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16468 as u32), ctx.r[11].u32 ) };
	// 82EBB6F8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB6FC: 4182000C  beq 0x82ebb708
	if ctx.cr[0].eq {
	pc = 0x82EBB708; continue 'dispatch;
	}
	// 82EBB700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB704: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB70C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB710: 386A8B00  addi r3, r10, -0x7500
	ctx.r[3].s64 = ctx.r[10].s64 + -29952;
	// 82EBB714: 9969DF43  stb r11, -0x20bd(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8381 as u32), ctx.r[11].u8 ) };
	// 82EBB718: 4BDEE809  bl 0x82ca9f20
	ctx.lr = 0x82EBB71C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB720: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB72C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB730: 4E800020  blr
	return;
}

pub fn sub_82EBB738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB738 size=120
	// 82EBB738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB73C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB740: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB744: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB748: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB74C: 816AC3B4  lwz r11, -0x3c4c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15436 as u32) ) } as u64;
	// 82EBB750: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB754: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB758: 3BE9BFB0  addi r31, r9, -0x4050
	ctx.r[31].s64 = ctx.r[9].s64 + -16464;
	// 82EBB75C: 40820038  bne 0x82ebb794
	if !ctx.cr[0].eq {
	pc = 0x82EBB794; continue 'dispatch;
	}
	// 82EBB760: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB764: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB768: 8909DF49  lbz r8, -0x20b7(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8375 as u32) ) } as u64;
	// 82EBB76C: 916AC3B4  stw r11, -0x3c4c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-15436 as u32), ctx.r[11].u32 ) };
	// 82EBB770: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB774: 4182000C  beq 0x82ebb780
	if ctx.cr[0].eq {
	pc = 0x82EBB780; continue 'dispatch;
	}
	// 82EBB778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB77C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB780: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB784: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB788: 386A8AE8  addi r3, r10, -0x7518
	ctx.r[3].s64 = ctx.r[10].s64 + -29976;
	// 82EBB78C: 9969DF49  stb r11, -0x20b7(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8375 as u32), ctx.r[11].u8 ) };
	// 82EBB790: 4BDEE791  bl 0x82ca9f20
	ctx.lr = 0x82EBB794;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB798: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB79C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB7A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB7A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB7A8: 4E800020  blr
	return;
}

pub fn sub_82EBB7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB7B0 size=120
	// 82EBB7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB7B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB7BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB7C0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB7C4: 816AC7BC  lwz r11, -0x3844(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14404 as u32) ) } as u64;
	// 82EBB7C8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB7CC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB7D0: 3BE9C3B8  addi r31, r9, -0x3c48
	ctx.r[31].s64 = ctx.r[9].s64 + -15432;
	// 82EBB7D4: 40820038  bne 0x82ebb80c
	if !ctx.cr[0].eq {
	pc = 0x82EBB80C; continue 'dispatch;
	}
	// 82EBB7D8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB7DC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB7E0: 8909DF48  lbz r8, -0x20b8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8376 as u32) ) } as u64;
	// 82EBB7E4: 916AC7BC  stw r11, -0x3844(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-14404 as u32), ctx.r[11].u32 ) };
	// 82EBB7E8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB7EC: 4182000C  beq 0x82ebb7f8
	if ctx.cr[0].eq {
	pc = 0x82EBB7F8; continue 'dispatch;
	}
	// 82EBB7F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB7F4: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB7F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB7FC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB800: 386A8AD0  addi r3, r10, -0x7530
	ctx.r[3].s64 = ctx.r[10].s64 + -30000;
	// 82EBB804: 9969DF48  stb r11, -0x20b8(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8376 as u32), ctx.r[11].u8 ) };
	// 82EBB808: 4BDEE719  bl 0x82ca9f20
	ctx.lr = 0x82EBB80C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB810: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB81C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB820: 4E800020  blr
	return;
}

pub fn sub_82EBB828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB828 size=120
	// 82EBB828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB82C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB834: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB838: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB83C: 816ACBC4  lwz r11, -0x343c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13372 as u32) ) } as u64;
	// 82EBB840: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB844: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB848: 3BE9C7C0  addi r31, r9, -0x3840
	ctx.r[31].s64 = ctx.r[9].s64 + -14400;
	// 82EBB84C: 40820038  bne 0x82ebb884
	if !ctx.cr[0].eq {
	pc = 0x82EBB884; continue 'dispatch;
	}
	// 82EBB850: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB854: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB858: 8909DF4A  lbz r8, -0x20b6(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8374 as u32) ) } as u64;
	// 82EBB85C: 916ACBC4  stw r11, -0x343c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-13372 as u32), ctx.r[11].u32 ) };
	// 82EBB860: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB864: 4182000C  beq 0x82ebb870
	if ctx.cr[0].eq {
	pc = 0x82EBB870; continue 'dispatch;
	}
	// 82EBB868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB86C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 82EBB870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB874: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB878: 386A8AB8  addi r3, r10, -0x7548
	ctx.r[3].s64 = ctx.r[10].s64 + -30024;
	// 82EBB87C: 9969DF4A  stb r11, -0x20b6(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8374 as u32), ctx.r[11].u8 ) };
	// 82EBB880: 4BDEE6A1  bl 0x82ca9f20
	ctx.lr = 0x82EBB884;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9F20);
	// 82EBB884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB888: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB88C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB898: 4E800020  blr
	return;
}

pub fn sub_82EBB8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB8A0 size=16
	// 82EBB8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB8A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB8AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBB940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB940 size=16
	// 82EBB940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB948: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB94C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBB9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB9E0 size=16
	// 82EBB9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB9E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB9EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBBA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBA80 size=16
	// 82EBBA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBA8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBBB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBB20 size=16
	// 82EBBB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBB28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBB2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBBBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBBC0 size=16
	// 82EBBBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBBC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBBCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBBC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBC60 size=16
	// 82EBBC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBC68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBC6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBBD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBD00 size=16
	// 82EBBD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBD08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBD0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBBDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBDA0 size=16
	// 82EBBDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBDA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBDA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBDAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBBE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBE40 size=16
	// 82EBBE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBE44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBE48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBE4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBBEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBEE0 size=16
	// 82EBBEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBEE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBEEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBBF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBF80 size=72
	// 82EBBF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBF88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBF8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBF90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBF94: 38600450  li r3, 0x450
	ctx.r[3].s64 = 1104;
	// 82EBBF98: 4B75A991  bl 0x82616928
	ctx.lr = 0x82EBBF9C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBBF9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBBFA0: 41820010  beq 0x82ebbfb0
	if ctx.cr[0].eq {
	pc = 0x82EBBFB0; continue 'dispatch;
	}
	// 82EBBFA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBBFA8: 4BFFDC59  bl 0x82eb9c00
	ctx.lr = 0x82EBBFAC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB9C00);
	// 82EBBFAC: 48000008  b 0x82ebbfb4
	pc = 0x82EBBFB4; continue 'dispatch;
	// 82EBBFB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBBFB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBFB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBFBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBFC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBFC4: 4E800020  blr
	return;
}

pub fn sub_82EBBFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBFC8 size=88
	// 82EBBFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBFD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBBFD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBFD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBFDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBFE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBBFE4: 4BFFE07D  bl 0x82eba060
	ctx.lr = 0x82EBBFE8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBA060);
	// 82EBBFE8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBBFEC: 41820018  beq 0x82ebc004
	if ctx.cr[0].eq {
	pc = 0x82EBC004; continue 'dispatch;
	}
	// 82EBBFF0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBBFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBBFF8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBBFFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC000: 4E800421  bctrl
	ctx.lr = 0x82EBC004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBC00C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBC010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBC014: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBC018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBC01C: 4E800020  blr
	return;
}

pub fn sub_82EBC020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBC020 size=3088
	// 82EBC020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBC024: 4BDED3DD  bl 0x82ca9400
	ctx.lr = 0x82EBC028;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EBC028: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EBC02C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBC030: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBC034: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EBC038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC03C: 48300025  bl 0x831bc060
	ctx.lr = 0x82EBC040;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC040: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC044: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82EBC048: 409A000C  bne cr6, 0x82ebc054
	if !ctx.cr[6].eq {
	pc = 0x82EBC054; continue 'dispatch;
	}
	// 82EBC04C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBC050: 48000184  b 0x82ebc1d4
	pc = 0x82EBC1D4; continue 'dispatch;
	// 82EBC054: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC05C: 3BCBACD0  addi r30, r11, -0x5330
	ctx.r[30].s64 = ctx.r[11].s64 + -21296;
	// 82EBC060: 48300001  bl 0x831bc060
	ctx.lr = 0x82EBC064;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC064: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC068: 4BDF0AE9  bl 0x82cacb50
	ctx.lr = 0x82EBC06C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC06C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC074: 40820034  bne 0x82ebc0a8
	if !ctx.cr[0].eq {
	pc = 0x82EBC0A8; continue 'dispatch;
	}
	// 82EBC078: 4BA51C91  bl 0x8290dd08
	ctx.lr = 0x82EBC07C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC07C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC080: 4182FFCC  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC084: 4BDEE33D  bl 0x82caa3c0
	ctx.lr = 0x82EBC088;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CAA3C0);
	// 82EBC088: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EBC08C: 40980008  bge cr6, 0x82ebc094
	if !ctx.cr[6].lt {
	pc = 0x82EBC094; continue 'dispatch;
	}
	// 82EBC090: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBC094: 2B031000  cmplwi cr6, r3, 0x1000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4096 as u32, &mut ctx.xer);
	// 82EBC098: 40990008  ble cr6, 0x82ebc0a0
	if !ctx.cr[6].gt {
	pc = 0x82EBC0A0; continue 'dispatch;
	}
	// 82EBC09C: 38601000  li r3, 0x1000
	ctx.r[3].s64 = 4096;
	// 82EBC0A0: 907A0030  stw r3, 0x30(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82EBC0A4: 4BFFFFA8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC0A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC0AC: 3BCBACBC  addi r30, r11, -0x5344
	ctx.r[30].s64 = ctx.r[11].s64 + -21316;
	// 82EBC0B0: 482FFFB1  bl 0x831bc060
	ctx.lr = 0x82EBC0B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC0B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC0B8: 4BDF0A99  bl 0x82cacb50
	ctx.lr = 0x82EBC0BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC0BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC0C4: 40820034  bne 0x82ebc0f8
	if !ctx.cr[0].eq {
	pc = 0x82EBC0F8; continue 'dispatch;
	}
	// 82EBC0C8: 4BA51C41  bl 0x8290dd08
	ctx.lr = 0x82EBC0CC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC0CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC0D0: 4182FF7C  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC0D4: 4BDEE2ED  bl 0x82caa3c0
	ctx.lr = 0x82EBC0D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CAA3C0);
	// 82EBC0D8: 2B030008  cmplwi cr6, r3, 8
	ctx.cr[6].compare_u32(ctx.r[3].u32, 8 as u32, &mut ctx.xer);
	// 82EBC0DC: 40980008  bge cr6, 0x82ebc0e4
	if !ctx.cr[6].lt {
	pc = 0x82EBC0E4; continue 'dispatch;
	}
	// 82EBC0E0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82EBC0E4: 2B030800  cmplwi cr6, r3, 0x800
	ctx.cr[6].compare_u32(ctx.r[3].u32, 2048 as u32, &mut ctx.xer);
	// 82EBC0E8: 40990008  ble cr6, 0x82ebc0f0
	if !ctx.cr[6].gt {
	pc = 0x82EBC0F0; continue 'dispatch;
	}
	// 82EBC0EC: 38600800  li r3, 0x800
	ctx.r[3].s64 = 2048;
	// 82EBC0F0: 907A0028  stw r3, 0x28(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 82EBC0F4: 4BFFFF58  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC0F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC0FC: 3BCBAC94  addi r30, r11, -0x536c
	ctx.r[30].s64 = ctx.r[11].s64 + -21356;
	// 82EBC100: 482FFF61  bl 0x831bc060
	ctx.lr = 0x82EBC104;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC104: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC108: 4BDF0A49  bl 0x82cacb50
	ctx.lr = 0x82EBC10C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC10C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC114: 40820038  bne 0x82ebc14c
	if !ctx.cr[0].eq {
	pc = 0x82EBC14C; continue 'dispatch;
	}
	// 82EBC118: 4BA51BF1  bl 0x8290dd08
	ctx.lr = 0x82EBC11C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC11C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC120: 4182FF2C  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC124: 4BDEE29D  bl 0x82caa3c0
	ctx.lr = 0x82EBC128;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CAA3C0);
	// 82EBC128: 2B030400  cmplwi cr6, r3, 0x400
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1024 as u32, &mut ctx.xer);
	// 82EBC12C: 40980008  bge cr6, 0x82ebc134
	if !ctx.cr[6].lt {
	pc = 0x82EBC134; continue 'dispatch;
	}
	// 82EBC130: 38600400  li r3, 0x400
	ctx.r[3].s64 = 1024;
	// 82EBC134: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 82EBC138: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC13C: 40990008  ble cr6, 0x82ebc144
	if !ctx.cr[6].gt {
	pc = 0x82EBC144; continue 'dispatch;
	}
	// 82EBC140: 3C600004  lis r3, 4
	ctx.r[3].s64 = 262144;
	// 82EBC144: 907A0098  stw r3, 0x98(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 82EBC148: 4BFFFF04  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC14C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC150: 3BCBAC60  addi r30, r11, -0x53a0
	ctx.r[30].s64 = ctx.r[11].s64 + -21408;
	// 82EBC154: 482FFF0D  bl 0x831bc060
	ctx.lr = 0x82EBC158;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC15C: 4BDF09F5  bl 0x82cacb50
	ctx.lr = 0x82EBC160;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC160: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC168: 4082001C  bne 0x82ebc184
	if !ctx.cr[0].eq {
	pc = 0x82EBC184; continue 'dispatch;
	}
	// 82EBC16C: 4BA51B9D  bl 0x8290dd08
	ctx.lr = 0x82EBC170;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC170: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC174: 4182FED8  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC178: 4BDEE249  bl 0x82caa3c0
	ctx.lr = 0x82EBC17C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CAA3C0);
	// 82EBC17C: 907A009C  stw r3, 0x9c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(156 as u32), ctx.r[3].u32 ) };
	// 82EBC180: 4BFFFECC  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC184: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC188: 3BCB9C80  addi r30, r11, -0x6380
	ctx.r[30].s64 = ctx.r[11].s64 + -25472;
	// 82EBC18C: 482FFED5  bl 0x831bc060
	ctx.lr = 0x82EBC190;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC190: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC194: 4BDF09BD  bl 0x82cacb50
	ctx.lr = 0x82EBC198;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC198: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC1A0: 40820040  bne 0x82ebc1e0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1E0; continue 'dispatch;
	}
	// 82EBC1A4: 4BA51B65  bl 0x8290dd08
	ctx.lr = 0x82EBC1A8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC1A8: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EBC1AC: 4182FEA0  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC1B0: 817A0044  lwz r11, 0x44(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EBC1B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC1B8: 41820018  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC1BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EBC1C0: 48012321  bl 0x82ece4e0
	ctx.lr = 0x82EBC1C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ECE4E0);
	// 82EBC1C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC1C8: 907A0048  stw r3, 0x48(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82EBC1CC: 4082FE80  bne 0x82ebc04c
	if !ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC1D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBC1D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EBC1D8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EBC1DC: 4BDED274  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
	// 82EBC1E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC1E4: 3BCBAC54  addi r30, r11, -0x53ac
	ctx.r[30].s64 = ctx.r[11].s64 + -21420;
	// 82EBC1E8: 482FFE79  bl 0x831bc060
	ctx.lr = 0x82EBC1EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC1EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC1F0: 4BDF0961  bl 0x82cacb50
	ctx.lr = 0x82EBC1F4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC1F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC1F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC1FC: 4082005C  bne 0x82ebc258
	if !ctx.cr[0].eq {
	pc = 0x82EBC258; continue 'dispatch;
	}
	// 82EBC200: 4BA51B09  bl 0x8290dd08
	ctx.lr = 0x82EBC204;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC204: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBC208: 4182FFC8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC20C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82EBC210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC214: 388BD7D0  addi r4, r11, -0x2830
	ctx.r[4].s64 = ctx.r[11].s64 + -10288;
	// 82EBC218: 4BDF0939  bl 0x82cacb50
	ctx.lr = 0x82EBC21C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC21C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC220: 40820014  bne 0x82ebc234
	if !ctx.cr[0].eq {
	pc = 0x82EBC234; continue 'dispatch;
	}
	// 82EBC224: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC228: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBC22C: 917A0020  stw r11, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EBC230: 4BFFFFA4  b 0x82ebc1d4
	pc = 0x82EBC1D4; continue 'dispatch;
	// 82EBC234: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC23C: 388BAC44  addi r4, r11, -0x53bc
	ctx.r[4].s64 = ctx.r[11].s64 + -21436;
	// 82EBC240: 4BDF0911  bl 0x82cacb50
	ctx.lr = 0x82EBC244;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC244: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC248: 4082FF88  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC24C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EBC250: 917A0020  stw r11, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EBC254: 4BFFFDF8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC258: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC25C: 3BCBAC28  addi r30, r11, -0x53d8
	ctx.r[30].s64 = ctx.r[11].s64 + -21464;
	// 82EBC260: 482FFE01  bl 0x831bc060
	ctx.lr = 0x82EBC264;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC264: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC268: 4BDF08E9  bl 0x82cacb50
	ctx.lr = 0x82EBC26C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC26C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC274: 408200AC  bne 0x82ebc320
	if !ctx.cr[0].eq {
	pc = 0x82EBC320; continue 'dispatch;
	}
	// 82EBC278: 4BA51A91  bl 0x8290dd08
	ctx.lr = 0x82EBC27C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC27C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBC284: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EBC288: 4BDF08C9  bl 0x82cacb50
	ctx.lr = 0x82EBC28C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC28C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC290: 41820084  beq 0x82ebc314
	if ctx.cr[0].eq {
	pc = 0x82EBC314; continue 'dispatch;
	}
	// 82EBC294: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC29C: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EBC2A0: 4BDF08B1  bl 0x82cacb50
	ctx.lr = 0x82EBC2A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC2A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2A8: 4182006C  beq 0x82ebc314
	if ctx.cr[0].eq {
	pc = 0x82EBC314; continue 'dispatch;
	}
	// 82EBC2AC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EBC2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2B4: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EBC2B8: 4BDF0899  bl 0x82cacb50
	ctx.lr = 0x82EBC2BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC2BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2C0: 41820054  beq 0x82ebc314
	if ctx.cr[0].eq {
	pc = 0x82EBC314; continue 'dispatch;
	}
	// 82EBC2C4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2CC: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EBC2D0: 4BDF0881  bl 0x82cacb50
	ctx.lr = 0x82EBC2D4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC2D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2D8: 41820034  beq 0x82ebc30c
	if ctx.cr[0].eq {
	pc = 0x82EBC30C; continue 'dispatch;
	}
	// 82EBC2DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC2E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2E4: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EBC2E8: 4BDF0869  bl 0x82cacb50
	ctx.lr = 0x82EBC2EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC2EC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2F0: 4182001C  beq 0x82ebc30c
	if ctx.cr[0].eq {
	pc = 0x82EBC30C; continue 'dispatch;
	}
	// 82EBC2F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC2F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2FC: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EBC300: 4BDF0851  bl 0x82cacb50
	ctx.lr = 0x82EBC304;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC304: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC308: 4082FEC8  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC30C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBC310: 48000008  b 0x82ebc318
	pc = 0x82EBC318; continue 'dispatch;
	// 82EBC314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC318: 997A007E  stb r11, 0x7e(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(126 as u32), ctx.r[11].u8 ) };
	// 82EBC31C: 4BFFFD30  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC320: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC324: 3BCBAC0C  addi r30, r11, -0x53f4
	ctx.r[30].s64 = ctx.r[11].s64 + -21492;
	// 82EBC328: 482FFD39  bl 0x831bc060
	ctx.lr = 0x82EBC32C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC32C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC330: 4BDF0821  bl 0x82cacb50
	ctx.lr = 0x82EBC334;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC334: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC33C: 408200B4  bne 0x82ebc3f0
	if !ctx.cr[0].eq {
	pc = 0x82EBC3F0; continue 'dispatch;
	}
	// 82EBC340: 4BA519C9  bl 0x8290dd08
	ctx.lr = 0x82EBC344;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC344: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBC348: 4182FD04  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC34C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC354: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EBC358: 4BDF07F9  bl 0x82cacb50
	ctx.lr = 0x82EBC35C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC35C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC360: 41820084  beq 0x82ebc3e4
	if ctx.cr[0].eq {
	pc = 0x82EBC3E4; continue 'dispatch;
	}
	// 82EBC364: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC36C: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EBC370: 4BDF07E1  bl 0x82cacb50
	ctx.lr = 0x82EBC374;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC374: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC378: 4182006C  beq 0x82ebc3e4
	if ctx.cr[0].eq {
	pc = 0x82EBC3E4; continue 'dispatch;
	}
	// 82EBC37C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EBC380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC384: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EBC388: 4BDF07C9  bl 0x82cacb50
	ctx.lr = 0x82EBC38C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC38C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC390: 41820054  beq 0x82ebc3e4
	if ctx.cr[0].eq {
	pc = 0x82EBC3E4; continue 'dispatch;
	}
	// 82EBC394: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC39C: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EBC3A0: 4BDF07B1  bl 0x82cacb50
	ctx.lr = 0x82EBC3A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC3A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC3A8: 41820034  beq 0x82ebc3dc
	if ctx.cr[0].eq {
	pc = 0x82EBC3DC; continue 'dispatch;
	}
	// 82EBC3AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC3B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC3B4: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EBC3B8: 4BDF0799  bl 0x82cacb50
	ctx.lr = 0x82EBC3BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC3BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC3C0: 4182001C  beq 0x82ebc3dc
	if ctx.cr[0].eq {
	pc = 0x82EBC3DC; continue 'dispatch;
	}
	// 82EBC3C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC3C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC3CC: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EBC3D0: 4BDF0781  bl 0x82cacb50
	ctx.lr = 0x82EBC3D4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC3D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC3D8: 4082FDF8  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC3DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBC3E0: 48000008  b 0x82ebc3e8
	pc = 0x82EBC3E8; continue 'dispatch;
	// 82EBC3E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC3E8: 997A007F  stb r11, 0x7f(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(127 as u32), ctx.r[11].u8 ) };
	// 82EBC3EC: 4BFFFC60  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC3F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC3F4: 3BCBABFC  addi r30, r11, -0x5404
	ctx.r[30].s64 = ctx.r[11].s64 + -21508;
	// 82EBC3F8: 482FFC69  bl 0x831bc060
	ctx.lr = 0x82EBC3FC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC3FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC400: 4BDF0751  bl 0x82cacb50
	ctx.lr = 0x82EBC404;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC404: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC40C: 40820064  bne 0x82ebc470
	if !ctx.cr[0].eq {
	pc = 0x82EBC470; continue 'dispatch;
	}
	// 82EBC410: 4BA518F9  bl 0x8290dd08
	ctx.lr = 0x82EBC414;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC414: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC418: 4182FDB8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC41C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBC420: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBC424: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC428: 4182000C  beq 0x82ebc434
	if ctx.cr[0].eq {
	pc = 0x82EBC434; continue 'dispatch;
	}
	// 82EBC42C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC430: 4800000C  b 0x82ebc43c
	pc = 0x82EBC43C; continue 'dispatch;
	// 82EBC434: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC438: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC43C: 4BDEF775  bl 0x82cabbb0
	ctx.lr = 0x82EBC440;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EBC440: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBC444: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC448: C01A0024  lfs f0, 0x24(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBC44C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBC450: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBC454: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBC458: 41980008  blt cr6, 0x82ebc460
	if ctx.cr[6].lt {
	pc = 0x82EBC460; continue 'dispatch;
	}
	// 82EBC45C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBC460: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBC464: 409AFFF0  bne cr6, 0x82ebc454
	if !ctx.cr[6].eq {
	pc = 0x82EBC454; continue 'dispatch;
	}
	// 82EBC468: D01A0024  stfs f0, 0x24(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBC46C: 4BFFFBE0  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC470: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC474: 3BCBABE0  addi r30, r11, -0x5420
	ctx.r[30].s64 = ctx.r[11].s64 + -21536;
	// 82EBC478: 482FFBE9  bl 0x831bc060
	ctx.lr = 0x82EBC47C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC47C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC480: 4BDF06D1  bl 0x82cacb50
	ctx.lr = 0x82EBC484;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC484: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC48C: 40820064  bne 0x82ebc4f0
	if !ctx.cr[0].eq {
	pc = 0x82EBC4F0; continue 'dispatch;
	}
	// 82EBC490: 4BA51879  bl 0x8290dd08
	ctx.lr = 0x82EBC494;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC494: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC498: 4182FD38  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC49C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBC4A0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBC4A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC4A8: 4182000C  beq 0x82ebc4b4
	if ctx.cr[0].eq {
	pc = 0x82EBC4B4; continue 'dispatch;
	}
	// 82EBC4AC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC4B0: 4800000C  b 0x82ebc4bc
	pc = 0x82EBC4BC; continue 'dispatch;
	// 82EBC4B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC4B8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC4BC: 4BDEF6F5  bl 0x82cabbb0
	ctx.lr = 0x82EBC4C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EBC4C0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBC4C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC4C8: C01A002C  lfs f0, 0x2c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBC4CC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBC4D0: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBC4D4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBC4D8: 41980008  blt cr6, 0x82ebc4e0
	if ctx.cr[6].lt {
	pc = 0x82EBC4E0; continue 'dispatch;
	}
	// 82EBC4DC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBC4E0: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBC4E4: 409AFFF0  bne cr6, 0x82ebc4d4
	if !ctx.cr[6].eq {
	pc = 0x82EBC4D4; continue 'dispatch;
	}
	// 82EBC4E8: D01A002C  stfs f0, 0x2c(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EBC4EC: 4BFFFB60  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC4F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC4F4: 3BCBABD0  addi r30, r11, -0x5430
	ctx.r[30].s64 = ctx.r[11].s64 + -21552;
	// 82EBC4F8: 482FFB69  bl 0x831bc060
	ctx.lr = 0x82EBC4FC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC4FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC500: 4BDF0651  bl 0x82cacb50
	ctx.lr = 0x82EBC504;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC504: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC50C: 408200E0  bne 0x82ebc5ec
	if !ctx.cr[0].eq {
	pc = 0x82EBC5EC; continue 'dispatch;
	}
	// 82EBC510: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC514: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82EBC518: 4BA517F1  bl 0x8290dd08
	ctx.lr = 0x82EBC51C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC51C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC520: 4BDF0631  bl 0x82cacb50
	ctx.lr = 0x82EBC524;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC524: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC528: 418200AC  beq 0x82ebc5d4
	if ctx.cr[0].eq {
	pc = 0x82EBC5D4; continue 'dispatch;
	}
	// 82EBC52C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC534: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82EBC538: 4BA517D1  bl 0x8290dd08
	ctx.lr = 0x82EBC53C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC53C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC540: 4BDF0611  bl 0x82cacb50
	ctx.lr = 0x82EBC544;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC544: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC548: 4182008C  beq 0x82ebc5d4
	if ctx.cr[0].eq {
	pc = 0x82EBC5D4; continue 'dispatch;
	}
	// 82EBC54C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EBC550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC554: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82EBC558: 4BA517B1  bl 0x8290dd08
	ctx.lr = 0x82EBC55C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC55C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC560: 4BDF05F1  bl 0x82cacb50
	ctx.lr = 0x82EBC564;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC564: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC568: 4182006C  beq 0x82ebc5d4
	if ctx.cr[0].eq {
	pc = 0x82EBC5D4; continue 'dispatch;
	}
	// 82EBC56C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC574: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82EBC578: 4BA51791  bl 0x8290dd08
	ctx.lr = 0x82EBC57C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC57C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC580: 4BDF05D1  bl 0x82cacb50
	ctx.lr = 0x82EBC584;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC584: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC588: 41820044  beq 0x82ebc5cc
	if ctx.cr[0].eq {
	pc = 0x82EBC5CC; continue 'dispatch;
	}
	// 82EBC58C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC594: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82EBC598: 4BA51771  bl 0x8290dd08
	ctx.lr = 0x82EBC59C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC59C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC5A0: 4BDF05B1  bl 0x82cacb50
	ctx.lr = 0x82EBC5A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC5A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC5A8: 41820024  beq 0x82ebc5cc
	if ctx.cr[0].eq {
	pc = 0x82EBC5CC; continue 'dispatch;
	}
	// 82EBC5AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC5B4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82EBC5B8: 4BA51751  bl 0x8290dd08
	ctx.lr = 0x82EBC5BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC5BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC5C0: 4BDF0591  bl 0x82cacb50
	ctx.lr = 0x82EBC5C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC5C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC5C8: 4082FC08  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC5CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBC5D0: 48000008  b 0x82ebc5d8
	pc = 0x82EBC5D8; continue 'dispatch;
	// 82EBC5D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC5D8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC5DC: 4182FA70  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC5E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC5E4: 997A0440  stb r11, 0x440(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(1088 as u32), ctx.r[11].u8 ) };
	// 82EBC5E8: 4BFFFA64  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC5EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC5F0: 3BCBA5B4  addi r30, r11, -0x5a4c
	ctx.r[30].s64 = ctx.r[11].s64 + -23116;
	// 82EBC5F4: 482FFA6D  bl 0x831bc060
	ctx.lr = 0x82EBC5F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC5F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC5FC: 4BDF0555  bl 0x82cacb50
	ctx.lr = 0x82EBC600;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC600: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC608: 40820050  bne 0x82ebc658
	if !ctx.cr[0].eq {
	pc = 0x82EBC658; continue 'dispatch;
	}
	// 82EBC60C: 4BA516FD  bl 0x8290dd08
	ctx.lr = 0x82EBC610;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC614: 4182FBBC  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC618: 4BDEF599  bl 0x82cabbb0
	ctx.lr = 0x82EBC61C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EBC61C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBC620: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC624: C1BA044C  lfs f13, 0x44c(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBC628: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBC62C: C16A0C18  lfs f11, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBC630: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBC634: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBC638: 41980010  blt cr6, 0x82ebc648
	if ctx.cr[6].lt {
	pc = 0x82EBC648; continue 'dispatch;
	}
	// 82EBC63C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EBC640: 41990008  bgt cr6, 0x82ebc648
	if ctx.cr[6].gt {
	pc = 0x82EBC648; continue 'dispatch;
	}
	// 82EBC644: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EBC648: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EBC64C: 409AFFE8  bne cr6, 0x82ebc634
	if !ctx.cr[6].eq {
	pc = 0x82EBC634; continue 'dispatch;
	}
	// 82EBC650: D1BA044C  stfs f13, 0x44c(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(1100 as u32), tmp.u32 ) };
	// 82EBC654: 4BFFF9F8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC658: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC65C: 3BCBABB8  addi r30, r11, -0x5448
	ctx.r[30].s64 = ctx.r[11].s64 + -21576;
	// 82EBC660: 482FFA01  bl 0x831bc060
	ctx.lr = 0x82EBC664;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC664: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC668: 4BDF04E9  bl 0x82cacb50
	ctx.lr = 0x82EBC66C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC66C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC670: 40820118  bne 0x82ebc788
	if !ctx.cr[0].eq {
	pc = 0x82EBC788; continue 'dispatch;
	}
	// 82EBC674: 387A01A0  addi r3, r26, 0x1a0
	ctx.r[3].s64 = ctx.r[26].s64 + 416;
	// 82EBC678: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC67C: 4BFFCB5D  bl 0x82eb91d8
	ctx.lr = 0x82EBC680;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB91D8);
	// 82EBC680: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC684: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBC688: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBC68C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC690: 409900D0  ble cr6, 0x82ebc760
	if !ctx.cr[6].gt {
	pc = 0x82EBC760; continue 'dispatch;
	}
	// 82EBC694: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC698: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBC69C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBC6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC6A4: 4BFC7985  bl 0x82e84028
	ctx.lr = 0x82EBC6A8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E84028);
	// 82EBC6A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBC6AC: 482FF9B5  bl 0x831bc060
	ctx.lr = 0x82EBC6B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC6B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBC6B4: 4BDF049D  bl 0x82cacb50
	ctx.lr = 0x82EBC6B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC6B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC6BC: 40820014  bne 0x82ebc6d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC6D0; continue 'dispatch;
	}
	// 82EBC6C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBC6C4: 4BA51645  bl 0x8290dd08
	ctx.lr = 0x82EBC6C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC6C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBC6CC: 48000024  b 0x82ebc6f0
	pc = 0x82EBC6F0; continue 'dispatch;
	// 82EBC6D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC6D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC6D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBC6DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC6E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC6E4: 4E800421  bctrl
	ctx.lr = 0x82EBC6E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC6E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC6EC: 4182FAE4  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC6F0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC6F4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBC6F8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC6FC: 4198FFA0  blt cr6, 0x82ebc69c
	if ctx.cr[6].lt {
	pc = 0x82EBC69C; continue 'dispatch;
	}
	// 82EBC700: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBC704: 419A005C  beq cr6, 0x82ebc760
	if ctx.cr[6].eq {
	pc = 0x82EBC760; continue 'dispatch;
	}
	// 82EBC708: 817A01AC  lwz r11, 0x1ac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBC70C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBC710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC714: 4099004C  ble cr6, 0x82ebc760
	if !ctx.cr[6].gt {
	pc = 0x82EBC760; continue 'dispatch;
	}
	// 82EBC718: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBC71C: 817A01A4  lwz r11, 0x1a4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBC720: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBC724: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC728: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC72C: 4BDF0425  bl 0x82cacb50
	ctx.lr = 0x82EBC730;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC730: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC734: 4182001C  beq 0x82ebc750
	if ctx.cr[0].eq {
	pc = 0x82EBC750; continue 'dispatch;
	}
	// 82EBC738: 817A01AC  lwz r11, 0x1ac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBC73C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBC740: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBC744: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC748: 4198FFD4  blt cr6, 0x82ebc71c
	if ctx.cr[6].lt {
	pc = 0x82EBC71C; continue 'dispatch;
	}
	// 82EBC74C: 48000014  b 0x82ebc760
	pc = 0x82EBC760; continue 'dispatch;
	// 82EBC750: 817A01A4  lwz r11, 0x1a4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBC754: 57CA103A  slwi r10, r30, 2
	// 82EBC758: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC75C: 917A01B0  stw r11, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 82EBC760: 817A01B0  lwz r11, 0x1b0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EBC764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC768: 409AF8E4  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC76C: 817A01AC  lwz r11, 0x1ac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBC770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC774: 419AF8D8  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC778: 817A01A4  lwz r11, 0x1a4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBC77C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC780: 917A01B0  stw r11, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 82EBC784: 4BFFF8C8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC788: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC790: 3BCBAB98  addi r30, r11, -0x5468
	ctx.r[30].s64 = ctx.r[11].s64 + -21608;
	// 82EBC794: 482FF8CD  bl 0x831bc060
	ctx.lr = 0x82EBC798;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC798: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC79C: 4BDF03B5  bl 0x82cacb50
	ctx.lr = 0x82EBC7A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC7A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC7A4: 40820118  bne 0x82ebc8bc
	if !ctx.cr[0].eq {
	pc = 0x82EBC8BC; continue 'dispatch;
	}
	// 82EBC7A8: 387A01B4  addi r3, r26, 0x1b4
	ctx.r[3].s64 = ctx.r[26].s64 + 436;
	// 82EBC7AC: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC7B0: 4BFFCA29  bl 0x82eb91d8
	ctx.lr = 0x82EBC7B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB91D8);
	// 82EBC7B4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC7B8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBC7BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBC7C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC7C4: 409900D0  ble cr6, 0x82ebc894
	if !ctx.cr[6].gt {
	pc = 0x82EBC894; continue 'dispatch;
	}
	// 82EBC7C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC7CC: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBC7D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBC7D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC7D8: 4BFC7851  bl 0x82e84028
	ctx.lr = 0x82EBC7DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E84028);
	// 82EBC7DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBC7E0: 482FF881  bl 0x831bc060
	ctx.lr = 0x82EBC7E4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC7E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBC7E8: 4BDF0369  bl 0x82cacb50
	ctx.lr = 0x82EBC7EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC7EC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC7F0: 40820014  bne 0x82ebc804
	if !ctx.cr[0].eq {
	pc = 0x82EBC804; continue 'dispatch;
	}
	// 82EBC7F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBC7F8: 4BA51511  bl 0x8290dd08
	ctx.lr = 0x82EBC7FC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC7FC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBC800: 48000024  b 0x82ebc824
	pc = 0x82EBC824; continue 'dispatch;
	// 82EBC804: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC808: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC80C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBC810: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC818: 4E800421  bctrl
	ctx.lr = 0x82EBC81C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC81C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC820: 4182F9B0  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC824: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC828: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBC82C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC830: 4198FFA0  blt cr6, 0x82ebc7d0
	if ctx.cr[6].lt {
	pc = 0x82EBC7D0; continue 'dispatch;
	}
	// 82EBC834: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBC838: 419A005C  beq cr6, 0x82ebc894
	if ctx.cr[6].eq {
	pc = 0x82EBC894; continue 'dispatch;
	}
	// 82EBC83C: 817A01C0  lwz r11, 0x1c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBC840: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBC844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC848: 4099004C  ble cr6, 0x82ebc894
	if !ctx.cr[6].gt {
	pc = 0x82EBC894; continue 'dispatch;
	}
	// 82EBC84C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBC850: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBC854: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBC858: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBC85C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC860: 4BDF02F1  bl 0x82cacb50
	ctx.lr = 0x82EBC864;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC864: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC868: 4182001C  beq 0x82ebc884
	if ctx.cr[0].eq {
	pc = 0x82EBC884; continue 'dispatch;
	}
	// 82EBC86C: 817A01C0  lwz r11, 0x1c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBC870: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBC874: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBC878: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC87C: 4198FFD4  blt cr6, 0x82ebc850
	if ctx.cr[6].lt {
	pc = 0x82EBC850; continue 'dispatch;
	}
	// 82EBC880: 48000014  b 0x82ebc894
	pc = 0x82EBC894; continue 'dispatch;
	// 82EBC884: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBC888: 57CA103A  slwi r10, r30, 2
	// 82EBC88C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC890: 917A01C4  stw r11, 0x1c4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 82EBC894: 817A01C4  lwz r11, 0x1c4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EBC898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC89C: 409AF7B0  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC8A0: 817A01C0  lwz r11, 0x1c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBC8A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC8A8: 419AF7A4  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC8AC: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBC8B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC8B4: 917A01C4  stw r11, 0x1c4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 82EBC8B8: 4BFFF794  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC8BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC8C4: 3BCBAB78  addi r30, r11, -0x5488
	ctx.r[30].s64 = ctx.r[11].s64 + -21640;
	// 82EBC8C8: 482FF799  bl 0x831bc060
	ctx.lr = 0x82EBC8CC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC8CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC8D0: 4BDF0281  bl 0x82cacb50
	ctx.lr = 0x82EBC8D4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC8D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC8D8: 40820118  bne 0x82ebc9f0
	if !ctx.cr[0].eq {
	pc = 0x82EBC9F0; continue 'dispatch;
	}
	// 82EBC8DC: 387A01C8  addi r3, r26, 0x1c8
	ctx.r[3].s64 = ctx.r[26].s64 + 456;
	// 82EBC8E0: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC8E4: 4BFFC8F5  bl 0x82eb91d8
	ctx.lr = 0x82EBC8E8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB91D8);
	// 82EBC8E8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC8EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBC8F0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBC8F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC8F8: 409900D0  ble cr6, 0x82ebc9c8
	if !ctx.cr[6].gt {
	pc = 0x82EBC9C8; continue 'dispatch;
	}
	// 82EBC8FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC900: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBC904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBC908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC90C: 4BFC771D  bl 0x82e84028
	ctx.lr = 0x82EBC910;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E84028);
	// 82EBC910: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBC914: 482FF74D  bl 0x831bc060
	ctx.lr = 0x82EBC918;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBC918: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBC91C: 4BDF0235  bl 0x82cacb50
	ctx.lr = 0x82EBC920;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC920: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC924: 40820014  bne 0x82ebc938
	if !ctx.cr[0].eq {
	pc = 0x82EBC938; continue 'dispatch;
	}
	// 82EBC928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBC92C: 4BA513DD  bl 0x8290dd08
	ctx.lr = 0x82EBC930;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBC930: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBC934: 48000024  b 0x82ebc958
	pc = 0x82EBC958; continue 'dispatch;
	// 82EBC938: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC93C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC940: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBC944: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC948: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC94C: 4E800421  bctrl
	ctx.lr = 0x82EBC950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC950: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC954: 4182F87C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC958: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC95C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBC960: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC964: 4198FFA0  blt cr6, 0x82ebc904
	if ctx.cr[6].lt {
	pc = 0x82EBC904; continue 'dispatch;
	}
	// 82EBC968: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBC96C: 419A005C  beq cr6, 0x82ebc9c8
	if ctx.cr[6].eq {
	pc = 0x82EBC9C8; continue 'dispatch;
	}
	// 82EBC970: 817A01D4  lwz r11, 0x1d4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBC974: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBC978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC97C: 4099004C  ble cr6, 0x82ebc9c8
	if !ctx.cr[6].gt {
	pc = 0x82EBC9C8; continue 'dispatch;
	}
	// 82EBC980: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBC984: 817A01CC  lwz r11, 0x1cc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBC988: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBC98C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC990: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC994: 4BDF01BD  bl 0x82cacb50
	ctx.lr = 0x82EBC998;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBC998: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC99C: 4182001C  beq 0x82ebc9b8
	if ctx.cr[0].eq {
	pc = 0x82EBC9B8; continue 'dispatch;
	}
	// 82EBC9A0: 817A01D4  lwz r11, 0x1d4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBC9A4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBC9A8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBC9AC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC9B0: 4198FFD4  blt cr6, 0x82ebc984
	if ctx.cr[6].lt {
	pc = 0x82EBC984; continue 'dispatch;
	}
	// 82EBC9B4: 48000014  b 0x82ebc9c8
	pc = 0x82EBC9C8; continue 'dispatch;
	// 82EBC9B8: 817A01CC  lwz r11, 0x1cc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBC9BC: 57CA103A  slwi r10, r30, 2
	// 82EBC9C0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC9C4: 917A01D8  stw r11, 0x1d8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 82EBC9C8: 817A01D8  lwz r11, 0x1d8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EBC9CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC9D0: 409AF67C  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC9D4: 817A01D4  lwz r11, 0x1d4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBC9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC9DC: 419AF670  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC9E0: 817A01CC  lwz r11, 0x1cc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBC9E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC9E8: 917A01D8  stw r11, 0x1d8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 82EBC9EC: 4BFFF660  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBC9F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC9F8: 3BCBAB64  addi r30, r11, -0x549c
	ctx.r[30].s64 = ctx.r[11].s64 + -21660;
	// 82EBC9FC: 482FF665  bl 0x831bc060
	ctx.lr = 0x82EBCA00;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBCA00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCA04: 4BDF014D  bl 0x82cacb50
	ctx.lr = 0x82EBCA08;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBCA08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCA0C: 40820118  bne 0x82ebcb24
	if !ctx.cr[0].eq {
	pc = 0x82EBCB24; continue 'dispatch;
	}
	// 82EBCA10: 387A0218  addi r3, r26, 0x218
	ctx.r[3].s64 = ctx.r[26].s64 + 536;
	// 82EBCA14: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCA18: 4BFFC7C1  bl 0x82eb91d8
	ctx.lr = 0x82EBCA1C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB91D8);
	// 82EBCA1C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCA20: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCA24: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCA28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCA2C: 409900D0  ble cr6, 0x82ebcafc
	if !ctx.cr[6].gt {
	pc = 0x82EBCAFC; continue 'dispatch;
	}
	// 82EBCA30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCA34: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBCA38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCA3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCA40: 4BFC75E9  bl 0x82e84028
	ctx.lr = 0x82EBCA44;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E84028);
	// 82EBCA44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCA48: 482FF619  bl 0x831bc060
	ctx.lr = 0x82EBCA4C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBCA4C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCA50: 4BDF0101  bl 0x82cacb50
	ctx.lr = 0x82EBCA54;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBCA54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCA58: 40820014  bne 0x82ebca6c
	if !ctx.cr[0].eq {
	pc = 0x82EBCA6C; continue 'dispatch;
	}
	// 82EBCA5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCA60: 4BA512A9  bl 0x8290dd08
	ctx.lr = 0x82EBCA64;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBCA64: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCA68: 48000024  b 0x82ebca8c
	pc = 0x82EBCA8C; continue 'dispatch;
	// 82EBCA6C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCA70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCA74: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCA78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCA7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCA80: 4E800421  bctrl
	ctx.lr = 0x82EBCA84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCA84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCA88: 4182F748  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBCA8C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCA90: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCA94: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCA98: 4198FFA0  blt cr6, 0x82ebca38
	if ctx.cr[6].lt {
	pc = 0x82EBCA38; continue 'dispatch;
	}
	// 82EBCA9C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCAA0: 419A005C  beq cr6, 0x82ebcafc
	if ctx.cr[6].eq {
	pc = 0x82EBCAFC; continue 'dispatch;
	}
	// 82EBCAA4: 817A0224  lwz r11, 0x224(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBCAA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCAB0: 4099004C  ble cr6, 0x82ebcafc
	if !ctx.cr[6].gt {
	pc = 0x82EBCAFC; continue 'dispatch;
	}
	// 82EBCAB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBCAB8: 817A021C  lwz r11, 0x21c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBCABC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCAC0: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBCAC4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCAC8: 4BDF0089  bl 0x82cacb50
	ctx.lr = 0x82EBCACC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBCACC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCAD0: 4182001C  beq 0x82ebcaec
	if ctx.cr[0].eq {
	pc = 0x82EBCAEC; continue 'dispatch;
	}
	// 82EBCAD4: 817A0224  lwz r11, 0x224(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBCAD8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCADC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCAE0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCAE4: 4198FFD4  blt cr6, 0x82ebcab8
	if ctx.cr[6].lt {
	pc = 0x82EBCAB8; continue 'dispatch;
	}
	// 82EBCAE8: 48000014  b 0x82ebcafc
	pc = 0x82EBCAFC; continue 'dispatch;
	// 82EBCAEC: 817A021C  lwz r11, 0x21c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBCAF0: 57CA103A  slwi r10, r30, 2
	// 82EBCAF4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCAF8: 917A0228  stw r11, 0x228(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 82EBCAFC: 817A0228  lwz r11, 0x228(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EBCB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCB04: 409AF548  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCB08: 817A0224  lwz r11, 0x224(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBCB0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCB10: 419AF53C  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCB14: 817A021C  lwz r11, 0x21c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBCB18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCB1C: 917A0228  stw r11, 0x228(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 82EBCB20: 4BFFF52C  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
	// 82EBCB24: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCB2C: 3BCBAB48  addi r30, r11, -0x54b8
	ctx.r[30].s64 = ctx.r[11].s64 + -21688;
	// 82EBCB30: 482FF531  bl 0x831bc060
	ctx.lr = 0x82EBCB34;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBCB34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCB38: 4BDF0019  bl 0x82cacb50
	ctx.lr = 0x82EBCB3C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBCB3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCB40: 40820118  bne 0x82ebcc58
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(&mut ctx, base, 0x82EBCC58);
		return;
	}
	// 82EBCB44: 387A01DC  addi r3, r26, 0x1dc
	ctx.r[3].s64 = ctx.r[26].s64 + 476;
	// 82EBCB48: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCB4C: 4BFFC68D  bl 0x82eb91d8
	ctx.lr = 0x82EBCB50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB91D8);
	// 82EBCB50: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCB54: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCB58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCB5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCB60: 409900D0  ble cr6, 0x82ebcc30
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(&mut ctx, base, 0x82EBCC30);
		return;
	}
	// 82EBCB64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCB68: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	// 82EBCB6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCB70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCB74: 4BFC74B5  bl 0x82e84028
	ctx.lr = 0x82EBCB78;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E84028);
	// 82EBCB78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCB7C: 482FF4E5  bl 0x831bc060
	ctx.lr = 0x82EBCB80;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBCB80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCB84: 4BDEFFCD  bl 0x82cacb50
	ctx.lr = 0x82EBCB88;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBCB88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCB8C: 40820014  bne 0x82ebcba0
	if !ctx.cr[0].eq {
	pc = 0x82EBCBA0; continue 'dispatch;
	}
	// 82EBCB90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCB94: 4BA51175  bl 0x8290dd08
	ctx.lr = 0x82EBCB98;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBCB98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCB9C: 48000024  b 0x82ebcbc0
	pc = 0x82EBCBC0; continue 'dispatch;
	// 82EBCBA0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCBA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCBA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCBAC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCBB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCBB4: 4E800421  bctrl
	ctx.lr = 0x82EBCBB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCBB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCBBC: 4182F614  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBCBC0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCBC4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCBC8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCBCC: 4198FFA0  blt cr6, 0x82ebcb6c
	if ctx.cr[6].lt {
	pc = 0x82EBCB6C; continue 'dispatch;
	}
	// 82EBCBD0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCBD4: 419A005C  beq cr6, 0x82ebcc30
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(&mut ctx, base, 0x82EBCC30);
		return;
	}
	// 82EBCBD8: 817A01E8  lwz r11, 0x1e8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBCBDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCBE4: 4099004C  ble cr6, 0x82ebcc30
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(&mut ctx, base, 0x82EBCC30);
		return;
	}
	// 82EBCBE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBCBEC: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBCBF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCBF4: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCBF8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCBFC: 4BDEFF55  bl 0x82cacb50
	ctx.lr = 0x82EBCC00;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBCC00: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCC04: 4182001C  beq 0x82ebcc20
	if ctx.cr[0].eq {
	pc = 0x82EBCC20; continue 'dispatch;
	}
	// 82EBCC08: 817A01E8  lwz r11, 0x1e8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBCC0C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCC10: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCC14: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCC18: 4198FFD4  blt cr6, 0x82ebcbec
	if ctx.cr[6].lt {
	pc = 0x82EBCBEC; continue 'dispatch;
	}
	// 82EBCC1C: 48000014  b 0x82ebcc30
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBCC30);
	return;
	// 82EBCC20: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBCC24: 57CA103A  slwi r10, r30, 2
	// 82EBCC28: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCC2C: 917A01EC  stw r11, 0x1ec(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
}

pub fn sub_82EBDCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDCB0 size=88
	// 82EBDCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDCB4: 4BDEB759  bl 0x82ca940c
	ctx.lr = 0x82EBDCB8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EBDCB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDCBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBDCC0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBDCC4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBDCC8: 4B758C61  bl 0x82616928
	ctx.lr = 0x82EBDCCC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBDCCC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBDCD0: 41820028  beq 0x82ebdcf8
	if ctx.cr[0].eq {
	pc = 0x82EBDCF8; continue 'dispatch;
	}
	// 82EBDCD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBDCD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDCDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDCE0: 4BFF7651  bl 0x82eb5330
	ctx.lr = 0x82EBDCE4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBDCE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDCEC: 396BA8D8  addi r11, r11, -0x5728
	ctx.r[11].s64 = ctx.r[11].s64 + -22312;
	// 82EBDCF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBDCF4: 48000008  b 0x82ebdcfc
	pc = 0x82EBDCFC; continue 'dispatch;
	// 82EBDCF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDCFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBDD00: 4BDEB75C  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EBDD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDD08 size=280
	// 82EBDD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDD0C: 4BDEB6F1  bl 0x82ca93fc
	ctx.lr = 0x82EBDD10;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93FC);
	// 82EBDD10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDD14: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EBDD18: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDD1C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EBDD20: 388B75C8  addi r4, r11, 0x75c8
	ctx.r[4].s64 = ctx.r[11].s64 + 30152;
	// 82EBDD24: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBDD28: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EBDD2C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82EBDD30: 4BFCB9B1  bl 0x82e896e0
	ctx.lr = 0x82EBDD34;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EBDD34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD38: 418200B4  beq 0x82ebddec
	if ctx.cr[0].eq {
	pc = 0x82EBDDEC; continue 'dispatch;
	}
	// 82EBDD3C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDD40: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDD44: 48015B95  bl 0x82ed38d8
	ctx.lr = 0x82EBDD48;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED38D8);
	// 82EBDD48: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBDD4C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDD50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD54: 4182000C  beq 0x82ebdd60
	if ctx.cr[0].eq {
	pc = 0x82EBDD60; continue 'dispatch;
	}
	// 82EBDD58: 48017CB9  bl 0x82ed5a10
	ctx.lr = 0x82EBDD5C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5A10);
	// 82EBDD5C: 48000008  b 0x82ebdd64
	pc = 0x82EBDD64; continue 'dispatch;
	// 82EBDD60: 48017CC1  bl 0x82ed5a20
	ctx.lr = 0x82EBDD64;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5A20);
	// 82EBDD64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBDD68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD6C: 419A0078  beq cr6, 0x82ebdde4
	if ctx.cr[6].eq {
	pc = 0x82EBDDE4; continue 'dispatch;
	}
	// 82EBDD70: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82EBDD74: 419A0070  beq cr6, 0x82ebdde4
	if ctx.cr[6].eq {
	pc = 0x82EBDDE4; continue 'dispatch;
	}
	// 82EBDD78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDD7C: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82EBDD80: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDD84: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBDD88: 4B3A9E99  bl 0x82267c20
	ctx.lr = 0x82EBDD8C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EBDD8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD90: 4182005C  beq 0x82ebddec
	if ctx.cr[0].eq {
	pc = 0x82EBDDEC; continue 'dispatch;
	}
	// 82EBDD94: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EBDD98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBDD9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EBDDA0: 419A003C  beq cr6, 0x82ebdddc
	if ctx.cr[6].eq {
	pc = 0x82EBDDDC; continue 'dispatch;
	}
	// 82EBDDA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDDA8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDDAC: 48017C0D  bl 0x82ed59b8
	ctx.lr = 0x82EBDDB0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED59B8);
	// 82EBDDB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EBDDB4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDDB8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDDBC: 48016B55  bl 0x82ed4910
	ctx.lr = 0x82EBDDC0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED4910);
	// 82EBDDC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDDC4: 40820014  bne 0x82ebddd8
	if !ctx.cr[0].eq {
	pc = 0x82EBDDD8; continue 'dispatch;
	}
	// 82EBDDC8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBDDCC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EBDDD0: 4198FFD4  blt cr6, 0x82ebdda4
	if ctx.cr[6].lt {
	pc = 0x82EBDDA4; continue 'dispatch;
	}
	// 82EBDDD4: 48000008  b 0x82ebdddc
	pc = 0x82EBDDDC; continue 'dispatch;
	// 82EBDDD8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EBDDDC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDDE0: 4082000C  bne 0x82ebddec
	if !ctx.cr[0].eq {
	pc = 0x82EBDDEC; continue 'dispatch;
	}
	// 82EBDDE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDDE8: 4800002C  b 0x82ebde14
	pc = 0x82EBDE14; continue 'dispatch;
	// 82EBDDEC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDDF0: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EBDDF4: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDDF8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EBDDFC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDE00: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBDE04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDE08: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBDE0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDE10: 4E800421  bctrl
	ctx.lr = 0x82EBDE14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDE14: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EBDE18: 4BDEB634  b 0x82ca944c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA944C);
	return;
}

pub fn sub_82EBDE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDE20 size=408
	// 82EBDE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDE24: 4BDEB5D5  bl 0x82ca93f8
	ctx.lr = 0x82EBDE28;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93F8);
	// 82EBDE28: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDE2C: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82EBDE30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBDE34: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EBDE38: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EBDE3C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EBDE40: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDE44: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82EBDE48: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDE4C: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 82EBDE50: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EBDE54: 409A0094  bne cr6, 0x82ebdee8
	if !ctx.cr[6].eq {
	pc = 0x82EBDEE8; continue 'dispatch;
	}
	// 82EBDE58: 57A3003E  slwi r3, r29, 0
	// 82EBDE5C: 81630250  lwz r11, 0x250(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBDE60: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EBDE64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDE68: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBDE6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDE70: 4E800421  bctrl
	ctx.lr = 0x82EBDE74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDE74: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDE78: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EBDE7C: 3D4082EC  lis r10, -0x7d14
	ctx.r[10].s64 = -2098462720;
	// 82EBDE80: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EBDE84: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EBDE88: 38AADD08  addi r5, r10, -0x22f8
	ctx.r[5].s64 = ctx.r[10].s64 + -8952;
	// 82EBDE8C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EBDE90: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDE94: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EBDE98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EBDE9C: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82EBDEA0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EBDEA4: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82EBDEA8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EBDEAC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EBDEB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBDEB4: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBDEB8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EBDEBC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBDEC0: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82EBDEC4: 9B410080  stb r26, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u8 ) };
	// 82EBDEC8: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82EBDECC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBDED0: 48017661  bl 0x82ed5530
	ctx.lr = 0x82EBDED4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5530);
	// 82EBDED4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDED8: 40820034  bne 0x82ebdf0c
	if !ctx.cr[0].eq {
	pc = 0x82EBDF0C; continue 'dispatch;
	}
	// 82EBDEDC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDEE0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EBDEE4: 419A00B8  beq cr6, 0x82ebdf9c
	if ctx.cr[6].eq {
	pc = 0x82EBDF9C; continue 'dispatch;
	}
	// 82EBDEE8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDEEC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBDEF0: 388B75C8  addi r4, r11, 0x75c8
	ctx.r[4].s64 = ctx.r[11].s64 + 30152;
	// 82EBDEF4: 4BFCB7ED  bl 0x82e896e0
	ctx.lr = 0x82EBDEF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EBDEF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDEFC: 41820018  beq 0x82ebdf14
	if ctx.cr[0].eq {
	pc = 0x82EBDF14; continue 'dispatch;
	}
	// 82EBDF00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF04: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBDF08: 48000094  b 0x82ebdf9c
	pc = 0x82EBDF9C; continue 'dispatch;
	// 82EBDF0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDF10: 48000090  b 0x82ebdfa0
	pc = 0x82EBDFA0; continue 'dispatch;
	// 82EBDF14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF18: 81630250  lwz r11, 0x250(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBDF1C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EBDF20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDF24: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBDF28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDF2C: 4E800421  bctrl
	ctx.lr = 0x82EBDF30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDF30: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF34: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EBDF38: 3D4082EC  lis r10, -0x7d14
	ctx.r[10].s64 = -2098462720;
	// 82EBDF3C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EBDF40: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EBDF44: 38AADD08  addi r5, r10, -0x22f8
	ctx.r[5].s64 = ctx.r[10].s64 + -8952;
	// 82EBDF48: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBDF4C: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EBDF54: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EBDF58: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82EBDF5C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EBDF60: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82EBDF64: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EBDF68: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EBDF6C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBDF70: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBDF74: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBDF78: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EBDF7C: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82EBDF80: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82EBDF84: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82EBDF88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBDF8C: 480175A5  bl 0x82ed5530
	ctx.lr = 0x82EBDF90;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5530);
	// 82EBDF90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDF94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDF98: 40820008  bne 0x82ebdfa0
	if !ctx.cr[0].eq {
	pc = 0x82EBDFA0; continue 'dispatch;
	}
	// 82EBDF9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBDFA0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EBDFA4: 4BDEB4A4  b 0x82ca9448
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9448);
	return;
	// 82EBDFA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBDFAC: 386BCCDC  addi r3, r11, -0x3324
	ctx.r[3].s64 = ctx.r[11].s64 + -13092;
	// 82EBDFB0: 4E800020  blr
	return;
}

pub fn sub_82EBDFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDFB8 size=96
	// 82EBDFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDFBC: 4BDEB451  bl 0x82ca940c
	ctx.lr = 0x82EBDFC0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EBDFC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDFC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBDFC8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBDFCC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBDFD0: 4B758959  bl 0x82616928
	ctx.lr = 0x82EBDFD4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBDFD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBDFD8: 41820028  beq 0x82ebe000
	if ctx.cr[0].eq {
	pc = 0x82EBE000; continue 'dispatch;
	}
	// 82EBDFDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBDFE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDFE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDFE8: 4BFF7349  bl 0x82eb5330
	ctx.lr = 0x82EBDFEC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBDFEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDFF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDFF4: 396BAD3C  addi r11, r11, -0x52c4
	ctx.r[11].s64 = ctx.r[11].s64 + -21188;
	// 82EBDFF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBDFFC: 48000008  b 0x82ebe004
	pc = 0x82EBE004; continue 'dispatch;
	// 82EBE000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE004: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE008: 4BDEB454  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EBE018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE018 size=424
	// 82EBE018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE01C: 4BDEB3E5  bl 0x82ca9400
	ctx.lr = 0x82EBE020;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EBE020: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EBE024: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE028: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EBE02C: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82EBE030: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE034: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE038: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EBE03C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBE040: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82EBE044: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82EBE048: 4B32A631  bl 0x821e8678
	ctx.lr = 0x82EBE04C;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EBE04C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE050: 41820160  beq 0x82ebe1b0
	if ctx.cr[0].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE054: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE058: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE05C: 41820154  beq 0x82ebe1b0
	if ctx.cr[0].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE060: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE064: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE068: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82EBE06C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE070: 4BFBF651  bl 0x82e7d6c0
	ctx.lr = 0x82EBE074;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EBE074: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE078: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE07C: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 82EBE080: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE088: 4BFBF639  bl 0x82e7d6c0
	ctx.lr = 0x82EBE08C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EBE08C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE090: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBE094: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82EBE098: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE0A0: 4BFBF621  bl 0x82e7d6c0
	ctx.lr = 0x82EBE0A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EBE0A4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EBE0A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EBE0AC: 419A0104  beq cr6, 0x82ebe1b0
	if ctx.cr[6].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE0B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EBE0B4: 419A00FC  beq cr6, 0x82ebe1b0
	if ctx.cr[6].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE0B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EBE0BC: 419A00F4  beq cr6, 0x82ebe1b0
	if ctx.cr[6].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE0C0: C01B0038  lfs f0, 0x38(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE0C8: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE0CC: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE0D0: C01B003C  lfs f0, 0x3c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0D4: C19A000C  lfs f12, 0xc(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE0D8: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE0DC: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0E0: C17B0034  lfs f11, 0x34(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE0E4: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBE0E8: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBE0EC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE0F0: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE0F4: ED40002C  fsqrts f10, f0
	ctx.f[10].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBE0F8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0FC: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82EBE100: 409A000C  bne cr6, 0x82ebe10c
	if !ctx.cr[6].eq {
	pc = 0x82EBE10C; continue 'dispatch;
	}
	// 82EBE104: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE108: 480000AC  b 0x82ebe1b4
	pc = 0x82EBE1B4; continue 'dispatch;
	// 82EBE10C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE110: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBE114: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBE118: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE11C: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EBE120: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBE124: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBE128: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBE12C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBE130: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBE134: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBE138: 4BFC7C31  bl 0x82e85d68
	ctx.lr = 0x82EBE13C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85D68);
	// 82EBE13C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EBE140: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82EBE144: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE148: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE14C: 9BFC0004  stb r31, 4(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EBE150: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE154: C00B0ED4  lfs f0, 0xed4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE158: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE15C: 4B37BD55  bl 0x82239eb0
	ctx.lr = 0x82EBE160;
	crate::recompiler::externs::call(&mut ctx, base, 0x82239EB0);
	// 82EBE160: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE164: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBE168: 9BFE0004  stb r31, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EBE16C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE170: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EBE174: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE178: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE17C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE180: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE184: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBE188: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE18C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE190: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE194: C1410050  lfs f10, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBE198: 9BFD0004  stb r31, 4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EBE19C: EC0C583A  fmadds f0, f12, f0, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EBE1A0: EC0D02BA  fmadds f0, f13, f10, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE1A4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE1A8: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE1AC: 48000008  b 0x82ebe1b4
	pc = 0x82EBE1B4; continue 'dispatch;
	// 82EBE1B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE1B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EBE1B8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EBE1BC: 4BDEB294  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
}

pub fn sub_82EBE1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBE1C0 size=88
	// 82EBE1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBE1C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBE1CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBE1D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE1D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBE1D8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82EBE1DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBE1E0: 4B758749  bl 0x82616928
	ctx.lr = 0x82EBE1E4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBE1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE1E8: 41820014  beq 0x82ebe1fc
	if ctx.cr[0].eq {
	pc = 0x82EBE1FC; continue 'dispatch;
	}
	// 82EBE1EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBE1F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBE1F4: 4BFF755D  bl 0x82eb5750
	ctx.lr = 0x82EBE1F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5750);
	// 82EBE1F8: 48000008  b 0x82ebe200
	pc = 0x82EBE200; continue 'dispatch;
	// 82EBE1FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE200: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE204: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBE208: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBE20C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBE210: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBE214: 4E800020  blr
	return;
}

pub fn sub_82EBE218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE218 size=376
	// 82EBE218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE21C: 4BDEB1F1  bl 0x82ca940c
	ctx.lr = 0x82EBE220;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EBE220: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBE224: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE228: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBE22C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE230: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBE234: 482FDE2D  bl 0x831bc060
	ctx.lr = 0x82EBE238;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBE238: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBE23C: 4182012C  beq 0x82ebe368
	if ctx.cr[0].eq {
	pc = 0x82EBE368; continue 'dispatch;
	}
	// 82EBE240: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE248: 388BAD78  addi r4, r11, -0x5288
	ctx.r[4].s64 = ctx.r[11].s64 + -21128;
	// 82EBE24C: 4BDEE905  bl 0x82cacb50
	ctx.lr = 0x82EBE250;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBE250: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE254: 40820064  bne 0x82ebe2b8
	if !ctx.cr[0].eq {
	pc = 0x82EBE2B8; continue 'dispatch;
	}
	// 82EBE258: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE25C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBE260: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE264: 4182000C  beq 0x82ebe270
	if ctx.cr[0].eq {
	pc = 0x82EBE270; continue 'dispatch;
	}
	// 82EBE268: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE26C: 4800000C  b 0x82ebe278
	pc = 0x82EBE278; continue 'dispatch;
	// 82EBE270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE274: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE278: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBE27C: 4BA4FA8D  bl 0x8290dd08
	ctx.lr = 0x82EBE280;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBE280: 4BDED931  bl 0x82cabbb0
	ctx.lr = 0x82EBE284;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EBE284: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE288: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE28C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE290: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE294: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE298: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBE29C: 41980008  blt cr6, 0x82ebe2a4
	if ctx.cr[6].lt {
	pc = 0x82EBE2A4; continue 'dispatch;
	}
	// 82EBE2A0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBE2A4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBE2A8: 409AFFF0  bne cr6, 0x82ebe298
	if !ctx.cr[6].eq {
	pc = 0x82EBE298; continue 'dispatch;
	}
	// 82EBE2AC: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBE2B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE2B4: 480000C0  b 0x82ebe374
	pc = 0x82EBE374; continue 'dispatch;
	// 82EBE2B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE2C0: 388BAD6C  addi r4, r11, -0x5294
	ctx.r[4].s64 = ctx.r[11].s64 + -21140;
	// 82EBE2C4: 4BDEE88D  bl 0x82cacb50
	ctx.lr = 0x82EBE2C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBE2C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE2CC: 4082009C  bne 0x82ebe368
	if !ctx.cr[0].eq {
	pc = 0x82EBE368; continue 'dispatch;
	}
	// 82EBE2D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBE2D4: 4BA4FA35  bl 0x8290dd08
	ctx.lr = 0x82EBE2D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBE2D8: 4BDED8D9  bl 0x82cabbb0
	ctx.lr = 0x82EBE2DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EBE2DC: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE2E0: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE2E4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82EBE2E8: 4B3A2659  bl 0x82260940
	ctx.lr = 0x82EBE2EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82260940);
	// 82EBE2EC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBE2F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE2F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBE2F8: C1ABDF6C  lfs f13, -0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE2FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE300: C16A0A44  lfs f11, 0xa44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2628 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE304: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EBE308: C18B89C8  lfs f12, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE30C: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE310: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 82EBE314: 41980010  blt cr6, 0x82ebe324
	if ctx.cr[6].lt {
	pc = 0x82EBE324; continue 'dispatch;
	}
	// 82EBE318: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82EBE31C: 41990008  bgt cr6, 0x82ebe324
	if ctx.cr[6].gt {
	pc = 0x82EBE324; continue 'dispatch;
	}
	// 82EBE320: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EBE324: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBE328: 409AFFE8  bne cr6, 0x82ebe310
	if !ctx.cr[6].eq {
	pc = 0x82EBE310; continue 'dispatch;
	}
	// 82EBE32C: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE330: EC2D07F2  fmuls f1, f13, f31
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE334: 4B37BB7D  bl 0x82239eb0
	ctx.lr = 0x82EBE338;
	crate::recompiler::externs::call(&mut ctx, base, 0x82239EB0);
	// 82EBE338: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE33C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE340: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE344: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE348: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE34C: 41990014  bgt cr6, 0x82ebe360
	if ctx.cr[6].gt {
	pc = 0x82EBE360; continue 'dispatch;
	}
	// 82EBE350: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE354: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE358: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE35C: 4098FF54  bge cr6, 0x82ebe2b0
	if !ctx.cr[6].lt {
	pc = 0x82EBE2B0; continue 'dispatch;
	}
	// 82EBE360: D1BE0010  stfs f13, 0x10(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE364: 4BFFFF4C  b 0x82ebe2b0
	pc = 0x82EBE2B0; continue 'dispatch;
	// 82EBE368: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE36C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBE370: 4BFF70B1  bl 0x82eb5420
	ctx.lr = 0x82EBE374;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5420);
	// 82EBE374: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBE378: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBE37C: 4BDEB0E0  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
	// 82EBE380: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE384: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EBE388: 4E800020  blr
	return;
}

pub fn sub_82EBE390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE390 size=848
	// 82EBE390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE394: 4BDEB071  bl 0x82ca9404
	ctx.lr = 0x82EBE398;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EBE398: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EBE39C: 4BDEF935  bl 0x82cadcd0
	ctx.lr = 0x82EBE3A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCD0);
	// 82EBE3A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE3A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBE3A8: C1A60004  lfs f13, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBE3B0: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82EBE3B4: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 82EBE3B8: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EBE3BC: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE3C0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBE3C4: 409A0028  bne cr6, 0x82ebe3ec
	if !ctx.cr[6].eq {
	pc = 0x82EBE3EC; continue 'dispatch;
	}
	// 82EBE3C8: C0060008  lfs f0, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE3CC: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE3D4: 409A0018  bne cr6, 0x82ebe3ec
	if !ctx.cr[6].eq {
	pc = 0x82EBE3EC; continue 'dispatch;
	}
	// 82EBE3D8: C006000C  lfs f0, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE3DC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EBE3E0: C1BE003C  lfs f13, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE3E8: 419A0008  beq cr6, 0x82ebe3f0
	if ctx.cr[6].eq {
	pc = 0x82EBE3F0; continue 'dispatch;
	}
	// 82EBE3EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE3F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBE3F4: 408202B0  bne 0x82ebe6a4
	if !ctx.cr[0].eq {
	pc = 0x82EBE6A4; continue 'dispatch;
	}
	// 82EBE3F8: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE400: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE404: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBE408: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE40C: C186000C  lfs f12, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE410: C1BE003C  lfs f13, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE414: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EBE418: C38B0C18  lfs f28, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EBE41C: D3810054  stfs f28, 0x54(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBE420: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE424: EC0C6828  fsubs f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBE428: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE42C: C19E0034  lfs f12, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE430: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBE434: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBE438: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBE43C: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EBE440: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE444: EFC0002C  fsqrts f30, f0
	ctx.f[30].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBE448: 4BFC7921  bl 0x82e85d68
	ctx.lr = 0x82EBE44C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85D68);
	// 82EBE44C: C1A10084  lfs f13, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE450: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE454: C01E0044  lfs f0, 0x44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE458: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE45C: FF406890  fmr f26, f13
	ctx.f[26].f64 = ctx.f[13].f64;
	// 82EBE460: C1AB0A44  lfs f13, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE464: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE468: 40990014  ble cr6, 0x82ebe47c
	if !ctx.cr[6].gt {
	pc = 0x82EBE47C; continue 'dispatch;
	}
	// 82EBE46C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE470: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE474: EFA06828  fsubs f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBE478: 48000028  b 0x82ebe4a0
	pc = 0x82EBE4A0; continue 'dispatch;
	// 82EBE47C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE480: C1AB89C8  lfs f13, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE484: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE488: 40980014  bge cr6, 0x82ebe49c
	if !ctx.cr[6].lt {
	pc = 0x82EBE49C; continue 'dispatch;
	}
	// 82EBE48C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE490: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE494: EFA0682A  fadds f29, f0, f13
	ctx.f[29].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBE498: 48000008  b 0x82ebe4a0
	pc = 0x82EBE4A0; continue 'dispatch;
	// 82EBE49C: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	// 82EBE4A0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBE4A4: C00BDF6C  lfs f0, -0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE4A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE4AC: EDA00772  fmuls f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EBE4B0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE4B4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE4B8: 4B37B9F9  bl 0x82239eb0
	ctx.lr = 0x82EBE4BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82239EB0);
	// 82EBE4BC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE4C0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE4C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE4C8: 388BC904  addi r4, r11, -0x36fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14076;
	// 82EBE4CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE4D0: EF6007F2  fmuls f27, f0, f31
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE4D4: 4BFBF1ED  bl 0x82e7d6c0
	ctx.lr = 0x82EBE4D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EBE4D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBE4DC: 418200F4  beq 0x82ebe5d0
	if ctx.cr[0].eq {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE4E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE4E4: 895D0014  lbz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBE4E8: C1BD000C  lfs f13, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE4EC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE4F0: C00B0C80  lfs f0, 0xc80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE4F4: 41820008  beq 0x82ebe4fc
	if ctx.cr[0].eq {
	pc = 0x82EBE4FC; continue 'dispatch;
	}
	// 82EBE4F8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE4FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBE500: 419A0010  beq cr6, 0x82ebe510
	if ctx.cr[6].eq {
	pc = 0x82EBE510; continue 'dispatch;
	}
	// 82EBE504: C19D0010  lfs f12, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE508: EFEC0032  fmuls f31, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE50C: 48000008  b 0x82ebe514
	pc = 0x82EBE514; continue 'dispatch;
	// 82EBE510: C3FD0010  lfs f31, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE514: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE518: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 82EBE51C: 997D0014  stb r11, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EBE520: 409900B0  ble cr6, 0x82ebe5d0
	if !ctx.cr[6].gt {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE524: FF1E6800  fcmpu cr6, f30, f13
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[13].f64);
	// 82EBE528: 409800A8  bge cr6, 0x82ebe5d0
	if !ctx.cr[6].lt {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE52C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE530: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE534: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EBE538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBE53C: 4B32A13D  bl 0x821e8678
	ctx.lr = 0x82EBE540;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EBE540: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE544: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EBE548: 40820008  bne 0x82ebe550
	if !ctx.cr[0].eq {
	pc = 0x82EBE550; continue 'dispatch;
	}
	// 82EBE54C: 397E004C  addi r11, r30, 0x4c
	ctx.r[11].s64 = ctx.r[30].s64 + 76;
	// 82EBE550: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE554: ED7F07B2  fmuls f11, f31, f30
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EBE558: C1410050  lfs f10, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBE55C: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBE560: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE564: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE568: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE56C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBE570: 40980060  bge cr6, 0x82ebe5d0
	if !ctx.cr[6].lt {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE574: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE578: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EBE57C: 9B7D0014  stb r27, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82EBE580: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE584: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE588: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EBE58C: C1AB03B0  lfs f13, 0x3b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(944 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE590: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE594: C18B03AC  lfs f12, 0x3ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(940 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE598: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE59C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBE5A0: C18B03A8  lfs f12, 0x3a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(936 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE5A4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBE5A8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EBE5AC: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EBE5B0: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EBE5B4: 4BFC77B5  bl 0x82e85d68
	ctx.lr = 0x82EBE5B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E85D68);
	// 82EBE5B8: C0010074  lfs f0, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE5BC: 9B7F0004  stb r27, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE5C0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBE5C4: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE5C8: 9B7F0004  stb r27, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE5CC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE5D0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE5D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE5D8: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82EBE5DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE5E0: 4BFBF0E1  bl 0x82e7d6c0
	ctx.lr = 0x82EBE5E4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EBE5E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBE5E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE5EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE5F0: C3CA0EE0  lfs f30, 0xee0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3808 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBE5F4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE5F8: 40820044  bne 0x82ebe63c
	if !ctx.cr[0].eq {
	pc = 0x82EBE63C; continue 'dispatch;
	}
	// 82EBE5FC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE600: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE604: 388BCB2C  addi r4, r11, -0x34d4
	ctx.r[4].s64 = ctx.r[11].s64 + -13524;
	// 82EBE608: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE60C: 4BFBF0B5  bl 0x82e7d6c0
	ctx.lr = 0x82EBE610;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EBE610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE614: 4082000C  bne 0x82ebe620
	if !ctx.cr[0].eq {
	pc = 0x82EBE620; continue 'dispatch;
	}
	// 82EBE618: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE61C: 4800008C  b 0x82ebe6a8
	pc = 0x82EBE6A8; continue 'dispatch;
	// 82EBE620: FF1DE000  fcmpu cr6, f29, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[28].f64);
	// 82EBE624: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE628: 4099000C  ble cr6, 0x82ebe634
	if !ctx.cr[6].gt {
	pc = 0x82EBE634; continue 'dispatch;
	}
	// 82EBE62C: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE630: 48000014  b 0x82ebe644
	pc = 0x82EBE644; continue 'dispatch;
	// 82EBE634: D3C30008  stfs f30, 8(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE638: 4800000C  b 0x82ebe644
	pc = 0x82EBE644; continue 'dispatch;
	// 82EBE63C: D3430008  stfs f26, 8(r3)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE640: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE644: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE648: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE64C: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82EBE650: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE654: 4BFBF06D  bl 0x82e7d6c0
	ctx.lr = 0x82EBE658;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EBE658: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE65C: 40820040  bne 0x82ebe69c
	if !ctx.cr[0].eq {
	pc = 0x82EBE69C; continue 'dispatch;
	}
	// 82EBE660: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE664: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE668: 388BCF7C  addi r4, r11, -0x3084
	ctx.r[4].s64 = ctx.r[11].s64 + -12420;
	// 82EBE66C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE670: 4BFBF051  bl 0x82e7d6c0
	ctx.lr = 0x82EBE674;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EBE674: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE678: 4182FFA0  beq 0x82ebe618
	if ctx.cr[0].eq {
	pc = 0x82EBE618; continue 'dispatch;
	}
	// 82EBE67C: C01E0058  lfs f0, 0x58(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE680: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE684: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EBE688: 4099000C  ble cr6, 0x82ebe694
	if !ctx.cr[6].gt {
	pc = 0x82EBE694; continue 'dispatch;
	}
	// 82EBE68C: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE690: 48000014  b 0x82ebe6a4
	pc = 0x82EBE6A4; continue 'dispatch;
	// 82EBE694: D3C30008  stfs f30, 8(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE698: 4800000C  b 0x82ebe6a4
	pc = 0x82EBE6A4; continue 'dispatch;
	// 82EBE69C: D3630008  stfs f27, 8(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE6A0: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE6A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE6A8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EBE6AC: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EBE6B0: 4BDEF66D  bl 0x82cadd1c
	ctx.lr = 0x82EBE6B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADD1C);
	// 82EBE6B4: 4BDEADA0  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
	// 82EBE6B8: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82EBE6BC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82EBE6C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBE6C4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBE6C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBE6CC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82EBE6D0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBE6D4: 386BCF04  addi r3, r11, -0x30fc
	ctx.r[3].s64 = ctx.r[11].s64 + -12540;
	// 82EBE6D8: 4E800020  blr
	return;
}

pub fn sub_82EBE6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBE6E0 size=152
	// 82EBE6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE6E4: 4BDEAD29  bl 0x82ca940c
	ctx.lr = 0x82EBE6E8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EBE6E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE6EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE6F0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBE6F4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBE6F8: 4B758231  bl 0x82616928
	ctx.lr = 0x82EBE6FC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBE6FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBE700: 41820028  beq 0x82ebe728
	if ctx.cr[0].eq {
	pc = 0x82EBE728; continue 'dispatch;
	}
	// 82EBE704: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBE708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBE70C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE710: 4BFF6C21  bl 0x82eb5330
	ctx.lr = 0x82EBE714;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBE714: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE71C: 396BADA4  addi r11, r11, -0x525c
	ctx.r[11].s64 = ctx.r[11].s64 + -21084;
	// 82EBE720: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBE724: 48000008  b 0x82ebe72c
	pc = 0x82EBE72C; continue 'dispatch;
	// 82EBE728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE72C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE730: 4BDEAD2C  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EBE778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBE778 size=12
	// 82EBE778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE77C: 4BDEAC91  bl 0x82ca940c
	ctx.lr = 0x82EBE780;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EBE780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBE950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBE950 size=28
	// 82EBE950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBE958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBE95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBE960: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82EBE964: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EBE968: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EBEC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBEC60 size=88
	// 82EBEC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBEC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBEC68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBEC6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBEC70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBEC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBEC78: 386000F8  li r3, 0xf8
	ctx.r[3].s64 = 248;
	// 82EBEC7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBEC80: 4B757CA9  bl 0x82616928
	ctx.lr = 0x82EBEC84;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBEC84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEC88: 41820014  beq 0x82ebec9c
	if ctx.cr[0].eq {
	pc = 0x82EBEC9C; continue 'dispatch;
	}
	// 82EBEC8C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBEC90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBEC94: 4BFFFCBD  bl 0x82ebe950
	ctx.lr = 0x82EBEC98;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBE950);
	// 82EBEC98: 48000008  b 0x82ebeca0
	pc = 0x82EBECA0; continue 'dispatch;
	// 82EBEC9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBECA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBECA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBECA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBECAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBECB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBECB4: 4E800020  blr
	return;
}

pub fn sub_82EBECB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBECB8 size=824
	// 82EBECB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBECBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBECC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBECC4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EBECC8: 4BDEEFFD  bl 0x82cadcc4
	ctx.lr = 0x82EBECCC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCC4);
	// 82EBECCC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBECD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBECD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBECD8: C36B0C18  lfs f27, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EBECDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBECE0: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBECE4: FDA0D890  fmr f13, f27
	ctx.f[13].f64 = ctx.f[27].f64;
	// 82EBECE8: FD80D890  fmr f12, f27
	ctx.f[12].f64 = ctx.f[27].f64;
	// 82EBECEC: FD60D890  fmr f11, f27
	ctx.f[11].f64 = ctx.f[27].f64;
	// 82EBECF0: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBECF4: C34B0C14  lfs f26, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EBECF8: 40810070  ble 0x82ebed68
	if !ctx.cr[0].gt {
	pc = 0x82EBED68; continue 'dispatch;
	}
	// 82EBECFC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBED00: 393F0058  addi r9, r31, 0x58
	ctx.r[9].s64 = ctx.r[31].s64 + 88;
	// 82EBED04: C0EB0034  lfs f7, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBED08: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EBED0C: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EBED10: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBED14: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBED18: ED254828  fsubs f9, f5, f9
	ctx.f[9].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBED1C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBED20: ED470028  fsubs f10, f7, f0
	ctx.f[10].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBED24: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBED28: ED060028  fsubs f8, f6, f0
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBED2C: EC090272  fmuls f0, f9, f9
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EBED30: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED34: EC08023A  fmadds f0, f8, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED38: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBED3C: 40990020  ble cr6, 0x82ebed5c
	if !ctx.cr[6].gt {
	pc = 0x82EBED5C; continue 'dispatch;
	}
	// 82EBED40: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBED44: ED4002B2  fmuls f10, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBED48: ED000232  fmuls f8, f0, f8
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EBED4C: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EBED50: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBED54: ED88602A  fadds f12, f8, f12
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBED58: ED60582A  fadds f11, f0, f11
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EBED5C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EBED60: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EBED64: 4082FFAC  bne 0x82ebed10
	if !ctx.cr[0].eq {
	pc = 0x82EBED10; continue 'dispatch;
	}
	// 82EBED68: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBED6C: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED70: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED74: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBED78: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBED7C: 40990018  ble cr6, 0x82ebed94
	if !ctx.cr[6].gt {
	pc = 0x82EBED94; continue 'dispatch;
	}
	// 82EBED80: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBED84: EF200372  fmuls f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBED88: EEE00332  fmuls f23, f0, f12
	ctx.f[23].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBED8C: EF0002F2  fmuls f24, f0, f11
	ctx.f[24].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBED90: 48000010  b 0x82ebeda0
	pc = 0x82EBEDA0; continue 'dispatch;
	// 82EBED94: FF20D890  fmr f25, f27
	ctx.f[25].f64 = ctx.f[27].f64;
	// 82EBED98: FEE0D890  fmr f23, f27
	ctx.f[23].f64 = ctx.f[27].f64;
	// 82EBED9C: FF00D890  fmr f24, f27
	ctx.f[24].f64 = ctx.f[27].f64;
	// 82EBEDA0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBEDA4: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEDA8: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEDAC: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEDB0: C143003C  lfs f10, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEDB4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEDB8: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEDBC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBEDC0: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEDC4: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBEDC8: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEDCC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEDD0: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEDD4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBEDD8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBEDDC: 40990018  ble cr6, 0x82ebedf4
	if !ctx.cr[6].gt {
	pc = 0x82EBEDF4; continue 'dispatch;
	}
	// 82EBEDE0: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBEDE4: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEDE8: EFA002F2  fmuls f29, f0, f11
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEDEC: EFC00332  fmuls f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEDF0: 48000010  b 0x82ebee00
	pc = 0x82EBEE00; continue 'dispatch;
	// 82EBEDF4: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 82EBEDF8: FFA0D890  fmr f29, f27
	ctx.f[29].f64 = ctx.f[27].f64;
	// 82EBEDFC: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82EBEE00: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEE04: C39F00D4  lfs f28, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EBEE08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBEE0C: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EBEE10: 4B329869  bl 0x821e8678
	ctx.lr = 0x82EBEE14;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EBEE14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEE18: 4182010C  beq 0x82ebef24
	if ctx.cr[0].eq {
	pc = 0x82EBEF24; continue 'dispatch;
	}
	// 82EBEE1C: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEE20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEE24: 41820100  beq 0x82ebef24
	if ctx.cr[0].eq {
	pc = 0x82EBEF24; continue 'dispatch;
	}
	// 82EBEE28: ED9D0672  fmuls f12, f29, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EBEE2C: EC1E05F2  fmuls f0, f30, f23
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[23].f64) as f32) as f64);
	// 82EBEE30: ED5807F2  fmuls f10, f24, f31
	ctx.f[10].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBEE34: ED7767F8  fmsubs f11, f23, f31, f12
	ctx.f[11].f64 = (((ctx.f[23].f64 * ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBEE38: EDBD0638  fmsubs f13, f29, f24, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBEE3C: ED9E5678  fmsubs f12, f30, f25, f10
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEE40: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEE44: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEE48: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEE4C: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBEE50: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBEE54: 409A0074  bne cr6, 0x82ebeec8
	if !ctx.cr[6].eq {
	pc = 0x82EBEEC8; continue 'dispatch;
	}
	// 82EBEE58: FF1FD800  fcmpu cr6, f31, f27
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[27].f64);
	// 82EBEE5C: 409A0018  bne cr6, 0x82ebee74
	if !ctx.cr[6].eq {
	pc = 0x82EBEE74; continue 'dispatch;
	}
	// 82EBEE60: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EBEE64: 409A0010  bne cr6, 0x82ebee74
	if !ctx.cr[6].eq {
	pc = 0x82EBEE74; continue 'dispatch;
	}
	// 82EBEE68: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBEE6C: 396BDBE4  addi r11, r11, -0x241c
	ctx.r[11].s64 = ctx.r[11].s64 + -9244;
	// 82EBEE70: 4800000C  b 0x82ebee7c
	pc = 0x82EBEE7C; continue 'dispatch;
	// 82EBEE74: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBEE78: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EBEE7C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEE80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBEE84: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEE88: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEE8C: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEE90: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEE94: ED3D0332  fmuls f9, f29, f12
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEE98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBEE9C: EC1D5838  fmsubs f0, f29, f0, f11
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBEEA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBEEA4: EC1E5338  fmsubs f0, f30, f12, f10
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEEA8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBEEAC: EC1F4B78  fmsubs f0, f31, f13, f9
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBEEB0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBEEB4: 4B3C03B5  bl 0x8227f268
	ctx.lr = 0x82EBEEB8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8227F268);
	// 82EBEEB8: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEEBC: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEEC0: C1630008  lfs f11, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEEC4: 48000030  b 0x82ebeef4
	pc = 0x82EBEEF4; continue 'dispatch;
	// 82EBEEC8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBEECC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEED0: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEED4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEED8: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEEDC: ED2C07F2  fmuls f9, f12, f31
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBEEE0: ED400772  fmuls f10, f0, f29
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EBEEE4: ED4C57B8  fmsubs f10, f12, f30, f10
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEEE8: ED805FF8  fmsubs f12, f0, f31, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBEEEC: ED7D4B78  fmsubs f11, f29, f13, f9
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBEEF0: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EBEEF4: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EBEEF8: ED5F0732  fmuls f10, f31, f28
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEEFC: ED3D0732  fmuls f9, f29, f28
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF00: ED1E0732  fmuls f8, f30, f28
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF04: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF08: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF0C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF10: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBEF14: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBEF18: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBEF1C: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBEF20: 48000084  b 0x82ebefa4
	pc = 0x82EBEFA4; continue 'dispatch;
	// 82EBEF24: EC1807F2  fmuls f0, f24, f31
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBEF28: FDA0D090  fmr f13, f26
	ctx.f[13].f64 = ctx.f[26].f64;
	// 82EBEF2C: EC1E0678  fmsubs f0, f30, f25, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBEF30: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBEF34: 4098000C  bge cr6, 0x82ebef40
	if !ctx.cr[6].lt {
	pc = 0x82EBEF40; continue 'dispatch;
	}
	// 82EBEF38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEF3C: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEF40: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBEF44: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EBEF48: ED3F0732  fmuls f9, f31, f28
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF4C: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EBEF50: ECFE0732  fmuls f7, f30, f28
	ctx.f[7].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF54: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEF58: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEF5C: ED1D02F2  fmuls f8, f29, f11
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEF60: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEF64: ECDE02B2  fmuls f6, f30, f10
	ctx.f[6].f64 = (((ctx.f[30].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBEF68: ECBF0332  fmuls f5, f31, f12
	ctx.f[5].f64 = (((ctx.f[31].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEF6C: ED9E4338  fmsubs f12, f30, f12, f8
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EBEF70: ED7F32F8  fmsubs f11, f31, f11, f6
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EBEF74: ED5D2AB8  fmsubs f10, f29, f10, f5
	ctx.f[10].f64 = (((ctx.f[29].f64 * ctx.f[10].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EBEF78: ED1D0732  fmuls f8, f29, f28
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF7C: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF80: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF84: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF88: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF8C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF90: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF94: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBEF98: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBEF9C: EDA8582A  fadds f13, f8, f11
	ctx.f[13].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EBEFA0: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBEFA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBEFA8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBEFAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBEFB0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBEFB4: 4B3C02B5  bl 0x8227f268
	ctx.lr = 0x82EBEFB8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8227F268);
	// 82EBEFB8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEFBC: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EBEFC0: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEFC4: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EBEFC8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEFCC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EBEFD0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EBEFD4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EBEFD8: 4BDEED39  bl 0x82cadd10
	ctx.lr = 0x82EBEFDC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADD10);
	// 82EBEFDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBEFE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBEFE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBEFE8: 4E800020  blr
	return;
}

pub fn sub_82EBEFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBEFF0 size=712
	// 82EBEFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBEFF4: 4BDEA419  bl 0x82ca940c
	ctx.lr = 0x82EBEFF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EBEFF8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EBEFFC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBF000: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF004: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF008: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF00C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF010: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF014: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EBF018: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF01C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBF020: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF024: 4182000C  beq 0x82ebf030
	if ctx.cr[0].eq {
	pc = 0x82EBF030; continue 'dispatch;
	}
	// 82EBF028: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBF02C: 48000008  b 0x82ebf034
	pc = 0x82EBF034; continue 'dispatch;
	// 82EBF030: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82EBF034: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF038: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBF03C: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EBF040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBF044: 4B329635  bl 0x821e8678
	ctx.lr = 0x82EBF048;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EBF048: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF04C: 41820008  beq 0x82ebf054
	if ctx.cr[0].eq {
	pc = 0x82EBF054; continue 'dispatch;
	}
	// 82EBF050: C3C30004  lfs f30, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBF054: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF058: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF05C: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF060: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF064: C19E003C  lfs f12, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF068: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF06C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBF070: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF074: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF078: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBF07C: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBF080: C14A0C18  lfs f10, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF084: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF088: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF08C: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF090: ED20002C  fsqrts f9, f0
	ctx.f[9].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBF094: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 82EBF098: 40990018  ble cr6, 0x82ebf0b0
	if !ctx.cr[6].gt {
	pc = 0x82EBF0B0; continue 'dispatch;
	}
	// 82EBF09C: EC1F4824  fdivs f0, f31, f9
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[9].f64) as f32) as f64;
	// 82EBF0A0: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBF0A4: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF0A8: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBF0AC: 48000010  b 0x82ebf0bc
	pc = 0x82EBF0BC; continue 'dispatch;
	// 82EBF0B0: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 82EBF0B4: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EBF0B8: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 82EBF0BC: C18B0050  lfs f12, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF0C0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF0C4: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF0C8: C10B004C  lfs f8, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBF0CC: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBF0D0: EC0802FA  fmadds f0, f8, f11, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF0D4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EBF0D8: 41990010  bgt cr6, 0x82ebf0e8
	if ctx.cr[6].gt {
	pc = 0x82EBF0E8; continue 'dispatch;
	}
	// 82EBF0DC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF0E0: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82EBF0E4: 409801C0  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF0E8: C00B0058  lfs f0, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF0EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF0F0: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF0F4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EBF0F8: C12B004C  lfs f9, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF0FC: C17E004C  lfs f11, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF100: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF104: C10B0050  lfs f8, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBF108: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF10C: C15E0050  lfs f10, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF110: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF114: C0FE0054  lfs f7, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBF118: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF11C: C08B0054  lfs f4, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EBF120: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF124: EC040032  fmuls f0, f4, f0
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF128: C0CB0034  lfs f6, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EBF12C: C0FE0034  lfs f7, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBF130: ECE73028  fsubs f7, f7, f6
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EBF134: C0BE0038  lfs f5, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EBF138: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EBF13C: ECC53028  fsubs f6, f5, f6
	ctx.f[6].f64 = (((ctx.f[5].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EBF140: C18A0A40  lfs f12, 0xa40(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2624 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF144: C07E003C  lfs f3, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EBF148: FFE06090  fmr f31, f12
	ctx.f[31].f64 = ctx.f[12].f64;
	// 82EBF14C: ED6B4828  fsubs f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBF150: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EBF154: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EBF158: ECA32828  fsubs f5, f3, f5
	ctx.f[5].f64 = (((ctx.f[3].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EBF15C: ED6A4028  fsubs f11, f10, f8
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EBF160: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EBF164: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBF168: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EBF16C: 419A0040  beq cr6, 0x82ebf1ac
	if ctx.cr[6].eq {
	pc = 0x82EBF1AC; continue 'dispatch;
	}
	// 82EBF170: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF174: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF178: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBF17C: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF180: C10B003C  lfs f8, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBF184: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBF188: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF18C: C12B0034  lfs f9, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF190: ED695828  fsubs f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF194: C14B0058  lfs f10, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF198: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF19C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF1A0: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF1A4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBF1A8: EFE05024  fdivs f31, f0, f10
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EBF1AC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF1B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF1B4: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EBF1B8: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EBF1BC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EBF1C0: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBF1C4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EBF1C8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBF1CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EBF1D0: D0E10070  stfs f7, 0x70(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EBF1D4: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF1D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBF1DC: D0C10074  stfs f6, 0x74(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EBF1E0: D0A10078  stfs f5, 0x78(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EBF1E4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF1E8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBF1EC: 4BFFFA15  bl 0x82ebec00
	ctx.lr = 0x82EBF1F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBEC00);
	// 82EBF1F0: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF1F4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF1F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF1FC: 41980008  blt cr6, 0x82ebf204
	if ctx.cr[6].lt {
	pc = 0x82EBF204; continue 'dispatch;
	}
	// 82EBF200: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBF204: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBF208: 4182009C  beq 0x82ebf2a4
	if ctx.cr[0].eq {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF20C: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF210: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF214: 40980090  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF218: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EBF21C: 40980088  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF220: C1BF00DC  lfs f13, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF224: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF228: 4099007C  ble cr6, 0x82ebf2a4
	if !ctx.cr[6].gt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF22C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBF230: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 82EBF234: 4098001C  bge cr6, 0x82ebf250
	if !ctx.cr[6].lt {
	pc = 0x82EBF250; continue 'dispatch;
	}
	// 82EBF238: 396B0016  addi r11, r11, 0x16
	ctx.r[11].s64 = ctx.r[11].s64 + 22;
	// 82EBF23C: 556B103A  slwi r11, r11, 2
	// 82EBF240: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	// 82EBF244: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBF248: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBF24C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBF250: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF254: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF258: 4098004C  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF25C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EBF260: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF264: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBF268: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82EBF26C: 995F003C  stb r10, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u8 ) };
	// 82EBF270: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF274: C16B0050  lfs f11, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF278: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF27C: C14B0054  lfs f10, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF280: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF284: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF288: C1AB0058  lfs f13, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF28C: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF290: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EBF294: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF298: D17F0048  stfs f11, 0x48(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82EBF29C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF2A0: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EBF2A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EBF2A8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EBF2AC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBF2B0: 4BDEA1AC  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EBF2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF2B8 size=344
	// 82EBF2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF2BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF2C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF2C4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF2C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBF2CC: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EBF2D0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF2D4: C1AB00C0  lfs f13, 0xc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF2D8: C16B00C4  lfs f11, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF2DC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF2E0: C12B00BC  lfs f9, 0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF2E4: C00B00F0  lfs f0, 0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF2E8: C18A0050  lfs f12, 0x50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF2EC: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF2F0: C18A0054  lfs f12, 0x54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF2F4: C14A004C  lfs f10, 0x4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF2F8: 807F0264  lwz r3, 0x264(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBF2FC: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBF300: EDAA6A7A  fmadds f13, f10, f9, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBF304: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBF308: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF30C: C1AB00F4  lfs f13, 0xf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF310: 40990054  ble cr6, 0x82ebf364
	if !ctx.cr[6].gt {
	pc = 0x82EBF364; continue 'dispatch;
	}
	// 82EBF314: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF318: 40980018  bge cr6, 0x82ebf330
	if !ctx.cr[6].lt {
	pc = 0x82EBF330; continue 'dispatch;
	}
	// 82EBF31C: C04B0024  lfs f2, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EBF320: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EBF324: C1AB00C0  lfs f13, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF328: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	// 82EBF32C: 48000060  b 0x82ebf38c
	pc = 0x82EBF38C; continue 'dispatch;
	// 82EBF330: C16B00E4  lfs f11, 0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF334: C14B0024  lfs f10, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF338: EC4B02B2  fmuls f2, f11, f10
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBF33C: C16A0034  lfs f11, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF340: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF344: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF348: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF34C: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF350: C14A0038  lfs f10, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF354: C16A003C  lfs f11, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF358: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBF35C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF360: 4800002C  b 0x82ebf38c
	pc = 0x82EBF38C; continue 'dispatch;
	// 82EBF364: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF368: C18B00C4  lfs f12, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF36C: C00B00BC  lfs f0, 0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF370: C1AB00C0  lfs f13, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF374: C14B0024  lfs f10, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF378: 4098000C  bge cr6, 0x82ebf384
	if !ctx.cr[6].lt {
	pc = 0x82EBF384; continue 'dispatch;
	}
	// 82EBF37C: C16B00E8  lfs f11, 0xe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF380: 48000008  b 0x82ebf388
	pc = 0x82EBF388; continue 'dispatch;
	// 82EBF384: C16B00E4  lfs f11, 0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF388: EC4B02B2  fmuls f2, f11, f10
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBF38C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBF390: C16A0034  lfs f11, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF394: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBF398: C14A0038  lfs f10, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF39C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EBF3A0: C16A003C  lfs f11, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF3A4: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBF3A8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBF3AC: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBF3B0: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBF3B4: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EBF3B8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EBF3BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBF3C0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EBF3C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EBF3C8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82EBF3CC: 90C70000  stw r6, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82EBF3D0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBF3D4: 4200FFF8  bdnz 0x82ebf3cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBF3CC; continue 'dispatch;
	}
	// 82EBF3D8: 98C100A8  stb r6, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[6].u8 ) };
	// 82EBF3DC: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EBF3E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBF3E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EBF3E8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EBF3EC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EBF3F0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF3F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF3F8: 4E800421  bctrl
	ctx.lr = 0x82EBF3FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF3FC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EBF400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF40C: 4E800020  blr
	return;
}

pub fn sub_82EBF410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF410 size=344
	// 82EBF410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF414: 4BDE9FF5  bl 0x82ca9408
	ctx.lr = 0x82EBF418;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EBF418: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF420: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF424: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBF428: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EBF42C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF430: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF434: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBF438: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82EBF43C: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EBF440: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF444: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBF448: 4182006C  beq 0x82ebf4b4
	if ctx.cr[0].eq {
	pc = 0x82EBF4B4; continue 'dispatch;
	}
	// 82EBF44C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF450: C03F00D0  lfs f1, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EBF454: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EBF458: 4BFC8851  bl 0x82e87ca8
	ctx.lr = 0x82EBF45C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E87CA8);
	// 82EBF45C: 4800004C  b 0x82ebf4a8
	pc = 0x82EBF4A8; continue 'dispatch;
	// 82EBF460: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF464: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBF468: 419A0038  beq cr6, 0x82ebf4a0
	if ctx.cr[6].eq {
	pc = 0x82EBF4A0; continue 'dispatch;
	}
	// 82EBF46C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF470: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF474: 4182001C  beq 0x82ebf490
	if ctx.cr[0].eq {
	pc = 0x82EBF490; continue 'dispatch;
	}
	// 82EBF478: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF47C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF480: 4E800421  bctrl
	ctx.lr = 0x82EBF484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF484: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EBF488: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EBF48C: 409A0014  bne cr6, 0x82ebf4a0
	if !ctx.cr[6].eq {
	pc = 0x82EBF4A0; continue 'dispatch;
	}
	// 82EBF490: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EBF494: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF49C: 4BFFFB55  bl 0x82ebeff0
	ctx.lr = 0x82EBF4A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBEFF0);
	// 82EBF4A0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF4A4: 4BFC82CD  bl 0x82e87770
	ctx.lr = 0x82EBF4A8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E87770);
	// 82EBF4A8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBF4AC: 4082FFB4  bne 0x82ebf460
	if !ctx.cr[0].eq {
	pc = 0x82EBF460; continue 'dispatch;
	}
	// 82EBF4B0: 480000AC  b 0x82ebf55c
	pc = 0x82EBF55C; continue 'dispatch;
	// 82EBF4B4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF4B8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF4BC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF4C0: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBF4C4: 48000090  b 0x82ebf554
	pc = 0x82EBF554; continue 'dispatch;
	// 82EBF4C8: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF4CC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF4D0: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBF4D4: 419A007C  beq cr6, 0x82ebf550
	if ctx.cr[6].eq {
	pc = 0x82EBF550; continue 'dispatch;
	}
	// 82EBF4D8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF4DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF4E0: 4182001C  beq 0x82ebf4fc
	if ctx.cr[0].eq {
	pc = 0x82EBF4FC; continue 'dispatch;
	}
	// 82EBF4E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF4E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF4EC: 4E800421  bctrl
	ctx.lr = 0x82EBF4F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF4F0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EBF4F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EBF4F8: 409A0058  bne cr6, 0x82ebf550
	if !ctx.cr[6].eq {
	pc = 0x82EBF550; continue 'dispatch;
	}
	// 82EBF4FC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF500: C01F00D0  lfs f0, 0xd0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF504: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF508: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF50C: C19E0038  lfs f12, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF510: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF514: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBF518: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF51C: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBF520: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF524: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF528: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBF52C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF530: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF534: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF538: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBF53C: 40980014  bge cr6, 0x82ebf550
	if !ctx.cr[6].lt {
	pc = 0x82EBF550; continue 'dispatch;
	}
	// 82EBF540: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EBF544: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF54C: 4BFFFAA5  bl 0x82ebeff0
	ctx.lr = 0x82EBF550;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBEFF0);
	// 82EBF550: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF554: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF558: 4082FF70  bne 0x82ebf4c8
	if !ctx.cr[0].eq {
	pc = 0x82EBF4C8; continue 'dispatch;
	}
	// 82EBF55C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBF560: 4BDE9EF8  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EBF568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF568 size=200
	// 82EBF568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF56C: 4BDE9E9D  bl 0x82ca9408
	ctx.lr = 0x82EBF570;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EBF570: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF578: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EBF57C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EBF580: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82EBF584: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF58C: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF590: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBF594: 4BFFFE7D  bl 0x82ebf410
	ctx.lr = 0x82EBF598;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBF410);
	// 82EBF598: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EBF59C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF5A0: 4182003C  beq 0x82ebf5dc
	if ctx.cr[0].eq {
	pc = 0x82EBF5DC; continue 'dispatch;
	}
	// 82EBF5A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF5A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF5AC: 4BFFF70D  bl 0x82ebecb8
	ctx.lr = 0x82EBF5B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBECB8);
	// 82EBF5B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBF5B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBF5B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF5BC: 4BFFFCFD  bl 0x82ebf2b8
	ctx.lr = 0x82EBF5C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBF2B8);
	// 82EBF5C0: 4B3A13F9  bl 0x822609b8
	ctx.lr = 0x82EBF5C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EBF5C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBF5C8: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF5CC: C01F00D8  lfs f0, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF5D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBF5D4: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EBF5D8: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82EBF5DC: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EBF5E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF5E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF5E8: 40820014  bne 0x82ebf5fc
	if !ctx.cr[0].eq {
	pc = 0x82EBF5FC; continue 'dispatch;
	}
	// 82EBF5EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBF5F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBF5F4: 4BFFF14D  bl 0x82ebe740
	ctx.lr = 0x82EBF5F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBE740);
	// 82EBF5F8: 48000030  b 0x82ebf628
	pc = 0x82EBF628; continue 'dispatch;
	// 82EBF5FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBF600: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBF604: 4BFFFCB5  bl 0x82ebf2b8
	ctx.lr = 0x82EBF608;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBF2B8);
	// 82EBF608: 4B3A13B1  bl 0x822609b8
	ctx.lr = 0x82EBF60C;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EBF60C: C01F00CC  lfs f0, 0xcc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF610: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF614: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF618: 4098000C  bge cr6, 0x82ebf624
	if !ctx.cr[6].lt {
	pc = 0x82EBF624; continue 'dispatch;
	}
	// 82EBF61C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBF620: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82EBF624: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBF628: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBF62C: 4BDE9E2C  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EBF630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF630 size=296
	// 82EBF630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF634: 4BDE9DD9  bl 0x82ca940c
	ctx.lr = 0x82EBF638;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EBF638: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBF63C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF640: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBF644: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBF648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF64C: 482FCA15  bl 0x831bc060
	ctx.lr = 0x82EBF650;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBF650: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF654: 41820084  beq 0x82ebf6d8
	if ctx.cr[0].eq {
	pc = 0x82EBF6D8; continue 'dispatch;
	}
	// 82EBF658: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBF65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF660: 3BCBAEA0  addi r30, r11, -0x5160
	ctx.r[30].s64 = ctx.r[11].s64 + -20832;
	// 82EBF664: 482FC9FD  bl 0x831bc060
	ctx.lr = 0x82EBF668;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBF668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF66C: 4BDED4E5  bl 0x82cacb50
	ctx.lr = 0x82EBF670;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBF670: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBF674: 40820064  bne 0x82ebf6d8
	if !ctx.cr[0].eq {
	pc = 0x82EBF6D8; continue 'dispatch;
	}
	// 82EBF678: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF67C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF680: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF684: 4182000C  beq 0x82ebf690
	if ctx.cr[0].eq {
	pc = 0x82EBF690; continue 'dispatch;
	}
	// 82EBF688: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBF68C: 4800000C  b 0x82ebf698
	pc = 0x82EBF698; continue 'dispatch;
	// 82EBF690: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF694: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBF698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF69C: 4BA4E66D  bl 0x8290dd08
	ctx.lr = 0x82EBF6A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBF6A0: 4BDEC511  bl 0x82cabbb0
	ctx.lr = 0x82EBF6A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EBF6A4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBF6A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF6AC: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF6B0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF6B4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBF6B8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBF6BC: 40990008  ble cr6, 0x82ebf6c4
	if !ctx.cr[6].gt {
	pc = 0x82EBF6C4; continue 'dispatch;
	}
	// 82EBF6C0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBF6C4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBF6C8: 409AFFF0  bne cr6, 0x82ebf6b8
	if !ctx.cr[6].eq {
	pc = 0x82EBF6B8; continue 'dispatch;
	}
	// 82EBF6CC: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBF6D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBF6D4: 48000078  b 0x82ebf74c
	pc = 0x82EBF74C; continue 'dispatch;
	// 82EBF6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF6DC: 482FC985  bl 0x831bc060
	ctx.lr = 0x82EBF6E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBF6E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF6E4: 4182005C  beq 0x82ebf740
	if ctx.cr[0].eq {
	pc = 0x82EBF740; continue 'dispatch;
	}
	// 82EBF6E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBF6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF6F0: 3BCBAE90  addi r30, r11, -0x5170
	ctx.r[30].s64 = ctx.r[11].s64 + -20848;
	// 82EBF6F4: 482FC96D  bl 0x831bc060
	ctx.lr = 0x82EBF6F8;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EBF6F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF6FC: 4BDED455  bl 0x82cacb50
	ctx.lr = 0x82EBF700;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EBF700: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBF704: 4082003C  bne 0x82ebf740
	if !ctx.cr[0].eq {
	pc = 0x82EBF740; continue 'dispatch;
	}
	// 82EBF708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF70C: 4BA4E5FD  bl 0x8290dd08
	ctx.lr = 0x82EBF710;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EBF710: 4BDEC4A1  bl 0x82cabbb0
	ctx.lr = 0x82EBF714;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EBF714: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF718: C01D0088  lfs f0, 0x88(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF71C: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBF720: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF724: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBF728: 41980008  blt cr6, 0x82ebf730
	if ctx.cr[6].lt {
	pc = 0x82EBF730; continue 'dispatch;
	}
	// 82EBF72C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EBF730: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBF734: 409AFFF0  bne cr6, 0x82ebf724
	if !ctx.cr[6].eq {
	pc = 0x82EBF724; continue 'dispatch;
	}
	// 82EBF738: D01D0088  stfs f0, 0x88(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EBF73C: 4BFFFF94  b 0x82ebf6d0
	pc = 0x82EBF6D0; continue 'dispatch;
	// 82EBF740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBF744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBF748: 4BFF5CD9  bl 0x82eb5420
	ctx.lr = 0x82EBF74C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5420);
	// 82EBF74C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBF750: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBF754: 4BDE9D08  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EBF758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF758 size=192
	// 82EBF758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBF764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF76C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF770: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF774: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF778: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF77C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF780: 4182000C  beq 0x82ebf78c
	if ctx.cr[0].eq {
	pc = 0x82EBF78C; continue 'dispatch;
	}
	// 82EBF784: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF788: 4800000C  b 0x82ebf794
	pc = 0x82EBF794; continue 'dispatch;
	// 82EBF78C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF790: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF794: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF798: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBF79C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF7A0: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF7A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF7A8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF7AC: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBF7B0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF7B4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF7B8: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EBF7BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF7C0: 4E800421  bctrl
	ctx.lr = 0x82EBF7C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF7C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF7CC: 480048AD  bl 0x82ec4078
	ctx.lr = 0x82EBF7D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC4078);
	// 82EBF7D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBF7D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF7D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF7DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBF7E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF7E4: 4E800020  blr
	return;
	// 82EBF7E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF7EC: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF7F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF7F4: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBF7F8: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBF7FC: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF800: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF804: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EBF808: C00B0C1C  lfs f0, 0xc1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF80C: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EBF810: 4E800020  blr
	return;
}

pub fn sub_82EBF818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF818 size=168
	// 82EBF818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF824: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF82C: 4BFF5B05  bl 0x82eb5330
	ctx.lr = 0x82EBF830;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EBF830: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF834: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EBF838: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 82EBF83C: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EBF840: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EBF844: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF848: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EBF84C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EBF850: 394AAEB0  addi r10, r10, -0x5150
	ctx.r[10].s64 = ctx.r[10].s64 + -20816;
	// 82EBF854: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EBF858: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBF85C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EBF860: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 82EBF864: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBF868: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBF86C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBF870: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBF874: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EBF878: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EBF87C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBF880: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBF884: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82EBF888: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EBF88C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EBF890: 4200FFF8  bdnz 0x82ebf888
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBF888; continue 'dispatch;
	}
	// 82EBF894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF898: 98EB0058  stb r7, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[7].u8 ) };
	// 82EBF89C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBF8A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF8A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF8A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF8AC: 4E800020  blr
	return;
	// 82EBF8B0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBF8B4: 386BD12C  addi r3, r11, -0x2ed4
	ctx.r[3].s64 = ctx.r[11].s64 + -11988;
	// 82EBF8B8: 4E800020  blr
	return;
}

pub fn sub_82EBF8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBF8C0 size=104
	// 82EBF8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF8C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBF8CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF8D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF8D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBF8D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF8DC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EBF8E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF8E4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EBF8E8: 4BFF5AE1  bl 0x82eb53c8
	ctx.lr = 0x82EBF8EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB53C8);
	// 82EBF8EC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBF8F0: 41820018  beq 0x82ebf908
	if ctx.cr[0].eq {
	pc = 0x82EBF908; continue 'dispatch;
	}
	// 82EBF8F4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBF8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF8FC: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBF900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF904: 4E800421  bctrl
	ctx.lr = 0x82EBF908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF90C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBF910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF918: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBF91C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF920: 4E800020  blr
	return;
}

pub fn sub_82EBF928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBF928 size=88
	// 82EBF928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF92C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF930: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBF934: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF938: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF93C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF940: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82EBF944: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF948: 4B756FE1  bl 0x82616928
	ctx.lr = 0x82EBF94C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBF94C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF950: 41820014  beq 0x82ebf964
	if ctx.cr[0].eq {
	pc = 0x82EBF964; continue 'dispatch;
	}
	// 82EBF954: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBF958: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBF95C: 4BFFFEBD  bl 0x82ebf818
	ctx.lr = 0x82EBF960;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBF818);
	// 82EBF960: 48000008  b 0x82ebf968
	pc = 0x82EBF968; continue 'dispatch;
	// 82EBF964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBF968: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBF96C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF974: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBF978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF97C: 4E800020  blr
	return;
}

pub fn sub_82EBF980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF980 size=1144
	// 82EBF980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF984: 4BDE9A71  bl 0x82ca93f4
	ctx.lr = 0x82EBF988;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93F4);
	// 82EBF988: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82EBF98C: 4BDEE349  bl 0x82cadcd4
	ctx.lr = 0x82EBF990;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCD4);
	// 82EBF990: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF998: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EBF99C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82EBF9A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF9A4: 83CB039C  lwz r30, 0x39c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EBF9A8: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBF9AC: 3BBE0014  addi r29, r30, 0x14
	ctx.r[29].s64 = ctx.r[30].s64 + 20;
	// 82EBF9B0: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBF9B4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBF9B8: 409A000C  bne cr6, 0x82ebf9c4
	if !ctx.cr[6].eq {
	pc = 0x82EBF9C4; continue 'dispatch;
	}
	// 82EBF9BC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EBF9C0: 4800041C  b 0x82ebfddc
	pc = 0x82EBFDDC; continue 'dispatch;
	// 82EBF9C4: 4B3A0FF5  bl 0x822609b8
	ctx.lr = 0x82EBF9C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EBF9C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF9CC: C01F0088  lfs f0, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF9D0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EBF9D4: C17F008C  lfs f11, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF9D8: C183004C  lfs f12, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF9DC: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF9E0: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF9E4: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF9E8: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EBF9EC: 4099000C  ble cr6, 0x82ebf9f8
	if !ctx.cr[6].gt {
	pc = 0x82EBF9F8; continue 'dispatch;
	}
	// 82EBF9F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBF9F4: 48000024  b 0x82ebfa18
	pc = 0x82EBFA18; continue 'dispatch;
	// 82EBF9F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBF9FC: 40990018  ble cr6, 0x82ebfa14
	if !ctx.cr[6].gt {
	pc = 0x82EBFA14; continue 'dispatch;
	}
	// 82EBFA00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFA04: 896B0410  lbz r11, 0x410(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EBFA08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFA0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFA10: 40820008  bne 0x82ebfa18
	if !ctx.cr[0].eq {
	pc = 0x82EBFA18; continue 'dispatch;
	}
	// 82EBFA14: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFA18: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFA1C: 4082008C  bne 0x82ebfaa8
	if !ctx.cr[0].eq {
	pc = 0x82EBFAA8; continue 'dispatch;
	}
	// 82EBFA20: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA24: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA28: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFA2C: 409A0028  bne cr6, 0x82ebfa54
	if !ctx.cr[6].eq {
	pc = 0x82EBFA54; continue 'dispatch;
	}
	// 82EBFA30: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA34: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA3C: 409A0018  bne cr6, 0x82ebfa54
	if !ctx.cr[6].eq {
	pc = 0x82EBFA54; continue 'dispatch;
	}
	// 82EBFA40: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFA48: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA50: 419A0008  beq cr6, 0x82ebfa58
	if ctx.cr[6].eq {
	pc = 0x82EBFA58; continue 'dispatch;
	}
	// 82EBFA54: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFA58: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFA5C: 4182FF60  beq 0x82ebf9bc
	if ctx.cr[0].eq {
	pc = 0x82EBF9BC; continue 'dispatch;
	}
	// 82EBFA60: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA64: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA68: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFA6C: 409A0028  bne cr6, 0x82ebfa94
	if !ctx.cr[6].eq {
	pc = 0x82EBFA94; continue 'dispatch;
	}
	// 82EBFA70: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA74: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA78: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA7C: 409A0018  bne cr6, 0x82ebfa94
	if !ctx.cr[6].eq {
	pc = 0x82EBFA94; continue 'dispatch;
	}
	// 82EBFA80: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFA88: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA8C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA90: 419A0008  beq cr6, 0x82ebfa98
	if ctx.cr[6].eq {
	pc = 0x82EBFA98; continue 'dispatch;
	}
	// 82EBFA94: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFA98: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFA9C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82EBFAA0: 4082033C  bne 0x82ebfddc
	if !ctx.cr[0].eq {
	pc = 0x82EBFDDC; continue 'dispatch;
	}
	// 82EBFAA4: 4BFFFF18  b 0x82ebf9bc
	pc = 0x82EBF9BC; continue 'dispatch;
	// 82EBFAA8: D19F008C  stfs f12, 0x8c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EBFAAC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAB0: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFAB8: 409A0028  bne cr6, 0x82ebfae0
	if !ctx.cr[6].eq {
	pc = 0x82EBFAE0; continue 'dispatch;
	}
	// 82EBFABC: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAC0: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAC4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFAC8: 409A0018  bne cr6, 0x82ebfae0
	if !ctx.cr[6].eq {
	pc = 0x82EBFAE0; continue 'dispatch;
	}
	// 82EBFACC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAD0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFAD4: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAD8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFADC: 419A0008  beq cr6, 0x82ebfae4
	if ctx.cr[6].eq {
	pc = 0x82EBFAE4; continue 'dispatch;
	}
	// 82EBFAE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFAE4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFAE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFAEC: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBFAF0: 40820044  bne 0x82ebfb34
	if !ctx.cr[0].eq {
	pc = 0x82EBFB34; continue 'dispatch;
	}
	// 82EBFAF4: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAF8: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAFC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFB00: 409A0028  bne cr6, 0x82ebfb28
	if !ctx.cr[6].eq {
	pc = 0x82EBFB28; continue 'dispatch;
	}
	// 82EBFB04: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB08: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB0C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFB10: 409A0018  bne cr6, 0x82ebfb28
	if !ctx.cr[6].eq {
	pc = 0x82EBFB28; continue 'dispatch;
	}
	// 82EBFB14: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB18: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFB1C: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB20: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFB24: 419A0008  beq cr6, 0x82ebfb2c
	if ctx.cr[6].eq {
	pc = 0x82EBFB2C; continue 'dispatch;
	}
	// 82EBFB28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFB2C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFB30: 41820044  beq 0x82ebfb74
	if ctx.cr[0].eq {
	pc = 0x82EBFB74; continue 'dispatch;
	}
	// 82EBFB34: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB38: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EBFB3C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBFB40: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82EBFB44: C0180008  lfs f0, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB48: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EBFB4C: C018000C  lfs f0, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB50: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBFB54: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB58: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBFB5C: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB60: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBFB64: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB68: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBFB6C: D3DF0084  stfs f30, 0x84(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EBFB70: 4BFB0389  bl 0x82e6fef8
	ctx.lr = 0x82EBFB74;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EBFB74: C1BE0004  lfs f13, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB78: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB7C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBFB80: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFB84: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB88: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBFB8C: C17E000C  lfs f11, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFB90: C19D000C  lfs f12, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFB94: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBFB98: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBFB9C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBFBA0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBFBA4: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBFBA8: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 82EBFBAC: 409A001C  bne cr6, 0x82ebfbc8
	if !ctx.cr[6].eq {
	pc = 0x82EBFBC8; continue 'dispatch;
	}
	// 82EBFBB0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EBFBB4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82EBFBB8: 4BFB0341  bl 0x82e6fef8
	ctx.lr = 0x82EBFBBC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EBFBBC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EBFBC0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82EBFBC4: 4800021C  b 0x82ebfde0
	pc = 0x82EBFDE0; continue 'dispatch;
	// 82EBFBC8: C19F000C  lfs f12, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFBCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFBD0: C17F0084  lfs f11, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFBD4: EFEC582A  fadds f31, f12, f11
	ctx.f[31].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EBFBD8: C17D0004  lfs f11, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFBDC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFBE0: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBFBE4: C15D0008  lfs f10, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBFBE8: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFBEC: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFBF0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EBFBF4: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBFBF8: C15E000C  lfs f10, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBFBFC: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82EBFC00: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFC04: ED4D5028  fsubs f10, f13, f10
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBFC08: EDA00332  fmuls f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBFC0C: ED8002F2  fmuls f12, f0, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBFC10: ED6002B2  fmuls f11, f0, f10
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBFC14: 419901C4  bgt cr6, 0x82ebfdd8
	if ctx.cr[6].gt {
	pc = 0x82EBFDD8; continue 'dispatch;
	}
	// 82EBFC18: EC0D07F2  fmuls f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFC1C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFC20: EDAC07F2  fmuls f13, f12, f31
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFC24: C15E0008  lfs f10, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBFC28: ED8B07F2  fmuls f12, f11, f31
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFC2C: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFC30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFC34: EFAB002A  fadds f29, f11, f0
	ctx.f[29].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBFC38: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC3C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBFC40: EF8A682A  fadds f28, f10, f13
	ctx.f[28].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBFC44: EF60602A  fadds f27, f0, f12
	ctx.f[27].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBFC48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFC4C: 4E800421  bctrl
	ctx.lr = 0x82EBFC50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFC50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFC54: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EBFC58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBFC5C: 3B8A9128  addi r28, r10, -0x6ed8
	ctx.r[28].s64 = ctx.r[10].s64 + -28376;
	// 82EBFC60: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82EBFC64: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFC68: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EBFC6C: 83AB0250  lwz r29, 0x250(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBFC70: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EBFC74: 83C70014  lwz r30, 0x14(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBFC78: D3C10054  stfs f30, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBFC7C: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBFC80: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EBFC84: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBFC88: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC8C: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EBFC90: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC94: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EBFC98: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC9C: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EBFCA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EBFCA4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EBFCA8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EBFCAC: 4200FFF8  bdnz 0x82ebfca4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBFCA4; continue 'dispatch;
	}
	// 82EBFCB0: 9B210118  stb r25, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[25].u8 ) };
	// 82EBFCB4: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EBFCB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFCBC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EBFCC0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EBFCC4: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EBFCC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFCCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBFCD0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBFCD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFCD8: 4E800421  bctrl
	ctx.lr = 0x82EBFCDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFCDC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFCE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBFCE4: 3B4B9128  addi r26, r11, -0x6ed8
	ctx.r[26].s64 = ctx.r[11].s64 + -28376;
	// 82EBFCE8: 418200EC  beq 0x82ebfdd4
	if ctx.cr[0].eq {
	pc = 0x82EBFDD4; continue 'dispatch;
	}
	// 82EBFCEC: D3A10064  stfs f29, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EBFCF0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82EBFCF4: D3810068  stfs f28, 0x68(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EBFCF8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EBFCFC: D361006C  stfs f27, 0x6c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EBFD00: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82EBFD04: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EBFD08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EBFD0C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EBFD10: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EBFD14: 4200FFF8  bdnz 0x82ebfd0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBFD0C; continue 'dispatch;
	}
	// 82EBFD18: 9B2100B8  stb r25, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[25].u8 ) };
	// 82EBFD1C: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82EBFD20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFD24: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EBFD28: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EBFD2C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EBFD30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFD34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBFD38: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBFD3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFD40: 4E800421  bctrl
	ctx.lr = 0x82EBFD44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFD44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFD48: 41820088  beq 0x82ebfdd0
	if ctx.cr[0].eq {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFD4C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFD50: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82EBFD54: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EBFD58: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EBFD5C: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EBFD60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFD64: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBFD68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBFD6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFD70: 4E800421  bctrl
	ctx.lr = 0x82EBFD74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFD74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFD78: 41820058  beq 0x82ebfdd0
	if ctx.cr[0].eq {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFD7C: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFD80: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFD84: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBFD88: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFD8C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFD90: 41990040  bgt cr6, 0x82ebfdd0
	if ctx.cr[6].gt {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFD94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFD98: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EBFD9C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EBFDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFDA4: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EBFDA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFDAC: 4E800421  bctrl
	ctx.lr = 0x82EBFDB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFDB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFDB4: 4182001C  beq 0x82ebfdd0
	if ctx.cr[0].eq {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFDB8: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 82EBFDBC: D3AB0004  stfs f29, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EBFDC0: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBFDC4: D36B000C  stfs f27, 0xc(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBFDC8: 9B2B0058  stb r25, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[25].u8 ) };
	// 82EBFDCC: D3FF0084  stfs f31, 0x84(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EBFDD0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82EBFDD4: 934100C0  stw r26, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u32 ) };
	// 82EBFDD8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82EBFDDC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82EBFDE0: 4BFB0119  bl 0x82e6fef8
	ctx.lr = 0x82EBFDE4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EBFDE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBFDE8: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82EBFDEC: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82EBFDF0: 4BDEDF31  bl 0x82cadd20
	ctx.lr = 0x82EBFDF4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADD20);
	// 82EBFDF4: 4BDE9650  b 0x82ca9444
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9444);
	return;
}

pub fn sub_82EBFDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBFDF8 size=88
	// 82EBFDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBFDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBFE00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBFE04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBFE08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBFE0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBFE10: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EBFE14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBFE18: 4B756B11  bl 0x82616928
	ctx.lr = 0x82EBFE1C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EBFE1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFE20: 41820014  beq 0x82ebfe34
	if ctx.cr[0].eq {
	pc = 0x82EBFE34; continue 'dispatch;
	}
	// 82EBFE24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBFE28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBFE2C: 4BFF570D  bl 0x82eb5538
	ctx.lr = 0x82EBFE30;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5538);
	// 82EBFE30: 48000008  b 0x82ebfe38
	pc = 0x82EBFE38; continue 'dispatch;
	// 82EBFE34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBFE38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBFE3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBFE40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBFE44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBFE48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBFE4C: 4E800020  blr
	return;
}

pub fn sub_82EBFE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBFE50 size=16
	// 82EBFE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBFE54: 4BDE95B9  bl 0x82ca940c
	ctx.lr = 0x82EBFE58;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EBFE58: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBFE5C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC0090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0090 size=376
	// 82EC0090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0098: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC009C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC00A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC00A4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC00A8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC00AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC00B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC00B4: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC00B8: C1890C14  lfs f12, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC00BC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC00C0: 4182000C  beq 0x82ec00cc
	if ctx.cr[0].eq {
	pc = 0x82EC00CC; continue 'dispatch;
	}
	// 82EC00C4: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC00C8: 48000008  b 0x82ec00d0
	pc = 0x82EC00D0; continue 'dispatch;
	// 82EC00CC: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 82EC00D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC00D4: C1AA0A54  lfs f13, 0xa54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC00D8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC00DC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC00E0: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC00E4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC00E8: 4182000C  beq 0x82ec00f4
	if ctx.cr[0].eq {
	pc = 0x82EC00F4; continue 'dispatch;
	}
	// 82EC00EC: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC00F0: 48000008  b 0x82ec00f8
	pc = 0x82EC00F8; continue 'dispatch;
	// 82EC00F4: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 82EC00F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC00FC: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC0100: C00A0A7C  lfs f0, 0xa7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0104: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0108: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC010C: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0110: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0114: 41820008  beq 0x82ec011c
	if ctx.cr[0].eq {
	pc = 0x82EC011C; continue 'dispatch;
	}
	// 82EC0118: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC011C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC0120: 388A1BA0  addi r4, r10, 0x1ba0
	ctx.r[4].s64 = ctx.r[10].s64 + 7072;
	// 82EC0124: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC0128: C00A0A9C  lfs f0, 0xa9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2716 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC012C: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0130: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC0134: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0138: 4B3A7AE9  bl 0x82267c20
	ctx.lr = 0x82EC013C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EC013C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC0140: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0148: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC014C: 48003F2D  bl 0x82ec4078
	ctx.lr = 0x82EC0150;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC4078);
	// 82EC0150: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC015C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC0160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC0164: 4E800020  blr
	return;
	// 82EC0168: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC016C: C1A40004  lfs f13, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0170: C00B02DC  lfs f0, 0x2dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0174: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC0178: 409A0028  bne cr6, 0x82ec01a0
	if !ctx.cr[6].eq {
	pc = 0x82EC01A0; continue 'dispatch;
	}
	// 82EC017C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0180: C1AB02E0  lfs f13, 0x2e0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(736 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0184: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC0188: 409A0018  bne cr6, 0x82ec01a0
	if !ctx.cr[6].eq {
	pc = 0x82EC01A0; continue 'dispatch;
	}
	// 82EC018C: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0190: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC0194: C1AB02E4  lfs f13, 0x2e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(740 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0198: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC019C: 419A0008  beq cr6, 0x82ec01a4
	if ctx.cr[6].eq {
	pc = 0x82EC01A4; continue 'dispatch;
	}
	// 82EC01A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC01A4: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC01A8: 4182000C  beq 0x82ec01b4
	if ctx.cr[0].eq {
	pc = 0x82EC01B4; continue 'dispatch;
	}
	// 82EC01AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC01B0: 4E800020  blr
	return;
	// 82EC01B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC01B8: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC01BC: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC01C0: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC01C4: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC01C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC01CC: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC01D0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC01D4: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC01D8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC01DC: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC01E0: EDA96028  fsubs f13, f9, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC01E4: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC01E8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC01EC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC01F0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC01F4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC01F8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC01FC: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 82EC0200: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0204: 4E800020  blr
	return;
}

pub fn sub_82EC0208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0208 size=20
	// 82EC0208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC020C: 4BDE91F5  bl 0x82ca9400
	ctx.lr = 0x82EC0210;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EC0210: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EC0214: 4BDEDAB5  bl 0x82cadcc8
	ctx.lr = 0x82EC0218;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCC8);
	// 82EC0218: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC0648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0648 size=20
	// 82EC0648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC064C: 4BDE8DB9  bl 0x82ca9404
	ctx.lr = 0x82EC0650;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC0650: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82EC0654: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82EC0658: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC0848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0848 size=20
	// 82EC0848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC084C: 4BDE8BB9  bl 0x82ca9404
	ctx.lr = 0x82EC0850;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC0850: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EC0854: 4BDED481  bl 0x82cadcd4
	ctx.lr = 0x82EC0858;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCD4);
	// 82EC0858: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC0B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0B38 size=88
	// 82EC0B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0B3C: 4BDE88D1  bl 0x82ca940c
	ctx.lr = 0x82EC0B40;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC0B40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0B44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0B48: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EC0B4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0B50: 4B755DD9  bl 0x82616928
	ctx.lr = 0x82EC0B54;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC0B54: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0B58: 41820028  beq 0x82ec0b80
	if ctx.cr[0].eq {
	pc = 0x82EC0B80; continue 'dispatch;
	}
	// 82EC0B5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0B60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0B68: 4BFF47C9  bl 0x82eb5330
	ctx.lr = 0x82EC0B6C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC0B6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0B74: 396BAF44  addi r11, r11, -0x50bc
	ctx.r[11].s64 = ctx.r[11].s64 + -20668;
	// 82EC0B78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0B7C: 48000008  b 0x82ec0b84
	pc = 0x82EC0B84; continue 'dispatch;
	// 82EC0B80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0B84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0B88: 4BDE88D4  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC0B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0B90 size=56
	// 82EC0B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0B98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0B9C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82EC0BA0: 4BFAF359  bl 0x82e6fef8
	ctx.lr = 0x82EC0BA4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EC0BA4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC0BA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC0BAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0BB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC0BB4: 4E800020  blr
	return;
	// 82EC0BB8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC0BBC: 386BD47C  addi r3, r11, -0x2b84
	ctx.r[3].s64 = ctx.r[11].s64 + -11140;
	// 82EC0BC0: 4E800020  blr
	return;
}

pub fn sub_82EC0BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0BC8 size=88
	// 82EC0BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0BCC: 4BDE8841  bl 0x82ca940c
	ctx.lr = 0x82EC0BD0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC0BD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0BD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0BD8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EC0BDC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0BE0: 4B755D49  bl 0x82616928
	ctx.lr = 0x82EC0BE4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC0BE4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0BE8: 41820028  beq 0x82ec0c10
	if ctx.cr[0].eq {
	pc = 0x82EC0C10; continue 'dispatch;
	}
	// 82EC0BEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0BF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0BF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0BF8: 4BFF4739  bl 0x82eb5330
	ctx.lr = 0x82EC0BFC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC0BFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0C04: 396BAF7C  addi r11, r11, -0x5084
	ctx.r[11].s64 = ctx.r[11].s64 + -20612;
	// 82EC0C08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0C0C: 48000008  b 0x82ec0c14
	pc = 0x82EC0C14; continue 'dispatch;
	// 82EC0C10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0C14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0C18: 4BDE8844  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC0C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0C20 size=264
	// 82EC0C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0C28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0C2C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC0C30: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC0C34: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EC0C38: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0C3C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC0C40: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82EC0C44: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0C48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC0C4C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0C50: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0C54: 409A000C  bne cr6, 0x82ec0c60
	if !ctx.cr[6].eq {
	pc = 0x82EC0C60; continue 'dispatch;
	}
	// 82EC0C58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0C5C: 48000020  b 0x82ec0c7c
	pc = 0x82EC0C7C; continue 'dispatch;
	// 82EC0C60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC0C64: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0C68: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EC0C6C: C00A0C4C  lfs f0, 0xc4c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0C70: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0C74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0C78: 4E800421  bctrl
	ctx.lr = 0x82EC0C7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0C7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC0C80: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC0C84: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC0C88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC0C8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0C90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC0C94: 4E800020  blr
	return;
	// 82EC0C98: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EC0C9C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EC0CA0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC0CA4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EC0CA8: 816AD478  lwz r11, -0x2b88(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11144 as u32) ) } as u64;
	// 82EC0CAC: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC0CB0: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EC0CB4: 3909D46C  addi r8, r9, -0x2b94
	ctx.r[8].s64 = ctx.r[9].s64 + -11156;
	// 82EC0CB8: 40820020  bne 0x82ec0cd8
	if !ctx.cr[0].eq {
	pc = 0x82EC0CD8; continue 'dispatch;
	}
	// 82EC0CBC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EC0CC0: 916AD478  stw r11, -0x2b88(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-11144 as u32), ctx.r[11].u32 ) };
	// 82EC0CC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0CC8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0CCC: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC0CD0: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC0CD4: D0080008  stfs f0, 8(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC0CD8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC0CDC: 394BDAC0  addi r10, r11, -0x2540
	ctx.r[10].s64 = ctx.r[11].s64 + -9536;
	// 82EC0CE0: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC0CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC0CE8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC0CEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0CF0: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0CF4: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC0CF8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EC0CFC: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0D00: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0D04: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0D08: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0D0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC0D10: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82EC0D14: 4E800020  blr
	return;
	// 82EC0D18: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC0D1C: 386BB38C  addi r3, r11, -0x4c74
	ctx.r[3].s64 = ctx.r[11].s64 + -19572;
	// 82EC0D20: 4E800020  blr
	return;
}

pub fn sub_82EC0D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0D28 size=96
	// 82EC0D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0D2C: 4BDE86E1  bl 0x82ca940c
	ctx.lr = 0x82EC0D30;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC0D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0D34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0D38: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC0D3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0D40: 4B755BE9  bl 0x82616928
	ctx.lr = 0x82EC0D44;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC0D44: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0D48: 41820030  beq 0x82ec0d78
	if ctx.cr[0].eq {
	pc = 0x82EC0D78; continue 'dispatch;
	}
	// 82EC0D4C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0D50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0D58: 4BFF45D9  bl 0x82eb5330
	ctx.lr = 0x82EC0D5C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC0D5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0D60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC0D64: 396BA890  addi r11, r11, -0x5770
	ctx.r[11].s64 = ctx.r[11].s64 + -22384;
	// 82EC0D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0D6C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EC0D70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0D74: 48000008  b 0x82ec0d7c
	pc = 0x82EC0D7C; continue 'dispatch;
	// 82EC0D78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0D80: 4BDE86DC  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC0D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0D88 size=96
	// 82EC0D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC0D94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC0D9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0DA0: 396BA890  addi r11, r11, -0x5770
	ctx.r[11].s64 = ctx.r[11].s64 + -22384;
	// 82EC0DA4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0DA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0DAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0DB0: 41820018  beq 0x82ec0dc8
	if ctx.cr[0].eq {
	pc = 0x82EC0DC8; continue 'dispatch;
	}
	// 82EC0DB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0DB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC0DBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0DC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0DC4: 4E800421  bctrl
	ctx.lr = 0x82EC0DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0DCC: 4BFF45FD  bl 0x82eb53c8
	ctx.lr = 0x82EC0DD0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB53C8);
	// 82EC0DD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC0DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC0DDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC0DE0: 4E800020  blr
	return;
}

pub fn sub_82EC0DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0DE8 size=360
	// 82EC0DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0DEC: 4BDE8615  bl 0x82ca9400
	ctx.lr = 0x82EC0DF0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EC0DF0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EC0DF4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0DF8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC0DFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC0E00: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0E04: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EC0E08: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0E0C: 834B0048  lwz r26, 0x48(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0E10: 281A0000  cmplwi r26, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E14: 41820100  beq 0x82ec0f14
	if ctx.cr[0].eq {
	pc = 0x82EC0F14; continue 'dispatch;
	}
	// 82EC0E18: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0E1C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E20: 418200F4  beq 0x82ec0f14
	if ctx.cr[0].eq {
	pc = 0x82EC0F14; continue 'dispatch;
	}
	// 82EC0E24: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC0E28: 813C000C  lwz r9, 0xc(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0E2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC0E30: 3BEBB38C  addi r31, r11, -0x4c74
	ctx.r[31].s64 = ctx.r[11].s64 + -19572;
	// 82EC0E34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0E38: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EC0E3C: 4BFC88A5  bl 0x82e896e0
	ctx.lr = 0x82EC0E40;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EC0E40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0E48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EC0E4C: 4BFC8895  bl 0x82e896e0
	ctx.lr = 0x82EC0E50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EC0E50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC0E54: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E58: 419A0014  beq cr6, 0x82ec0e6c
	if ctx.cr[6].eq {
	pc = 0x82EC0E6C; continue 'dispatch;
	}
	// 82EC0E5C: 897E001C  lbz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC0E60: 38FE0004  addi r7, r30, 4
	ctx.r[7].s64 = ctx.r[30].s64 + 4;
	// 82EC0E64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E68: 40820008  bne 0x82ec0e70
	if !ctx.cr[0].eq {
	pc = 0x82EC0E70; continue 'dispatch;
	}
	// 82EC0E6C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82EC0E70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E74: 419A0014  beq cr6, 0x82ec0e88
	if ctx.cr[6].eq {
	pc = 0x82EC0E88; continue 'dispatch;
	}
	// 82EC0E78: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC0E7C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82EC0E80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E84: 40820008  bne 0x82ec0e8c
	if !ctx.cr[0].eq {
	pc = 0x82EC0E8C; continue 'dispatch;
	}
	// 82EC0E88: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82EC0E8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0E90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EC0E94: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EC0E98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E9C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EC0EA0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EC0EA4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC0EA8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC0EAC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EC0EB0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EC0EB4: 409A0044  bne cr6, 0x82ec0ef8
	if !ctx.cr[6].eq {
	pc = 0x82EC0EF8; continue 'dispatch;
	}
	// 82EC0EB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC0EBC: 807A0048  lwz r3, 0x48(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0EC0: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82EC0EC4: 4822D935  bl 0x830ee7f8
	ctx.lr = 0x82EC0EC8;
	crate::recompiler::externs::call(&mut ctx, base, 0x830EE7F8);
	// 82EC0EC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC0ECC: 40820028  bne 0x82ec0ef4
	if !ctx.cr[0].eq {
	pc = 0x82EC0EF4; continue 'dispatch;
	}
	// 82EC0ED0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0ED4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC0ED8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC0EDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC0EE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC0EE4: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0EEC: 4E800421  bctrl
	ctx.lr = 0x82EC0EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0EF0: 48000028  b 0x82ec0f18
	pc = 0x82EC0F18; continue 'dispatch;
	// 82EC0EF4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC0EF8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82EC0EFC: 807A0048  lwz r3, 0x48(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0F00: 38BB0004  addi r5, r27, 4
	ctx.r[5].s64 = ctx.r[27].s64 + 4;
	// 82EC0F04: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC0F08: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82EC0F0C: 4822E445  bl 0x830ef350
	ctx.lr = 0x82EC0F10;
	crate::recompiler::externs::call(&mut ctx, base, 0x830EF350);
	// 82EC0F10: 48000008  b 0x82ec0f18
	pc = 0x82EC0F18; continue 'dispatch;
	// 82EC0F14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0F18: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC0F1C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EC0F20: 4BDE8530  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
}

pub fn sub_82EC0F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0F50 size=552
	// 82EC0F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0F54: 4BDE8495  bl 0x82ca93e8
	ctx.lr = 0x82EC0F58;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93E8);
	// 82EC0F58: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82EC0F5C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0F60: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EC0F64: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC0F68: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC0F6C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82EC0F70: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 82EC0F74: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0F78: 828B0048  lwz r20, 0x48(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0F7C: 28140000  cmplwi r20, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0F80: 418201B8  beq 0x82ec1138
	if ctx.cr[0].eq {
	pc = 0x82EC1138; continue 'dispatch;
	}
	// 82EC0F84: 81540048  lwz r10, 0x48(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0F88: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0F8C: 418201AC  beq 0x82ec1138
	if ctx.cr[0].eq {
	pc = 0x82EC1138; continue 'dispatch;
	}
	// 82EC0F90: 8139000C  lwz r9, 0xc(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0F94: 3BBA0004  addi r29, r26, 4
	ctx.r[29].s64 = ctx.r[26].s64 + 4;
	// 82EC0F98: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC0F9C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82EC0FA0: 3B6BB38C  addi r27, r11, -0x4c74
	ctx.r[27].s64 = ctx.r[11].s64 + -19572;
	// 82EC0FA4: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0FA8: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EC0FAC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC0FB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC0FB4: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0FB8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC0FBC: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0FC0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC0FC4: 4BFC871D  bl 0x82e896e0
	ctx.lr = 0x82EC0FC8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EC0FC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC0FCC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC0FD0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC0FD4: 4BFC870D  bl 0x82e896e0
	ctx.lr = 0x82EC0FD8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EC0FD8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC0FDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC0FE0: 419A0014  beq cr6, 0x82ec0ff4
	if ctx.cr[6].eq {
	pc = 0x82EC0FF4; continue 'dispatch;
	}
	// 82EC0FE4: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC0FE8: 3B1F0004  addi r24, r31, 4
	ctx.r[24].s64 = ctx.r[31].s64 + 4;
	// 82EC0FEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0FF0: 40820008  bne 0x82ec0ff8
	if !ctx.cr[0].eq {
	pc = 0x82EC0FF8; continue 'dispatch;
	}
	// 82EC0FF4: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 82EC0FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC0FFC: 419A0014  beq cr6, 0x82ec1010
	if ctx.cr[6].eq {
	pc = 0x82EC1010; continue 'dispatch;
	}
	// 82EC1000: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC1004: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82EC1008: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC100C: 40820008  bne 0x82ec1014
	if !ctx.cr[0].eq {
	pc = 0x82EC1014; continue 'dispatch;
	}
	// 82EC1010: 7FD7F378  mr r23, r30
	ctx.r[23].u64 = ctx.r[30].u64;
	// 82EC1014: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1018: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82EC101C: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 82EC1020: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82EC1024: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82EC1028: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 82EC102C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82EC1030: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 82EC1034: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82EC1038: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 82EC103C: 409A0048  bne cr6, 0x82ec1084
	if !ctx.cr[6].eq {
	pc = 0x82EC1084; continue 'dispatch;
	}
	// 82EC1040: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82EC1044: 80740048  lwz r3, 0x48(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC1048: 38960004  addi r4, r22, 4
	ctx.r[4].s64 = ctx.r[22].s64 + 4;
	// 82EC104C: 4822D7AD  bl 0x830ee7f8
	ctx.lr = 0x82EC1050;
	crate::recompiler::externs::call(&mut ctx, base, 0x830EE7F8);
	// 82EC1050: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1054: 4082002C  bne 0x82ec1080
	if !ctx.cr[0].eq {
	pc = 0x82EC1080; continue 'dispatch;
	}
	// 82EC1058: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC105C: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 82EC1060: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC1064: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EC1068: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EC106C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EC1070: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC1074: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1078: 4E800421  bctrl
	ctx.lr = 0x82EC107C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC107C: 480000EC  b 0x82ec1168
	pc = 0x82EC1168; continue 'dispatch;
	// 82EC1080: 3B010090  addi r24, r1, 0x90
	ctx.r[24].s64 = ctx.r[1].s64 + 144;
	// 82EC1084: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82EC1088: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC108C: 4BFC8655  bl 0x82e896e0
	ctx.lr = 0x82EC1090;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EC1090: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82EC1094: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82EC1098: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 82EC109C: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82EC10A0: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82EC10A4: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82EC10A8: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82EC10AC: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EC10B0: 40820008  bne 0x82ec10b8
	if !ctx.cr[0].eq {
	pc = 0x82EC10B8; continue 'dispatch;
	}
	// 82EC10B4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82EC10B8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EC10BC: 80740048  lwz r3, 0x48(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC10C0: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82EC10C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC10C8: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 82EC10CC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82EC10D0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EC10D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC10D8: 38960004  addi r4, r22, 4
	ctx.r[4].s64 = ctx.r[22].s64 + 4;
	// 82EC10DC: 4822DC75  bl 0x830eed50
	ctx.lr = 0x82EC10E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x830EED50);
	// 82EC10E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC10E4: 419A0034  beq cr6, 0x82ec1118
	if ctx.cr[6].eq {
	pc = 0x82EC1118; continue 'dispatch;
	}
	// 82EC10E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC10EC: 997B001C  stb r11, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC10F0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EC10F4: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC10F8: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC10FC: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC1100: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC1104: 917B0014  stw r11, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EC1108: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EC110C: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC1110: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EC1114: 917B0018  stw r11, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC1118: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC111C: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1120: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1124: D0150004  stfs f0, 4(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC1128: D1B50008  stfs f13, 8(r21)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC112C: D195000C  stfs f12, 0xc(r21)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1130: 9BD50058  stb r30, 0x58(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EC1134: 48000034  b 0x82ec1168
	pc = 0x82EC1168; continue 'dispatch;
	// 82EC1138: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC113C: 39750010  addi r11, r21, 0x10
	ctx.r[11].s64 = ctx.r[21].s64 + 16;
	// 82EC1140: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EC1144: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC1148: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC114C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC1150: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC1154: 4200FFF8  bdnz 0x82ec114c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC114C; continue 'dispatch;
	}
	// 82EC1158: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EC115C: 9BD50058  stb r30, 0x58(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EC1160: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82EC1164: 4BFAED95  bl 0x82e6fef8
	ctx.lr = 0x82EC1168;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EC1168: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EC116C: CBE1FF90  lfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82EC1170: 4BDE82C8  b 0x82ca9438
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9438);
	return;
}

pub fn sub_82EC1178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1178 size=88
	// 82EC1178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC117C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1180: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1184: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1188: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC118C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1190: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC1194: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC1198: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC119C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC11A0: 41820014  beq 0x82ec11b4
	if ctx.cr[0].eq {
	pc = 0x82EC11B4; continue 'dispatch;
	}
	// 82EC11A4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC11A8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC11AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC11B0: 4E800421  bctrl
	ctx.lr = 0x82EC11B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC11B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC11B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC11BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC11C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC11C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC11C8: 4E800020  blr
	return;
}

pub fn sub_82EC11D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC11D0 size=608
	// 82EC11D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC11D4: 4BDE8229  bl 0x82ca93fc
	ctx.lr = 0x82EC11D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93FC);
	// 82EC11D8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82EC11DC: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC11E0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EC11E4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC11E8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC11EC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EC11F0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EC11F4: 388BB38C  addi r4, r11, -0x4c74
	ctx.r[4].s64 = ctx.r[11].s64 + -19572;
	// 82EC11F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EC11FC: 4BFC84E5  bl 0x82e896e0
	ctx.lr = 0x82EC1200;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EC1200: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EC1204: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1208: 41820014  beq 0x82ec121c
	if ctx.cr[0].eq {
	pc = 0x82EC121C; continue 'dispatch;
	}
	// 82EC120C: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC1210: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 82EC1214: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1218: 40820008  bne 0x82ec1220
	if !ctx.cr[0].eq {
	pc = 0x82EC1220; continue 'dispatch;
	}
	// 82EC121C: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82EC1220: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1224: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1228: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 82EC122C: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82EC1230: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82EC1234: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 82EC1238: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC123C: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82EC1240: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC1244: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1248: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82EC124C: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EC1250: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EC1254: 83AA0048  lwz r29, 0x48(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC1258: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC125C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1260: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82EC1264: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC1268: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82EC126C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1270: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82EC1274: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC1278: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82EC127C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EC1280: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EC1284: 409A0028  bne cr6, 0x82ec12ac
	if !ctx.cr[6].eq {
	pc = 0x82EC12AC; continue 'dispatch;
	}
	// 82EC1288: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82EC128C: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC1290: 38990004  addi r4, r25, 4
	ctx.r[4].s64 = ctx.r[25].s64 + 4;
	// 82EC1294: 4822D565  bl 0x830ee7f8
	ctx.lr = 0x82EC1298;
	crate::recompiler::externs::call(&mut ctx, base, 0x830EE7F8);
	// 82EC1298: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC129C: 4082000C  bne 0x82ec12a8
	if !ctx.cr[0].eq {
	pc = 0x82EC12A8; continue 'dispatch;
	}
	// 82EC12A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC12A4: 4800017C  b 0x82ec1420
	pc = 0x82EC1420; continue 'dispatch;
	// 82EC12A8: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 82EC12AC: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82EC12B0: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC12B4: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82EC12B8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC12BC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC12C0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EC12C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC12C8: 38990004  addi r4, r25, 4
	ctx.r[4].s64 = ctx.r[25].s64 + 4;
	// 82EC12CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC12D0: 4822DA81  bl 0x830eed50
	ctx.lr = 0x82EC12D4;
	crate::recompiler::externs::call(&mut ctx, base, 0x830EED50);
	// 82EC12D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC12D8: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC12DC: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 82EC12E0: 3BCB9128  addi r30, r11, -0x6ed8
	ctx.r[30].s64 = ctx.r[11].s64 + -28376;
	// 82EC12E4: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EC12E8: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC12EC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82EC12F0: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EC12F4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC12F8: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC12FC: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EC1300: 93C100D0  stw r30, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 82EC1304: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1308: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC130C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC1310: 4200FFF8  bdnz 0x82ec1308
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC1308; continue 'dispatch;
	}
	// 82EC1314: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC1318: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC131C: 9BE10128  stb r31, 0x128(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[31].u8 ) };
	// 82EC1320: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82EC1324: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC1328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC132C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1330: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1334: 409A000C  bne cr6, 0x82ec1340
	if !ctx.cr[6].eq {
	pc = 0x82EC1340; continue 'dispatch;
	}
	// 82EC1338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC133C: 48000028  b 0x82ec1364
	pc = 0x82EC1364; continue 'dispatch;
	// 82EC1340: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC1344: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC1348: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82EC134C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82EC1350: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC1354: C00A0C4C  lfs f0, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1358: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC135C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1360: 4E800421  bctrl
	ctx.lr = 0x82EC1364;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1364: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC1368: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC136C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC1370: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82EC1374: 4082FF2C  bne 0x82ec12a0
	if !ctx.cr[0].eq {
	pc = 0x82EC12A0; continue 'dispatch;
	}
	// 82EC1378: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC137C: 39610140  addi r11, r1, 0x140
	ctx.r[11].s64 = ctx.r[1].s64 + 320;
	// 82EC1380: D0010134  stfs f0, 0x134(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82EC1384: 93C10130  stw r30, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 82EC1388: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC138C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82EC1390: D0010138  stfs f0, 0x138(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82EC1394: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC1398: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC139C: D001013C  stfs f0, 0x13c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82EC13A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC13A4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC13A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC13AC: 4200FFF8  bdnz 0x82ec13a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC13A4; continue 'dispatch;
	}
	// 82EC13B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC13B4: 9BE10188  stb r31, 0x188(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[31].u8 ) };
	// 82EC13B8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EC13BC: 938100B4  stw r28, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	// 82EC13C0: 396BAFB8  addi r11, r11, -0x5048
	ctx.r[11].s64 = ctx.r[11].s64 + -20552;
	// 82EC13C4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82EC13C8: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EC13CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC13D0: 996100CC  stb r11, 0xcc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u8 ) };
	// 82EC13D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EC13D8: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EC13DC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC13E0: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82EC13E4: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC13E8: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EC13EC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EC13F0: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EC13F4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EC13F8: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EC13FC: 4B2ED2AD  bl 0x821ae6a8
	ctx.lr = 0x82EC1400;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EC1400: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1404: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC1408: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EC140C: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82EC1410: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EC1414: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC141C: 4E800421  bctrl
	ctx.lr = 0x82EC1420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1420: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 82EC1424: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EC1428: 4BDE8024  b 0x82ca944c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA944C);
	return;
}

pub fn sub_82EC1430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1430 size=120
	// 82EC1430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC143C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1444: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1448: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC144C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1450: 41820030  beq 0x82ec1480
	if ctx.cr[0].eq {
	pc = 0x82EC1480; continue 'dispatch;
	}
	// 82EC1454: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC1458: 48000020  b 0x82ec1478
	pc = 0x82EC1478; continue 'dispatch;
	// 82EC145C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC1464: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1468: 4BDEB6E9  bl 0x82cacb50
	ctx.lr = 0x82EC146C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC146C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1470: 4182002C  beq 0x82ec149c
	if ctx.cr[0].eq {
	pc = 0x82EC149C; continue 'dispatch;
	}
	// 82EC1474: 83FF000C  lwz r31, 0xc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC1478: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC147C: 4082FFE0  bne 0x82ec145c
	if !ctx.cr[0].eq {
	pc = 0x82EC145C; continue 'dispatch;
	}
	// 82EC1480: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1484: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC148C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1490: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1498: 4E800020  blr
	return;
	// 82EC149C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC14A0: 4BFFFFE4  b 0x82ec1484
	pc = 0x82EC1484; continue 'dispatch;
}

pub fn sub_82EC14A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC14A8 size=208
	// 82EC14A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC14AC: 4BDE7F61  bl 0x82ca940c
	ctx.lr = 0x82EC14B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC14B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC14B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC14B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC14BC: 4BFF3F65  bl 0x82eb5420
	ctx.lr = 0x82EC14C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5420);
	// 82EC14C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC14C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC14C8: 409A000C  bne cr6, 0x82ec14d4
	if !ctx.cr[6].eq {
	pc = 0x82EC14D4; continue 'dispatch;
	}
	// 82EC14CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC14D0: 480000A0  b 0x82ec1570
	pc = 0x82EC1570; continue 'dispatch;
	// 82EC14D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC14D8: 482FAB89  bl 0x831bc060
	ctx.lr = 0x82EC14DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC14DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC14E0: 4182008C  beq 0x82ec156c
	if ctx.cr[0].eq {
	pc = 0x82EC156C; continue 'dispatch;
	}
	// 82EC14E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EC14E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC14EC: 3BEB2304  addi r31, r11, 0x2304
	ctx.r[31].s64 = ctx.r[11].s64 + 8964;
	// 82EC14F0: 482FAB71  bl 0x831bc060
	ctx.lr = 0x82EC14F4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC14F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC14F8: 4BDEB659  bl 0x82cacb50
	ctx.lr = 0x82EC14FC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC14FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1500: 4082006C  bne 0x82ec156c
	if !ctx.cr[0].eq {
	pc = 0x82EC156C; continue 'dispatch;
	}
	// 82EC1504: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC1508: 388BBA88  addi r4, r11, -0x4578
	ctx.r[4].s64 = ctx.r[11].s64 + -17784;
	// 82EC150C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1510: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1514: 4B3A670D  bl 0x82267c20
	ctx.lr = 0x82EC1518;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EC1518: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC151C: 4182FFB0  beq 0x82ec14cc
	if ctx.cr[0].eq {
	pc = 0x82EC14CC; continue 'dispatch;
	}
	// 82EC1520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC1524: 4BA4C7E5  bl 0x8290dd08
	ctx.lr = 0x82EC1528;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC1528: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC152C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1530: 4BFFFF01  bl 0x82ec1430
	ctx.lr = 0x82EC1534;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC1430);
	// 82EC1534: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EC1538: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC153C: 4182FF90  beq 0x82ec14cc
	if ctx.cr[0].eq {
	pc = 0x82EC14CC; continue 'dispatch;
	}
	// 82EC1540: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1544: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC1548: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EC154C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EC1550: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC1554: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC1558: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EC155C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC1560: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC1564: 4BFBE60D  bl 0x82e7fb70
	ctx.lr = 0x82EC1568;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FB70);
	// 82EC1568: 4BFFFF64  b 0x82ec14cc
	pc = 0x82EC14CC; continue 'dispatch;
	// 82EC156C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1570: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC1574: 4BDE7EE8  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC1578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1578 size=200
	// 82EC1578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC157C: 4BDE7E85  bl 0x82ca9400
	ctx.lr = 0x82EC1580;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EC1580: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1584: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1588: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EC158C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EC1590: 419A009C  beq cr6, 0x82ec162c
	if ctx.cr[6].eq {
	pc = 0x82EC162C; continue 'dispatch;
	}
	// 82EC1594: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC1598: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC159C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC15A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC15A4: 40990088  ble cr6, 0x82ec162c
	if !ctx.cr[6].gt {
	pc = 0x82EC162C; continue 'dispatch;
	}
	// 82EC15A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EC15AC: 3B6B2304  addi r27, r11, 0x2304
	ctx.r[27].s64 = ctx.r[11].s64 + 8964;
	// 82EC15B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC15B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC15B8: 4BFC2A71  bl 0x82e84028
	ctx.lr = 0x82EC15BC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E84028);
	// 82EC15BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC15C0: 41820030  beq 0x82ec15f0
	if ctx.cr[0].eq {
	pc = 0x82EC15F0; continue 'dispatch;
	}
	// 82EC15C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC15C8: 482FAA99  bl 0x831bc060
	ctx.lr = 0x82EC15CC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC15CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC15D0: 41820020  beq 0x82ec15f0
	if ctx.cr[0].eq {
	pc = 0x82EC15F0; continue 'dispatch;
	}
	// 82EC15D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC15D8: 482FAA89  bl 0x831bc060
	ctx.lr = 0x82EC15DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC15DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC15E0: 4BDEB571  bl 0x82cacb50
	ctx.lr = 0x82EC15E4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC15E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC15E8: 40820008  bne 0x82ec15f0
	if !ctx.cr[0].eq {
	pc = 0x82EC15F0; continue 'dispatch;
	}
	// 82EC15EC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EC15F0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC15F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EC15F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC15FC: 4198FFB4  blt cr6, 0x82ec15b0
	if ctx.cr[6].lt {
	pc = 0x82EC15B0; continue 'dispatch;
	}
	// 82EC1600: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EC1604: 419A0028  beq cr6, 0x82ec162c
	if ctx.cr[6].eq {
	pc = 0x82EC162C; continue 'dispatch;
	}
	// 82EC1608: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EC160C: 4B75531D  bl 0x82616928
	ctx.lr = 0x82EC1610;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC1610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1614: 41820010  beq 0x82ec1624
	if ctx.cr[0].eq {
	pc = 0x82EC1624; continue 'dispatch;
	}
	// 82EC1618: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC161C: 4BFCBC15  bl 0x82e8d230
	ctx.lr = 0x82EC1620;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8D230);
	// 82EC1620: 48000008  b 0x82ec1628
	pc = 0x82EC1628; continue 'dispatch;
	// 82EC1624: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1628: 907A000C  stw r3, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82EC162C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1630: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC1634: 48002A45  bl 0x82ec4078
	ctx.lr = 0x82EC1638;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC4078);
	// 82EC1638: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC163C: 4BDE7E14  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
}

pub fn sub_82EC1640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1640 size=88
	// 82EC1640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1644: 4BDE7DC9  bl 0x82ca940c
	ctx.lr = 0x82EC1648;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC1648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC164C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1650: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EC1654: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1658: 4B7552D1  bl 0x82616928
	ctx.lr = 0x82EC165C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC165C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC1660: 41820028  beq 0x82ec1688
	if ctx.cr[0].eq {
	pc = 0x82EC1688; continue 'dispatch;
	}
	// 82EC1664: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC1668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC166C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1670: 4BFF3CC1  bl 0x82eb5330
	ctx.lr = 0x82EC1674;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC1674: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC167C: 396BA834  addi r11, r11, -0x57cc
	ctx.r[11].s64 = ctx.r[11].s64 + -22476;
	// 82EC1680: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC1684: 48000008  b 0x82ec168c
	pc = 0x82EC168C; continue 'dispatch;
	// 82EC1688: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC168C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1690: 4BDE7DCC  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC1698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1698 size=336
	// 82EC1698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC169C: 4BDE7D71  bl 0x82ca940c
	ctx.lr = 0x82EC16A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC16A0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC16A4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC16A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC16AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC16B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC16B4: 482FA9AD  bl 0x831bc060
	ctx.lr = 0x82EC16B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC16B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC16BC: 41820084  beq 0x82ec1740
	if ctx.cr[0].eq {
	pc = 0x82EC1740; continue 'dispatch;
	}
	// 82EC16C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC16C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC16C8: 3BCBAF1C  addi r30, r11, -0x50e4
	ctx.r[30].s64 = ctx.r[11].s64 + -20708;
	// 82EC16CC: 482FA995  bl 0x831bc060
	ctx.lr = 0x82EC16D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC16D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC16D4: 4BDEB47D  bl 0x82cacb50
	ctx.lr = 0x82EC16D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC16D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC16DC: 40820064  bne 0x82ec1740
	if !ctx.cr[0].eq {
	pc = 0x82EC1740; continue 'dispatch;
	}
	// 82EC16E0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC16E4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC16E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC16EC: 4182000C  beq 0x82ec16f8
	if ctx.cr[0].eq {
	pc = 0x82EC16F8; continue 'dispatch;
	}
	// 82EC16F0: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC16F4: 4800000C  b 0x82ec1700
	pc = 0x82EC1700; continue 'dispatch;
	// 82EC16F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC16FC: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1704: 4BA4C605  bl 0x8290dd08
	ctx.lr = 0x82EC1708;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC1708: 4BDEA4A9  bl 0x82cabbb0
	ctx.lr = 0x82EC170C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC170C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1710: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1714: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1718: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC171C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC1720: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC1724: 40990008  ble cr6, 0x82ec172c
	if !ctx.cr[6].gt {
	pc = 0x82EC172C; continue 'dispatch;
	}
	// 82EC1728: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC172C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC1730: 409AFFF0  bne cr6, 0x82ec1720
	if !ctx.cr[6].eq {
	pc = 0x82EC1720; continue 'dispatch;
	}
	// 82EC1734: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1738: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC173C: 4800009C  b 0x82ec17d8
	pc = 0x82EC17D8; continue 'dispatch;
	// 82EC1740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1744: 482FA91D  bl 0x831bc060
	ctx.lr = 0x82EC1748;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC1748: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC174C: 41820080  beq 0x82ec17cc
	if ctx.cr[0].eq {
	pc = 0x82EC17CC; continue 'dispatch;
	}
	// 82EC1750: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1758: 3BCBA628  addi r30, r11, -0x59d8
	ctx.r[30].s64 = ctx.r[11].s64 + -23000;
	// 82EC175C: 482FA905  bl 0x831bc060
	ctx.lr = 0x82EC1760;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC1760: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1764: 4BDEB3ED  bl 0x82cacb50
	ctx.lr = 0x82EC1768;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC1768: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC176C: 40820060  bne 0x82ec17cc
	if !ctx.cr[0].eq {
	pc = 0x82EC17CC; continue 'dispatch;
	}
	// 82EC1770: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1774: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1778: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC177C: 4182000C  beq 0x82ec1788
	if ctx.cr[0].eq {
	pc = 0x82EC1788; continue 'dispatch;
	}
	// 82EC1780: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1784: 4800000C  b 0x82ec1790
	pc = 0x82EC1790; continue 'dispatch;
	// 82EC1788: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC178C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1794: 4BA4C575  bl 0x8290dd08
	ctx.lr = 0x82EC1798;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC1798: 4BDEA419  bl 0x82cabbb0
	ctx.lr = 0x82EC179C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC179C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC17A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC17A4: C01D0010  lfs f0, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC17A8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC17AC: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC17B0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC17B4: 40990008  ble cr6, 0x82ec17bc
	if !ctx.cr[6].gt {
	pc = 0x82EC17BC; continue 'dispatch;
	}
	// 82EC17B8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC17BC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC17C0: 409AFFF0  bne cr6, 0x82ec17b0
	if !ctx.cr[6].eq {
	pc = 0x82EC17B0; continue 'dispatch;
	}
	// 82EC17C4: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC17C8: 4BFFFF70  b 0x82ec1738
	pc = 0x82EC1738; continue 'dispatch;
	// 82EC17CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC17D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC17D4: 4BFF3C4D  bl 0x82eb5420
	ctx.lr = 0x82EC17D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5420);
	// 82EC17D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC17DC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC17E0: 4BDE7C7C  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC17E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC17E8 size=288
	// 82EC17E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC17EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC17F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC17F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC17F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC17FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1800: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC1804: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC1808: 388AC178  addi r4, r10, -0x3e88
	ctx.r[4].s64 = ctx.r[10].s64 + -16008;
	// 82EC180C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC1810: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1814: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1818: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC181C: 4B326E5D  bl 0x821e8678
	ctx.lr = 0x82EC1820;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EC1820: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC1824: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1828: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC182C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EC1830: C16A0BFC  lfs f11, 0xbfc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC1834: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1838: 41820010  beq 0x82ec1848
	if ctx.cr[0].eq {
	pc = 0x82EC1848; continue 'dispatch;
	}
	// 82EC183C: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1840: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC1844: 48000028  b 0x82ec186c
	pc = 0x82EC186C; continue 'dispatch;
	// 82EC1848: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC184C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1850: 4182000C  beq 0x82ec185c
	if ctx.cr[0].eq {
	pc = 0x82EC185C; continue 'dispatch;
	}
	// 82EC1854: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1858: 48000008  b 0x82ec1860
	pc = 0x82EC1860; continue 'dispatch;
	// 82EC185C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EC1860: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82EC1864: C18B5CC4  lfs f12, 0x5cc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(23748 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1868: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC186C: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC1870: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1874: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1878: 41820008  beq 0x82ec1880
	if ctx.cr[0].eq {
	pc = 0x82EC1880; continue 'dispatch;
	}
	// 82EC187C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1880: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1884: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC1888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC188C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1890: 480027E9  bl 0x82ec4078
	ctx.lr = 0x82EC1894;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC4078);
	// 82EC1894: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC189C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC18A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC18A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC18A8: 4E800020  blr
	return;
}

pub fn sub_82EC1908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1908 size=88
	// 82EC1908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC190C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1910: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1914: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1918: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC191C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1920: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC1924: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC1928: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC192C: 41820008  beq 0x82ec1934
	if ctx.cr[0].eq {
	pc = 0x82EC1934; continue 'dispatch;
	}
	// 82EC1930: 4B983E81  bl 0x828457b0
	ctx.lr = 0x82EC1934;
	crate::recompiler::externs::call(&mut ctx, base, 0x828457B0);
	// 82EC1934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1938: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC193C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1948: 4E800020  blr
	return;
}

pub fn sub_82EC1960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1960 size=88
	// 82EC1960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1964: 4BDE7AA9  bl 0x82ca940c
	ctx.lr = 0x82EC1968;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC1968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC196C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1970: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC1974: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1978: 4B754FB1  bl 0x82616928
	ctx.lr = 0x82EC197C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC197C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC1980: 41820028  beq 0x82ec19a8
	if ctx.cr[0].eq {
	pc = 0x82EC19A8; continue 'dispatch;
	}
	// 82EC1984: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC1988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC198C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1990: 4BFF39A1  bl 0x82eb5330
	ctx.lr = 0x82EC1994;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC1994: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC199C: 396BB000  addi r11, r11, -0x5000
	ctx.r[11].s64 = ctx.r[11].s64 + -20480;
	// 82EC19A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC19A4: 48000008  b 0x82ec19ac
	pc = 0x82EC19AC; continue 'dispatch;
	// 82EC19A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC19AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC19B0: 4BDE7AAC  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC19B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC19B8 size=16
	// 82EC19B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC19BC: 4BDE7A51  bl 0x82ca940c
	ctx.lr = 0x82EC19C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC19C0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC19C4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC1B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1B00 size=88
	// 82EC1B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1B04: 4BDE7909  bl 0x82ca940c
	ctx.lr = 0x82EC1B08;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC1B08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1B0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1B10: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EC1B14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1B18: 4B754E11  bl 0x82616928
	ctx.lr = 0x82EC1B1C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC1B1C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC1B20: 41820028  beq 0x82ec1b48
	if ctx.cr[0].eq {
	pc = 0x82EC1B48; continue 'dispatch;
	}
	// 82EC1B24: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC1B28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B30: 4BFF3801  bl 0x82eb5330
	ctx.lr = 0x82EC1B34;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC1B34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B3C: 396BA84C  addi r11, r11, -0x57b4
	ctx.r[11].s64 = ctx.r[11].s64 + -22452;
	// 82EC1B40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC1B44: 48000008  b 0x82ec1b4c
	pc = 0x82EC1B4C; continue 'dispatch;
	// 82EC1B48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1B4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1B50: 4BDE790C  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC1B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1B58 size=272
	// 82EC1B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1B5C: 4BDE78B1  bl 0x82ca940c
	ctx.lr = 0x82EC1B60;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC1B60: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC1B64: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1B68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC1B6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC1B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B74: 482FA4ED  bl 0x831bc060
	ctx.lr = 0x82EC1B78;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC1B78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1B7C: 41820040  beq 0x82ec1bbc
	if ctx.cr[0].eq {
	pc = 0x82EC1BBC; continue 'dispatch;
	}
	// 82EC1B80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B88: 3BCBB050  addi r30, r11, -0x4fb0
	ctx.r[30].s64 = ctx.r[11].s64 + -20400;
	// 82EC1B8C: 482FA4D5  bl 0x831bc060
	ctx.lr = 0x82EC1B90;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC1B90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1B94: 4BDEAFBD  bl 0x82cacb50
	ctx.lr = 0x82EC1B98;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC1B98: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1B9C: 40820020  bne 0x82ec1bbc
	if !ctx.cr[0].eq {
	pc = 0x82EC1BBC; continue 'dispatch;
	}
	// 82EC1BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1BA4: 4BA4C165  bl 0x8290dd08
	ctx.lr = 0x82EC1BA8;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC1BA8: 4BDE8819  bl 0x82caa3c0
	ctx.lr = 0x82EC1BAC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CAA3C0);
	// 82EC1BAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC1BB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1BB4: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC1BB8: 480000A0  b 0x82ec1c58
	pc = 0x82EC1C58; continue 'dispatch;
	// 82EC1BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1BC0: 482FA4A1  bl 0x831bc060
	ctx.lr = 0x82EC1BC4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC1BC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1BC8: 41820084  beq 0x82ec1c4c
	if ctx.cr[0].eq {
	pc = 0x82EC1C4C; continue 'dispatch;
	}
	// 82EC1BCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1BD4: 3BCBB040  addi r30, r11, -0x4fc0
	ctx.r[30].s64 = ctx.r[11].s64 + -20416;
	// 82EC1BD8: 482FA489  bl 0x831bc060
	ctx.lr = 0x82EC1BDC;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC1BDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1BE0: 4BDEAF71  bl 0x82cacb50
	ctx.lr = 0x82EC1BE4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC1BE4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1BE8: 40820064  bne 0x82ec1c4c
	if !ctx.cr[0].eq {
	pc = 0x82EC1C4C; continue 'dispatch;
	}
	// 82EC1BEC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1BF0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1BF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1BF8: 4182000C  beq 0x82ec1c04
	if ctx.cr[0].eq {
	pc = 0x82EC1C04; continue 'dispatch;
	}
	// 82EC1BFC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1C00: 4800000C  b 0x82ec1c0c
	pc = 0x82EC1C0C; continue 'dispatch;
	// 82EC1C04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1C08: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1C10: 4BA4C0F9  bl 0x8290dd08
	ctx.lr = 0x82EC1C14;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC1C14: 4BDE9F9D  bl 0x82cabbb0
	ctx.lr = 0x82EC1C18;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC1C18: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1C1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1C20: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1C24: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1C28: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC1C2C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC1C30: 41980008  blt cr6, 0x82ec1c38
	if ctx.cr[6].lt {
	pc = 0x82EC1C38; continue 'dispatch;
	}
	// 82EC1C34: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC1C38: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC1C3C: 409AFFF0  bne cr6, 0x82ec1c2c
	if !ctx.cr[6].eq {
	pc = 0x82EC1C2C; continue 'dispatch;
	}
	// 82EC1C40: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1C44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1C48: 48000010  b 0x82ec1c58
	pc = 0x82EC1C58; continue 'dispatch;
	// 82EC1C4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC1C50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC1C54: 4BFF37CD  bl 0x82eb5420
	ctx.lr = 0x82EC1C58;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5420);
	// 82EC1C58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC1C5C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC1C60: 4BDE77FC  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC1C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1C68 size=168
	// 82EC1C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1C70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC1C74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1C78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1C7C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EC1C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1C84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC1C88: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC1C8C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1C90: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1C94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1C98: 4182000C  beq 0x82ec1ca4
	if ctx.cr[0].eq {
	pc = 0x82EC1CA4; continue 'dispatch;
	}
	// 82EC1C9C: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1CA0: 4800000C  b 0x82ec1cac
	pc = 0x82EC1CAC; continue 'dispatch;
	// 82EC1CA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1CA8: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1CAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1CB0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1CB8: C00B0AEC  lfs f0, 0xaec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1CBC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC1CC0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1CC4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1CC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1CCC: 4E800421  bctrl
	ctx.lr = 0x82EC1CD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1CD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1CD8: 480023A1  bl 0x82ec4078
	ctx.lr = 0x82EC1CDC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC4078);
	// 82EC1CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1CE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1CF0: 4E800020  blr
	return;
}

pub fn sub_82EC1D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1D10 size=216
	// 82EC1D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1D18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC1D1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1D28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC1D2C: 4B39EC8D  bl 0x822609b8
	ctx.lr = 0x82EC1D30;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EC1D30: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D34: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1D38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC1D3C: 419A0018  beq cr6, 0x82ec1d54
	if ctx.cr[6].eq {
	pc = 0x82EC1D54; continue 'dispatch;
	}
	// 82EC1D40: 4B39EC79  bl 0x822609b8
	ctx.lr = 0x82EC1D44;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EC1D44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC1D48: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D4C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC1D50: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC1D54: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1D58: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC1D5C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC1D60: 4098006C  bge cr6, 0x82ec1dcc
	if !ctx.cr[6].lt {
	pc = 0x82EC1DCC; continue 'dispatch;
	}
	// 82EC1D64: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1D68: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D6C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1D70: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1D74: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1D78: C15E000C  lfs f10, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC1D7C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1D80: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1D84: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D88: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC1D8C: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC1D90: EDAC4828  fsubs f13, f12, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC1D94: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1D98: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC1D9C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1DA0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1DA4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1DA8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC1DAC: 41990020  bgt cr6, 0x82ec1dcc
	if ctx.cr[6].gt {
	pc = 0x82EC1DCC; continue 'dispatch;
	}
	// 82EC1DB0: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 82EC1DB4: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 82EC1DB8: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC1DBC: 816A0054  lwz r11, 0x54(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC1DC0: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC1DC4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC1DC8: 409A0008  bne cr6, 0x82ec1dd0
	if !ctx.cr[6].eq {
	pc = 0x82EC1DD0; continue 'dispatch;
	}
	// 82EC1DCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1DD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1DDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1DE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1DE4: 4E800020  blr
	return;
}

pub fn sub_82EC1DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1DE8 size=320
	// 82EC1DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1DEC: 4BDE7615  bl 0x82ca9400
	ctx.lr = 0x82EC1DF0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9400);
	// 82EC1DF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1DF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1DF8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EC1DFC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC1E00: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82EC1E04: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1E08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1E0C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC1E10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1E14: 4E800421  bctrl
	ctx.lr = 0x82EC1E18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1E18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1E1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1E20: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82EC1E24: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC1E28: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC1E2C: 83EB0250  lwz r31, 0x250(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EC1E30: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EC1E34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1E3C: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1E40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1E44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1E48: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1E4C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC1E50: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC1E54: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC1E58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1E5C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1E60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1E64: 4E800421  bctrl
	ctx.lr = 0x82EC1E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1E68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1E6C: 4082000C  bne 0x82ec1e78
	if !ctx.cr[0].eq {
	pc = 0x82EC1E78; continue 'dispatch;
	}
	// 82EC1E70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1E74: 48000084  b 0x82ec1ef8
	pc = 0x82EC1EF8; continue 'dispatch;
	// 82EC1E78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1E7C: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EC1E80: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EC1E84: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EC1E88: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC1E8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1E90: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1E98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1E9C: 4E800421  bctrl
	ctx.lr = 0x82EC1EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1EA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1EA4: 4182FFCC  beq 0x82ec1e70
	if ctx.cr[0].eq {
	pc = 0x82EC1E70; continue 'dispatch;
	}
	// 82EC1EA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1EAC: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82EC1EB0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EC1EB4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EC1EB8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC1EBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1EC0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1EC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1ECC: 4E800421  bctrl
	ctx.lr = 0x82EC1ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1ED0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1ED4: 4182FF9C  beq 0x82ec1e70
	if ctx.cr[0].eq {
	pc = 0x82EC1E70; continue 'dispatch;
	}
	// 82EC1ED8: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1EDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1EE0: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1EE4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC1EE8: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1EEC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC1EF0: 41990008  bgt cr6, 0x82ec1ef8
	if ctx.cr[6].gt {
	pc = 0x82EC1EF8; continue 'dispatch;
	}
	// 82EC1EF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1EF8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EC1EFC: 4BDE7554  b 0x82ca9450
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9450);
	return;
	// 82EC1F00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1F04: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82EC1F08: 806B0228  lwz r3, 0x228(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EC1F0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1F10: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1F14: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1F18: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1F1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC1F20: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
}

pub fn sub_82EC1F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1F28 size=88
	// 82EC1F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC1F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1F38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1F40: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 82EC1F44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC1F48: 4B7549E1  bl 0x82616928
	ctx.lr = 0x82EC1F4C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC1F4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1F50: 41820014  beq 0x82ec1f64
	if ctx.cr[0].eq {
	pc = 0x82EC1F64; continue 'dispatch;
	}
	// 82EC1F54: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC1F58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC1F5C: 4BFF354D  bl 0x82eb54a8
	ctx.lr = 0x82EC1F60;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB54A8);
	// 82EC1F60: 48000008  b 0x82ec1f68
	pc = 0x82EC1F68; continue 'dispatch;
	// 82EC1F64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1F68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1F74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1F78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1F7C: 4E800020  blr
	return;
}

pub fn sub_82EC1F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1F80 size=168
	// 82EC1F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1F84: 4BDE7489  bl 0x82ca940c
	ctx.lr = 0x82EC1F88;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC1F88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1F8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC1F90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC1F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1F98: 482FA0C9  bl 0x831bc060
	ctx.lr = 0x82EC1F9C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC1F9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1FA0: 41820070  beq 0x82ec2010
	if ctx.cr[0].eq {
	pc = 0x82EC2010; continue 'dispatch;
	}
	// 82EC1FA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1FAC: 3BCBB094  addi r30, r11, -0x4f6c
	ctx.r[30].s64 = ctx.r[11].s64 + -20332;
	// 82EC1FB0: 482FA0B1  bl 0x831bc060
	ctx.lr = 0x82EC1FB4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC1FB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1FB8: 4BDEAB99  bl 0x82cacb50
	ctx.lr = 0x82EC1FBC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC1FBC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1FC0: 40820050  bne 0x82ec2010
	if !ctx.cr[0].eq {
	pc = 0x82EC2010; continue 'dispatch;
	}
	// 82EC1FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1FC8: 4BA4BD41  bl 0x8290dd08
	ctx.lr = 0x82EC1FCC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC1FCC: 4BDE9BE5  bl 0x82cabbb0
	ctx.lr = 0x82EC1FD0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC1FD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC1FD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1FD8: C1BD000C  lfs f13, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1FDC: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1FE0: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC1FE4: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1FE8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC1FEC: 41980010  blt cr6, 0x82ec1ffc
	if ctx.cr[6].lt {
	pc = 0x82EC1FFC; continue 'dispatch;
	}
	// 82EC1FF0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC1FF4: 41990008  bgt cr6, 0x82ec1ffc
	if ctx.cr[6].gt {
	pc = 0x82EC1FFC; continue 'dispatch;
	}
	// 82EC1FF8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EC1FFC: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EC2000: 409AFFE8  bne cr6, 0x82ec1fe8
	if !ctx.cr[6].eq {
	pc = 0x82EC1FE8; continue 'dispatch;
	}
	// 82EC2004: D1BD000C  stfs f13, 0xc(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2008: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC200C: 48000010  b 0x82ec201c
	pc = 0x82EC201C; continue 'dispatch;
	// 82EC2010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC2014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2018: 4BFF3409  bl 0x82eb5420
	ctx.lr = 0x82EC201C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5420);
	// 82EC201C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2020: 4BDE743C  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC2028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2028 size=16
	// 82EC2028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC202C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2030: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2034: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC2170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2170 size=472
	// 82EC2170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC217C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2180: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82EC2184: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EC2188: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC218C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2190: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2194: 897E0400  lbz r11, 0x400(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC2198: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC219C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC21A0: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC21A4: 409A00A8  bne cr6, 0x82ec224c
	if !ctx.cr[6].eq {
	pc = 0x82EC224C; continue 'dispatch;
	}
	// 82EC21A8: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21AC: C1BE0404  lfs f13, 0x404(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC21B0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC21B4: 409A0028  bne cr6, 0x82ec21dc
	if !ctx.cr[6].eq {
	pc = 0x82EC21DC; continue 'dispatch;
	}
	// 82EC21B8: C01E0408  lfs f0, 0x408(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21BC: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC21C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC21C4: 409A0018  bne cr6, 0x82ec21dc
	if !ctx.cr[6].eq {
	pc = 0x82EC21DC; continue 'dispatch;
	}
	// 82EC21C8: C01E040C  lfs f0, 0x40c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC21D0: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC21D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC21D8: 419A0008  beq cr6, 0x82ec21e0
	if ctx.cr[6].eq {
	pc = 0x82EC21E0; continue 'dispatch;
	}
	// 82EC21DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC21E0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC21E4: 41820068  beq 0x82ec224c
	if ctx.cr[0].eq {
	pc = 0x82EC224C; continue 'dispatch;
	}
	// 82EC21E8: C01E0404  lfs f0, 0x404(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21EC: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EC21F0: C01E0408  lfs f0, 0x408(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21F4: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC21F8: C01E040C  lfs f0, 0x40c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21FC: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC2200: D3FF0010  stfs f31, 0x10(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2204: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2208: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC220C: C01E0404  lfs f0, 0x404(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2210: C1BE0408  lfs f13, 0x408(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1032 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2214: C19E040C  lfs f12, 0x40c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1036 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2218: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC221C: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2220: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC2224: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2228: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC222C: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2230: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC2234: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2238: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC223C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2240: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2244: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC2248: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC224C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2250: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2254: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EC2258: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC225C: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2260: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC2264: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2268: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC226C: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2270: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2274: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2278: C17F0034  lfs f11, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC227C: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2280: 419A0020  beq cr6, 0x82ec22a0
	if ctx.cr[6].eq {
	pc = 0x82EC22A0; continue 'dispatch;
	}
	// 82EC2284: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC2288: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC228C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC2290: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC2294: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC2298: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EC229C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC22A0: 4B39E719  bl 0x822609b8
	ctx.lr = 0x82EC22A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EC22A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC22A8: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC22AC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC22B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC22B4: 388AC7F0  addi r4, r10, -0x3810
	ctx.r[4].s64 = ctx.r[10].s64 + -14352;
	// 82EC22B8: C3CB0058  lfs f30, 0x58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC22BC: 4BFBB405  bl 0x82e7d6c0
	ctx.lr = 0x82EC22C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7D6C0);
	// 82EC22C0: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC22C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC22C8: 4182001C  beq 0x82ec22e4
	if ctx.cr[0].eq {
	pc = 0x82EC22E4; continue 'dispatch;
	}
	// 82EC22CC: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC22D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC22D4: 4182000C  beq 0x82ec22e0
	if ctx.cr[0].eq {
	pc = 0x82EC22E0; continue 'dispatch;
	}
	// 82EC22D8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC22DC: 48000008  b 0x82ec22e4
	pc = 0x82EC22E4; continue 'dispatch;
	// 82EC22E0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EC22E4: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC22E8: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC22EC: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC22F0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC22F4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC22F8: D1BF0020  stfs f13, 0x20(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC22FC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2300: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2304: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2308: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC230C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2310: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC2314: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2318: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EC231C: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2320: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EC2324: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC2328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC232C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2330: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC2334: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EC2338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC233C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2340: 4E800020  blr
	return;
}

pub fn sub_82EC2348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2348 size=224
	// 82EC2348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC234C: 4BDE70C1  bl 0x82ca940c
	ctx.lr = 0x82EC2350;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC2350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2354: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2358: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC235C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2360: 4B7545C9  bl 0x82616928
	ctx.lr = 0x82EC2364;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC2364: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2368: 41820028  beq 0x82ec2390
	if ctx.cr[0].eq {
	pc = 0x82EC2390; continue 'dispatch;
	}
	// 82EC236C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC2370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2378: 4BFF2FB9  bl 0x82eb5330
	ctx.lr = 0x82EC237C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC237C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2384: 396BA800  addi r11, r11, -0x5800
	ctx.r[11].s64 = ctx.r[11].s64 + -22528;
	// 82EC2388: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC238C: 48000008  b 0x82ec2394
	pc = 0x82EC2394; continue 'dispatch;
	// 82EC2390: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2394: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2398: 4BDE70C4  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC2428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2428 size=88
	// 82EC2428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC242C: 4BDE6FE1  bl 0x82ca940c
	ctx.lr = 0x82EC2430;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC2430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2434: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2438: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EC243C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2440: 4B7544E9  bl 0x82616928
	ctx.lr = 0x82EC2444;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC2444: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2448: 41820028  beq 0x82ec2470
	if ctx.cr[0].eq {
	pc = 0x82EC2470; continue 'dispatch;
	}
	// 82EC244C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC2450: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2458: 4BFF2ED9  bl 0x82eb5330
	ctx.lr = 0x82EC245C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC245C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2464: 396BB0E8  addi r11, r11, -0x4f18
	ctx.r[11].s64 = ctx.r[11].s64 + -20248;
	// 82EC2468: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC246C: 48000008  b 0x82ec2474
	pc = 0x82EC2474; continue 'dispatch;
	// 82EC2470: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2478: 4BDE6FE4  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC2480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2480 size=16
	// 82EC2480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2484: 4BDE6F89  bl 0x82ca940c
	ctx.lr = 0x82EC2488;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC2488: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC248C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC2540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2540 size=152
	// 82EC2540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC254C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2550: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2558: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC255C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2560: 4182000C  beq 0x82ec256c
	if ctx.cr[0].eq {
	pc = 0x82EC256C; continue 'dispatch;
	}
	// 82EC2564: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2568: 4800000C  b 0x82ec2574
	pc = 0x82EC2574; continue 'dispatch;
	// 82EC256C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2570: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2574: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC257C: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2580: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2584: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2588: 48000299  bl 0x82ec2820
	ctx.lr = 0x82EC258C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC2820);
	// 82EC258C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2590: 4082000C  bne 0x82ec259c
	if !ctx.cr[0].eq {
	pc = 0x82EC259C; continue 'dispatch;
	}
	// 82EC2594: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2598: 4800001C  b 0x82ec25b4
	pc = 0x82EC25B4; continue 'dispatch;
	// 82EC259C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC25A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC25A4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC25A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC25AC: 4E800421  bctrl
	ctx.lr = 0x82EC25B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC25B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC25B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC25B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC25BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC25C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC25C4: 4E800020  blr
	return;
	// 82EC25C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC25CC: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC25D0: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC25D4: 4E800020  blr
	return;
}

pub fn sub_82EC25D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC25D8 size=304
	// 82EC25D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC25DC: 4BDE6E31  bl 0x82ca940c
	ctx.lr = 0x82EC25E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC25E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC25E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC25E8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC25EC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EC25F0: 48000301  bl 0x82ec28f0
	ctx.lr = 0x82EC25F4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC28F0);
	// 82EC25F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC25F8: 4182000C  beq 0x82ec2604
	if ctx.cr[0].eq {
	pc = 0x82EC2604; continue 'dispatch;
	}
	// 82EC25FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2600: 480000F8  b 0x82ec26f8
	pc = 0x82EC26F8; continue 'dispatch;
	// 82EC2604: 4B39E3B5  bl 0x822609b8
	ctx.lr = 0x82EC2608;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EC2608: C1BE0018  lfs f13, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC260C: C003004C  lfs f0, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2610: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC2614: 40990018  ble cr6, 0x82ec262c
	if !ctx.cr[6].gt {
	pc = 0x82EC262C; continue 'dispatch;
	}
	// 82EC2618: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC261C: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2620: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2624: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2628: 480000CC  b 0x82ec26f4
	pc = 0x82EC26F4; continue 'dispatch;
	// 82EC262C: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2630: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2634: C15D0004  lfs f10, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2638: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC263C: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC2640: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2644: C13D0008  lfs f9, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC2648: EDAD4828  fsubs f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC264C: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2650: C15D000C  lfs f10, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2654: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC2658: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC265C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2660: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2664: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC2668: 4098008C  bge cr6, 0x82ec26f4
	if !ctx.cr[6].lt {
	pc = 0x82EC26F4; continue 'dispatch;
	}
	// 82EC266C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2670: 806B023C  lwz r3, 0x23c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EC2674: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2678: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC267C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2680: 4E800421  bctrl
	ctx.lr = 0x82EC2684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2684: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC2688: 396BD244  addi r11, r11, -0x2dbc
	ctx.r[11].s64 = ctx.r[11].s64 + -11708;
	// 82EC268C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC2690: 419A0070  beq cr6, 0x82ec2700
	if ctx.cr[6].eq {
	pc = 0x82EC2700; continue 'dispatch;
	}
	// 82EC2694: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EC2698: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC269C: 4082FFF0  bne 0x82ec268c
	if !ctx.cr[0].eq {
	pc = 0x82EC268C; continue 'dispatch;
	}
	// 82EC26A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC26A4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC26A8: 4182004C  beq 0x82ec26f4
	if ctx.cr[0].eq {
	pc = 0x82EC26F4; continue 'dispatch;
	}
	// 82EC26AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC26B0: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC26B4: C1AB03A8  lfs f13, 0x3a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(936 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC26B8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC26BC: 409A0028  bne cr6, 0x82ec26e4
	if !ctx.cr[6].eq {
	pc = 0x82EC26E4; continue 'dispatch;
	}
	// 82EC26C0: C00B03AC  lfs f0, 0x3ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(940 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC26C4: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC26C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC26CC: 409A0018  bne cr6, 0x82ec26e4
	if !ctx.cr[6].eq {
	pc = 0x82EC26E4; continue 'dispatch;
	}
	// 82EC26D0: C00B03B0  lfs f0, 0x3b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(944 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC26D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC26D8: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC26DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC26E0: 419A0008  beq cr6, 0x82ec26e8
	if ctx.cr[6].eq {
	pc = 0x82EC26E8; continue 'dispatch;
	}
	// 82EC26E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC26E8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC26EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC26F0: 40820008  bne 0x82ec26f8
	if !ctx.cr[0].eq {
	pc = 0x82EC26F8; continue 'dispatch;
	}
	// 82EC26F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC26F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC26FC: 4BDE6D60  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
	// 82EC2700: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC2704: 4BFFFFA0  b 0x82ec26a4
	pc = 0x82EC26A4; continue 'dispatch;
}

pub fn sub_82EC2708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2708 size=88
	// 82EC2708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC270C: 4BDE6D01  bl 0x82ca940c
	ctx.lr = 0x82EC2710;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC2710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2714: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2718: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EC271C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2720: 4B754209  bl 0x82616928
	ctx.lr = 0x82EC2724;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC2724: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2728: 41820028  beq 0x82ec2750
	if ctx.cr[0].eq {
	pc = 0x82EC2750; continue 'dispatch;
	}
	// 82EC272C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC2730: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2738: 4BFF2BF9  bl 0x82eb5330
	ctx.lr = 0x82EC273C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC273C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2744: 396BA7E8  addi r11, r11, -0x5818
	ctx.r[11].s64 = ctx.r[11].s64 + -22552;
	// 82EC2748: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC274C: 48000008  b 0x82ec2754
	pc = 0x82EC2754; continue 'dispatch;
	// 82EC2750: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2758: 4BDE6D04  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2760 size=16
	// 82EC2760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2764: 4BDE6CA9  bl 0x82ca940c
	ctx.lr = 0x82EC2768;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC2768: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC276C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC2820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2820 size=344
	// 82EC2820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC282C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2838: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC283C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC2840: 388AC178  addi r4, r10, -0x3e88
	ctx.r[4].s64 = ctx.r[10].s64 + -16008;
	// 82EC2844: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC2848: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC284C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2850: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC2854: 4B325E25  bl 0x821e8678
	ctx.lr = 0x82EC2858;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EC2858: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC285C: 41820014  beq 0x82ec2870
	if ctx.cr[0].eq {
	pc = 0x82EC2870; continue 'dispatch;
	}
	// 82EC2860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2864: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2868: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC286C: 4800002C  b 0x82ec2898
	pc = 0x82EC2898; continue 'dispatch;
	// 82EC2870: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2874: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2878: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC287C: 4182000C  beq 0x82ec2888
	if ctx.cr[0].eq {
	pc = 0x82EC2888; continue 'dispatch;
	}
	// 82EC2880: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2884: 4800000C  b 0x82ec2890
	pc = 0x82EC2890; continue 'dispatch;
	// 82EC2888: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC288C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2890: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82EC2894: C00B5CC4  lfs f0, 0x5cc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(23748 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC289C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC28A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC28A4: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC28A8: 480017D1  bl 0x82ec4078
	ctx.lr = 0x82EC28AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC4078);
	// 82EC28AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC28B0: 4082000C  bne 0x82ec28bc
	if !ctx.cr[0].eq {
	pc = 0x82EC28BC; continue 'dispatch;
	}
	// 82EC28B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC28B8: 4800001C  b 0x82ec28d4
	pc = 0x82EC28D4; continue 'dispatch;
	// 82EC28BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC28C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC28C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC28C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC28CC: 4E800421  bctrl
	ctx.lr = 0x82EC28D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC28D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC28D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC28D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC28DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC28E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC28E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC28E8: 4E800020  blr
	return;
}

pub fn sub_82EC2978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2978 size=88
	// 82EC2978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC297C: 4BDE6A91  bl 0x82ca940c
	ctx.lr = 0x82EC2980;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC2980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2988: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC298C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2990: 4B753F99  bl 0x82616928
	ctx.lr = 0x82EC2994;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC2994: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2998: 41820028  beq 0x82ec29c0
	if ctx.cr[0].eq {
	pc = 0x82EC29C0; continue 'dispatch;
	}
	// 82EC299C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC29A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC29A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC29A8: 4BFF2989  bl 0x82eb5330
	ctx.lr = 0x82EC29AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC29AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC29B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC29B4: 396BB148  addi r11, r11, -0x4eb8
	ctx.r[11].s64 = ctx.r[11].s64 + -20152;
	// 82EC29B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC29BC: 48000008  b 0x82ec29c4
	pc = 0x82EC29C4; continue 'dispatch;
	// 82EC29C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC29C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC29C8: 4BDE6A94  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC29D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC29D0 size=200
	// 82EC29D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC29D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC29D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC29DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC29E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC29E4: 48001695  bl 0x82ec4078
	ctx.lr = 0x82EC29E8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC4078);
	// 82EC29E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC29EC: 4082000C  bne 0x82ec29f8
	if !ctx.cr[0].eq {
	pc = 0x82EC29F8; continue 'dispatch;
	}
	// 82EC29F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC29F4: 4800001C  b 0x82ec2a10
	pc = 0x82EC2A10; continue 'dispatch;
	// 82EC29F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC29FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2A00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC2A04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2A08: 4E800421  bctrl
	ctx.lr = 0x82EC2A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2A0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2A10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC2A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC2A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2A1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2A20: 4E800020  blr
	return;
}

pub fn sub_82EC2A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2A98 size=152
	// 82EC2A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2AA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2AA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2AA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2AAC: 4BFF2885  bl 0x82eb5330
	ctx.lr = 0x82EC2AB0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC2AB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2AB8: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2ABC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2AC0: 396BB184  addi r11, r11, -0x4e7c
	ctx.r[11].s64 = ctx.r[11].s64 + -20092;
	// 82EC2AC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC2AC8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2ACC: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2AD0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2AD4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2AD8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC2ADC: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2AE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC2AE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC2AE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2AF0: 4E800020  blr
	return;
}

pub fn sub_82EC2B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2B30 size=568
	// 82EC2B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2B34: 4BDE68D1  bl 0x82ca9404
	ctx.lr = 0x82EC2B38;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC2B38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2B3C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC2B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2B44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC2B48: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2B4C: 4BFAD3AD  bl 0x82e6fef8
	ctx.lr = 0x82EC2B50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EC2B50: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC2B54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2B58: 388BB38C  addi r4, r11, -0x4c74
	ctx.r[4].s64 = ctx.r[11].s64 + -19572;
	// 82EC2B5C: 4BFC6B85  bl 0x82e896e0
	ctx.lr = 0x82EC2B60;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E896E0);
	// 82EC2B60: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC2B64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B68: 41820038  beq 0x82ec2ba0
	if ctx.cr[0].eq {
	pc = 0x82EC2BA0; continue 'dispatch;
	}
	// 82EC2B6C: 8943001C  lbz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC2B70: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC2B74: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B78: 40820008  bne 0x82ec2b80
	if !ctx.cr[0].eq {
	pc = 0x82EC2B80; continue 'dispatch;
	}
	// 82EC2B7C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC2B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B84: 419A001C  beq cr6, 0x82ec2ba0
	if ctx.cr[6].eq {
	pc = 0x82EC2BA0; continue 'dispatch;
	}
	// 82EC2B88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B8C: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC2B90: 409A0008  bne cr6, 0x82ec2b98
	if !ctx.cr[6].eq {
	pc = 0x82EC2B98; continue 'dispatch;
	}
	// 82EC2B94: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC2B98: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC2B9C: 48000008  b 0x82ec2ba4
	pc = 0x82EC2BA4; continue 'dispatch;
	// 82EC2BA0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC2BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2BA8: 409A0170  bne cr6, 0x82ec2d18
	if !ctx.cr[6].eq {
	pc = 0x82EC2D18; continue 'dispatch;
	}
	// 82EC2BAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2BB0: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2BB4: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2BB8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2BBC: 419A0098  beq cr6, 0x82ec2c54
	if ctx.cr[6].eq {
	pc = 0x82EC2C54; continue 'dispatch;
	}
	// 82EC2BC0: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2BC4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2BC8: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2BCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2BD0: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2BD4: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2BD8: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2BDC: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC2BE0: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2BE4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2BE8: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2BEC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2BF0: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2BF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2BF8: 4182000C  beq 0x82ec2c04
	if ctx.cr[0].eq {
	pc = 0x82EC2C04; continue 'dispatch;
	}
	// 82EC2BFC: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2C00: 48000008  b 0x82ec2c08
	pc = 0x82EC2C08; continue 'dispatch;
	// 82EC2C04: FD405890  fmr f10, f11
	ctx.f[10].f64 = ctx.f[11].f64;
	// 82EC2C08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2C0C: 41820008  beq 0x82ec2c14
	if ctx.cr[0].eq {
	pc = 0x82EC2C14; continue 'dispatch;
	}
	// 82EC2C10: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2C14: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2C18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2C1C: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC2C20: ED8C033A  fmadds f12, f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2C24: C00B0BE8  lfs f0, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C28: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2C2C: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EC2C30: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2C34: 41990020  bgt cr6, 0x82ec2c54
	if ctx.cr[6].gt {
	pc = 0x82EC2C54; continue 'dispatch;
	}
	// 82EC2C38: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C3C: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC2C40: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C44: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC2C48: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C4C: D01C000C  stfs f0, 0xc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2C50: 4800010C  b 0x82ec2d5c
	pc = 0x82EC2D5C; continue 'dispatch;
	// 82EC2C54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2C58: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2C5C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2C60: 41820100  beq 0x82ec2d60
	if ctx.cr[0].eq {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2C64: 816A0048  lwz r11, 0x48(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2C6C: 419A00F4  beq cr6, 0x82ec2d60
	if ctx.cr[6].eq {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2C70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2C74: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82EC2C78: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82EC2C7C: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82EC2C80: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EC2C84: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82EC2C88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC2C8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2C90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC2C94: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC2C98: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EC2C9C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EC2CA0: 806A0048  lwz r3, 0x48(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2CA4: 4822BB55  bl 0x830ee7f8
	ctx.lr = 0x82EC2CA8;
	crate::recompiler::externs::call(&mut ctx, base, 0x830EE7F8);
	// 82EC2CA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2CAC: 40820054  bne 0x82ec2d00
	if !ctx.cr[0].eq {
	pc = 0x82EC2D00; continue 'dispatch;
	}
	// 82EC2CB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2CB4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC2CB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC2CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2CC0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC2CC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2CC8: 4E800421  bctrl
	ctx.lr = 0x82EC2CCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2CCC: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CD0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2CD4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CD8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2CDC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CE0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2CE4: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CE8: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2CEC: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CF0: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC2CF4: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CF8: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2CFC: 48000064  b 0x82ec2d60
	pc = 0x82EC2D60; continue 'dispatch;
	// 82EC2D00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC2D04: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EC2D08: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC2D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2D10: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC2D14: 419A004C  beq cr6, 0x82ec2d60
	if ctx.cr[6].eq {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2D18: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2D1C: C1BC0008  lfs f13, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2D20: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2D24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2D28: C17C000C  lfs f11, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2D2C: 41980010  blt cr6, 0x82ec2d3c
	if ctx.cr[6].lt {
	pc = 0x82EC2D3C; continue 'dispatch;
	}
	// 82EC2D30: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2D34: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EC2D38: 40990028  ble cr6, 0x82ec2d60
	if !ctx.cr[6].gt {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2D3C: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2D40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2D44: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2D48: D19C0004  stfs f12, 4(r28)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC2D4C: D17C000C  stfs f11, 0xc(r28)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2D50: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2D54: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2D58: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC2D5C: 9B7C0058  stb r27, 0x58(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(88 as u32), ctx.r[27].u8 ) };
	// 82EC2D60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EC2D64: 4BDE66F0  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC2D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2D68 size=712
	// 82EC2D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2D6C: 4BDE6685  bl 0x82ca93f0
	ctx.lr = 0x82EC2D70;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93F0);
	// 82EC2D70: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 82EC2D74: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82EC2D78: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82EC2D7C: 9421FB00  stwu r1, -0x500(r1)
	ea = ctx.r[1].u32.wrapping_add(-1280 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2D80: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EC2D84: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EC2D88: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82EC2D8C: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2D90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2D94: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EC2D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2D9C: 4E800421  bctrl
	ctx.lr = 0x82EC2DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2DA0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EC2DA4: 41820274  beq 0x82ec3018
	if ctx.cr[0].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2DAC: 48010AA5  bl 0x82ed3850
	ctx.lr = 0x82EC2DB0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3850);
	// 82EC2DB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2DB4: 41820264  beq 0x82ec3018
	if ctx.cr[0].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DB8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2DBC: 82EB0048  lwz r23, 0x48(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2DC0: 28170000  cmplwi r23, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2DC4: 41820254  beq 0x82ec3018
	if ctx.cr[0].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DC8: 81570048  lwz r10, 0x48(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2DCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC2DD0: 419A0248  beq cr6, 0x82ec3018
	if ctx.cr[6].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DD4: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC2DD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2DDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC2DE0: 388AC5C8  addi r4, r10, -0x3a38
	ctx.r[4].s64 = ctx.r[10].s64 + -14904;
	// 82EC2DE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2DE8: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC2DEC: C3CA0C18  lfs f30, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC2DF0: 4B325889  bl 0x821e8678
	ctx.lr = 0x82EC2DF4;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EC2DF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2DF8: 41820014  beq 0x82ec2e0c
	if ctx.cr[0].eq {
	pc = 0x82EC2E0C; continue 'dispatch;
	}
	// 82EC2DFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2E00: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2E04: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2E08: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2E0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2E10: 48010851  bl 0x82ed3660
	ctx.lr = 0x82EC2E14;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED3660);
	// 82EC2E14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2E18: C00B0EE0  lfs f0, 0xee0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2E1C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82EC2E20: 409A000C  bne cr6, 0x82ec2e2c
	if !ctx.cr[6].eq {
	pc = 0x82EC2E2C; continue 'dispatch;
	}
	// 82EC2E24: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2E28: C02B0024  lfs f1, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC2E2C: 3BF80004  addi r31, r24, 4
	ctx.r[31].s64 = ctx.r[24].s64 + 4;
	// 82EC2E30: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC2E34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC2E38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC2E3C: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 82EC2E40: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2E44: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 82EC2E48: ED600828  fsubs f11, f0, f1
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC2E4C: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2E50: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EC2E54: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC2E58: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EC2E5C: ED6D0828  fsubs f11, f13, f1
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC2E60: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2E64: EC0D082A  fadds f0, f13, f1
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EC2E68: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EC2E6C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EC2E70: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EC2E74: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EC2E78: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EC2E7C: ED6C0828  fsubs f11, f12, f1
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC2E80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2E84: EC0C082A  fadds f0, f12, f1
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EC2E88: D1610078  stfs f11, 0x78(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EC2E8C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EC2E90: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EC2E94: 480125CD  bl 0x82ed5460
	ctx.lr = 0x82EC2E98;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5460);
	// 82EC2E98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2E9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2EA0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2EA4: C3AA0BEC  lfs f29, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EC2EA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2EAC: 4182000C  beq 0x82ec2eb8
	if ctx.cr[0].eq {
	pc = 0x82EC2EB8; continue 'dispatch;
	}
	// 82EC2EB0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2EB4: 4800000C  b 0x82ec2ec0
	pc = 0x82EC2EC0; continue 'dispatch;
	// 82EC2EB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2EBC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2EC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2EC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC2EC8: C00B0BF8  lfs f0, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2ECC: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2ED0: 419A0148  beq cr6, 0x82ec3018
	if ctx.cr[6].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2ED4: 3B610090  addi r27, r1, 0x90
	ctx.r[27].s64 = ctx.r[1].s64 + 144;
	// 82EC2ED8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EC2EDC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2EE0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC2EE4: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82EC2EE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC2EEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC2EF0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EC2EF4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EC2EF8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EC2EFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EC2F00: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC2F04: 556B003E  slwi r11, r11, 0
	// 82EC2F08: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F0C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC2F10: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82EC2F14: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F18: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC2F1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2F20: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F24: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC2F28: 80770048  lwz r3, 0x48(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2F2C: 4822BE25  bl 0x830eed50
	ctx.lr = 0x82EC2F30;
	crate::recompiler::externs::call(&mut ctx, base, 0x830EED50);
	// 82EC2F30: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2F34: C1410060  lfs f10, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2F38: ED6A6828  fsubs f11, f10, f13
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2F3C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F40: C1210064  lfs f9, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC2F44: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC2F48: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2F4C: C1010068  lfs f8, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC2F50: ED886028  fsubs f12, f8, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2F54: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC2F58: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EC2F5C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2F60: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC2F64: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EC2F68: 41990018  bgt cr6, 0x82ec2f80
	if ctx.cr[6].gt {
	pc = 0x82EC2F80; continue 'dispatch;
	}
	// 82EC2F6C: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC2F70: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F74: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC2F78: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F7C: 48000040  b 0x82ec2fbc
	pc = 0x82EC2FBC; continue 'dispatch;
	// 82EC2F80: ECE0F828  fsubs f7, f0, f31
	ctx.f[7].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EC2F84: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2F88: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2F8C: ED4A6828  fsubs f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2F90: ED296028  fsubs f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2F94: ED085828  fsubs f8, f8, f11
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC2F98: EC070024  fdivs f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC2F9C: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2FA0: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2FA4: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2FA8: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EC2FAC: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC2FB0: ED8C482A  fadds f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EC2FB4: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC2FB8: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2FBC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2FC0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC2FC4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EC2FC8: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EC2FCC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EC2FD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC2FD4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EC2FD8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC2FDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2FE0: 4E800421  bctrl
	ctx.lr = 0x82EC2FE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2FE4: FF01E800  fcmpu cr6, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 82EC2FE8: 40980024  bge cr6, 0x82ec300c
	if !ctx.cr[6].lt {
	pc = 0x82EC300C; continue 'dispatch;
	}
	// 82EC2FEC: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2FF0: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82EC2FF4: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2FF8: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2FFC: D0160004  stfs f0, 4(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC3000: D1B60008  stfs f13, 8(r22)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC3004: D196000C  stfs f12, 0xc(r22)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC3008: 9B960058  stb r28, 0x58(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EC300C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82EC3010: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EC3014: 4082FEC8  bne 0x82ec2edc
	if !ctx.cr[0].eq {
	pc = 0x82EC2EDC; continue 'dispatch;
	}
	// 82EC3018: 38210500  addi r1, r1, 0x500
	ctx.r[1].s64 = ctx.r[1].s64 + 1280;
	// 82EC301C: CBA1FF90  lfd f29, -0x70(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82EC3020: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82EC3024: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82EC3028: 4BDE6418  b 0x82ca9440
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9440);
	return;
}

pub fn sub_82EC3030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3030 size=88
	// 82EC3030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC303C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3048: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82EC304C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC3050: 4B7538D9  bl 0x82616928
	ctx.lr = 0x82EC3054;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC3054: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3058: 41820014  beq 0x82ec306c
	if ctx.cr[0].eq {
	pc = 0x82EC306C; continue 'dispatch;
	}
	// 82EC305C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC3060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC3064: 4BFFFA35  bl 0x82ec2a98
	ctx.lr = 0x82EC3068;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC2A98);
	// 82EC3068: 48000008  b 0x82ec3070
	pc = 0x82EC3070; continue 'dispatch;
	// 82EC306C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC307C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC3080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3084: 4E800020  blr
	return;
}

pub fn sub_82EC3088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3088 size=168
	// 82EC3088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC308C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC3094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC309C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC30A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC30A4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EC30A8: 3BC60004  addi r30, r6, 4
	ctx.r[30].s64 = ctx.r[6].s64 + 4;
	// 82EC30AC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82EC30B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC30B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC30B8: C00A0C4C  lfs f0, 0xc4c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC30BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC30C0: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC30C4: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC30C8: 4B76C449  bl 0x8262f510
	ctx.lr = 0x82EC30CC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8262F510);
	// 82EC30CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC30D0: 41820010  beq 0x82ec30e0
	if ctx.cr[0].eq {
	pc = 0x82EC30E0; continue 'dispatch;
	}
	// 82EC30D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC30D8: C02B0BEC  lfs f1, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC30DC: 48000038  b 0x82ec3114
	pc = 0x82EC3114; continue 'dispatch;
	// 82EC30E0: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC30E4: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC30E8: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC30EC: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC30F0: C15E0004  lfs f10, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC30F4: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC30F8: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC30FC: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3100: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3104: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3108: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC310C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3110: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC311C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC3120: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC3124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3128: 4E800020  blr
	return;
}

pub fn sub_82EC3130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3130 size=88
	// 82EC3130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3134: 4BDE62D9  bl 0x82ca940c
	ctx.lr = 0x82EC3138;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC3138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC313C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC3140: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EC3144: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC3148: 4B7537E1  bl 0x82616928
	ctx.lr = 0x82EC314C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC314C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC3150: 41820028  beq 0x82ec3178
	if ctx.cr[0].eq {
	pc = 0x82EC3178; continue 'dispatch;
	}
	// 82EC3154: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC3158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC315C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3160: 4BFF21D1  bl 0x82eb5330
	ctx.lr = 0x82EC3164;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB5330);
	// 82EC3164: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC316C: 396BA7D0  addi r11, r11, -0x5830
	ctx.r[11].s64 = ctx.r[11].s64 + -22576;
	// 82EC3170: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC3174: 48000008  b 0x82ec317c
	pc = 0x82EC317C; continue 'dispatch;
	// 82EC3178: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC317C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3180: 4BDE62DC  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC3188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3188 size=20
	// 82EC3188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC318C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC3194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC3268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3268 size=616
	// 82EC3268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC326C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC3274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3278: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82EC327C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EC3280: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3284: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC328C: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EC3290: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC3294: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3298: 394BB1E0  addi r10, r11, -0x4e20
	ctx.r[10].s64 = ctx.r[11].s64 + -20000;
	// 82EC329C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC32A0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EC32A4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC32A8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC32AC: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC32B0: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC32B4: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC32B8: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EC32BC: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC32C0: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC32C4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC32C8: D3FF0024  stfs f31, 0x24(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EC32CC: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC32D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC32D4: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC32D8: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC32DC: D3FF0034  stfs f31, 0x34(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EC32E0: D3FF0038  stfs f31, 0x38(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EC32E4: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82EC32E8: D3FF0040  stfs f31, 0x40(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EC32EC: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82EC32F0: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EC32F4: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC32F8: D3FF0050  stfs f31, 0x50(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC32FC: D3FF0054  stfs f31, 0x54(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3300: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC3304: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3308: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC330C: D3FF00C8  stfs f31, 0xc8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC3310: D3FF00CC  stfs f31, 0xcc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC3314: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 82EC3318: D3FF00D4  stfs f31, 0xd4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EC331C: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3320: C3CA0C14  lfs f30, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC3324: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3328: 4182000C  beq 0x82ec3334
	if ctx.cr[0].eq {
	pc = 0x82EC3334; continue 'dispatch;
	}
	// 82EC332C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3330: 48000008  b 0x82ec3338
	pc = 0x82EC3338; continue 'dispatch;
	// 82EC3334: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 82EC3338: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC333C: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EC3340: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC3344: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82EC3348: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC334C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3350: ED4D0032  fmuls f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3354: D15F00D8  stfs f10, 0xd8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EC3358: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC335C: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3360: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3364: D1BF00DC  stfs f13, 0xdc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EC3368: D1BF00EC  stfs f13, 0xec(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EC336C: C18B0BF8  lfs f12, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3374: D19F00E0  stfs f12, 0xe0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EC3378: C16B0EE0  lfs f11, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC337C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3380: D17F00E4  stfs f11, 0xe4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC3384: C14B0A7C  lfs f10, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3388: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC338C: D15F00F0  stfs f10, 0xf0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EC3390: C18BBE10  lfs f12, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3394: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3398: D19F00F4  stfs f12, 0xf4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EC339C: D19F00FC  stfs f12, 0xfc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EC33A0: C00B0B64  lfs f0, 0xb64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC33A4: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EC33A8: 4BDE6609  bl 0x82ca99b0
	ctx.lr = 0x82EC33AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA99B0);
	// 82EC33AC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC33B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC33B4: 418200AC  beq 0x82ec3460
	if ctx.cr[0].eq {
	pc = 0x82EC3460; continue 'dispatch;
	}
	// 82EC33B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC33BC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC33C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC33C4: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC33C8: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC33CC: 4B3252AD  bl 0x821e8678
	ctx.lr = 0x82EC33D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EC33D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC33D4: 41820014  beq 0x82ec33e8
	if ctx.cr[0].eq {
	pc = 0x82EC33E8; continue 'dispatch;
	}
	// 82EC33D8: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC33DC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC33E0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EC33E4: 409A0020  bne cr6, 0x82ec3404
	if !ctx.cr[6].eq {
	pc = 0x82EC3404; continue 'dispatch;
	}
	// 82EC33E8: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC33EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC33F0: 4182000C  beq 0x82ec33fc
	if ctx.cr[0].eq {
	pc = 0x82EC33FC; continue 'dispatch;
	}
	// 82EC33F4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC33F8: 48000008  b 0x82ec3400
	pc = 0x82EC3400; continue 'dispatch;
	// 82EC33FC: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82EC3400: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC3404: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3408: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC340C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC3410: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EC3414: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3418: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC341C: 4B32525D  bl 0x821e8678
	ctx.lr = 0x82EC3420;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EC3420: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3424: 4182000C  beq 0x82ec3430
	if ctx.cr[0].eq {
	pc = 0x82EC3430; continue 'dispatch;
	}
	// 82EC3428: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC342C: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC3430: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3434: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3438: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC343C: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EC3440: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3444: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC3448: 4B325231  bl 0x821e8678
	ctx.lr = 0x82EC344C;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EC344C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3450: 4182002C  beq 0x82ec347c
	if ctx.cr[0].eq {
	pc = 0x82EC347C; continue 'dispatch;
	}
	// 82EC3454: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3458: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC345C: 48000020  b 0x82ec347c
	pc = 0x82EC347C; continue 'dispatch;
	// 82EC3460: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3464: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3468: 4182000C  beq 0x82ec3474
	if ctx.cr[0].eq {
	pc = 0x82EC3474; continue 'dispatch;
	}
	// 82EC346C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3470: 48000008  b 0x82ec3478
	pc = 0x82EC3478; continue 'dispatch;
	// 82EC3474: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82EC3478: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC347C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3480: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3484: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82EC3488: 4B3A4799  bl 0x82267c20
	ctx.lr = 0x82EC348C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82267C20);
	// 82EC348C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC3490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3494: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC3498: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC349C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC34A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC34A4: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC34A8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EC34AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC34B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC34B4: 4E800020  blr
	return;
	// 82EC34B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC34BC: 386BE16C  addi r3, r11, -0x1e94
	ctx.r[3].s64 = ctx.r[11].s64 + -7828;
	// 82EC34C0: 4E800020  blr
	return;
}

pub fn sub_82EC34D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC34D0 size=824
	// 82EC34D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC34D4: 4BDE5F39  bl 0x82ca940c
	ctx.lr = 0x82EC34D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC34D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC34DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC34E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC34E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC34E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC34EC: 3BABAE40  addi r29, r11, -0x51c0
	ctx.r[29].s64 = ctx.r[11].s64 + -20928;
	// 82EC34F0: 482F8B71  bl 0x831bc060
	ctx.lr = 0x82EC34F4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC34F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC34F8: 4BDE9659  bl 0x82cacb50
	ctx.lr = 0x82EC34FC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC34FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3504: 4082001C  bne 0x82ec3520
	if !ctx.cr[0].eq {
	pc = 0x82EC3520; continue 'dispatch;
	}
	// 82EC3508: 4BA4A801  bl 0x8290dd08
	ctx.lr = 0x82EC350C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC350C: 4BDE86A5  bl 0x82cabbb0
	ctx.lr = 0x82EC3510;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC3510: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC3514: D01E00E0  stfs f0, 0xe0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EC3518: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC351C: 48000164  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3520: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3524: 3BABAE30  addi r29, r11, -0x51d0
	ctx.r[29].s64 = ctx.r[11].s64 + -20944;
	// 82EC3528: 482F8B39  bl 0x831bc060
	ctx.lr = 0x82EC352C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC352C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3530: 4BDE9621  bl 0x82cacb50
	ctx.lr = 0x82EC3534;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC3534: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC353C: 4082001C  bne 0x82ec3558
	if !ctx.cr[0].eq {
	pc = 0x82EC3558; continue 'dispatch;
	}
	// 82EC3540: 4BA4A7C9  bl 0x8290dd08
	ctx.lr = 0x82EC3544;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC3544: 4BDE866D  bl 0x82cabbb0
	ctx.lr = 0x82EC3548;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC3548: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC354C: D01E00DC  stfs f0, 0xdc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EC3550: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3554: 4800012C  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3558: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC355C: 3BABAE20  addi r29, r11, -0x51e0
	ctx.r[29].s64 = ctx.r[11].s64 + -20960;
	// 82EC3560: 482F8B01  bl 0x831bc060
	ctx.lr = 0x82EC3564;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC3564: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3568: 4BDE95E9  bl 0x82cacb50
	ctx.lr = 0x82EC356C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC356C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3574: 4082001C  bne 0x82ec3590
	if !ctx.cr[0].eq {
	pc = 0x82EC3590; continue 'dispatch;
	}
	// 82EC3578: 4BA4A791  bl 0x8290dd08
	ctx.lr = 0x82EC357C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC357C: 4BDE8635  bl 0x82cabbb0
	ctx.lr = 0x82EC3580;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC3580: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC3584: D01E00E4  stfs f0, 0xe4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC3588: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC358C: 480000F4  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3590: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3594: 3BABAE10  addi r29, r11, -0x51f0
	ctx.r[29].s64 = ctx.r[11].s64 + -20976;
	// 82EC3598: 482F8AC9  bl 0x831bc060
	ctx.lr = 0x82EC359C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC359C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC35A0: 4BDE95B1  bl 0x82cacb50
	ctx.lr = 0x82EC35A4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC35A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC35A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC35AC: 4082001C  bne 0x82ec35c8
	if !ctx.cr[0].eq {
	pc = 0x82EC35C8; continue 'dispatch;
	}
	// 82EC35B0: 4BA4A759  bl 0x8290dd08
	ctx.lr = 0x82EC35B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC35B4: 4BDE85FD  bl 0x82cabbb0
	ctx.lr = 0x82EC35B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC35B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC35BC: D01E00E8  stfs f0, 0xe8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC35C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC35C4: 480000BC  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC35C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC35CC: 3BABAE00  addi r29, r11, -0x5200
	ctx.r[29].s64 = ctx.r[11].s64 + -20992;
	// 82EC35D0: 482F8A91  bl 0x831bc060
	ctx.lr = 0x82EC35D4;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC35D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC35D8: 4BDE9579  bl 0x82cacb50
	ctx.lr = 0x82EC35DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC35DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC35E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC35E4: 4082001C  bne 0x82ec3600
	if !ctx.cr[0].eq {
	pc = 0x82EC3600; continue 'dispatch;
	}
	// 82EC35E8: 4BA4A721  bl 0x8290dd08
	ctx.lr = 0x82EC35EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC35EC: 4BDE85C5  bl 0x82cabbb0
	ctx.lr = 0x82EC35F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC35F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC35F4: D01E00EC  stfs f0, 0xec(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EC35F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC35FC: 48000084  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3600: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3604: 3BABADEC  addi r29, r11, -0x5214
	ctx.r[29].s64 = ctx.r[11].s64 + -21012;
	// 82EC3608: 482F8A59  bl 0x831bc060
	ctx.lr = 0x82EC360C;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC360C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3610: 4BDE9541  bl 0x82cacb50
	ctx.lr = 0x82EC3614;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC3614: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC361C: 4082001C  bne 0x82ec3638
	if !ctx.cr[0].eq {
	pc = 0x82EC3638; continue 'dispatch;
	}
	// 82EC3620: 4BA4A6E9  bl 0x8290dd08
	ctx.lr = 0x82EC3624;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC3624: 4BDE858D  bl 0x82cabbb0
	ctx.lr = 0x82EC3628;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC3628: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC362C: D01E00F0  stfs f0, 0xf0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EC3630: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3634: 4800004C  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC3638: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC363C: 3BABADD4  addi r29, r11, -0x522c
	ctx.r[29].s64 = ctx.r[11].s64 + -21036;
	// 82EC3640: 482F8A21  bl 0x831bc060
	ctx.lr = 0x82EC3644;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC3644: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3648: 4BDE9509  bl 0x82cacb50
	ctx.lr = 0x82EC364C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC364C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3650: 4082002C  bne 0x82ec367c
	if !ctx.cr[0].eq {
	pc = 0x82EC367C; continue 'dispatch;
	}
	// 82EC3654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3658: 4BA4A6B1  bl 0x8290dd08
	ctx.lr = 0x82EC365C;
	crate::recompiler::externs::call(&mut ctx, base, 0x8290DD08);
	// 82EC365C: 4BDE8555  bl 0x82cabbb0
	ctx.lr = 0x82EC3660;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CABBB0);
	// 82EC3660: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC3664: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3668: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC366C: D01E00F4  stfs f0, 0xf4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EC3670: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3674: D01E00D8  stfs f0, 0xd8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EC3678: 48000008  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
	// 82EC367C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3684: 4BDE5DD8  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
	// 82EC3688: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC368C: C0E60000  lfs f7, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3690: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3694: C1450004  lfs f10, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3698: ECCA02B2  fmuls f6, f10, f10
	ctx.f[6].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC369C: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC36A0: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC36A4: C10B0A98  lfs f8, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC36A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC36AC: ED070232  fmuls f8, f7, f8
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EC36B0: C1250008  lfs f9, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC36B4: ECED0372  fmuls f7, f13, f13
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC36B8: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC36BC: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC36C0: ED40383A  fmadds f10, f0, f0, f7
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EC36C4: ECEB32FA  fmadds f7, f11, f11, f6
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[6].f64) as f32) as f64);
	// 82EC36C8: EC0B683A  fmadds f0, f11, f0, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC36CC: EDAC533A  fmadds f13, f12, f12, f10
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC36D0: ED693A7A  fmadds f11, f9, f9, f7
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EC36D4: EC09033A  fmadds f0, f9, f12, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC36D8: ED485A3C  fnmsubs f10, f8, f8, f11
	ctx.f[10].f64 = -(((ctx.f[8].f64 * ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC36DC: C16B0C4C  lfs f11, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC36E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC36E4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC36E8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC36EC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC36F0: 409A0024  bne cr6, 0x82ec3714
	if !ctx.cr[6].eq {
	pc = 0x82EC3714; continue 'dispatch;
	}
	// 82EC36F4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC36F8: 409A000C  bne cr6, 0x82ec3704
	if !ctx.cr[6].eq {
	pc = 0x82EC3704; continue 'dispatch;
	}
	// 82EC36FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3700: 4E800020  blr
	return;
	// 82EC3704: EC0A0024  fdivs f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3708: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC370C: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC3710: 48000040  b 0x82ec3750
	pc = 0x82EC3750; continue 'dispatch;
	// 82EC3714: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3718: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC371C: C14B0A4C  lfs f10, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3720: ED4902B2  fmuls f10, f9, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3724: ED405038  fmsubs f10, f0, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3728: FF0A6000  fcmpu cr6, f10, f12
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[12].f64);
	// 82EC372C: 4198FFD0  blt cr6, 0x82ec36fc
	if ctx.cr[6].lt {
	pc = 0x82EC36FC; continue 'dispatch;
	}
	// 82EC3730: ED80502C  fsqrts f12, f10
	ctx.f[12].f64 = ((ctx.f[10].f64).sqrt() as f32) as f64;
	// 82EC3734: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3738: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC373C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3740: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3744: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EC3748: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC374C: EC0C6824  fdivs f0, f12, f13
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EC3750: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC3754: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3758: 4E800020  blr
	return;
}

pub fn sub_82EC3808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3808 size=72
	// 82EC3808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC380C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3814: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC381C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82EC3820: 4B753109  bl 0x82616928
	ctx.lr = 0x82EC3824;
	crate::recompiler::externs::call(&mut ctx, base, 0x82616928);
	// 82EC3824: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3828: 41820010  beq 0x82ec3838
	if ctx.cr[0].eq {
	pc = 0x82EC3838; continue 'dispatch;
	}
	// 82EC382C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC3830: 4BFFFA39  bl 0x82ec3268
	ctx.lr = 0x82EC3834;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC3268);
	// 82EC3834: 48000008  b 0x82ec383c
	pc = 0x82EC383C; continue 'dispatch;
	// 82EC3838: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC383C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC3840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC3848: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC384C: 4E800020  blr
	return;
}

pub fn sub_82EC3850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3850 size=712
	// 82EC3850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3854: 4BDE5BB9  bl 0x82ca940c
	ctx.lr = 0x82EC3858;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC3858: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EC385C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC3860: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3864: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3868: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC386C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3870: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC3874: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC3878: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC387C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC3880: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3884: 4182000C  beq 0x82ec3890
	if ctx.cr[0].eq {
	pc = 0x82EC3890; continue 'dispatch;
	}
	// 82EC3888: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC388C: 48000008  b 0x82ec3894
	pc = 0x82EC3894; continue 'dispatch;
	// 82EC3890: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82EC3894: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3898: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC389C: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC38A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC38A4: 4B324DD5  bl 0x821e8678
	ctx.lr = 0x82EC38A8;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EC38A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC38AC: 41820008  beq 0x82ec38b4
	if ctx.cr[0].eq {
	pc = 0x82EC38B4; continue 'dispatch;
	}
	// 82EC38B0: C3C30004  lfs f30, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC38B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC38B8: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC38BC: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC38C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC38C4: C19E003C  lfs f12, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC38C8: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC38CC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC38D0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC38D4: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC38D8: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC38DC: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC38E0: C14A0C18  lfs f10, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC38E4: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC38E8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC38EC: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC38F0: ED20002C  fsqrts f9, f0
	ctx.f[9].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC38F4: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 82EC38F8: 40990018  ble cr6, 0x82ec3910
	if !ctx.cr[6].gt {
	pc = 0x82EC3910; continue 'dispatch;
	}
	// 82EC38FC: EC1F4824  fdivs f0, f31, f9
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[9].f64) as f32) as f64;
	// 82EC3900: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3904: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3908: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC390C: 48000010  b 0x82ec391c
	pc = 0x82EC391C; continue 'dispatch;
	// 82EC3910: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 82EC3914: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EC3918: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 82EC391C: C18B0050  lfs f12, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3920: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3924: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3928: C10B004C  lfs f8, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC392C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC3930: EC0802FA  fmadds f0, f8, f11, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3934: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EC3938: 41990010  bgt cr6, 0x82ec3948
	if ctx.cr[6].gt {
	pc = 0x82EC3948; continue 'dispatch;
	}
	// 82EC393C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3940: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82EC3944: 409801C4  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3948: C00B0058  lfs f0, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC394C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC3950: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3954: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EC3958: C12B004C  lfs f9, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC395C: C17E004C  lfs f11, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3960: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3964: C10B0050  lfs f8, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC3968: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC396C: C15E0050  lfs f10, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3970: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3974: C0FE0054  lfs f7, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3978: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC397C: C06B0054  lfs f3, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EC3980: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3984: EC030032  fmuls f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3988: C0CB0034  lfs f6, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EC398C: C0FE0034  lfs f7, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3990: ECE73028  fsubs f7, f7, f6
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EC3994: C0BE0038  lfs f5, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EC3998: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EC399C: ECC53028  fsubs f6, f5, f6
	ctx.f[6].f64 = (((ctx.f[5].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EC39A0: C18A0A40  lfs f12, 0xa40(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2624 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC39A4: C05E003C  lfs f2, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EC39A8: FC806090  fmr f4, f12
	ctx.f[4].f64 = ctx.f[12].f64;
	// 82EC39AC: ED6B4828  fsubs f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC39B0: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EC39B4: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC39B8: ECA22828  fsubs f5, f2, f5
	ctx.f[5].f64 = (((ctx.f[2].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EC39BC: ED6A4028  fsubs f11, f10, f8
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EC39C0: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC39C4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC39C8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC39CC: 419A0040  beq cr6, 0x82ec3a0c
	if ctx.cr[6].eq {
	pc = 0x82EC3A0C; continue 'dispatch;
	}
	// 82EC39D0: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC39D4: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC39D8: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC39DC: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC39E0: C10B003C  lfs f8, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC39E4: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC39E8: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC39EC: C12B0034  lfs f9, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC39F0: ED695828  fsubs f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC39F4: C14B0058  lfs f10, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC39F8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC39FC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3A00: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3A04: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3A08: EC805024  fdivs f4, f0, f10
	ctx.f[4].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EC3A0C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3A10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3A14: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EC3A18: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EC3A1C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC3A20: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3A24: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EC3A28: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3A2C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EC3A30: D0E10070  stfs f7, 0x70(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC3A34: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3A38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EC3A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3A40: D0C10074  stfs f6, 0x74(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EC3A44: D0A10078  stfs f5, 0x78(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EC3A48: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3A4C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3A50: 4BFFFC39  bl 0x82ec3688
	ctx.lr = 0x82EC3A54;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC3688);
	// 82EC3A54: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3A58: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3A5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3A60: 41980008  blt cr6, 0x82ec3a68
	if ctx.cr[6].lt {
	pc = 0x82EC3A68; continue 'dispatch;
	}
	// 82EC3A64: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EC3A68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC3A6C: 4182009C  beq 0x82ec3b08
	if ctx.cr[0].eq {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A70: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3A74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3A78: 40980090  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A7C: FF002000  fcmpu cr6, f0, f4
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 82EC3A80: 40980088  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A84: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3A88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3A8C: 4099007C  ble cr6, 0x82ec3b08
	if !ctx.cr[6].gt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A90: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EC3A94: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 82EC3A98: 4098001C  bge cr6, 0x82ec3ab4
	if !ctx.cr[6].lt {
	pc = 0x82EC3AB4; continue 'dispatch;
	}
	// 82EC3A9C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EC3AA0: 556B103A  slwi r11, r11, 2
	// 82EC3AA4: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	// 82EC3AA8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EC3AAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC3AB0: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC3AB4: C1BF0058  lfs f13, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3AB8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3ABC: 4098004C  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3AC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC3AC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3AC8: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3ACC: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82EC3AD0: 995F0044  stb r10, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82EC3AD4: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3AD8: C16B0050  lfs f11, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3ADC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3AE0: C14B0054  lfs f10, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3AE4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3AE8: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3AEC: C1AB0058  lfs f13, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3AF0: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3AF4: D19F004C  stfs f12, 0x4c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC3AF8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3AFC: D17F0050  stfs f11, 0x50(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3B00: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3B04: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3B08: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC3B0C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EC3B10: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC3B14: 4BDE5948  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC3B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3B18 size=848
	// 82EC3B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3B20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3B24: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EC3B28: 4BDEA19D  bl 0x82cadcc4
	ctx.lr = 0x82EC3B2C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADCC4);
	// 82EC3B2C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3B30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3B34: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3B38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3B3C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC3B40: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3B44: 4082000C  bne 0x82ec3b50
	if !ctx.cr[0].eq {
	pc = 0x82EC3B50; continue 'dispatch;
	}
	// 82EC3B48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3B4C: 48000300  b 0x82ec3e4c
	pc = 0x82EC3E4C; continue 'dispatch;
	// 82EC3B50: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC3B54: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EC3B58: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3B5C: C3690C18  lfs f27, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EC3B60: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC3B64: FDA0D890  fmr f13, f27
	ctx.f[13].f64 = ctx.f[27].f64;
	// 82EC3B68: FD80D890  fmr f12, f27
	ctx.f[12].f64 = ctx.f[27].f64;
	// 82EC3B6C: FD60D890  fmr f11, f27
	ctx.f[11].f64 = ctx.f[27].f64;
	// 82EC3B70: C3490C14  lfs f26, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EC3B74: 4081006C  ble 0x82ec3be0
	if !ctx.cr[0].gt {
	pc = 0x82EC3BE0; continue 'dispatch;
	}
	// 82EC3B78: C0EB0034  lfs f7, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3B7C: 393F0060  addi r9, r31, 0x60
	ctx.r[9].s64 = ctx.r[31].s64 + 96;
	// 82EC3B80: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EC3B84: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EC3B88: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC3B8C: C128003C  lfs f9, 0x3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC3B90: ED254828  fsubs f9, f5, f9
	ctx.f[9].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC3B94: C0080034  lfs f0, 0x34(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3B98: ED470028  fsubs f10, f7, f0
	ctx.f[10].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3B9C: C0080038  lfs f0, 0x38(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3BA0: ED060028  fsubs f8, f6, f0
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3BA4: EC090272  fmuls f0, f9, f9
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EC3BA8: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BAC: EC08023A  fmadds f0, f8, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BB0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3BB4: 40990020  ble cr6, 0x82ec3bd4
	if !ctx.cr[6].gt {
	pc = 0x82EC3BD4; continue 'dispatch;
	}
	// 82EC3BB8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3BBC: ED4002B2  fmuls f10, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3BC0: ED000232  fmuls f8, f0, f8
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EC3BC4: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EC3BC8: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC3BCC: ED88602A  fadds f12, f8, f12
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC3BD0: ED60582A  fadds f11, f0, f11
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EC3BD4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC3BD8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC3BDC: 4082FFAC  bne 0x82ec3b88
	if !ctx.cr[0].eq {
	pc = 0x82EC3B88; continue 'dispatch;
	}
	// 82EC3BE0: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3BE4: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BE8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BEC: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3BF0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3BF4: 40990018  ble cr6, 0x82ec3c0c
	if !ctx.cr[6].gt {
	pc = 0x82EC3C0C; continue 'dispatch;
	}
	// 82EC3BF8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3BFC: EF200372  fmuls f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3C00: EEE00332  fmuls f23, f0, f12
	ctx.f[23].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3C04: EF0002F2  fmuls f24, f0, f11
	ctx.f[24].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3C08: 48000010  b 0x82ec3c18
	pc = 0x82EC3C18; continue 'dispatch;
	// 82EC3C0C: FF20D890  fmr f25, f27
	ctx.f[25].f64 = ctx.f[27].f64;
	// 82EC3C10: FEE0D890  fmr f23, f27
	ctx.f[23].f64 = ctx.f[27].f64;
	// 82EC3C14: FF00D890  fmr f24, f27
	ctx.f[24].f64 = ctx.f[27].f64;
	// 82EC3C18: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3C1C: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3C20: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3C24: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3C28: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3C2C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC3C30: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3C34: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3C38: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3C3C: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3C40: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3C44: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3C48: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3C4C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3C50: 40990018  ble cr6, 0x82ec3c68
	if !ctx.cr[6].gt {
	pc = 0x82EC3C68; continue 'dispatch;
	}
	// 82EC3C54: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3C58: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3C5C: EFA002F2  fmuls f29, f0, f11
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3C60: EFC00332  fmuls f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3C64: 48000010  b 0x82ec3c74
	pc = 0x82EC3C74; continue 'dispatch;
	// 82EC3C68: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 82EC3C6C: FFA0D890  fmr f29, f27
	ctx.f[29].f64 = ctx.f[27].f64;
	// 82EC3C70: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82EC3C74: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3C78: C39F00DC  lfs f28, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EC3C7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC3C80: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3C84: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EC3C88: 4B3249F1  bl 0x821e8678
	ctx.lr = 0x82EC3C8C;
	crate::recompiler::externs::call(&mut ctx, base, 0x821E8678);
	// 82EC3C8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3C90: 4182010C  beq 0x82ec3d9c
	if ctx.cr[0].eq {
	pc = 0x82EC3D9C; continue 'dispatch;
	}
	// 82EC3C94: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3C98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3C9C: 41820100  beq 0x82ec3d9c
	if ctx.cr[0].eq {
	pc = 0x82EC3D9C; continue 'dispatch;
	}
	// 82EC3CA0: ED9D0672  fmuls f12, f29, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EC3CA4: EC1E05F2  fmuls f0, f30, f23
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[23].f64) as f32) as f64);
	// 82EC3CA8: ED5807F2  fmuls f10, f24, f31
	ctx.f[10].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC3CAC: ED7767F8  fmsubs f11, f23, f31, f12
	ctx.f[11].f64 = (((ctx.f[23].f64 * ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3CB0: EDBD0638  fmsubs f13, f29, f24, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3CB4: ED9E5678  fmsubs f12, f30, f25, f10
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3CB8: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3CBC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3CC0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3CC4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3CC8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3CCC: 409A0074  bne cr6, 0x82ec3d40
	if !ctx.cr[6].eq {
	pc = 0x82EC3D40; continue 'dispatch;
	}
	// 82EC3CD0: FF1FD800  fcmpu cr6, f31, f27
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[27].f64);
	// 82EC3CD4: 409A0018  bne cr6, 0x82ec3cec
	if !ctx.cr[6].eq {
	pc = 0x82EC3CEC; continue 'dispatch;
	}
	// 82EC3CD8: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EC3CDC: 409A0010  bne cr6, 0x82ec3cec
	if !ctx.cr[6].eq {
	pc = 0x82EC3CEC; continue 'dispatch;
	}
	// 82EC3CE0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC3CE4: 396BDBE4  addi r11, r11, -0x241c
	ctx.r[11].s64 = ctx.r[11].s64 + -9244;
	// 82EC3CE8: 4800000C  b 0x82ec3cf4
	pc = 0x82EC3CF4; continue 'dispatch;
	// 82EC3CEC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC3CF0: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EC3CF4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3CF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC3CFC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3D00: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D04: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3D08: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3D0C: ED3D0332  fmuls f9, f29, f12
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3D10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC3D14: EC1D5838  fmsubs f0, f29, f0, f11
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC3D18: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3D1C: EC1E5338  fmsubs f0, f30, f12, f10
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3D20: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3D24: EC1F4B78  fmsubs f0, f31, f13, f9
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC3D28: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3D2C: 4B3BB53D  bl 0x8227f268
	ctx.lr = 0x82EC3D30;
	crate::recompiler::externs::call(&mut ctx, base, 0x8227F268);
	// 82EC3D30: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3D34: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3D38: C1630008  lfs f11, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3D3C: 48000030  b 0x82ec3d6c
	pc = 0x82EC3D6C; continue 'dispatch;
	// 82EC3D40: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3D44: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D48: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3D4C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3D50: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D54: ED2C07F2  fmuls f9, f12, f31
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC3D58: ED400772  fmuls f10, f0, f29
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EC3D5C: ED4C57B8  fmsubs f10, f12, f30, f10
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3D60: ED805FF8  fmsubs f12, f0, f31, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC3D64: ED7D4B78  fmsubs f11, f29, f13, f9
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC3D68: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EC3D6C: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EC3D70: ED5F0732  fmuls f10, f31, f28
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3D74: ED3D0732  fmuls f9, f29, f28
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3D78: ED1E0732  fmuls f8, f30, f28
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3D7C: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D80: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3D84: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3D88: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC3D8C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3D90: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC3D94: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC3D98: 48000084  b 0x82ec3e1c
	pc = 0x82EC3E1C; continue 'dispatch;
	// 82EC3D9C: EC1807F2  fmuls f0, f24, f31
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC3DA0: FDA0D090  fmr f13, f26
	ctx.f[13].f64 = ctx.f[26].f64;
	// 82EC3DA4: EC1E0678  fmsubs f0, f30, f25, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3DA8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3DAC: 4098000C  bge cr6, 0x82ec3db8
	if !ctx.cr[6].lt {
	pc = 0x82EC3DB8; continue 'dispatch;
	}
	// 82EC3DB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3DB4: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3DB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC3DBC: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EC3DC0: ED3F0732  fmuls f9, f31, f28
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3DC4: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EC3DC8: ECFE0732  fmuls f7, f30, f28
	ctx.f[7].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3DCC: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3DD0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3DD4: ED1D02F2  fmuls f8, f29, f11
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3DD8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3DDC: ECDE02B2  fmuls f6, f30, f10
	ctx.f[6].f64 = (((ctx.f[30].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3DE0: ECBF0332  fmuls f5, f31, f12
	ctx.f[5].f64 = (((ctx.f[31].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3DE4: ED9E4338  fmsubs f12, f30, f12, f8
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EC3DE8: ED7F32F8  fmsubs f11, f31, f11, f6
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EC3DEC: ED5D2AB8  fmsubs f10, f29, f10, f5
	ctx.f[10].f64 = (((ctx.f[29].f64 * ctx.f[10].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EC3DF0: ED1D0732  fmuls f8, f29, f28
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3DF4: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3DF8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3DFC: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3E00: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3E04: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3E08: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3E0C: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC3E10: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3E14: EDA8582A  fadds f13, f8, f11
	ctx.f[13].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EC3E18: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC3E1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC3E20: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3E24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC3E28: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3E2C: 4B3BB43D  bl 0x8227f268
	ctx.lr = 0x82EC3E30;
	crate::recompiler::externs::call(&mut ctx, base, 0x8227F268);
	// 82EC3E30: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E34: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC3E38: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E3C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC3E40: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3E48: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC3E4C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC3E50: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EC3E54: 4BDE9EBD  bl 0x82cadd10
	ctx.lr = 0x82EC3E58;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CADD10);
	// 82EC3E58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3E5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC3E60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3E64: 4E800020  blr
	return;
}

pub fn sub_82EC3E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3E68 size=344
	// 82EC3E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3E6C: 4BDE559D  bl 0x82ca9408
	ctx.lr = 0x82EC3E70;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EC3E70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3E74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3E78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC3E7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC3E80: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EC3E84: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC3E88: C00A0A48  lfs f0, 0xa48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2632 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E8C: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3E90: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82EC3E94: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EC3E98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3E9C: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC3EA0: 4182006C  beq 0x82ec3f0c
	if ctx.cr[0].eq {
	pc = 0x82EC3F0C; continue 'dispatch;
	}
	// 82EC3EA4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3EA8: C03F00D8  lfs f1, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC3EAC: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EC3EB0: 4BFC3DF9  bl 0x82e87ca8
	ctx.lr = 0x82EC3EB4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E87CA8);
	// 82EC3EB4: 4800004C  b 0x82ec3f00
	pc = 0x82EC3F00; continue 'dispatch;
	// 82EC3EB8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3EBC: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC3EC0: 419A0038  beq cr6, 0x82ec3ef8
	if ctx.cr[6].eq {
	pc = 0x82EC3EF8; continue 'dispatch;
	}
	// 82EC3EC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3EC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3ECC: 4182001C  beq 0x82ec3ee8
	if ctx.cr[0].eq {
	pc = 0x82EC3EE8; continue 'dispatch;
	}
	// 82EC3ED0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3ED4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC3ED8: 4E800421  bctrl
	ctx.lr = 0x82EC3EDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC3EDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC3EE0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC3EE4: 409A0014  bne cr6, 0x82ec3ef8
	if !ctx.cr[6].eq {
	pc = 0x82EC3EF8; continue 'dispatch;
	}
	// 82EC3EE8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC3EEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3EF4: 4BFFF95D  bl 0x82ec3850
	ctx.lr = 0x82EC3EF8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC3850);
	// 82EC3EF8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC3EFC: 4BFC3875  bl 0x82e87770
	ctx.lr = 0x82EC3F00;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E87770);
	// 82EC3F00: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC3F04: 4082FFB4  bne 0x82ec3eb8
	if !ctx.cr[0].eq {
	pc = 0x82EC3EB8; continue 'dispatch;
	}
	// 82EC3F08: 480000AC  b 0x82ec3fb4
	pc = 0x82EC3FB4; continue 'dispatch;
	// 82EC3F0C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3F10: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3F14: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC3F18: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3F1C: 48000090  b 0x82ec3fac
	pc = 0x82EC3FAC; continue 'dispatch;
	// 82EC3F20: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3F24: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3F28: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC3F2C: 419A007C  beq cr6, 0x82ec3fa8
	if ctx.cr[6].eq {
	pc = 0x82EC3FA8; continue 'dispatch;
	}
	// 82EC3F30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3F34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3F38: 4182001C  beq 0x82ec3f54
	if ctx.cr[0].eq {
	pc = 0x82EC3F54; continue 'dispatch;
	}
	// 82EC3F3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC3F44: 4E800421  bctrl
	ctx.lr = 0x82EC3F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC3F48: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC3F4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC3F50: 409A0058  bne cr6, 0x82ec3fa8
	if !ctx.cr[6].eq {
	pc = 0x82EC3FA8; continue 'dispatch;
	}
	// 82EC3F54: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3F58: C01F00D8  lfs f0, 0xd8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3F5C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3F60: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3F64: C19E0038  lfs f12, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3F68: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3F6C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC3F70: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3F74: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3F78: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3F7C: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3F80: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3F84: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3F88: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3F8C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3F90: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC3F94: 40980014  bge cr6, 0x82ec3fa8
	if !ctx.cr[6].lt {
	pc = 0x82EC3FA8; continue 'dispatch;
	}
	// 82EC3F98: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC3F9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3FA4: 4BFFF8AD  bl 0x82ec3850
	ctx.lr = 0x82EC3FA8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC3850);
	// 82EC3FA8: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3FAC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3FB0: 4082FF70  bne 0x82ec3f20
	if !ctx.cr[0].eq {
	pc = 0x82EC3F20; continue 'dispatch;
	}
	// 82EC3FB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC3FBC: 4BDE549C  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EC3FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3FC0 size=184
	// 82EC3FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3FC4: 4BDE5449  bl 0x82ca940c
	ctx.lr = 0x82EC3FC8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA940C);
	// 82EC3FC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3FD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC3FD4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC3FD8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3FDC: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3FE0: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC3FE4: 4BFFFE85  bl 0x82ec3e68
	ctx.lr = 0x82EC3FE8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC3E68);
	// 82EC3FE8: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC3FEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3FF0: 4182003C  beq 0x82ec402c
	if ctx.cr[0].eq {
	pc = 0x82EC402C; continue 'dispatch;
	}
	// 82EC3FF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3FFC: 4BFFFB1D  bl 0x82ec3b18
	ctx.lr = 0x82EC4000;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC3B18);
	// 82EC4000: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC4004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4008: 4BFFF759  bl 0x82ec3760
	ctx.lr = 0x82EC400C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC3760);
	// 82EC400C: 4B39C9AD  bl 0x822609b8
	ctx.lr = 0x82EC4010;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EC4010: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4014: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4018: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC401C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC4020: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EC4024: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 82EC4028: 48000048  b 0x82ec4070
	pc = 0x82EC4070; continue 'dispatch;
	// 82EC402C: 897F00D0  lbz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EC4030: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC4034: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC4038: 409A002C  bne cr6, 0x82ec4064
	if !ctx.cr[6].eq {
	pc = 0x82EC4064; continue 'dispatch;
	}
	// 82EC403C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4040: 4BFFF721  bl 0x82ec3760
	ctx.lr = 0x82EC4044;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC3760);
	// 82EC4044: 4B39C975  bl 0x822609b8
	ctx.lr = 0x82EC4048;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EC4048: C01F00D4  lfs f0, 0xd4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC404C: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4050: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4054: 4098001C  bge cr6, 0x82ec4070
	if !ctx.cr[6].lt {
	pc = 0x82EC4070; continue 'dispatch;
	}
	// 82EC4058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC405C: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 82EC4060: 48000010  b 0x82ec4070
	pc = 0x82EC4070; continue 'dispatch;
	// 82EC4064: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC4068: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC406C: 4BFF0B35  bl 0x82eb4ba0
	ctx.lr = 0x82EC4070;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EB4BA0);
	// 82EC4070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC4074: 4BDE53E8  b 0x82ca945c
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA945C);
	return;
}

pub fn sub_82EC4078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC4078 size=160
	// 82EC4078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC407C: 4BDE5389  bl 0x82ca9404
	ctx.lr = 0x82EC4080;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC4080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4084: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC4088: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EC408C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EC4090: 419A0070  beq cr6, 0x82ec4100
	if ctx.cr[6].eq {
	pc = 0x82EC4100; continue 'dispatch;
	}
	// 82EC4094: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC4098: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC409C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC40A0: 40990060  ble cr6, 0x82ec4100
	if !ctx.cr[6].gt {
	pc = 0x82EC4100; continue 'dispatch;
	}
	// 82EC40A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC40A8: 3B8B8FD8  addi r28, r11, -0x7028
	ctx.r[28].s64 = ctx.r[11].s64 + -28712;
	// 82EC40AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC40B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC40B4: 4BFBFF75  bl 0x82e84028
	ctx.lr = 0x82EC40B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E84028);
	// 82EC40B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC40BC: 482F7FA5  bl 0x831bc060
	ctx.lr = 0x82EC40C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x831BC060);
	// 82EC40C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC40C4: 4BDE8A8D  bl 0x82cacb50
	ctx.lr = 0x82EC40C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CACB50);
	// 82EC40C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC40CC: 41820024  beq 0x82ec40f0
	if ctx.cr[0].eq {
	pc = 0x82EC40F0; continue 'dispatch;
	}
	// 82EC40D0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC40D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC40D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EC40DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC40E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC40E4: 4E800421  bctrl
	ctx.lr = 0x82EC40E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC40E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC40EC: 41820020  beq 0x82ec410c
	if ctx.cr[0].eq {
	pc = 0x82EC410C; continue 'dispatch;
	}
	// 82EC40F0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC40F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EC40F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC40FC: 4198FFB0  blt cr6, 0x82ec40ac
	if ctx.cr[6].lt {
	pc = 0x82EC40AC; continue 'dispatch;
	}
	// 82EC4100: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4104: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC4108: 4BDE534C  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
	// 82EC410C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4110: 4BFFFFF4  b 0x82ec4104
	pc = 0x82EC4104; continue 'dispatch;
}

pub fn sub_82EC4118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC4118 size=12
	// 82EC4118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC411C: 4BDE52ED  bl 0x82ca9408
	ctx.lr = 0x82EC4120;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EC4120: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
}

pub fn sub_82EC4498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4498 size=176
	// 82EC4498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC449C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC44A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC44A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC44A8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC44AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC44B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC44B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC44B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC44BC: 814BE280  lwz r10, -0x1d80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7552 as u32) ) } as u64;
	// 82EC44C0: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC44C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC44C8: 914BE280  stw r10, -0x1d80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-7552 as u32), ctx.r[10].u32 ) };
	// 82EC44CC: 4BFC780D  bl 0x82e8bcd8
	ctx.lr = 0x82EC44D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E8BCD8);
	// 82EC44D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC44D4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC44D8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC44DC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82EC44E0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC44E4: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC44E8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC44EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC44F0: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC44F4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC44F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC44FC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC4500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4504: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC4508: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC450C: 4200FFF8  bdnz 0x82ec4504
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4504; continue 'dispatch;
	}
	// 82EC4510: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4514: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC4518: 992100A8  stb r9, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[9].u8 ) };
	// 82EC451C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC4520: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC4524: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4528: 4E800421  bctrl
	ctx.lr = 0x82EC452C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC452C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC4530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC4534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC4538: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC453C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC4540: 4E800020  blr
	return;
}

pub fn sub_82EC4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4548 size=816
	// 82EC4548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC454C: 4BDE4EBD  bl 0x82ca9408
	ctx.lr = 0x82EC4550;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EC4550: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4558: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC455C: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC4560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4564: 4082003C  bne 0x82ec45a0
	if !ctx.cr[0].eq {
	pc = 0x82EC45A0; continue 'dispatch;
	}
	// 82EC4568: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC456C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4570: 41820030  beq 0x82ec45a0
	if ctx.cr[0].eq {
	pc = 0x82EC45A0; continue 'dispatch;
	}
	// 82EC4574: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC4578: 480114B9  bl 0x82ed5a30
	ctx.lr = 0x82EC457C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82ED5A30);
	// 82EC457C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC4580: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC4584: 419A001C  beq cr6, 0x82ec45a0
	if ctx.cr[6].eq {
	pc = 0x82EC45A0; continue 'dispatch;
	}
	// 82EC4588: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC458C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82EC4590: 4098000C  bge cr6, 0x82ec459c
	if !ctx.cr[6].lt {
	pc = 0x82EC459C; continue 'dispatch;
	}
	// 82EC4594: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EC4598: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EC459C: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EC45A0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC45A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC45A8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC45AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC45B0: 4E800421  bctrl
	ctx.lr = 0x82EC45B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC45B4: 897F0394  lbz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EC45B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC45BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC45C0: 41820060  beq 0x82ec4620
	if ctx.cr[0].eq {
	pc = 0x82EC4620; continue 'dispatch;
	}
	// 82EC45C4: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC45C8: 816A01B8  lwz r11, 0x1b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC45CC: 814A01BC  lwz r10, 0x1bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC45D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC45D4: 419A004C  beq cr6, 0x82ec4620
	if ctx.cr[6].eq {
	pc = 0x82EC4620; continue 'dispatch;
	}
	// 82EC45D8: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC45DC: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC45E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC45E4: 409A0028  bne cr6, 0x82ec460c
	if !ctx.cr[6].eq {
	pc = 0x82EC460C; continue 'dispatch;
	}
	// 82EC45E8: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC45EC: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC45F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC45F4: 409A0018  bne cr6, 0x82ec460c
	if !ctx.cr[6].eq {
	pc = 0x82EC460C; continue 'dispatch;
	}
	// 82EC45F8: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC45FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC4600: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4604: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4608: 419A0008  beq cr6, 0x82ec4610
	if ctx.cr[6].eq {
	pc = 0x82EC4610; continue 'dispatch;
	}
	// 82EC460C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4610: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4614: 4182000C  beq 0x82ec4620
	if ctx.cr[0].eq {
	pc = 0x82EC4620; continue 'dispatch;
	}
	// 82EC4618: 9B9F018C  stb r28, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[28].u8 ) };
	// 82EC461C: 9B9F0394  stb r28, 0x394(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[28].u8 ) };
	// 82EC4620: 4B39C399  bl 0x822609b8
	ctx.lr = 0x82EC4624;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EC4624: 809F0414  lwz r4, 0x414(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) } as u64;
	// 82EC4628: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC462C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 82EC4630: 409A0014  bne cr6, 0x82ec4644
	if !ctx.cr[6].eq {
	pc = 0x82EC4644; continue 'dispatch;
	}
	// 82EC4634: 897E006C  lbz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC4638: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC463C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC4640: 48000018  b 0x82ec4658
	pc = 0x82EC4658; continue 'dispatch;
	// 82EC4644: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC464C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4650: 4BFBD109  bl 0x82e81758
	ctx.lr = 0x82EC4654;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81758);
	// 82EC4654: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC4658: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC465C: 809F0414  lwz r4, 0x414(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) } as u64;
	// 82EC4660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC4664: 997F0410  stb r11, 0x410(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), ctx.r[11].u8 ) };
	// 82EC4668: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC466C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4670: 4182000C  beq 0x82ec467c
	if ctx.cr[0].eq {
	pc = 0x82EC467C; continue 'dispatch;
	}
	// 82EC4674: 4BFBD47D  bl 0x82e81af0
	ctx.lr = 0x82EC4678;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81AF0);
	// 82EC4678: 48000008  b 0x82ec4680
	pc = 0x82EC4680; continue 'dispatch;
	// 82EC467C: 4BFBD5BD  bl 0x82e81c38
	ctx.lr = 0x82EC4680;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E81C38);
	// 82EC4680: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4684: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4688: 4182000C  beq 0x82ec4694
	if ctx.cr[0].eq {
	pc = 0x82EC4694; continue 'dispatch;
	}
	// 82EC468C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC4690: 48000008  b 0x82ec4698
	pc = 0x82EC4698; continue 'dispatch;
	// 82EC4694: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC4698: 3BDF027C  addi r30, r31, 0x27c
	ctx.r[30].s64 = ctx.r[31].s64 + 636;
	// 82EC469C: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82EC46A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC46A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC46A8: 4BFAB851  bl 0x82e6fef8
	ctx.lr = 0x82EC46AC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EC46AC: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EC46B0: 3BBF02D8  addi r29, r31, 0x2d8
	ctx.r[29].s64 = ctx.r[31].s64 + 728;
	// 82EC46B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC46B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC46BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC46C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC46C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC46C8: 4E800421  bctrl
	ctx.lr = 0x82EC46CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC46CC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC46D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC46D4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82EC46D8: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EC46DC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EC46E0: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC46E4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EC46E8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC46EC: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC46F0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC46F4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC46F8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC46FC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4700: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC4704: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82EC4708: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC470C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC4710: 4200FFF8  bdnz 0x82ec4708
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4708; continue 'dispatch;
	}
	// 82EC4714: 807F01C4  lwz r3, 0x1c4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EC4718: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC471C: 9B8100A8  stb r28, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[28].u8 ) };
	// 82EC4720: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC4724: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4728: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC472C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4730: 4E800421  bctrl
	ctx.lr = 0x82EC4734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4734: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC4738: 987F0396  stb r3, 0x396(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(918 as u32), ctx.r[3].u8 ) };
	// 82EC473C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC4740: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC4744: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4748: 4182000C  beq 0x82ec4754
	if ctx.cr[0].eq {
	pc = 0x82EC4754; continue 'dispatch;
	}
	// 82EC474C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4750: 4800011C  b 0x82ec486c
	pc = 0x82EC486C; continue 'dispatch;
	// 82EC4754: 897F0394  lbz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EC4758: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC475C: 41820020  beq 0x82ec477c
	if ctx.cr[0].eq {
	pc = 0x82EC477C; continue 'dispatch;
	}
	// 82EC4760: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4764: 814B01B8  lwz r10, 0x1b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC4768: 816B01BC  lwz r11, 0x1bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC476C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4770: 409A000C  bne cr6, 0x82ec477c
	if !ctx.cr[6].eq {
	pc = 0x82EC477C; continue 'dispatch;
	}
	// 82EC4774: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4778: 480000F4  b 0x82ec486c
	pc = 0x82EC486C; continue 'dispatch;
	// 82EC477C: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4780: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EC4784: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4788: 41820028  beq 0x82ec47b0
	if ctx.cr[0].eq {
	pc = 0x82EC47B0; continue 'dispatch;
	}
	// 82EC478C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4790: 38BF0435  addi r5, r31, 0x435
	ctx.r[5].s64 = ctx.r[31].s64 + 1077;
	// 82EC4794: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4798: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC479C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC47A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC47A4: 4E800421  bctrl
	ctx.lr = 0x82EC47A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC47A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC47AC: 41820060  beq 0x82ec480c
	if ctx.cr[0].eq {
	pc = 0x82EC480C; continue 'dispatch;
	}
	// 82EC47B0: 4B39C209  bl 0x822609b8
	ctx.lr = 0x82EC47B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EC47B4: 897F0410  lbz r11, 0x410(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EC47B8: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC47BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC47C0: 4182000C  beq 0x82ec47cc
	if ctx.cr[0].eq {
	pc = 0x82EC47CC; continue 'dispatch;
	}
	// 82EC47C4: C01F043C  lfs f0, 0x43c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC47C8: 48000014  b 0x82ec47dc
	pc = 0x82EC47DC; continue 'dispatch;
	// 82EC47CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC47D0: C19F043C  lfs f12, 0x43c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC47D4: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC47D8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC47DC: C19F0438  lfs f12, 0x438(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC47E0: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC47E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC47E8: 40980020  bge cr6, 0x82ec4808
	if !ctx.cr[6].lt {
	pc = 0x82EC4808; continue 'dispatch;
	}
	// 82EC47EC: 807F01EC  lwz r3, 0x1ec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EC47F0: D1BF0438  stfs f13, 0x438(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), tmp.u32 ) };
	// 82EC47F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC47F8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC47FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4800: 4E800421  bctrl
	ctx.lr = 0x82EC4804;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4804: 987F0435  stb r3, 0x435(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1077 as u32), ctx.r[3].u8 ) };
	// 82EC4808: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EC480C: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC4810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4814: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4818: 997F019D  stb r11, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[11].u8 ) };
	// 82EC481C: 816A0074  lwz r11, 0x74(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EC4820: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4824: 4E800421  bctrl
	ctx.lr = 0x82EC4828;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4828: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC482C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4830: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC4834: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4838: 4E800421  bctrl
	ctx.lr = 0x82EC483C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC483C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC4840: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4844: 41820020  beq 0x82ec4864
	if ctx.cr[0].eq {
	pc = 0x82EC4864; continue 'dispatch;
	}
	// 82EC4848: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC484C: 41820018  beq 0x82ec4864
	if ctx.cr[0].eq {
	pc = 0x82EC4864; continue 'dispatch;
	}
	// 82EC4850: 807F01EC  lwz r3, 0x1ec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EC4854: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4858: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC485C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4860: 4E800421  bctrl
	ctx.lr = 0x82EC4864;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC4868: 9B9F0435  stb r28, 0x435(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1077 as u32), ctx.r[28].u8 ) };
	// 82EC486C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EC4870: 4BDE4BE8  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
}

pub fn sub_82EC4878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4878 size=584
	// 82EC4878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC487C: 4BDE4B8D  bl 0x82ca9408
	ctx.lr = 0x82EC4880;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9408);
	// 82EC4880: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4888: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EC488C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EC4890: 409A000C  bne cr6, 0x82ec489c
	if !ctx.cr[6].eq {
	pc = 0x82EC489C; continue 'dispatch;
	}
	// 82EC4894: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4898: 48000214  b 0x82ec4aac
	pc = 0x82EC4AAC; continue 'dispatch;
	// 82EC489C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC48A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC48A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC48A8: 3B8B9128  addi r28, r11, -0x6ed8
	ctx.r[28].s64 = ctx.r[11].s64 + -28376;
	// 82EC48AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC48B0: 3BCB9128  addi r30, r11, -0x6ed8
	ctx.r[30].s64 = ctx.r[11].s64 + -28376;
	// 82EC48B4: 409A00C4  bne cr6, 0x82ec4978
	if !ctx.cr[6].eq {
	pc = 0x82EC4978; continue 'dispatch;
	}
	// 82EC48B8: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC48BC: 816A01B8  lwz r11, 0x1b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC48C0: 814A01BC  lwz r10, 0x1bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC48C4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EC48C8: 419AFFCC  beq cr6, 0x82ec4894
	if ctx.cr[6].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC48CC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82EC48D0: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC48D4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC48D8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EC48DC: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC48E0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EC48E4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC48E8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC48EC: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC48F0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EC48F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC48F8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC48FC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4900: 4200FFF8  bdnz 0x82ec48f8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC48F8; continue 'dispatch;
	}
	// 82EC4904: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4908: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 82EC490C: 9BA100B8  stb r29, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u8 ) };
	// 82EC4910: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EC4914: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4918: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC491C: 93C10120  stw r30, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 82EC4920: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4924: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EC4928: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC492C: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EC4930: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4934: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EC4938: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC493C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4940: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4944: 4200FFF8  bdnz 0x82ec493c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC493C; continue 'dispatch;
	}
	// 82EC4948: 807F01C4  lwz r3, 0x1c4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EC494C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EC4950: 9BA10178  stb r29, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[29].u8 ) };
	// 82EC4954: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82EC4958: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC495C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4960: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4964: 4E800421  bctrl
	ctx.lr = 0x82EC4968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4968: 93810120  stw r28, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 82EC496C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4970: 4082FF24  bne 0x82ec4894
	if !ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC4974: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EC4978: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC497C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4980: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC4984: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4988: 4E800421  bctrl
	ctx.lr = 0x82EC498C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC498C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4990: 4182FF04  beq 0x82ec4894
	if ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC4994: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4998: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC499C: 4182FEF8  beq 0x82ec4894
	if ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC49A0: C01F0404  lfs f0, 0x404(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC49A4: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82EC49A8: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC49AC: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82EC49B0: C01F0408  lfs f0, 0x408(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC49B4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EC49B8: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC49BC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC49C0: C01F040C  lfs f0, 0x40c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC49C4: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC49C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC49CC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC49D0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC49D4: 4200FFF8  bdnz 0x82ec49cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC49CC; continue 'dispatch;
	}
	// 82EC49D8: 807F023C  lwz r3, 0x23c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EC49DC: 3BDF03A4  addi r30, r31, 0x3a4
	ctx.r[30].s64 = ctx.r[31].s64 + 932;
	// 82EC49E0: 9BA10118  stb r29, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[29].u8 ) };
	// 82EC49E4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EC49E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC49EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC49F0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC49F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC49F8: 4E800421  bctrl
	ctx.lr = 0x82EC49FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC49FC: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EC4A00: 987F0400  stb r3, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[3].u8 ) };
	// 82EC4A04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4A08: 4182FE8C  beq 0x82ec4894
	if ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC4A0C: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4A10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC4A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC4A18: 419A007C  beq cr6, 0x82ec4a94
	if ctx.cr[6].eq {
	pc = 0x82EC4A94; continue 'dispatch;
	}
	// 82EC4A1C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EC4A20: 4B2E8031  bl 0x821aca50
	ctx.lr = 0x82EC4A24;
	crate::recompiler::externs::call(&mut ctx, base, 0x821ACA50);
	// 82EC4A24: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4A28: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4A2C: 39010180  addi r8, r1, 0x180
	ctx.r[8].s64 = ctx.r[1].s64 + 384;
	// 82EC4A30: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82EC4A34: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC4A38: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4A3C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC4A40: 813F03A0  lwz r9, 0x3a0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4A44: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4A48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4A4C: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC4A50: 80840014  lwz r4, 0x14(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4A54: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC4A58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4A5C: 4E800421  bctrl
	ctx.lr = 0x82EC4A60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4A60: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC4A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC4A68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4A6C: 4182001C  beq 0x82ec4a88
	if ctx.cr[0].eq {
	pc = 0x82EC4A88; continue 'dispatch;
	}
	// 82EC4A70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4A74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC4A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4A7C: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC4A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4A84: 4E800421  bctrl
	ctx.lr = 0x82EC4A88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4A88: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4A8C: 40820028  bne 0x82ec4ab4
	if !ctx.cr[0].eq {
	pc = 0x82EC4AB4; continue 'dispatch;
	}
	// 82EC4A90: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EC4A94: 807F0250  lwz r3, 0x250(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EC4A98: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC4A9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4AA0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4AA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4AA8: 4E800421  bctrl
	ctx.lr = 0x82EC4AAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4AAC: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 82EC4AB0: 4BDE49A8  b 0x82ca9458
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9458);
	return;
	// 82EC4AB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4AB8: 4BFFFFF4  b 0x82ec4aac
	pc = 0x82EC4AAC; continue 'dispatch;
}

pub fn sub_82EC4AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4AC0 size=1376
	// 82EC4AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC4AC4: 4BDE4931  bl 0x82ca93f4
	ctx.lr = 0x82EC4AC8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA93F4);
	// 82EC4AC8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82EC4ACC: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4AD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4AD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4AD8: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC4ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4AE0: 4E800421  bctrl
	ctx.lr = 0x82EC4AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4AE4: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4AE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4AEC: 41820520  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4AF0: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4AF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4AF8: 41820060  beq 0x82ec4b58
	if ctx.cr[0].eq {
	pc = 0x82EC4B58; continue 'dispatch;
	}
	// 82EC4AFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B00: 815F039C  lwz r10, 0x39c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4B04: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4B08: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4B0C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC4B10: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B14: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4B18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4B1C: 4E800421  bctrl
	ctx.lr = 0x82EC4B20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4B20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4B24: 418204E8  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4B28: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4B2C: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4B30: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4B34: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4B38: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B40: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4B44: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC4B48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4B4C: 4E800421  bctrl
	ctx.lr = 0x82EC4B50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4B50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4B54: 418204B8  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4B58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC4B60: 83DF0390  lwz r30, 0x390(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4B68: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC4B6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4B70: 4E800421  bctrl
	ctx.lr = 0x82EC4B74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4B74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4B78: 4082000C  bne 0x82ec4b84
	if !ctx.cr[0].eq {
	pc = 0x82EC4B84; continue 'dispatch;
	}
	// 82EC4B7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4B80: 48000490  b 0x82ec5010
	pc = 0x82EC5010; continue 'dispatch;
	// 82EC4B84: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4B88: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC4B8C: 419A0068  beq cr6, 0x82ec4bf4
	if ctx.cr[6].eq {
	pc = 0x82EC4BF4; continue 'dispatch;
	}
	// 82EC4B90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC4B94: 419A0060  beq cr6, 0x82ec4bf4
	if ctx.cr[6].eq {
	pc = 0x82EC4BF4; continue 'dispatch;
	}
	// 82EC4B98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B9C: 815F039C  lwz r10, 0x39c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4BA0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4BA4: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4BA8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC4BAC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4BB0: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4BB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4BB8: 4E800421  bctrl
	ctx.lr = 0x82EC4BBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4BBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4BC0: 4182044C  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4BC4: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4BC8: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4BCC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4BD0: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4BD4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4BD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4BDC: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4BE0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC4BE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4BE8: 4E800421  bctrl
	ctx.lr = 0x82EC4BEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4BEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4BF0: 4182041C  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4BF4: 897F0410  lbz r11, 0x410(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EC4BF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4BFC: 4182000C  beq 0x82ec4c08
	if ctx.cr[0].eq {
	pc = 0x82EC4C08; continue 'dispatch;
	}
	// 82EC4C00: C3FF0420  lfs f31, 0x420(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1056 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC4C04: 48000014  b 0x82ec4c18
	pc = 0x82EC4C18; continue 'dispatch;
	// 82EC4C08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC4C0C: C1BF0420  lfs f13, 0x420(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1056 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4C10: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4C14: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC4C18: 4B39BDA1  bl 0x822609b8
	ctx.lr = 0x82EC4C1C;
	crate::recompiler::externs::call(&mut ctx, base, 0x822609B8);
	// 82EC4C1C: C01F0424  lfs f0, 0x424(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4C20: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EC4C24: C003004C  lfs f0, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4C28: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EC4C2C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC4C30: 41980010  blt cr6, 0x82ec4c40
	if ctx.cr[6].lt {
	pc = 0x82EC4C40; continue 'dispatch;
	}
	// 82EC4C34: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC4C38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4C3C: 41820350  beq 0x82ec4f8c
	if ctx.cr[0].eq {
	pc = 0x82EC4F8C; continue 'dispatch;
	}
	// 82EC4C40: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4C44: D01F0424  stfs f0, 0x424(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	// 82EC4C48: 837F039C  lwz r27, 0x39c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4C4C: 82FF03A0  lwz r23, 0x3a0(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4C50: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4C54: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC4C58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4C5C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4C60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4C64: 4E800421  bctrl
	ctx.lr = 0x82EC4C68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4C68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC4C6C: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82EC4C70: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC4C74: 418202A4  beq 0x82ec4f18
	if ctx.cr[0].eq {
	pc = 0x82EC4F18; continue 'dispatch;
	}
	// 82EC4C78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC4C7C: 3B8B9128  addi r28, r11, -0x6ed8
	ctx.r[28].s64 = ctx.r[11].s64 + -28376;
	// 82EC4C80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC4C84: 3B2B9F1C  addi r25, r11, -0x60e4
	ctx.r[25].s64 = ctx.r[11].s64 + -24804;
	// 82EC4C88: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4C8C: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 82EC4C90: 816B01BC  lwz r11, 0x1bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC4C94: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4C98: 419A0008  beq cr6, 0x82ec4ca0
	if ctx.cr[6].eq {
	pc = 0x82EC4CA0; continue 'dispatch;
	}
	// 82EC4C9C: 831EFFEC  lwz r24, -0x14(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82EC4CA0: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC4CA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4CA8: 4182002C  beq 0x82ec4cd4
	if ctx.cr[0].eq {
	pc = 0x82EC4CD4; continue 'dispatch;
	}
	// 82EC4CAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4CB0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EC4CB4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4CB8: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4CBC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC4CC0: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4CC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4CC8: 4E800421  bctrl
	ctx.lr = 0x82EC4CCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4CCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4CD0: 41820248  beq 0x82ec4f18
	if ctx.cr[0].eq {
	pc = 0x82EC4F18; continue 'dispatch;
	}
	// 82EC4CD4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4CD8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EC4CDC: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EC4CE0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EC4CE4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82EC4CE8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4CEC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC4CF0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4CF4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC4CF8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4CFC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC4D00: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D04: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EC4D08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC4D0C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4D10: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4D14: 4200FFF8  bdnz 0x82ec4d0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4D0C; continue 'dispatch;
	}
	// 82EC4D18: 9B4100B8  stb r26, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u8 ) };
	// 82EC4D1C: C01F0338  lfs f0, 0x338(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D20: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4D24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC4D28: 409A0028  bne cr6, 0x82ec4d50
	if !ctx.cr[6].eq {
	pc = 0x82EC4D50; continue 'dispatch;
	}
	// 82EC4D2C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D30: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4D34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4D38: 409A0018  bne cr6, 0x82ec4d50
	if !ctx.cr[6].eq {
	pc = 0x82EC4D50; continue 'dispatch;
	}
	// 82EC4D3C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4D44: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4D48: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4D4C: 419A0008  beq cr6, 0x82ec4d54
	if ctx.cr[6].eq {
	pc = 0x82EC4D54; continue 'dispatch;
	}
	// 82EC4D50: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82EC4D54: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4D58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC4D5C: 41820010  beq 0x82ec4d6c
	if ctx.cr[0].eq {
	pc = 0x82EC4D6C; continue 'dispatch;
	}
	// 82EC4D60: 389F02D8  addi r4, r31, 0x2d8
	ctx.r[4].s64 = ctx.r[31].s64 + 728;
	// 82EC4D64: 4BFAB195  bl 0x82e6fef8
	ctx.lr = 0x82EC4D68;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EC4D68: 4800000C  b 0x82ec4d74
	pc = 0x82EC4D74; continue 'dispatch;
	// 82EC4D6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC4D70: 4B2E9939  bl 0x821ae6a8
	ctx.lr = 0x82EC4D74;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EC4D74: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4D78: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82EC4D7C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EC4D80: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4D84: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4D88: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82EC4D8C: 93A100C0  stw r29, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[29].u32 ) };
	// 82EC4D90: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82EC4D94: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D98: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC4D9C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DA0: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC4DA4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DA8: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC4DAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC4DB0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC4DB4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC4DB8: 4200FFF8  bdnz 0x82ec4db0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4DB0; continue 'dispatch;
	}
	// 82EC4DBC: 9B410118  stb r26, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[26].u8 ) };
	// 82EC4DC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4DC4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC4DC8: 419A0010  beq cr6, 0x82ec4dd8
	if ctx.cr[6].eq {
	pc = 0x82EC4DD8; continue 'dispatch;
	}
	// 82EC4DCC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EC4DD0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EC4DD4: 4B2E98D5  bl 0x821ae6a8
	ctx.lr = 0x82EC4DD8;
	crate::recompiler::externs::call(&mut ctx, base, 0x821AE6A8);
	// 82EC4DD8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4DDC: 39210190  addi r9, r1, 0x190
	ctx.r[9].s64 = ctx.r[1].s64 + 400;
	// 82EC4DE0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EC4DE4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4DE8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4DEC: 93A10180  stw r29, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[29].u32 ) };
	// 82EC4DF0: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DF4: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EC4DF8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DFC: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EC4E00: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E04: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82EC4E08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC4E0C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4E10: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4E14: 4200FFF8  bdnz 0x82ec4e0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4E0C; continue 'dispatch;
	}
	// 82EC4E18: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4E1C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC4E20: 9B4101D8  stb r26, 0x1d8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[26].u8 ) };
	// 82EC4E24: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EC4E28: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EC4E2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4E30: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC4E34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4E38: 4E800421  bctrl
	ctx.lr = 0x82EC4E3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4E3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC4E40: 93810180  stw r28, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[28].u32 ) };
	// 82EC4E44: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC4E48: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4E4C: 408200BC  bne 0x82ec4f08
	if !ctx.cr[0].eq {
	pc = 0x82EC4F08; continue 'dispatch;
	}
	// 82EC4E50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4E54: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 82EC4E58: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EC4E5C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4E60: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4E64: 93A10120  stw r29, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[29].u32 ) };
	// 82EC4E68: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E6C: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EC4E70: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E74: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EC4E78: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E7C: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EC4E80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC4E84: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4E88: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4E8C: 4200FFF8  bdnz 0x82ec4e84
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4E84; continue 'dispatch;
	}
	// 82EC4E90: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4E94: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC4E98: 9B410178  stb r26, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[26].u8 ) };
	// 82EC4E9C: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EC4EA0: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82EC4EA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4EA8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC4EAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4EB0: 4E800421  bctrl
	ctx.lr = 0x82EC4EB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4EB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC4EB8: 93810120  stw r28, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 82EC4EBC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC4EC0: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EC4EC4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EC4EC8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EC4ECC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EC4ED0: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4ED4: 40820044  bne 0x82ec4f18
	if !ctx.cr[0].eq {
	pc = 0x82EC4F18; continue 'dispatch;
	}
	// 82EC4ED8: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4EDC: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82EC4EE0: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4EE4: 7F17C378  mr r23, r24
	ctx.r[23].u64 = ctx.r[24].u64;
	// 82EC4EE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC4EEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4EF0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4EF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4EF8: 4E800421  bctrl
	ctx.lr = 0x82EC4EFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4EFC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC4F00: 4082FD88  bne 0x82ec4c88
	if !ctx.cr[0].eq {
	pc = 0x82EC4C88; continue 'dispatch;
	}
	// 82EC4F04: 48000014  b 0x82ec4f18
	pc = 0x82EC4F18; continue 'dispatch;
	// 82EC4F08: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EC4F0C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EC4F10: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EC4F14: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EC4F18: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EC4F1C: 419A0070  beq cr6, 0x82ec4f8c
	if ctx.cr[6].eq {
	pc = 0x82EC4F8C; continue 'dispatch;
	}
	// 82EC4F20: 937F039C  stw r27, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[27].u32 ) };
	// 82EC4F24: 394101F0  addi r10, r1, 0x1f0
	ctx.r[10].s64 = ctx.r[1].s64 + 496;
	// 82EC4F28: 92FF03A0  stw r23, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[23].u32 ) };
	// 82EC4F2C: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4F30: D00101E4  stfs f0, 0x1e4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82EC4F34: 93A101E0  stw r29, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[29].u32 ) };
	// 82EC4F38: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4F3C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82EC4F40: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82EC4F44: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC4F48: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4F4C: D00101EC  stfs f0, 0x1ec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 82EC4F50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4F54: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC4F58: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC4F5C: 4200FFF8  bdnz 0x82ec4f54
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4F54; continue 'dispatch;
	}
	// 82EC4F60: 388101E0  addi r4, r1, 0x1e0
	ctx.r[4].s64 = ctx.r[1].s64 + 480;
	// 82EC4F64: 9B410238  stb r26, 0x238(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), ctx.r[26].u8 ) };
	// 82EC4F68: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 82EC4F6C: 4BFAAF8D  bl 0x82e6fef8
	ctx.lr = 0x82EC4F70;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EC4F70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4F74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC4F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4F7C: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC4F80: 995F0400  stb r10, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[10].u8 ) };
	// 82EC4F84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4F88: 4E800421  bctrl
	ctx.lr = 0x82EC4F8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4F8C: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4F90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4F94: 41820078  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4F98: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4F9C: C01F0338  lfs f0, 0x338(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FA0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4FA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC4FA8: 409A0028  bne cr6, 0x82ec4fd0
	if !ctx.cr[6].eq {
	pc = 0x82EC4FD0; continue 'dispatch;
	}
	// 82EC4FAC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FB0: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4FB4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4FB8: 409A0018  bne cr6, 0x82ec4fd0
	if !ctx.cr[6].eq {
	pc = 0x82EC4FD0; continue 'dispatch;
	}
	// 82EC4FBC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FC0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82EC4FC4: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4FC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4FCC: 419A0008  beq cr6, 0x82ec4fd4
	if ctx.cr[6].eq {
	pc = 0x82EC4FD4; continue 'dispatch;
	}
	// 82EC4FD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC4FD4: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC4FD8: 4182001C  beq 0x82ec4ff4
	if ctx.cr[0].eq {
	pc = 0x82EC4FF4; continue 'dispatch;
	}
	// 82EC4FDC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FE0: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EC4FE4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FE8: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EC4FEC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FF0: 48000018  b 0x82ec5008
	pc = 0x82EC5008; continue 'dispatch;
	// 82EC4FF4: C01F02DC  lfs f0, 0x2dc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FF8: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EC4FFC: C01F02E0  lfs f0, 0x2e0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5000: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EC5004: C01F02E4  lfs f0, 0x2e4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5008: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82EC500C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5010: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 82EC5014: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EC5018: 4BDE442C  b 0x82ca9444
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9444);
	return;
}

pub fn sub_82EC5020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC5020 size=200
	// 82EC5020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5028: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC502C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC5030: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5034: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EC5038: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82EC503C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC5040: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5044: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EC5048: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC504C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5050: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC5054: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EC5058: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EC505C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC5060: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC5064: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC5068: 4200FFF8  bdnz 0x82ec5060
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5060; continue 'dispatch;
	}
	// 82EC506C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5070: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC5074: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC5078: 99010108  stb r8, 0x108(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[8].u8 ) };
	// 82EC507C: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5080: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82EC5084: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC5088: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82EC508C: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5090: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC5094: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC5098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC509C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC50A0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC50A4: 4200FFF8  bdnz 0x82ec509c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC509C; continue 'dispatch;
	}
	// 82EC50A8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC50AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC50B0: 81630228  lwz r11, 0x228(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EC50B4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EC50B8: 990100A8  stb r8, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u8 ) };
	// 82EC50BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EC50C0: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC50C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC50C8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC50CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC50D0: 4E800421  bctrl
	ctx.lr = 0x82EC50D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC50D4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EC50D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC50DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC50E0: 4E800020  blr
	return;
}

pub fn sub_82EC50E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC50E8 size=296
	// 82EC50E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC50EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC50F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC50F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC50F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC50FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5100: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC5104: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5108: 40820010  bne 0x82ec5118
	if !ctx.cr[0].eq {
	pc = 0x82EC5118; continue 'dispatch;
	}
	// 82EC510C: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5110: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5114: 419A00E0  beq cr6, 0x82ec51f4
	if ctx.cr[6].eq {
	pc = 0x82EC51F4; continue 'dispatch;
	}
	// 82EC5118: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC511C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC5120: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5124: 4082002C  bne 0x82ec5150
	if !ctx.cr[0].eq {
	pc = 0x82EC5150; continue 'dispatch;
	}
	// 82EC5128: 897F0434  lbz r11, 0x434(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1076 as u32) ) } as u64;
	// 82EC512C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5130: 409A0020  bne cr6, 0x82ec5150
	if !ctx.cr[6].eq {
	pc = 0x82EC5150; continue 'dispatch;
	}
	// 82EC5134: 38DF03A0  addi r6, r31, 0x3a0
	ctx.r[6].s64 = ctx.r[31].s64 + 928;
	// 82EC5138: 38BF039C  addi r5, r31, 0x39c
	ctx.r[5].s64 = ctx.r[31].s64 + 924;
	// 82EC513C: 389F0428  addi r4, r31, 0x428
	ctx.r[4].s64 = ctx.r[31].s64 + 1064;
	// 82EC5140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5144: 4BFFF215  bl 0x82ec4358
	ctx.lr = 0x82EC5148;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC4358);
	// 82EC5148: 987F0400  stb r3, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[3].u8 ) };
	// 82EC514C: 48000008  b 0x82ec5154
	pc = 0x82EC5154; continue 'dispatch;
	// 82EC5150: 9BDF0400  stb r30, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	// 82EC5154: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5158: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC515C: 4082002C  bne 0x82ec5188
	if !ctx.cr[0].eq {
	pc = 0x82EC5188; continue 'dispatch;
	}
	// 82EC5160: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC5164: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EC5168: 812B01BC  lwz r9, 0x1bc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC516C: 915F03A0  stw r10, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[10].u32 ) };
	// 82EC5170: 552A003E  slwi r10, r9, 0
	// 82EC5174: 913F039C  stw r9, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[9].u32 ) };
	// 82EC5178: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC517C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC5180: 409A0008  bne cr6, 0x82ec5188
	if !ctx.cr[6].eq {
	pc = 0x82EC5188; continue 'dispatch;
	}
	// 82EC5184: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	// 82EC5188: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC518C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5190: 41820060  beq 0x82ec51f0
	if ctx.cr[0].eq {
	pc = 0x82EC51F0; continue 'dispatch;
	}
	// 82EC5194: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EC5198: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EC519C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82EC51A0: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EC51A4: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82EC51A8: 98FF0400  stb r7, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[7].u8 ) };
	// 82EC51AC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC51B0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC51B4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC51B8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC51BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC51C0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC51C4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC51C8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC51CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC51D0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC51D4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC51D8: 4200FFF8  bdnz 0x82ec51d0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC51D0; continue 'dispatch;
	}
	// 82EC51DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC51E0: 9BC100A8  stb r30, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u8 ) };
	// 82EC51E4: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 82EC51E8: 4BFAAD11  bl 0x82e6fef8
	ctx.lr = 0x82EC51EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EC51EC: 48000008  b 0x82ec51f4
	pc = 0x82EC51F4; continue 'dispatch;
	// 82EC51F0: 9BDF0400  stb r30, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	// 82EC51F4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC51F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC51FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5200: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC5204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5208: 4E800020  blr
	return;
}

pub fn sub_82EC5210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC5210 size=752
	// 82EC5210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5214: 4BDE41F1  bl 0x82ca9404
	ctx.lr = 0x82EC5218;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC5218: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC521C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5220: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC5224: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82EC5228: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC522C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5230: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82EC5234: 409A02C0  bne cr6, 0x82ec54f4
	if !ctx.cr[6].eq {
	pc = 0x82EC54F4; continue 'dispatch;
	}
	// 82EC5238: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC523C: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC5240: 3B8B0014  addi r28, r11, 0x14
	ctx.r[28].s64 = ctx.r[11].s64 + 20;
	// 82EC5244: 814A01B8  lwz r10, 0x1b8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC5248: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC524C: 409A0108  bne cr6, 0x82ec5354
	if !ctx.cr[6].eq {
	pc = 0x82EC5354; continue 'dispatch;
	}
	// 82EC5250: C01F0338  lfs f0, 0x338(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5254: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC5258: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC525C: 409A0028  bne cr6, 0x82ec5284
	if !ctx.cr[6].eq {
	pc = 0x82EC5284; continue 'dispatch;
	}
	// 82EC5260: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5264: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC5268: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC526C: 409A0018  bne cr6, 0x82ec5284
	if !ctx.cr[6].eq {
	pc = 0x82EC5284; continue 'dispatch;
	}
	// 82EC5270: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5274: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82EC5278: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC527C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC5280: 419A0008  beq cr6, 0x82ec5288
	if ctx.cr[6].eq {
	pc = 0x82EC5288; continue 'dispatch;
	}
	// 82EC5284: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC5288: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC528C: 418200B4  beq 0x82ec5340
	if ctx.cr[0].eq {
	pc = 0x82EC5340; continue 'dispatch;
	}
	// 82EC5290: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EC5294: 39010130  addi r8, r1, 0x130
	ctx.r[8].s64 = ctx.r[1].s64 + 304;
	// 82EC5298: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EC529C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EC52A0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EC52A4: 91410120  stw r10, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[10].u32 ) };
	// 82EC52A8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52AC: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EC52B0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52B4: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EC52B8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52BC: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EC52C0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82EC52C4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC52C8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC52CC: 4200FFF8  bdnz 0x82ec52c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC52C4; continue 'dispatch;
	}
	// 82EC52D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC52D4: 39210190  addi r9, r1, 0x190
	ctx.r[9].s64 = ctx.r[1].s64 + 400;
	// 82EC52D8: 9B610178  stb r27, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[27].u8 ) };
	// 82EC52DC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EC52E0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC52E4: 91410180  stw r10, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[10].u32 ) };
	// 82EC52E8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC52EC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52F0: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EC52F4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52F8: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EC52FC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5300: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82EC5304: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC5308: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC530C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC5310: 4200FFF8  bdnz 0x82ec5308
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5308; continue 'dispatch;
	}
	// 82EC5314: 807F0214  lwz r3, 0x214(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EC5318: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 82EC531C: 9B6101D8  stb r27, 0x1d8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[27].u8 ) };
	// 82EC5320: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EC5324: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5328: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC532C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC5330: 4E800421  bctrl
	ctx.lr = 0x82EC5334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC5334: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5338: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC533C: 40820008  bne 0x82ec5344
	if !ctx.cr[0].eq {
	pc = 0x82EC5344; continue 'dispatch;
	}
	// 82EC5340: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC5344: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC5348: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC534C: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC5350: 480001A8  b 0x82ec54f8
	pc = 0x82EC54F8; continue 'dispatch;
	// 82EC5354: 548A063E  clrlwi r10, r4, 0x18
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EC5358: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EC535C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EC5360: 3BAA9128  addi r29, r10, -0x6ed8
	ctx.r[29].s64 = ctx.r[10].s64 + -28376;
	// 82EC5364: 419A00B0  beq cr6, 0x82ec5414
	if ctx.cr[6].eq {
	pc = 0x82EC5414; continue 'dispatch;
	}
	// 82EC5368: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82EC536C: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5370: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC5374: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EC5378: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC537C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EC5380: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC5384: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC5388: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC538C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EC5390: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC5394: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC5398: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC539C: 4200FFF8  bdnz 0x82ec5394
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5394; continue 'dispatch;
	}
	// 82EC53A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC53A4: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82EC53A8: 9B6100B8  stb r27, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[27].u8 ) };
	// 82EC53AC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EC53B0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC53B4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC53B8: 93A100C0  stw r29, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[29].u32 ) };
	// 82EC53BC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC53C0: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC53C4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC53C8: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC53CC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC53D0: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC53D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC53D8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC53DC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC53E0: 4200FFF8  bdnz 0x82ec53d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC53D8; continue 'dispatch;
	}
	// 82EC53E4: 807F0214  lwz r3, 0x214(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EC53E8: 3BC0000C  li r30, 0xc
	ctx.r[30].s64 = 12;
	// 82EC53EC: 9B610118  stb r27, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[27].u8 ) };
	// 82EC53F0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EC53F4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EC53F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC53FC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC5400: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC5404: 4E800421  bctrl
	ctx.lr = 0x82EC5408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC5408: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC540C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC5410: 41820008  beq 0x82ec5418
	if ctx.cr[0].eq {
	pc = 0x82EC5418; continue 'dispatch;
	}
	// 82EC5414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC5418: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC541C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC5420: 57C90739  rlwinm. r9, r30, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC5424: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC5428: 4182000C  beq 0x82ec5434
	if ctx.cr[0].eq {
	pc = 0x82EC5434; continue 'dispatch;
	}
	// 82EC542C: 57DE0776  rlwinm r30, r30, 0, 0x1d, 0x1b
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82EC5430: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EC5434: 57C9077B  rlwinm. r9, r30, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC5438: 41820008  beq 0x82ec5440
	if ctx.cr[0].eq {
	pc = 0x82EC5440; continue 'dispatch;
	}
	// 82EC543C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EC5440: 554B063F  clrlwi. r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5444: 418200B0  beq 0x82ec54f4
	if ctx.cr[0].eq {
	pc = 0x82EC54F4; continue 'dispatch;
	}
	// 82EC5448: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC544C: 394101F0  addi r10, r1, 0x1f0
	ctx.r[10].s64 = ctx.r[1].s64 + 496;
	// 82EC5450: 93A101E0  stw r29, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[29].u32 ) };
	// 82EC5454: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EC5458: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC545C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC5460: 939F039C  stw r28, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[28].u32 ) };
	// 82EC5464: 911F03A0  stw r8, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[8].u32 ) };
	// 82EC5468: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC546C: D00101E4  stfs f0, 0x1e4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82EC5470: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5474: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82EC5478: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC547C: D00101EC  stfs f0, 0x1ec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 82EC5480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC5484: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5488: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC548C: 4200FFF8  bdnz 0x82ec5484
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5484; continue 'dispatch;
	}
	// 82EC5490: 388101E0  addi r4, r1, 0x1e0
	ctx.r[4].s64 = ctx.r[1].s64 + 480;
	// 82EC5494: 9B610238  stb r27, 0x238(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), ctx.r[27].u8 ) };
	// 82EC5498: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 82EC549C: 4BFAAA5D  bl 0x82e6fef8
	ctx.lr = 0x82EC54A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E6FEF8);
	// 82EC54A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC54A4: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC54A8: 995F0400  stb r10, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[10].u8 ) };
	// 82EC54AC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC54B0: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EC54B4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC54B8: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EC54BC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC54C0: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82EC54C4: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC54C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC54CC: 4182000C  beq 0x82ec54d8
	if ctx.cr[0].eq {
	pc = 0x82EC54D8; continue 'dispatch;
	}
	// 82EC54D0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC54D4: 48000008  b 0x82ec54dc
	pc = 0x82EC54DC; continue 'dispatch;
	// 82EC54D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC54DC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC54E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC54E4: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82EC54E8: 814A0064  lwz r10, 0x64(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC54EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC54F0: 4E800421  bctrl
	ctx.lr = 0x82EC54F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC54F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC54F8: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 82EC54FC: 4BDE3F58  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC5500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5500 size=200
	// 82EC5500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5508: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC550C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5514: 4BFF6315  bl 0x82ebb828
	ctx.lr = 0x82EC5518;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB828);
	// 82EC5518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC551C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5520: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5524: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5528: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC552C: 40810054  ble 0x82ec5580
	if !ctx.cr[0].gt {
	pc = 0x82EC5580; continue 'dispatch;
	}
	// 82EC5530: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC5534: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5538: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC553C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5540: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5544: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5548: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC554C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5550: 41820014  beq 0x82ec5564
	if ctx.cr[0].eq {
	pc = 0x82EC5564; continue 'dispatch;
	}
	// 82EC5554: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5558: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC555C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5560: 419AFFE0  beq cr6, 0x82ec5540
	if ctx.cr[6].eq {
	pc = 0x82EC5540; continue 'dispatch;
	}
	// 82EC5564: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5568: 41820028  beq 0x82ec5590
	if ctx.cr[0].eq {
	pc = 0x82EC5590; continue 'dispatch;
	}
	// 82EC556C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5570: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5574: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5578: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC557C: 4198FFB8  blt cr6, 0x82ec5534
	if ctx.cr[6].lt {
	pc = 0x82EC5534; continue 'dispatch;
	}
	// 82EC5580: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5584: 409A0018  bne cr6, 0x82ec559c
	if !ctx.cr[6].eq {
	pc = 0x82EC559C; continue 'dispatch;
	}
	// 82EC5588: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC558C: 48000028  b 0x82ec55b4
	pc = 0x82EC55B4; continue 'dispatch;
	// 82EC5590: 54AA103A  slwi r10, r5, 2
	// 82EC5594: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5598: 48000018  b 0x82ec55b0
	pc = 0x82EC55B0; continue 'dispatch;
	// 82EC559C: 546A103A  slwi r10, r3, 2
	// 82EC55A0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC55A4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC55A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC55AC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC55B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC55B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC55B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC55BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC55C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC55C4: 4E800020  blr
	return;
}

pub fn sub_82EC55C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC55C8 size=200
	// 82EC55C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC55CC: 4BDE3E39  bl 0x82ca9404
	ctx.lr = 0x82EC55D0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC55D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC55D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC55D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC55DC: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC55E0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC55E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC55E8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC55EC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC55F0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC55F4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC55F8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC55FC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC5600: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5604: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5608: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC560C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5610: 4082FFF0  bne 0x82ec5600
	if !ctx.cr[0].eq {
	pc = 0x82EC5600; continue 'dispatch;
	}
	// 82EC5614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5618: 4BFFFEE9  bl 0x82ec5500
	ctx.lr = 0x82EC561C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC5500);
	// 82EC561C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5620: 4082000C  bne 0x82ec562c
	if !ctx.cr[0].eq {
	pc = 0x82EC562C; continue 'dispatch;
	}
	// 82EC5624: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5628: 48000010  b 0x82ec5638
	pc = 0x82EC5638; continue 'dispatch;
	// 82EC562C: 4BFF61FD  bl 0x82ebb828
	ctx.lr = 0x82EC5630;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB828);
	// 82EC5630: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5634: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5638: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC563C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5640: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5644: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5648: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC564C: 409A0010  bne cr6, 0x82ec565c
	if !ctx.cr[6].eq {
	pc = 0x82EC565C; continue 'dispatch;
	}
	// 82EC5650: 4BFBA409  bl 0x82e7fa58
	ctx.lr = 0x82EC5654;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC5654: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5658: 4800000C  b 0x82ec5664
	pc = 0x82EC5664; continue 'dispatch;
	// 82EC565C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5660: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5664: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5668: 41820018  beq 0x82ec5680
	if ctx.cr[0].eq {
	pc = 0x82EC5680; continue 'dispatch;
	}
	// 82EC566C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5670: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5674: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5678: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC567C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5684: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5688: 4BDE3DCC  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC5690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5690 size=72
	// 82EC5690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5698: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC569C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC56A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC56A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC56A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC56AC: 4BFFFF1D  bl 0x82ec55c8
	ctx.lr = 0x82EC56B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC55C8);
	// 82EC56B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC56B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC56B8: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC56BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC56C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC56C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC56C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC56CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC56D0: 4E800020  blr
	return;
}

pub fn sub_82EC56D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC56D8 size=200
	// 82EC56D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC56DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC56E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC56E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC56E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC56EC: 4BFF604D  bl 0x82ebb738
	ctx.lr = 0x82EC56F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB738);
	// 82EC56F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC56F4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC56F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC56FC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5700: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5704: 40810054  ble 0x82ec5758
	if !ctx.cr[0].gt {
	pc = 0x82EC5758; continue 'dispatch;
	}
	// 82EC5708: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC570C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5710: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5714: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5718: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC571C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5720: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5724: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5728: 41820014  beq 0x82ec573c
	if ctx.cr[0].eq {
	pc = 0x82EC573C; continue 'dispatch;
	}
	// 82EC572C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5730: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5734: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5738: 419AFFE0  beq cr6, 0x82ec5718
	if ctx.cr[6].eq {
	pc = 0x82EC5718; continue 'dispatch;
	}
	// 82EC573C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5740: 41820028  beq 0x82ec5768
	if ctx.cr[0].eq {
	pc = 0x82EC5768; continue 'dispatch;
	}
	// 82EC5744: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5748: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC574C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5750: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5754: 4198FFB8  blt cr6, 0x82ec570c
	if ctx.cr[6].lt {
	pc = 0x82EC570C; continue 'dispatch;
	}
	// 82EC5758: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC575C: 409A0018  bne cr6, 0x82ec5774
	if !ctx.cr[6].eq {
	pc = 0x82EC5774; continue 'dispatch;
	}
	// 82EC5760: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5764: 48000028  b 0x82ec578c
	pc = 0x82EC578C; continue 'dispatch;
	// 82EC5768: 54AA103A  slwi r10, r5, 2
	// 82EC576C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5770: 48000018  b 0x82ec5788
	pc = 0x82EC5788; continue 'dispatch;
	// 82EC5774: 546A103A  slwi r10, r3, 2
	// 82EC5778: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC577C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5780: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5784: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5788: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC578C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5790: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5794: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC579C: 4E800020  blr
	return;
}

pub fn sub_82EC57A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC57A0 size=200
	// 82EC57A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC57A4: 4BDE3C61  bl 0x82ca9404
	ctx.lr = 0x82EC57A8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC57A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC57AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC57B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC57B4: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC57B8: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC57BC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC57C0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC57C4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC57C8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC57CC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC57D0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC57D4: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC57D8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC57DC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC57E0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC57E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC57E8: 4082FFF0  bne 0x82ec57d8
	if !ctx.cr[0].eq {
	pc = 0x82EC57D8; continue 'dispatch;
	}
	// 82EC57EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC57F0: 4BFFFEE9  bl 0x82ec56d8
	ctx.lr = 0x82EC57F4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC56D8);
	// 82EC57F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC57F8: 4082000C  bne 0x82ec5804
	if !ctx.cr[0].eq {
	pc = 0x82EC5804; continue 'dispatch;
	}
	// 82EC57FC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5800: 48000010  b 0x82ec5810
	pc = 0x82EC5810; continue 'dispatch;
	// 82EC5804: 4BFF5F35  bl 0x82ebb738
	ctx.lr = 0x82EC5808;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB738);
	// 82EC5808: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC580C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5810: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5814: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5818: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC581C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5820: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5824: 409A0010  bne cr6, 0x82ec5834
	if !ctx.cr[6].eq {
	pc = 0x82EC5834; continue 'dispatch;
	}
	// 82EC5828: 4BFBA231  bl 0x82e7fa58
	ctx.lr = 0x82EC582C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC582C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5830: 4800000C  b 0x82ec583c
	pc = 0x82EC583C; continue 'dispatch;
	// 82EC5834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5838: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC583C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5840: 41820018  beq 0x82ec5858
	if ctx.cr[0].eq {
	pc = 0x82EC5858; continue 'dispatch;
	}
	// 82EC5844: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5848: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC584C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5850: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5854: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC585C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5860: 4BDE3BF4  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC5868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5868 size=72
	// 82EC5868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC586C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5874: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5878: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC587C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5884: 4BFFFF1D  bl 0x82ec57a0
	ctx.lr = 0x82EC5888;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC57A0);
	// 82EC5888: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC588C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5890: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC5894: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5898: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC589C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC58A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC58A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC58A8: 4E800020  blr
	return;
}

pub fn sub_82EC58B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC58B0 size=200
	// 82EC58B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC58B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC58B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC58BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC58C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC58C4: 4BFF5EED  bl 0x82ebb7b0
	ctx.lr = 0x82EC58C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB7B0);
	// 82EC58C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC58CC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC58D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC58D4: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC58D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC58DC: 40810054  ble 0x82ec5930
	if !ctx.cr[0].gt {
	pc = 0x82EC5930; continue 'dispatch;
	}
	// 82EC58E0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC58E4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC58E8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC58EC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC58F0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC58F4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC58F8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC58FC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5900: 41820014  beq 0x82ec5914
	if ctx.cr[0].eq {
	pc = 0x82EC5914; continue 'dispatch;
	}
	// 82EC5904: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5908: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC590C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5910: 419AFFE0  beq cr6, 0x82ec58f0
	if ctx.cr[6].eq {
	pc = 0x82EC58F0; continue 'dispatch;
	}
	// 82EC5914: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5918: 41820028  beq 0x82ec5940
	if ctx.cr[0].eq {
	pc = 0x82EC5940; continue 'dispatch;
	}
	// 82EC591C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5920: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5924: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5928: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC592C: 4198FFB8  blt cr6, 0x82ec58e4
	if ctx.cr[6].lt {
	pc = 0x82EC58E4; continue 'dispatch;
	}
	// 82EC5930: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5934: 409A0018  bne cr6, 0x82ec594c
	if !ctx.cr[6].eq {
	pc = 0x82EC594C; continue 'dispatch;
	}
	// 82EC5938: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC593C: 48000028  b 0x82ec5964
	pc = 0x82EC5964; continue 'dispatch;
	// 82EC5940: 54AA103A  slwi r10, r5, 2
	// 82EC5944: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5948: 48000018  b 0x82ec5960
	pc = 0x82EC5960; continue 'dispatch;
	// 82EC594C: 546A103A  slwi r10, r3, 2
	// 82EC5950: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5954: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5958: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC595C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5960: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5964: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC596C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5970: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5974: 4E800020  blr
	return;
}

pub fn sub_82EC5978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5978 size=200
	// 82EC5978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC597C: 4BDE3A89  bl 0x82ca9404
	ctx.lr = 0x82EC5980;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC5980: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5984: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC598C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5990: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5994: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5998: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC599C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC59A0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC59A4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC59A8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC59AC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC59B0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC59B4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC59B8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC59BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC59C0: 4082FFF0  bne 0x82ec59b0
	if !ctx.cr[0].eq {
	pc = 0x82EC59B0; continue 'dispatch;
	}
	// 82EC59C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC59C8: 4BFFFEE9  bl 0x82ec58b0
	ctx.lr = 0x82EC59CC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC58B0);
	// 82EC59CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC59D0: 4082000C  bne 0x82ec59dc
	if !ctx.cr[0].eq {
	pc = 0x82EC59DC; continue 'dispatch;
	}
	// 82EC59D4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC59D8: 48000010  b 0x82ec59e8
	pc = 0x82EC59E8; continue 'dispatch;
	// 82EC59DC: 4BFF5DD5  bl 0x82ebb7b0
	ctx.lr = 0x82EC59E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB7B0);
	// 82EC59E0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC59E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC59E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC59EC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC59F0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC59F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC59F8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC59FC: 409A0010  bne cr6, 0x82ec5a0c
	if !ctx.cr[6].eq {
	pc = 0x82EC5A0C; continue 'dispatch;
	}
	// 82EC5A00: 4BFBA059  bl 0x82e7fa58
	ctx.lr = 0x82EC5A04;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC5A04: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5A08: 4800000C  b 0x82ec5a14
	pc = 0x82EC5A14; continue 'dispatch;
	// 82EC5A0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5A10: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5A14: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5A18: 41820018  beq 0x82ec5a30
	if ctx.cr[0].eq {
	pc = 0x82EC5A30; continue 'dispatch;
	}
	// 82EC5A1C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5A20: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5A24: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5A28: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5A2C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5A34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5A38: 4BDE3A1C  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC5A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5A40 size=72
	// 82EC5A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5A48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5A4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5A50: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5A54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5A58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5A5C: 4BFFFF1D  bl 0x82ec5978
	ctx.lr = 0x82EC5A60;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC5978);
	// 82EC5A60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5A68: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC5A6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5A70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5A74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5A78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5A7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5A80: 4E800020  blr
	return;
}

pub fn sub_82EC5A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5A88 size=200
	// 82EC5A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5A94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5A98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5A9C: 4BFF5BAD  bl 0x82ebb648
	ctx.lr = 0x82EC5AA0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB648);
	// 82EC5AA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC5AA4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5AA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5AAC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5AB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5AB4: 40810054  ble 0x82ec5b08
	if !ctx.cr[0].gt {
	pc = 0x82EC5B08; continue 'dispatch;
	}
	// 82EC5AB8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC5ABC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5AC0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5AC4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5AC8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5ACC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5AD0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5AD4: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5AD8: 41820014  beq 0x82ec5aec
	if ctx.cr[0].eq {
	pc = 0x82EC5AEC; continue 'dispatch;
	}
	// 82EC5ADC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5AE0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5AE4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5AE8: 419AFFE0  beq cr6, 0x82ec5ac8
	if ctx.cr[6].eq {
	pc = 0x82EC5AC8; continue 'dispatch;
	}
	// 82EC5AEC: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5AF0: 41820028  beq 0x82ec5b18
	if ctx.cr[0].eq {
	pc = 0x82EC5B18; continue 'dispatch;
	}
	// 82EC5AF4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5AF8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5AFC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5B00: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5B04: 4198FFB8  blt cr6, 0x82ec5abc
	if ctx.cr[6].lt {
	pc = 0x82EC5ABC; continue 'dispatch;
	}
	// 82EC5B08: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5B0C: 409A0018  bne cr6, 0x82ec5b24
	if !ctx.cr[6].eq {
	pc = 0x82EC5B24; continue 'dispatch;
	}
	// 82EC5B10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5B14: 48000028  b 0x82ec5b3c
	pc = 0x82EC5B3C; continue 'dispatch;
	// 82EC5B18: 54AA103A  slwi r10, r5, 2
	// 82EC5B1C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5B20: 48000018  b 0x82ec5b38
	pc = 0x82EC5B38; continue 'dispatch;
	// 82EC5B24: 546A103A  slwi r10, r3, 2
	// 82EC5B28: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5B2C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5B30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5B34: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5B38: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5B3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5B40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5B44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5B48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5B4C: 4E800020  blr
	return;
}

pub fn sub_82EC5B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5B50 size=200
	// 82EC5B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5B54: 4BDE38B1  bl 0x82ca9404
	ctx.lr = 0x82EC5B58;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC5B58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5B5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5B60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5B64: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5B68: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5B6C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5B70: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC5B74: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC5B78: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC5B7C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5B80: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC5B84: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC5B88: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5B8C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5B90: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC5B94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5B98: 4082FFF0  bne 0x82ec5b88
	if !ctx.cr[0].eq {
	pc = 0x82EC5B88; continue 'dispatch;
	}
	// 82EC5B9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5BA0: 4BFFFEE9  bl 0x82ec5a88
	ctx.lr = 0x82EC5BA4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC5A88);
	// 82EC5BA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5BA8: 4082000C  bne 0x82ec5bb4
	if !ctx.cr[0].eq {
	pc = 0x82EC5BB4; continue 'dispatch;
	}
	// 82EC5BAC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5BB0: 48000010  b 0x82ec5bc0
	pc = 0x82EC5BC0; continue 'dispatch;
	// 82EC5BB4: 4BFF5A95  bl 0x82ebb648
	ctx.lr = 0x82EC5BB8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB648);
	// 82EC5BB8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5BBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5BC0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5BC4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5BC8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5BCC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5BD0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5BD4: 409A0010  bne cr6, 0x82ec5be4
	if !ctx.cr[6].eq {
	pc = 0x82EC5BE4; continue 'dispatch;
	}
	// 82EC5BD8: 4BFB9E81  bl 0x82e7fa58
	ctx.lr = 0x82EC5BDC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC5BDC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5BE0: 4800000C  b 0x82ec5bec
	pc = 0x82EC5BEC; continue 'dispatch;
	// 82EC5BE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5BE8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5BEC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5BF0: 41820018  beq 0x82ec5c08
	if ctx.cr[0].eq {
	pc = 0x82EC5C08; continue 'dispatch;
	}
	// 82EC5BF4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5BF8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5BFC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5C00: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5C04: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5C0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5C10: 4BDE3844  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC5C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5C18 size=72
	// 82EC5C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5C24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5C28: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5C2C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5C30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5C34: 4BFFFF1D  bl 0x82ec5b50
	ctx.lr = 0x82EC5C38;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC5B50);
	// 82EC5C38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5C40: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC5C44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5C48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5C4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5C50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5C54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5C58: 4E800020  blr
	return;
}

pub fn sub_82EC5C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5C60 size=200
	// 82EC5C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5C68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5C6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5C74: 4BFF5A4D  bl 0x82ebb6c0
	ctx.lr = 0x82EC5C78;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB6C0);
	// 82EC5C78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC5C7C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5C80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5C84: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5C88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5C8C: 40810054  ble 0x82ec5ce0
	if !ctx.cr[0].gt {
	pc = 0x82EC5CE0; continue 'dispatch;
	}
	// 82EC5C90: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC5C94: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5C98: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5C9C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5CA0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5CA4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5CA8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5CAC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5CB0: 41820014  beq 0x82ec5cc4
	if ctx.cr[0].eq {
	pc = 0x82EC5CC4; continue 'dispatch;
	}
	// 82EC5CB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5CB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5CBC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5CC0: 419AFFE0  beq cr6, 0x82ec5ca0
	if ctx.cr[6].eq {
	pc = 0x82EC5CA0; continue 'dispatch;
	}
	// 82EC5CC4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5CC8: 41820028  beq 0x82ec5cf0
	if ctx.cr[0].eq {
	pc = 0x82EC5CF0; continue 'dispatch;
	}
	// 82EC5CCC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5CD0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5CD4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5CD8: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5CDC: 4198FFB8  blt cr6, 0x82ec5c94
	if ctx.cr[6].lt {
	pc = 0x82EC5C94; continue 'dispatch;
	}
	// 82EC5CE0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5CE4: 409A0018  bne cr6, 0x82ec5cfc
	if !ctx.cr[6].eq {
	pc = 0x82EC5CFC; continue 'dispatch;
	}
	// 82EC5CE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5CEC: 48000028  b 0x82ec5d14
	pc = 0x82EC5D14; continue 'dispatch;
	// 82EC5CF0: 54AA103A  slwi r10, r5, 2
	// 82EC5CF4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5CF8: 48000018  b 0x82ec5d10
	pc = 0x82EC5D10; continue 'dispatch;
	// 82EC5CFC: 546A103A  slwi r10, r3, 2
	// 82EC5D00: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5D04: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5D08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5D0C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5D10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5D14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5D18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5D1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5D20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5D24: 4E800020  blr
	return;
}

pub fn sub_82EC5D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5D28 size=200
	// 82EC5D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5D2C: 4BDE36D9  bl 0x82ca9404
	ctx.lr = 0x82EC5D30;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC5D30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5D34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5D38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5D3C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5D40: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5D44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5D48: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC5D4C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC5D50: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC5D54: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5D58: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC5D5C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC5D60: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5D64: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5D68: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC5D6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5D70: 4082FFF0  bne 0x82ec5d60
	if !ctx.cr[0].eq {
	pc = 0x82EC5D60; continue 'dispatch;
	}
	// 82EC5D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5D78: 4BFFFEE9  bl 0x82ec5c60
	ctx.lr = 0x82EC5D7C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC5C60);
	// 82EC5D7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5D80: 4082000C  bne 0x82ec5d8c
	if !ctx.cr[0].eq {
	pc = 0x82EC5D8C; continue 'dispatch;
	}
	// 82EC5D84: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5D88: 48000010  b 0x82ec5d98
	pc = 0x82EC5D98; continue 'dispatch;
	// 82EC5D8C: 4BFF5935  bl 0x82ebb6c0
	ctx.lr = 0x82EC5D90;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB6C0);
	// 82EC5D90: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5D94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5D98: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5D9C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5DA0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5DA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5DA8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5DAC: 409A0010  bne cr6, 0x82ec5dbc
	if !ctx.cr[6].eq {
	pc = 0x82EC5DBC; continue 'dispatch;
	}
	// 82EC5DB0: 4BFB9CA9  bl 0x82e7fa58
	ctx.lr = 0x82EC5DB4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC5DB4: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5DB8: 4800000C  b 0x82ec5dc4
	pc = 0x82EC5DC4; continue 'dispatch;
	// 82EC5DBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5DC0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5DC4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5DC8: 41820018  beq 0x82ec5de0
	if ctx.cr[0].eq {
	pc = 0x82EC5DE0; continue 'dispatch;
	}
	// 82EC5DCC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5DD0: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5DD4: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5DD8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5DDC: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5DE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5DE8: 4BDE366C  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC5DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5DF0 size=72
	// 82EC5DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5DF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5DFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5E00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5E04: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5E08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5E0C: 4BFFFF1D  bl 0x82ec5d28
	ctx.lr = 0x82EC5E10;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC5D28);
	// 82EC5E10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5E18: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC5E1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5E20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5E24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5E28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5E30: 4E800020  blr
	return;
}

pub fn sub_82EC5E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5E38 size=200
	// 82EC5E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5E40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5E44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5E48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5E4C: 4BFF570D  bl 0x82ebb558
	ctx.lr = 0x82EC5E50;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB558);
	// 82EC5E50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC5E54: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5E58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5E5C: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5E60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5E64: 40810054  ble 0x82ec5eb8
	if !ctx.cr[0].gt {
	pc = 0x82EC5EB8; continue 'dispatch;
	}
	// 82EC5E68: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC5E6C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5E70: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5E74: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC5E78: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5E7C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5E80: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5E84: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5E88: 41820014  beq 0x82ec5e9c
	if ctx.cr[0].eq {
	pc = 0x82EC5E9C; continue 'dispatch;
	}
	// 82EC5E8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5E90: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5E94: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5E98: 419AFFE0  beq cr6, 0x82ec5e78
	if ctx.cr[6].eq {
	pc = 0x82EC5E78; continue 'dispatch;
	}
	// 82EC5E9C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5EA0: 41820028  beq 0x82ec5ec8
	if ctx.cr[0].eq {
	pc = 0x82EC5EC8; continue 'dispatch;
	}
	// 82EC5EA4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5EA8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5EAC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5EB0: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5EB4: 4198FFB8  blt cr6, 0x82ec5e6c
	if ctx.cr[6].lt {
	pc = 0x82EC5E6C; continue 'dispatch;
	}
	// 82EC5EB8: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5EBC: 409A0018  bne cr6, 0x82ec5ed4
	if !ctx.cr[6].eq {
	pc = 0x82EC5ED4; continue 'dispatch;
	}
	// 82EC5EC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5EC4: 48000028  b 0x82ec5eec
	pc = 0x82EC5EEC; continue 'dispatch;
	// 82EC5EC8: 54AA103A  slwi r10, r5, 2
	// 82EC5ECC: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5ED0: 48000018  b 0x82ec5ee8
	pc = 0x82EC5EE8; continue 'dispatch;
	// 82EC5ED4: 546A103A  slwi r10, r3, 2
	// 82EC5ED8: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5EDC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5EE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5EE4: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC5EE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC5EEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5EF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5EF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5EF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5EFC: 4E800020  blr
	return;
}

pub fn sub_82EC5F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5F00 size=200
	// 82EC5F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5F04: 4BDE3501  bl 0x82ca9404
	ctx.lr = 0x82EC5F08;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC5F08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5F0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5F10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5F14: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5F18: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5F1C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5F20: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC5F24: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC5F28: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC5F2C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5F30: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC5F34: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC5F38: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5F3C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5F40: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC5F44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5F48: 4082FFF0  bne 0x82ec5f38
	if !ctx.cr[0].eq {
	pc = 0x82EC5F38; continue 'dispatch;
	}
	// 82EC5F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5F50: 4BFFFEE9  bl 0x82ec5e38
	ctx.lr = 0x82EC5F54;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC5E38);
	// 82EC5F54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5F58: 4082000C  bne 0x82ec5f64
	if !ctx.cr[0].eq {
	pc = 0x82EC5F64; continue 'dispatch;
	}
	// 82EC5F5C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5F60: 48000010  b 0x82ec5f70
	pc = 0x82EC5F70; continue 'dispatch;
	// 82EC5F64: 4BFF55F5  bl 0x82ebb558
	ctx.lr = 0x82EC5F68;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB558);
	// 82EC5F68: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5F6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC5F70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5F74: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5F78: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5F7C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5F80: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5F84: 409A0010  bne cr6, 0x82ec5f94
	if !ctx.cr[6].eq {
	pc = 0x82EC5F94; continue 'dispatch;
	}
	// 82EC5F88: 4BFB9AD1  bl 0x82e7fa58
	ctx.lr = 0x82EC5F8C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC5F8C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5F90: 4800000C  b 0x82ec5f9c
	pc = 0x82EC5F9C; continue 'dispatch;
	// 82EC5F94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5F98: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC5F9C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5FA0: 41820018  beq 0x82ec5fb8
	if ctx.cr[0].eq {
	pc = 0x82EC5FB8; continue 'dispatch;
	}
	// 82EC5FA4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5FA8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5FAC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5FB0: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5FB4: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC5FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5FBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5FC0: 4BDE3494  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC5FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5FC8 size=72
	// 82EC5FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5FD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5FD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5FD8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5FDC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5FE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5FE4: 4BFFFF1D  bl 0x82ec5f00
	ctx.lr = 0x82EC5FE8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC5F00);
	// 82EC5FE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5FEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5FF0: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC5FF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5FF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6008: 4E800020  blr
	return;
}

pub fn sub_82EC6010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6010 size=200
	// 82EC6010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC601C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6024: 4BFF55AD  bl 0x82ebb5d0
	ctx.lr = 0x82EC6028;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB5D0);
	// 82EC6028: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC602C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC6030: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC6034: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6038: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC603C: 40810054  ble 0x82ec6090
	if !ctx.cr[0].gt {
	pc = 0x82EC6090; continue 'dispatch;
	}
	// 82EC6040: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC6044: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6048: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC604C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC6050: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6054: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6058: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC605C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC6060: 41820014  beq 0x82ec6074
	if ctx.cr[0].eq {
	pc = 0x82EC6074; continue 'dispatch;
	}
	// 82EC6064: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6068: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC606C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC6070: 419AFFE0  beq cr6, 0x82ec6050
	if ctx.cr[6].eq {
	pc = 0x82EC6050; continue 'dispatch;
	}
	// 82EC6074: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6078: 41820028  beq 0x82ec60a0
	if ctx.cr[0].eq {
	pc = 0x82EC60A0; continue 'dispatch;
	}
	// 82EC607C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6080: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC6084: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6088: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC608C: 4198FFB8  blt cr6, 0x82ec6044
	if ctx.cr[6].lt {
	pc = 0x82EC6044; continue 'dispatch;
	}
	// 82EC6090: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC6094: 409A0018  bne cr6, 0x82ec60ac
	if !ctx.cr[6].eq {
	pc = 0x82EC60AC; continue 'dispatch;
	}
	// 82EC6098: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC609C: 48000028  b 0x82ec60c4
	pc = 0x82EC60C4; continue 'dispatch;
	// 82EC60A0: 54AA103A  slwi r10, r5, 2
	// 82EC60A4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC60A8: 48000018  b 0x82ec60c0
	pc = 0x82EC60C0; continue 'dispatch;
	// 82EC60AC: 546A103A  slwi r10, r3, 2
	// 82EC60B0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC60B4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC60B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC60BC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC60C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC60C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC60C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC60CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC60D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC60D4: 4E800020  blr
	return;
}

pub fn sub_82EC60D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC60D8 size=200
	// 82EC60D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC60DC: 4BDE3329  bl 0x82ca9404
	ctx.lr = 0x82EC60E0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC60E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC60E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC60E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC60EC: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC60F0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC60F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC60F8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC60FC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC6100: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC6104: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC6108: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC610C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC6110: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6114: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6118: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC611C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6120: 4082FFF0  bne 0x82ec6110
	if !ctx.cr[0].eq {
	pc = 0x82EC6110; continue 'dispatch;
	}
	// 82EC6124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6128: 4BFFFEE9  bl 0x82ec6010
	ctx.lr = 0x82EC612C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC6010);
	// 82EC612C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6130: 4082000C  bne 0x82ec613c
	if !ctx.cr[0].eq {
	pc = 0x82EC613C; continue 'dispatch;
	}
	// 82EC6134: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC6138: 48000010  b 0x82ec6148
	pc = 0x82EC6148; continue 'dispatch;
	// 82EC613C: 4BFF5495  bl 0x82ebb5d0
	ctx.lr = 0x82EC6140;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB5D0);
	// 82EC6140: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6144: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC6148: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC614C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC6150: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC6154: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC6158: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC615C: 409A0010  bne cr6, 0x82ec616c
	if !ctx.cr[6].eq {
	pc = 0x82EC616C; continue 'dispatch;
	}
	// 82EC6160: 4BFB98F9  bl 0x82e7fa58
	ctx.lr = 0x82EC6164;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC6164: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC6168: 4800000C  b 0x82ec6174
	pc = 0x82EC6174; continue 'dispatch;
	// 82EC616C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6170: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC6174: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6178: 41820018  beq 0x82ec6190
	if ctx.cr[0].eq {
	pc = 0x82EC6190; continue 'dispatch;
	}
	// 82EC617C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6180: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC6184: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6188: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC618C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC6190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6194: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6198: 4BDE32BC  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC61A0 size=72
	// 82EC61A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC61A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC61A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC61AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC61B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC61B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC61B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC61BC: 4BFFFF1D  bl 0x82ec60d8
	ctx.lr = 0x82EC61C0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC60D8);
	// 82EC61C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC61C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC61C8: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC61CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC61D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC61D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC61D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC61DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC61E0: 4E800020  blr
	return;
}

pub fn sub_82EC61E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC61E8 size=200
	// 82EC61E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC61EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC61F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC61F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC61F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC61FC: 4BFF52E5  bl 0x82ebb4e0
	ctx.lr = 0x82EC6200;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB4E0);
	// 82EC6200: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC6204: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC6208: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC620C: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6210: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6214: 40810054  ble 0x82ec6268
	if !ctx.cr[0].gt {
	pc = 0x82EC6268; continue 'dispatch;
	}
	// 82EC6218: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC621C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6220: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC6224: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC6228: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC622C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6230: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6234: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC6238: 41820014  beq 0x82ec624c
	if ctx.cr[0].eq {
	pc = 0x82EC624C; continue 'dispatch;
	}
	// 82EC623C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6240: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC6244: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC6248: 419AFFE0  beq cr6, 0x82ec6228
	if ctx.cr[6].eq {
	pc = 0x82EC6228; continue 'dispatch;
	}
	// 82EC624C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6250: 41820028  beq 0x82ec6278
	if ctx.cr[0].eq {
	pc = 0x82EC6278; continue 'dispatch;
	}
	// 82EC6254: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6258: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC625C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6260: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC6264: 4198FFB8  blt cr6, 0x82ec621c
	if ctx.cr[6].lt {
	pc = 0x82EC621C; continue 'dispatch;
	}
	// 82EC6268: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC626C: 409A0018  bne cr6, 0x82ec6284
	if !ctx.cr[6].eq {
	pc = 0x82EC6284; continue 'dispatch;
	}
	// 82EC6270: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6274: 48000028  b 0x82ec629c
	pc = 0x82EC629C; continue 'dispatch;
	// 82EC6278: 54AA103A  slwi r10, r5, 2
	// 82EC627C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6280: 48000018  b 0x82ec6298
	pc = 0x82EC6298; continue 'dispatch;
	// 82EC6284: 546A103A  slwi r10, r3, 2
	// 82EC6288: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC628C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6290: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6294: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC6298: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC629C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC62A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC62A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC62A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC62AC: 4E800020  blr
	return;
}

pub fn sub_82EC62B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC62B0 size=200
	// 82EC62B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC62B4: 4BDE3151  bl 0x82ca9404
	ctx.lr = 0x82EC62B8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC62B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC62BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC62C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC62C4: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC62C8: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC62CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC62D0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC62D4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC62D8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC62DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC62E0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC62E4: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC62E8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC62EC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC62F0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC62F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC62F8: 4082FFF0  bne 0x82ec62e8
	if !ctx.cr[0].eq {
	pc = 0x82EC62E8; continue 'dispatch;
	}
	// 82EC62FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6300: 4BFFFEE9  bl 0x82ec61e8
	ctx.lr = 0x82EC6304;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC61E8);
	// 82EC6304: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6308: 4082000C  bne 0x82ec6314
	if !ctx.cr[0].eq {
	pc = 0x82EC6314; continue 'dispatch;
	}
	// 82EC630C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC6310: 48000010  b 0x82ec6320
	pc = 0x82EC6320; continue 'dispatch;
	// 82EC6314: 4BFF51CD  bl 0x82ebb4e0
	ctx.lr = 0x82EC6318;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB4E0);
	// 82EC6318: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC631C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC6320: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC6324: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC6328: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC632C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC6330: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC6334: 409A0010  bne cr6, 0x82ec6344
	if !ctx.cr[6].eq {
	pc = 0x82EC6344; continue 'dispatch;
	}
	// 82EC6338: 4BFB9721  bl 0x82e7fa58
	ctx.lr = 0x82EC633C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC633C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC6340: 4800000C  b 0x82ec634c
	pc = 0x82EC634C; continue 'dispatch;
	// 82EC6344: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6348: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC634C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6350: 41820018  beq 0x82ec6368
	if ctx.cr[0].eq {
	pc = 0x82EC6368; continue 'dispatch;
	}
	// 82EC6354: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6358: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC635C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6360: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC6364: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC6368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC636C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6370: 4BDE30E4  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC6378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6378 size=72
	// 82EC6378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC637C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6384: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6388: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC638C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6394: 4BFFFF1D  bl 0x82ec62b0
	ctx.lr = 0x82EC6398;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC62B0);
	// 82EC6398: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC639C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC63A0: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC63A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC63A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC63AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC63B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC63B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC63B8: 4E800020  blr
	return;
}

pub fn sub_82EC63C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC63C0 size=200
	// 82EC63C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC63C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC63C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC63CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC63D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC63D4: 4BFF5095  bl 0x82ebb468
	ctx.lr = 0x82EC63D8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB468);
	// 82EC63D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC63DC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC63E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC63E4: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC63E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC63EC: 40810054  ble 0x82ec6440
	if !ctx.cr[0].gt {
	pc = 0x82EC6440; continue 'dispatch;
	}
	// 82EC63F0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC63F4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC63F8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC63FC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC6400: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6404: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6408: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC640C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC6410: 41820014  beq 0x82ec6424
	if ctx.cr[0].eq {
	pc = 0x82EC6424; continue 'dispatch;
	}
	// 82EC6414: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6418: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC641C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC6420: 419AFFE0  beq cr6, 0x82ec6400
	if ctx.cr[6].eq {
	pc = 0x82EC6400; continue 'dispatch;
	}
	// 82EC6424: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6428: 41820028  beq 0x82ec6450
	if ctx.cr[0].eq {
	pc = 0x82EC6450; continue 'dispatch;
	}
	// 82EC642C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6430: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC6434: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6438: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC643C: 4198FFB8  blt cr6, 0x82ec63f4
	if ctx.cr[6].lt {
	pc = 0x82EC63F4; continue 'dispatch;
	}
	// 82EC6440: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC6444: 409A0018  bne cr6, 0x82ec645c
	if !ctx.cr[6].eq {
	pc = 0x82EC645C; continue 'dispatch;
	}
	// 82EC6448: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC644C: 48000028  b 0x82ec6474
	pc = 0x82EC6474; continue 'dispatch;
	// 82EC6450: 54AA103A  slwi r10, r5, 2
	// 82EC6454: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6458: 48000018  b 0x82ec6470
	pc = 0x82EC6470; continue 'dispatch;
	// 82EC645C: 546A103A  slwi r10, r3, 2
	// 82EC6460: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6464: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6468: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC646C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC6470: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC6474: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC647C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6480: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6484: 4E800020  blr
	return;
}

pub fn sub_82EC6488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6488 size=200
	// 82EC6488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC648C: 4BDE2F79  bl 0x82ca9404
	ctx.lr = 0x82EC6490;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC6490: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6494: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC649C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC64A0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC64A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC64A8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC64AC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC64B0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC64B4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC64B8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC64BC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC64C0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC64C4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC64C8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC64CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC64D0: 4082FFF0  bne 0x82ec64c0
	if !ctx.cr[0].eq {
	pc = 0x82EC64C0; continue 'dispatch;
	}
	// 82EC64D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC64D8: 4BFFFEE9  bl 0x82ec63c0
	ctx.lr = 0x82EC64DC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC63C0);
	// 82EC64DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC64E0: 4082000C  bne 0x82ec64ec
	if !ctx.cr[0].eq {
	pc = 0x82EC64EC; continue 'dispatch;
	}
	// 82EC64E4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC64E8: 48000010  b 0x82ec64f8
	pc = 0x82EC64F8; continue 'dispatch;
	// 82EC64EC: 4BFF4F7D  bl 0x82ebb468
	ctx.lr = 0x82EC64F0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB468);
	// 82EC64F0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC64F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC64F8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC64FC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC6500: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC6504: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC6508: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC650C: 409A0010  bne cr6, 0x82ec651c
	if !ctx.cr[6].eq {
	pc = 0x82EC651C; continue 'dispatch;
	}
	// 82EC6510: 4BFB9549  bl 0x82e7fa58
	ctx.lr = 0x82EC6514;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC6514: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC6518: 4800000C  b 0x82ec6524
	pc = 0x82EC6524; continue 'dispatch;
	// 82EC651C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6520: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC6524: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6528: 41820018  beq 0x82ec6540
	if ctx.cr[0].eq {
	pc = 0x82EC6540; continue 'dispatch;
	}
	// 82EC652C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6530: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC6534: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6538: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC653C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC6540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6544: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6548: 4BDE2F0C  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC6550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6550 size=72
	// 82EC6550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6558: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC655C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6560: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC6564: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC656C: 4BFFFF1D  bl 0x82ec6488
	ctx.lr = 0x82EC6570;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC6488);
	// 82EC6570: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6578: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC657C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC658C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6590: 4E800020  blr
	return;
}

pub fn sub_82EC6598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6598 size=200
	// 82EC6598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC659C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC65A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC65A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC65A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC65AC: 4BFF4E45  bl 0x82ebb3f0
	ctx.lr = 0x82EC65B0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB3F0);
	// 82EC65B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC65B4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC65B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC65BC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC65C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC65C4: 40810054  ble 0x82ec6618
	if !ctx.cr[0].gt {
	pc = 0x82EC6618; continue 'dispatch;
	}
	// 82EC65C8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC65CC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC65D0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC65D4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC65D8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC65DC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC65E0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC65E4: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC65E8: 41820014  beq 0x82ec65fc
	if ctx.cr[0].eq {
	pc = 0x82EC65FC; continue 'dispatch;
	}
	// 82EC65EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC65F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC65F4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC65F8: 419AFFE0  beq cr6, 0x82ec65d8
	if ctx.cr[6].eq {
	pc = 0x82EC65D8; continue 'dispatch;
	}
	// 82EC65FC: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6600: 41820028  beq 0x82ec6628
	if ctx.cr[0].eq {
	pc = 0x82EC6628; continue 'dispatch;
	}
	// 82EC6604: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6608: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC660C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6610: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC6614: 4198FFB8  blt cr6, 0x82ec65cc
	if ctx.cr[6].lt {
	pc = 0x82EC65CC; continue 'dispatch;
	}
	// 82EC6618: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC661C: 409A0018  bne cr6, 0x82ec6634
	if !ctx.cr[6].eq {
	pc = 0x82EC6634; continue 'dispatch;
	}
	// 82EC6620: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6624: 48000028  b 0x82ec664c
	pc = 0x82EC664C; continue 'dispatch;
	// 82EC6628: 54AA103A  slwi r10, r5, 2
	// 82EC662C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6630: 48000018  b 0x82ec6648
	pc = 0x82EC6648; continue 'dispatch;
	// 82EC6634: 546A103A  slwi r10, r3, 2
	// 82EC6638: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC663C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6640: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6644: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC6648: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC664C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6658: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC665C: 4E800020  blr
	return;
}

pub fn sub_82EC6660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6660 size=200
	// 82EC6660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6664: 4BDE2DA1  bl 0x82ca9404
	ctx.lr = 0x82EC6668;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC6668: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC666C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6670: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6674: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC6678: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC667C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC6680: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC6684: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC6688: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC668C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC6690: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC6694: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC6698: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC669C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC66A0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC66A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC66A8: 4082FFF0  bne 0x82ec6698
	if !ctx.cr[0].eq {
	pc = 0x82EC6698; continue 'dispatch;
	}
	// 82EC66AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC66B0: 4BFFFEE9  bl 0x82ec6598
	ctx.lr = 0x82EC66B4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC6598);
	// 82EC66B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC66B8: 4082000C  bne 0x82ec66c4
	if !ctx.cr[0].eq {
	pc = 0x82EC66C4; continue 'dispatch;
	}
	// 82EC66BC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC66C0: 48000010  b 0x82ec66d0
	pc = 0x82EC66D0; continue 'dispatch;
	// 82EC66C4: 4BFF4D2D  bl 0x82ebb3f0
	ctx.lr = 0x82EC66C8;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB3F0);
	// 82EC66C8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC66CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC66D0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC66D4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC66D8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC66DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC66E0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC66E4: 409A0010  bne cr6, 0x82ec66f4
	if !ctx.cr[6].eq {
	pc = 0x82EC66F4; continue 'dispatch;
	}
	// 82EC66E8: 4BFB9371  bl 0x82e7fa58
	ctx.lr = 0x82EC66EC;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC66EC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC66F0: 4800000C  b 0x82ec66fc
	pc = 0x82EC66FC; continue 'dispatch;
	// 82EC66F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC66F8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC66FC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6700: 41820018  beq 0x82ec6718
	if ctx.cr[0].eq {
	pc = 0x82EC6718; continue 'dispatch;
	}
	// 82EC6704: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6708: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC670C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6710: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC6714: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC6718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC671C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6720: 4BDE2D34  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC6728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6728 size=72
	// 82EC6728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC672C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6734: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6738: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC673C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6744: 4BFFFF1D  bl 0x82ec6660
	ctx.lr = 0x82EC6748;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC6660);
	// 82EC6748: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC674C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6750: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC6754: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC675C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6768: 4E800020  blr
	return;
}

pub fn sub_82EC6770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6770 size=200
	// 82EC6770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC677C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6784: 4BFF4BF5  bl 0x82ebb378
	ctx.lr = 0x82EC6788;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB378);
	// 82EC6788: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC678C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC6790: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC6794: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6798: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC679C: 40810054  ble 0x82ec67f0
	if !ctx.cr[0].gt {
	pc = 0x82EC67F0; continue 'dispatch;
	}
	// 82EC67A0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82EC67A4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC67A8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC67AC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EC67B0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC67B4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC67B8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC67BC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC67C0: 41820014  beq 0x82ec67d4
	if ctx.cr[0].eq {
	pc = 0x82EC67D4; continue 'dispatch;
	}
	// 82EC67C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC67C8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC67CC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC67D0: 419AFFE0  beq cr6, 0x82ec67b0
	if ctx.cr[6].eq {
	pc = 0x82EC67B0; continue 'dispatch;
	}
	// 82EC67D4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC67D8: 41820028  beq 0x82ec6800
	if ctx.cr[0].eq {
	pc = 0x82EC6800; continue 'dispatch;
	}
	// 82EC67DC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC67E0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC67E4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC67E8: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC67EC: 4198FFB8  blt cr6, 0x82ec67a4
	if ctx.cr[6].lt {
	pc = 0x82EC67A4; continue 'dispatch;
	}
	// 82EC67F0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC67F4: 409A0018  bne cr6, 0x82ec680c
	if !ctx.cr[6].eq {
	pc = 0x82EC680C; continue 'dispatch;
	}
	// 82EC67F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC67FC: 48000028  b 0x82ec6824
	pc = 0x82EC6824; continue 'dispatch;
	// 82EC6800: 54AA103A  slwi r10, r5, 2
	// 82EC6804: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6808: 48000018  b 0x82ec6820
	pc = 0x82EC6820; continue 'dispatch;
	// 82EC680C: 546A103A  slwi r10, r3, 2
	// 82EC6810: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6814: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6818: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC681C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	// 82EC6820: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC6824: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC682C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6834: 4E800020  blr
	return;
}

pub fn sub_82EC6838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6838 size=200
	// 82EC6838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC683C: 4BDE2BC9  bl 0x82ca9404
	ctx.lr = 0x82EC6840;
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9404);
	// 82EC6840: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6844: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6848: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC684C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC6850: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC6854: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC6858: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC685C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC6860: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC6864: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC6868: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC686C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82EC6870: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6874: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6878: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC687C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6880: 4082FFF0  bne 0x82ec6870
	if !ctx.cr[0].eq {
	pc = 0x82EC6870; continue 'dispatch;
	}
	// 82EC6884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6888: 4BFFFEE9  bl 0x82ec6770
	ctx.lr = 0x82EC688C;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC6770);
	// 82EC688C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6890: 4082000C  bne 0x82ec689c
	if !ctx.cr[0].eq {
	pc = 0x82EC689C; continue 'dispatch;
	}
	// 82EC6894: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC6898: 48000010  b 0x82ec68a8
	pc = 0x82EC68A8; continue 'dispatch;
	// 82EC689C: 4BFF4ADD  bl 0x82ebb378
	ctx.lr = 0x82EC68A0;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EBB378);
	// 82EC68A0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC68A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EC68A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC68AC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC68B0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC68B4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC68B8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC68BC: 409A0010  bne cr6, 0x82ec68cc
	if !ctx.cr[6].eq {
	pc = 0x82EC68CC; continue 'dispatch;
	}
	// 82EC68C0: 4BFB9199  bl 0x82e7fa58
	ctx.lr = 0x82EC68C4;
	crate::recompiler::externs::call(&mut ctx, base, 0x82E7FA58);
	// 82EC68C4: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC68C8: 4800000C  b 0x82ec68d4
	pc = 0x82EC68D4; continue 'dispatch;
	// 82EC68CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC68D0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EC68D4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC68D8: 41820018  beq 0x82ec68f0
	if ctx.cr[0].eq {
	pc = 0x82EC68F0; continue 'dispatch;
	}
	// 82EC68DC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC68E0: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC68E4: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC68E8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC68EC: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	// 82EC68F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC68F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC68F8: 4BDE2B5C  b 0x82ca9454
	crate::recompiler::externs::call(&mut ctx, base, 0x82CA9454);
	return;
}

pub fn sub_82EC6900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6900 size=344
	// 82EC6900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC690C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6910: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC6914: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC691C: 4BFFFF1D  bl 0x82ec6838
	ctx.lr = 0x82EC6920;
	crate::recompiler::externs::call(&mut ctx, base, 0x82EC6838);
	// 82EC6920: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6928: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC692C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6930: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6934: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6938: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC693C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6940: 4E800020  blr
	return;
}

